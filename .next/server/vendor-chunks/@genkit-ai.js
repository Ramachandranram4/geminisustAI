"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@genkit-ai";
exports.ids = ["vendor-chunks/@genkit-ai"];
exports.modules = {

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/chat.js":
/*!************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/chat.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar chat_exports = {};\n__export(chat_exports, {\n  Chat: () => Chat,\n  MAIN_THREAD: () => MAIN_THREAD,\n  SESSION_ID_ATTR: () => SESSION_ID_ATTR,\n  THREAD_NAME_ATTR: () => THREAD_NAME_ATTR\n});\nmodule.exports = __toCommonJS(chat_exports);\nvar import_async = __webpack_require__(/*! @genkit-ai/core/async */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/async.js\");\nvar import_tracing = __webpack_require__(/*! @genkit-ai/core/tracing */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing.js\");\nvar import_index = __webpack_require__(/*! ./index.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/index.js\");\nvar import_session = __webpack_require__(/*! ./session.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/session.js\");\nconst MAIN_THREAD = \"main\";\nconst SESSION_ID_ATTR = `${import_tracing.ATTR_PREFIX}:sessionId`;\nconst THREAD_NAME_ATTR = `${import_tracing.ATTR_PREFIX}:threadName`;\nclass Chat {\n  constructor(session, requestBase, options) {\n    this.session = session;\n    this.sessionId = options.id;\n    this.threadName = options.thread;\n    this.requestBase = requestBase?.then((rb) => {\n      const requestBase2 = { ...rb };\n      if (requestBase2 && requestBase2[\"prompt\"]) {\n        const basePrompt = requestBase2[\"prompt\"];\n        let promptMessage;\n        if (typeof basePrompt === \"string\") {\n          promptMessage = {\n            role: \"user\",\n            content: [{ text: basePrompt }]\n          };\n        } else if (Array.isArray(basePrompt)) {\n          promptMessage = {\n            role: \"user\",\n            content: basePrompt\n          };\n        } else {\n          promptMessage = {\n            role: \"user\",\n            content: [basePrompt]\n          };\n        }\n        requestBase2.messages = [...requestBase2.messages ?? [], promptMessage];\n      }\n      if (hasPreamble(requestBase2.messages)) {\n        requestBase2.messages = [\n          // if request base contains a preamble, always put it first\n          ...getPreamble(requestBase2.messages) ?? [],\n          // strip out the preamble from history\n          ...stripPreamble(options.messages) ?? [],\n          // add whatever non-preamble remains from request\n          ...stripPreamble(requestBase2.messages) ?? []\n        ];\n      } else {\n        requestBase2.messages = [\n          ...options.messages ?? [],\n          ...requestBase2.messages ?? []\n        ];\n      }\n      this._messages = requestBase2.messages;\n      return requestBase2;\n    });\n    this._messages = options.messages;\n  }\n  requestBase;\n  sessionId;\n  _messages;\n  threadName;\n  async send(options) {\n    return (0, import_session.runWithSession)(\n      this.session.registry,\n      this.session,\n      () => (0, import_tracing.runInNewSpan)(\n        this.session.registry,\n        {\n          metadata: {\n            name: \"send\"\n          },\n          labels: {\n            [import_tracing.SPAN_TYPE_ATTR]: \"helper\",\n            [SESSION_ID_ATTR]: this.session.id,\n            [THREAD_NAME_ATTR]: this.threadName\n          }\n        },\n        async (metadata) => {\n          const resolvedOptions = resolveSendOptions(options);\n          let streamingCallback = void 0;\n          if (resolvedOptions.onChunk || resolvedOptions.streamingCallback) {\n            streamingCallback = resolvedOptions.onChunk ?? resolvedOptions.streamingCallback;\n          }\n          const request = {\n            ...await this.requestBase,\n            messages: this.messages,\n            ...resolvedOptions\n          };\n          metadata.input = resolvedOptions;\n          const response = await (0, import_index.generate)(this.session.registry, {\n            ...request,\n            onChunk: streamingCallback\n          });\n          this.requestBase = Promise.resolve({\n            ...await this.requestBase,\n            // these things may get changed by tools calling within generate.\n            tools: response?.request?.tools?.map((td) => td.name),\n            toolChoice: response?.request?.toolChoice,\n            config: response?.request?.config\n          });\n          await this.updateMessages(response.messages);\n          metadata.output = JSON.stringify(response);\n          return response;\n        }\n      )\n    );\n  }\n  sendStream(options) {\n    const channel = new import_async.Channel();\n    const resolvedOptions = resolveSendOptions(options);\n    const sent = this.send({\n      ...resolvedOptions,\n      onChunk: (chunk) => channel.send(chunk)\n    });\n    sent.then(\n      () => channel.close(),\n      (err) => channel.error(err)\n    );\n    return {\n      response: sent,\n      stream: channel\n    };\n  }\n  get messages() {\n    return this._messages ?? [];\n  }\n  async updateMessages(messages) {\n    this._messages = messages;\n    await this.session.updateMessages(this.threadName, messages);\n  }\n}\nfunction hasPreamble(msgs) {\n  return !!msgs?.find((m) => m.metadata?.preamble);\n}\nfunction getPreamble(msgs) {\n  return msgs?.filter((m) => m.metadata?.preamble);\n}\nfunction stripPreamble(msgs) {\n  return msgs?.filter((m) => !m.metadata?.preamble);\n}\nfunction resolveSendOptions(options) {\n  let resolvedOptions;\n  if (typeof options === \"string\") {\n    resolvedOptions = {\n      prompt: options\n    };\n  } else if (Array.isArray(options)) {\n    resolvedOptions = {\n      prompt: options\n    };\n  } else {\n    resolvedOptions = options;\n  }\n  return resolvedOptions;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=chat.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9jaGF0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsMkZBQXVCO0FBQ2xELHFCQUFxQixtQkFBTyxDQUFDLCtGQUF5QjtBQUN0RCxtQkFBbUIsbUJBQU8sQ0FBQyw4RUFBWTtBQUN2QyxxQkFBcUIsbUJBQU8sQ0FBQyxrRkFBYztBQUMzQztBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBS0w7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcYWlcXGxpYlxcY2hhdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgY2hhdF9leHBvcnRzID0ge307XG5fX2V4cG9ydChjaGF0X2V4cG9ydHMsIHtcbiAgQ2hhdDogKCkgPT4gQ2hhdCxcbiAgTUFJTl9USFJFQUQ6ICgpID0+IE1BSU5fVEhSRUFELFxuICBTRVNTSU9OX0lEX0FUVFI6ICgpID0+IFNFU1NJT05fSURfQVRUUixcbiAgVEhSRUFEX05BTUVfQVRUUjogKCkgPT4gVEhSRUFEX05BTUVfQVRUUlxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhjaGF0X2V4cG9ydHMpO1xudmFyIGltcG9ydF9hc3luYyA9IHJlcXVpcmUoXCJAZ2Vua2l0LWFpL2NvcmUvYXN5bmNcIik7XG52YXIgaW1wb3J0X3RyYWNpbmcgPSByZXF1aXJlKFwiQGdlbmtpdC1haS9jb3JlL3RyYWNpbmdcIik7XG52YXIgaW1wb3J0X2luZGV4ID0gcmVxdWlyZShcIi4vaW5kZXguanNcIik7XG52YXIgaW1wb3J0X3Nlc3Npb24gPSByZXF1aXJlKFwiLi9zZXNzaW9uLmpzXCIpO1xuY29uc3QgTUFJTl9USFJFQUQgPSBcIm1haW5cIjtcbmNvbnN0IFNFU1NJT05fSURfQVRUUiA9IGAke2ltcG9ydF90cmFjaW5nLkFUVFJfUFJFRklYfTpzZXNzaW9uSWRgO1xuY29uc3QgVEhSRUFEX05BTUVfQVRUUiA9IGAke2ltcG9ydF90cmFjaW5nLkFUVFJfUFJFRklYfTp0aHJlYWROYW1lYDtcbmNsYXNzIENoYXQge1xuICBjb25zdHJ1Y3RvcihzZXNzaW9uLCByZXF1ZXN0QmFzZSwgb3B0aW9ucykge1xuICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgdGhpcy5zZXNzaW9uSWQgPSBvcHRpb25zLmlkO1xuICAgIHRoaXMudGhyZWFkTmFtZSA9IG9wdGlvbnMudGhyZWFkO1xuICAgIHRoaXMucmVxdWVzdEJhc2UgPSByZXF1ZXN0QmFzZT8udGhlbigocmIpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3RCYXNlMiA9IHsgLi4ucmIgfTtcbiAgICAgIGlmIChyZXF1ZXN0QmFzZTIgJiYgcmVxdWVzdEJhc2UyW1wicHJvbXB0XCJdKSB7XG4gICAgICAgIGNvbnN0IGJhc2VQcm9tcHQgPSByZXF1ZXN0QmFzZTJbXCJwcm9tcHRcIl07XG4gICAgICAgIGxldCBwcm9tcHRNZXNzYWdlO1xuICAgICAgICBpZiAodHlwZW9mIGJhc2VQcm9tcHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBwcm9tcHRNZXNzYWdlID0ge1xuICAgICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgICBjb250ZW50OiBbeyB0ZXh0OiBiYXNlUHJvbXB0IH1dXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJhc2VQcm9tcHQpKSB7XG4gICAgICAgICAgcHJvbXB0TWVzc2FnZSA9IHtcbiAgICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgICAgY29udGVudDogYmFzZVByb21wdFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvbXB0TWVzc2FnZSA9IHtcbiAgICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgICAgY29udGVudDogW2Jhc2VQcm9tcHRdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0QmFzZTIubWVzc2FnZXMgPSBbLi4ucmVxdWVzdEJhc2UyLm1lc3NhZ2VzID8/IFtdLCBwcm9tcHRNZXNzYWdlXTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNQcmVhbWJsZShyZXF1ZXN0QmFzZTIubWVzc2FnZXMpKSB7XG4gICAgICAgIHJlcXVlc3RCYXNlMi5tZXNzYWdlcyA9IFtcbiAgICAgICAgICAvLyBpZiByZXF1ZXN0IGJhc2UgY29udGFpbnMgYSBwcmVhbWJsZSwgYWx3YXlzIHB1dCBpdCBmaXJzdFxuICAgICAgICAgIC4uLmdldFByZWFtYmxlKHJlcXVlc3RCYXNlMi5tZXNzYWdlcykgPz8gW10sXG4gICAgICAgICAgLy8gc3RyaXAgb3V0IHRoZSBwcmVhbWJsZSBmcm9tIGhpc3RvcnlcbiAgICAgICAgICAuLi5zdHJpcFByZWFtYmxlKG9wdGlvbnMubWVzc2FnZXMpID8/IFtdLFxuICAgICAgICAgIC8vIGFkZCB3aGF0ZXZlciBub24tcHJlYW1ibGUgcmVtYWlucyBmcm9tIHJlcXVlc3RcbiAgICAgICAgICAuLi5zdHJpcFByZWFtYmxlKHJlcXVlc3RCYXNlMi5tZXNzYWdlcykgPz8gW11cbiAgICAgICAgXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcXVlc3RCYXNlMi5tZXNzYWdlcyA9IFtcbiAgICAgICAgICAuLi5vcHRpb25zLm1lc3NhZ2VzID8/IFtdLFxuICAgICAgICAgIC4uLnJlcXVlc3RCYXNlMi5tZXNzYWdlcyA/PyBbXVxuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWVzc2FnZXMgPSByZXF1ZXN0QmFzZTIubWVzc2FnZXM7XG4gICAgICByZXR1cm4gcmVxdWVzdEJhc2UyO1xuICAgIH0pO1xuICAgIHRoaXMuX21lc3NhZ2VzID0gb3B0aW9ucy5tZXNzYWdlcztcbiAgfVxuICByZXF1ZXN0QmFzZTtcbiAgc2Vzc2lvbklkO1xuICBfbWVzc2FnZXM7XG4gIHRocmVhZE5hbWU7XG4gIGFzeW5jIHNlbmQob3B0aW9ucykge1xuICAgIHJldHVybiAoMCwgaW1wb3J0X3Nlc3Npb24ucnVuV2l0aFNlc3Npb24pKFxuICAgICAgdGhpcy5zZXNzaW9uLnJlZ2lzdHJ5LFxuICAgICAgdGhpcy5zZXNzaW9uLFxuICAgICAgKCkgPT4gKDAsIGltcG9ydF90cmFjaW5nLnJ1bkluTmV3U3BhbikoXG4gICAgICAgIHRoaXMuc2Vzc2lvbi5yZWdpc3RyeSxcbiAgICAgICAge1xuICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICBuYW1lOiBcInNlbmRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICBbaW1wb3J0X3RyYWNpbmcuU1BBTl9UWVBFX0FUVFJdOiBcImhlbHBlclwiLFxuICAgICAgICAgICAgW1NFU1NJT05fSURfQVRUUl06IHRoaXMuc2Vzc2lvbi5pZCxcbiAgICAgICAgICAgIFtUSFJFQURfTkFNRV9BVFRSXTogdGhpcy50aHJlYWROYW1lXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhc3luYyAobWV0YWRhdGEpID0+IHtcbiAgICAgICAgICBjb25zdCByZXNvbHZlZE9wdGlvbnMgPSByZXNvbHZlU2VuZE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgbGV0IHN0cmVhbWluZ0NhbGxiYWNrID0gdm9pZCAwO1xuICAgICAgICAgIGlmIChyZXNvbHZlZE9wdGlvbnMub25DaHVuayB8fCByZXNvbHZlZE9wdGlvbnMuc3RyZWFtaW5nQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHN0cmVhbWluZ0NhbGxiYWNrID0gcmVzb2x2ZWRPcHRpb25zLm9uQ2h1bmsgPz8gcmVzb2x2ZWRPcHRpb25zLnN0cmVhbWluZ0NhbGxiYWNrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgLi4uYXdhaXQgdGhpcy5yZXF1ZXN0QmFzZSxcbiAgICAgICAgICAgIG1lc3NhZ2VzOiB0aGlzLm1lc3NhZ2VzLFxuICAgICAgICAgICAgLi4ucmVzb2x2ZWRPcHRpb25zXG4gICAgICAgICAgfTtcbiAgICAgICAgICBtZXRhZGF0YS5pbnB1dCA9IHJlc29sdmVkT3B0aW9ucztcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0ICgwLCBpbXBvcnRfaW5kZXguZ2VuZXJhdGUpKHRoaXMuc2Vzc2lvbi5yZWdpc3RyeSwge1xuICAgICAgICAgICAgLi4ucmVxdWVzdCxcbiAgICAgICAgICAgIG9uQ2h1bms6IHN0cmVhbWluZ0NhbGxiYWNrXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0QmFzZSA9IFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICAuLi5hd2FpdCB0aGlzLnJlcXVlc3RCYXNlLFxuICAgICAgICAgICAgLy8gdGhlc2UgdGhpbmdzIG1heSBnZXQgY2hhbmdlZCBieSB0b29scyBjYWxsaW5nIHdpdGhpbiBnZW5lcmF0ZS5cbiAgICAgICAgICAgIHRvb2xzOiByZXNwb25zZT8ucmVxdWVzdD8udG9vbHM/Lm1hcCgodGQpID0+IHRkLm5hbWUpLFxuICAgICAgICAgICAgdG9vbENob2ljZTogcmVzcG9uc2U/LnJlcXVlc3Q/LnRvb2xDaG9pY2UsXG4gICAgICAgICAgICBjb25maWc6IHJlc3BvbnNlPy5yZXF1ZXN0Py5jb25maWdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZU1lc3NhZ2VzKHJlc3BvbnNlLm1lc3NhZ2VzKTtcbiAgICAgICAgICBtZXRhZGF0YS5vdXRwdXQgPSBKU09OLnN0cmluZ2lmeShyZXNwb25zZSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgfVxuICBzZW5kU3RyZWFtKG9wdGlvbnMpIHtcbiAgICBjb25zdCBjaGFubmVsID0gbmV3IGltcG9ydF9hc3luYy5DaGFubmVsKCk7XG4gICAgY29uc3QgcmVzb2x2ZWRPcHRpb25zID0gcmVzb2x2ZVNlbmRPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IHNlbnQgPSB0aGlzLnNlbmQoe1xuICAgICAgLi4ucmVzb2x2ZWRPcHRpb25zLFxuICAgICAgb25DaHVuazogKGNodW5rKSA9PiBjaGFubmVsLnNlbmQoY2h1bmspXG4gICAgfSk7XG4gICAgc2VudC50aGVuKFxuICAgICAgKCkgPT4gY2hhbm5lbC5jbG9zZSgpLFxuICAgICAgKGVycikgPT4gY2hhbm5lbC5lcnJvcihlcnIpXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzcG9uc2U6IHNlbnQsXG4gICAgICBzdHJlYW06IGNoYW5uZWxcbiAgICB9O1xuICB9XG4gIGdldCBtZXNzYWdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVzc2FnZXMgPz8gW107XG4gIH1cbiAgYXN5bmMgdXBkYXRlTWVzc2FnZXMobWVzc2FnZXMpIHtcbiAgICB0aGlzLl9tZXNzYWdlcyA9IG1lc3NhZ2VzO1xuICAgIGF3YWl0IHRoaXMuc2Vzc2lvbi51cGRhdGVNZXNzYWdlcyh0aGlzLnRocmVhZE5hbWUsIG1lc3NhZ2VzKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFzUHJlYW1ibGUobXNncykge1xuICByZXR1cm4gISFtc2dzPy5maW5kKChtKSA9PiBtLm1ldGFkYXRhPy5wcmVhbWJsZSk7XG59XG5mdW5jdGlvbiBnZXRQcmVhbWJsZShtc2dzKSB7XG4gIHJldHVybiBtc2dzPy5maWx0ZXIoKG0pID0+IG0ubWV0YWRhdGE/LnByZWFtYmxlKTtcbn1cbmZ1bmN0aW9uIHN0cmlwUHJlYW1ibGUobXNncykge1xuICByZXR1cm4gbXNncz8uZmlsdGVyKChtKSA9PiAhbS5tZXRhZGF0YT8ucHJlYW1ibGUpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVNlbmRPcHRpb25zKG9wdGlvbnMpIHtcbiAgbGV0IHJlc29sdmVkT3B0aW9ucztcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmVzb2x2ZWRPcHRpb25zID0ge1xuICAgICAgcHJvbXB0OiBvcHRpb25zXG4gICAgfTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgcmVzb2x2ZWRPcHRpb25zID0ge1xuICAgICAgcHJvbXB0OiBvcHRpb25zXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXNvbHZlZE9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIHJldHVybiByZXNvbHZlZE9wdGlvbnM7XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ2hhdCxcbiAgTUFJTl9USFJFQUQsXG4gIFNFU1NJT05fSURfQVRUUixcbiAgVEhSRUFEX05BTUVfQVRUUlxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGF0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/chat.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/check-operation.js":
/*!***********************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/check-operation.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar check_operation_exports = {};\n__export(check_operation_exports, {\n  checkOperation: () => checkOperation\n});\nmodule.exports = __toCommonJS(check_operation_exports);\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nasync function checkOperation(registry, operation) {\n  if (!operation.action) {\n    throw new import_core.GenkitError({\n      status: \"INVALID_ARGUMENT\",\n      message: \"Provided operation is missing original request information\"\n    });\n  }\n  const backgroundAction = await registry.lookupBackgroundAction(\n    operation.action\n  );\n  if (!backgroundAction) {\n    throw new import_core.GenkitError({\n      status: \"INVALID_ARGUMENT\",\n      message: `Failed to resolve background action from original request: ${operation.action}`\n    });\n  }\n  return await backgroundAction.check(operation);\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=check-operation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9jaGVjay1vcGVyYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxxRkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxpQkFBaUI7QUFDOUYsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUVMO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcS1JhbWFjaGFcXERvY3VtZW50c1xcU3VzdEFJbmV4IEdJdCBDb2RlXFxub2RlX21vZHVsZXNcXEBnZW5raXQtYWlcXGFpXFxsaWJcXGNoZWNrLW9wZXJhdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgY2hlY2tfb3BlcmF0aW9uX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNoZWNrX29wZXJhdGlvbl9leHBvcnRzLCB7XG4gIGNoZWNrT3BlcmF0aW9uOiAoKSA9PiBjaGVja09wZXJhdGlvblxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhjaGVja19vcGVyYXRpb25fZXhwb3J0cyk7XG52YXIgaW1wb3J0X2NvcmUgPSByZXF1aXJlKFwiQGdlbmtpdC1haS9jb3JlXCIpO1xuYXN5bmMgZnVuY3Rpb24gY2hlY2tPcGVyYXRpb24ocmVnaXN0cnksIG9wZXJhdGlvbikge1xuICBpZiAoIW9wZXJhdGlvbi5hY3Rpb24pIHtcbiAgICB0aHJvdyBuZXcgaW1wb3J0X2NvcmUuR2Vua2l0RXJyb3Ioe1xuICAgICAgc3RhdHVzOiBcIklOVkFMSURfQVJHVU1FTlRcIixcbiAgICAgIG1lc3NhZ2U6IFwiUHJvdmlkZWQgb3BlcmF0aW9uIGlzIG1pc3Npbmcgb3JpZ2luYWwgcmVxdWVzdCBpbmZvcm1hdGlvblwiXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgYmFja2dyb3VuZEFjdGlvbiA9IGF3YWl0IHJlZ2lzdHJ5Lmxvb2t1cEJhY2tncm91bmRBY3Rpb24oXG4gICAgb3BlcmF0aW9uLmFjdGlvblxuICApO1xuICBpZiAoIWJhY2tncm91bmRBY3Rpb24pIHtcbiAgICB0aHJvdyBuZXcgaW1wb3J0X2NvcmUuR2Vua2l0RXJyb3Ioe1xuICAgICAgc3RhdHVzOiBcIklOVkFMSURfQVJHVU1FTlRcIixcbiAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgdG8gcmVzb2x2ZSBiYWNrZ3JvdW5kIGFjdGlvbiBmcm9tIG9yaWdpbmFsIHJlcXVlc3Q6ICR7b3BlcmF0aW9uLmFjdGlvbn1gXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IGJhY2tncm91bmRBY3Rpb24uY2hlY2sob3BlcmF0aW9uKTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBjaGVja09wZXJhdGlvblxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVjay1vcGVyYXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/check-operation.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/document.js":
/*!****************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/document.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar document_exports = {};\n__export(document_exports, {\n  CustomPartSchema: () => CustomPartSchema,\n  DataPartSchema: () => DataPartSchema,\n  Document: () => Document,\n  DocumentDataSchema: () => DocumentDataSchema,\n  MediaPartSchema: () => MediaPartSchema,\n  MediaSchema: () => MediaSchema,\n  PartSchema: () => PartSchema,\n  ReasoningPartSchema: () => ReasoningPartSchema,\n  ResourcePartSchema: () => ResourcePartSchema,\n  TextPartSchema: () => TextPartSchema,\n  ToolRequestPartSchema: () => ToolRequestPartSchema,\n  ToolRequestSchema: () => ToolRequestSchema,\n  ToolResponsePartSchema: () => ToolResponsePartSchema,\n  ToolResponseSchema: () => ToolResponseSchema,\n  checkUniqueDocuments: () => checkUniqueDocuments\n});\nmodule.exports = __toCommonJS(document_exports);\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nconst EmptyPartSchema = import_core.z.object({\n  text: import_core.z.never().optional(),\n  media: import_core.z.never().optional(),\n  toolRequest: import_core.z.never().optional(),\n  toolResponse: import_core.z.never().optional(),\n  data: import_core.z.unknown().optional(),\n  metadata: import_core.z.record(import_core.z.unknown()).optional(),\n  custom: import_core.z.record(import_core.z.unknown()).optional(),\n  reasoning: import_core.z.never().optional(),\n  resource: import_core.z.never().optional()\n});\nconst TextPartSchema = EmptyPartSchema.extend({\n  /** The text of the message. */\n  text: import_core.z.string()\n});\nconst ReasoningPartSchema = EmptyPartSchema.extend({\n  /** The reasoning text of the message. */\n  reasoning: import_core.z.string()\n});\nconst MediaSchema = import_core.z.object({\n  /** The media content type. Inferred from data uri if not provided. */\n  contentType: import_core.z.string().optional(),\n  /** A `data:` or `https:` uri containing the media content.  */\n  url: import_core.z.string()\n});\nconst MediaPartSchema = EmptyPartSchema.extend({\n  media: MediaSchema\n});\nconst ToolRequestSchema = import_core.z.object({\n  /** The call id or reference for a specific request. */\n  ref: import_core.z.string().optional(),\n  /** The name of the tool to call. */\n  name: import_core.z.string(),\n  /** The input parameters for the tool, usually a JSON object. */\n  input: import_core.z.unknown().optional()\n});\nconst ToolRequestPartSchema = EmptyPartSchema.extend({\n  /** A request for a tool to be executed, usually provided by a model. */\n  toolRequest: ToolRequestSchema\n});\nconst ToolResponseSchema = import_core.z.object({\n  /** The call id or reference for a specific request. */\n  ref: import_core.z.string().optional(),\n  /** The name of the tool. */\n  name: import_core.z.string(),\n  /** The output data returned from the tool, usually a JSON object. */\n  output: import_core.z.unknown().optional()\n});\nconst ToolResponsePartSchema = EmptyPartSchema.extend({\n  /** A provided response to a tool call. */\n  toolResponse: ToolResponseSchema\n});\nconst DataPartSchema = EmptyPartSchema.extend({\n  data: import_core.z.unknown()\n});\nconst CustomPartSchema = EmptyPartSchema.extend({\n  custom: import_core.z.record(import_core.z.any())\n});\nconst ResourcePartSchema = EmptyPartSchema.extend({\n  resource: import_core.z.object({\n    uri: import_core.z.string()\n  })\n});\nconst PartSchema = import_core.z.union([TextPartSchema, MediaPartSchema]);\nconst DocumentDataSchema = import_core.z.object({\n  content: import_core.z.array(PartSchema),\n  metadata: import_core.z.record(import_core.z.string(), import_core.z.any()).optional()\n});\nfunction deepCopy(value) {\n  if (value === void 0) {\n    return value;\n  }\n  return JSON.parse(JSON.stringify(value));\n}\nclass Document {\n  content;\n  metadata;\n  constructor(data) {\n    this.content = deepCopy(data.content);\n    this.metadata = deepCopy(data.metadata);\n  }\n  static fromText(text, metadata) {\n    return new Document({\n      content: [{ text }],\n      metadata\n    });\n  }\n  // Construct a Document from a single media item\n  static fromMedia(url, contentType, metadata) {\n    return new Document({\n      content: [\n        {\n          media: {\n            contentType,\n            url\n          }\n        }\n      ],\n      metadata\n    });\n  }\n  // Construct a Document from content\n  static fromData(data, dataType, metadata) {\n    if (dataType === \"text\") {\n      return this.fromText(data, metadata);\n    }\n    return this.fromMedia(data, dataType, metadata);\n  }\n  /**\n   * Concatenates all `text` parts present in the document with no delimiter.\n   * @returns A string of all concatenated text parts.\n   */\n  get text() {\n    return this.content.map((part) => part.text || \"\").join(\"\");\n  }\n  /**\n   * Media array getter.\n   * @returns the array of media parts.\n   */\n  get media() {\n    return this.content.filter((part) => part.media && !part.text).map((part) => part.media);\n  }\n  /**\n   * Gets the first item in the document. Either text or media url.\n   */\n  get data() {\n    if (this.text) {\n      return this.text;\n    }\n    if (this.media) {\n      return this.media[0].url;\n    }\n    return \"\";\n  }\n  /**\n   * Gets the contentType of the data that is returned by data()\n   */\n  get dataType() {\n    if (this.text) {\n      return \"text\";\n    }\n    if (this.media && this.media[0].contentType) {\n      return this.media[0].contentType;\n    }\n    return void 0;\n  }\n  toJSON() {\n    return {\n      content: deepCopy(this.content),\n      metadata: deepCopy(this.metadata)\n    };\n  }\n  /**\n   * Embedders may return multiple embeddings for a single document.\n   * But storage still requires a 1:1 relationship. So we create an\n   * array of Documents from a single document - one per embedding.\n   * @param embeddings The embeddings to create the documents from.\n   * @returns an array of documents based on this document and the embeddings.\n   */\n  getEmbeddingDocuments(embeddings) {\n    const documents = [];\n    for (const embedding of embeddings) {\n      const jsonDoc = this.toJSON();\n      if (embedding.metadata) {\n        if (!jsonDoc.metadata) {\n          jsonDoc.metadata = {};\n        }\n        jsonDoc.metadata.embedMetadata = embedding.metadata;\n      }\n      documents.push(new Document(jsonDoc));\n    }\n    checkUniqueDocuments(documents);\n    return documents;\n  }\n}\nfunction checkUniqueDocuments(documents) {\n  const seen = /* @__PURE__ */ new Set();\n  for (const doc of documents) {\n    const serialized = JSON.stringify(doc);\n    if (seen.has(serialized)) {\n      console.warn(\n        \"Warning: embedding documents are not unique. Are you missing embed metadata?\"\n      );\n      return false;\n    }\n    seen.add(serialized);\n  }\n  return true;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=document.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9kb2N1bWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxxRkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBZ0JMO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcS1JhbWFjaGFcXERvY3VtZW50c1xcU3VzdEFJbmV4IEdJdCBDb2RlXFxub2RlX21vZHVsZXNcXEBnZW5raXQtYWlcXGFpXFxsaWJcXGRvY3VtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBkb2N1bWVudF9leHBvcnRzID0ge307XG5fX2V4cG9ydChkb2N1bWVudF9leHBvcnRzLCB7XG4gIEN1c3RvbVBhcnRTY2hlbWE6ICgpID0+IEN1c3RvbVBhcnRTY2hlbWEsXG4gIERhdGFQYXJ0U2NoZW1hOiAoKSA9PiBEYXRhUGFydFNjaGVtYSxcbiAgRG9jdW1lbnQ6ICgpID0+IERvY3VtZW50LFxuICBEb2N1bWVudERhdGFTY2hlbWE6ICgpID0+IERvY3VtZW50RGF0YVNjaGVtYSxcbiAgTWVkaWFQYXJ0U2NoZW1hOiAoKSA9PiBNZWRpYVBhcnRTY2hlbWEsXG4gIE1lZGlhU2NoZW1hOiAoKSA9PiBNZWRpYVNjaGVtYSxcbiAgUGFydFNjaGVtYTogKCkgPT4gUGFydFNjaGVtYSxcbiAgUmVhc29uaW5nUGFydFNjaGVtYTogKCkgPT4gUmVhc29uaW5nUGFydFNjaGVtYSxcbiAgUmVzb3VyY2VQYXJ0U2NoZW1hOiAoKSA9PiBSZXNvdXJjZVBhcnRTY2hlbWEsXG4gIFRleHRQYXJ0U2NoZW1hOiAoKSA9PiBUZXh0UGFydFNjaGVtYSxcbiAgVG9vbFJlcXVlc3RQYXJ0U2NoZW1hOiAoKSA9PiBUb29sUmVxdWVzdFBhcnRTY2hlbWEsXG4gIFRvb2xSZXF1ZXN0U2NoZW1hOiAoKSA9PiBUb29sUmVxdWVzdFNjaGVtYSxcbiAgVG9vbFJlc3BvbnNlUGFydFNjaGVtYTogKCkgPT4gVG9vbFJlc3BvbnNlUGFydFNjaGVtYSxcbiAgVG9vbFJlc3BvbnNlU2NoZW1hOiAoKSA9PiBUb29sUmVzcG9uc2VTY2hlbWEsXG4gIGNoZWNrVW5pcXVlRG9jdW1lbnRzOiAoKSA9PiBjaGVja1VuaXF1ZURvY3VtZW50c1xufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhkb2N1bWVudF9leHBvcnRzKTtcbnZhciBpbXBvcnRfY29yZSA9IHJlcXVpcmUoXCJAZ2Vua2l0LWFpL2NvcmVcIik7XG5jb25zdCBFbXB0eVBhcnRTY2hlbWEgPSBpbXBvcnRfY29yZS56Lm9iamVjdCh7XG4gIHRleHQ6IGltcG9ydF9jb3JlLnoubmV2ZXIoKS5vcHRpb25hbCgpLFxuICBtZWRpYTogaW1wb3J0X2NvcmUuei5uZXZlcigpLm9wdGlvbmFsKCksXG4gIHRvb2xSZXF1ZXN0OiBpbXBvcnRfY29yZS56Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgdG9vbFJlc3BvbnNlOiBpbXBvcnRfY29yZS56Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgZGF0YTogaW1wb3J0X2NvcmUuei51bmtub3duKCkub3B0aW9uYWwoKSxcbiAgbWV0YWRhdGE6IGltcG9ydF9jb3JlLnoucmVjb3JkKGltcG9ydF9jb3JlLnoudW5rbm93bigpKS5vcHRpb25hbCgpLFxuICBjdXN0b206IGltcG9ydF9jb3JlLnoucmVjb3JkKGltcG9ydF9jb3JlLnoudW5rbm93bigpKS5vcHRpb25hbCgpLFxuICByZWFzb25pbmc6IGltcG9ydF9jb3JlLnoubmV2ZXIoKS5vcHRpb25hbCgpLFxuICByZXNvdXJjZTogaW1wb3J0X2NvcmUuei5uZXZlcigpLm9wdGlvbmFsKClcbn0pO1xuY29uc3QgVGV4dFBhcnRTY2hlbWEgPSBFbXB0eVBhcnRTY2hlbWEuZXh0ZW5kKHtcbiAgLyoqIFRoZSB0ZXh0IG9mIHRoZSBtZXNzYWdlLiAqL1xuICB0ZXh0OiBpbXBvcnRfY29yZS56LnN0cmluZygpXG59KTtcbmNvbnN0IFJlYXNvbmluZ1BhcnRTY2hlbWEgPSBFbXB0eVBhcnRTY2hlbWEuZXh0ZW5kKHtcbiAgLyoqIFRoZSByZWFzb25pbmcgdGV4dCBvZiB0aGUgbWVzc2FnZS4gKi9cbiAgcmVhc29uaW5nOiBpbXBvcnRfY29yZS56LnN0cmluZygpXG59KTtcbmNvbnN0IE1lZGlhU2NoZW1hID0gaW1wb3J0X2NvcmUuei5vYmplY3Qoe1xuICAvKiogVGhlIG1lZGlhIGNvbnRlbnQgdHlwZS4gSW5mZXJyZWQgZnJvbSBkYXRhIHVyaSBpZiBub3QgcHJvdmlkZWQuICovXG4gIGNvbnRlbnRUeXBlOiBpbXBvcnRfY29yZS56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIC8qKiBBIGBkYXRhOmAgb3IgYGh0dHBzOmAgdXJpIGNvbnRhaW5pbmcgdGhlIG1lZGlhIGNvbnRlbnQuICAqL1xuICB1cmw6IGltcG9ydF9jb3JlLnouc3RyaW5nKClcbn0pO1xuY29uc3QgTWVkaWFQYXJ0U2NoZW1hID0gRW1wdHlQYXJ0U2NoZW1hLmV4dGVuZCh7XG4gIG1lZGlhOiBNZWRpYVNjaGVtYVxufSk7XG5jb25zdCBUb29sUmVxdWVzdFNjaGVtYSA9IGltcG9ydF9jb3JlLnoub2JqZWN0KHtcbiAgLyoqIFRoZSBjYWxsIGlkIG9yIHJlZmVyZW5jZSBmb3IgYSBzcGVjaWZpYyByZXF1ZXN0LiAqL1xuICByZWY6IGltcG9ydF9jb3JlLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgLyoqIFRoZSBuYW1lIG9mIHRoZSB0b29sIHRvIGNhbGwuICovXG4gIG5hbWU6IGltcG9ydF9jb3JlLnouc3RyaW5nKCksXG4gIC8qKiBUaGUgaW5wdXQgcGFyYW1ldGVycyBmb3IgdGhlIHRvb2wsIHVzdWFsbHkgYSBKU09OIG9iamVjdC4gKi9cbiAgaW5wdXQ6IGltcG9ydF9jb3JlLnoudW5rbm93bigpLm9wdGlvbmFsKClcbn0pO1xuY29uc3QgVG9vbFJlcXVlc3RQYXJ0U2NoZW1hID0gRW1wdHlQYXJ0U2NoZW1hLmV4dGVuZCh7XG4gIC8qKiBBIHJlcXVlc3QgZm9yIGEgdG9vbCB0byBiZSBleGVjdXRlZCwgdXN1YWxseSBwcm92aWRlZCBieSBhIG1vZGVsLiAqL1xuICB0b29sUmVxdWVzdDogVG9vbFJlcXVlc3RTY2hlbWFcbn0pO1xuY29uc3QgVG9vbFJlc3BvbnNlU2NoZW1hID0gaW1wb3J0X2NvcmUuei5vYmplY3Qoe1xuICAvKiogVGhlIGNhbGwgaWQgb3IgcmVmZXJlbmNlIGZvciBhIHNwZWNpZmljIHJlcXVlc3QuICovXG4gIHJlZjogaW1wb3J0X2NvcmUuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAvKiogVGhlIG5hbWUgb2YgdGhlIHRvb2wuICovXG4gIG5hbWU6IGltcG9ydF9jb3JlLnouc3RyaW5nKCksXG4gIC8qKiBUaGUgb3V0cHV0IGRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgdG9vbCwgdXN1YWxseSBhIEpTT04gb2JqZWN0LiAqL1xuICBvdXRwdXQ6IGltcG9ydF9jb3JlLnoudW5rbm93bigpLm9wdGlvbmFsKClcbn0pO1xuY29uc3QgVG9vbFJlc3BvbnNlUGFydFNjaGVtYSA9IEVtcHR5UGFydFNjaGVtYS5leHRlbmQoe1xuICAvKiogQSBwcm92aWRlZCByZXNwb25zZSB0byBhIHRvb2wgY2FsbC4gKi9cbiAgdG9vbFJlc3BvbnNlOiBUb29sUmVzcG9uc2VTY2hlbWFcbn0pO1xuY29uc3QgRGF0YVBhcnRTY2hlbWEgPSBFbXB0eVBhcnRTY2hlbWEuZXh0ZW5kKHtcbiAgZGF0YTogaW1wb3J0X2NvcmUuei51bmtub3duKClcbn0pO1xuY29uc3QgQ3VzdG9tUGFydFNjaGVtYSA9IEVtcHR5UGFydFNjaGVtYS5leHRlbmQoe1xuICBjdXN0b206IGltcG9ydF9jb3JlLnoucmVjb3JkKGltcG9ydF9jb3JlLnouYW55KCkpXG59KTtcbmNvbnN0IFJlc291cmNlUGFydFNjaGVtYSA9IEVtcHR5UGFydFNjaGVtYS5leHRlbmQoe1xuICByZXNvdXJjZTogaW1wb3J0X2NvcmUuei5vYmplY3Qoe1xuICAgIHVyaTogaW1wb3J0X2NvcmUuei5zdHJpbmcoKVxuICB9KVxufSk7XG5jb25zdCBQYXJ0U2NoZW1hID0gaW1wb3J0X2NvcmUuei51bmlvbihbVGV4dFBhcnRTY2hlbWEsIE1lZGlhUGFydFNjaGVtYV0pO1xuY29uc3QgRG9jdW1lbnREYXRhU2NoZW1hID0gaW1wb3J0X2NvcmUuei5vYmplY3Qoe1xuICBjb250ZW50OiBpbXBvcnRfY29yZS56LmFycmF5KFBhcnRTY2hlbWEpLFxuICBtZXRhZGF0YTogaW1wb3J0X2NvcmUuei5yZWNvcmQoaW1wb3J0X2NvcmUuei5zdHJpbmcoKSwgaW1wb3J0X2NvcmUuei5hbnkoKSkub3B0aW9uYWwoKVxufSk7XG5mdW5jdGlvbiBkZWVwQ29weSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xufVxuY2xhc3MgRG9jdW1lbnQge1xuICBjb250ZW50O1xuICBtZXRhZGF0YTtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHRoaXMuY29udGVudCA9IGRlZXBDb3B5KGRhdGEuY29udGVudCk7XG4gICAgdGhpcy5tZXRhZGF0YSA9IGRlZXBDb3B5KGRhdGEubWV0YWRhdGEpO1xuICB9XG4gIHN0YXRpYyBmcm9tVGV4dCh0ZXh0LCBtZXRhZGF0YSkge1xuICAgIHJldHVybiBuZXcgRG9jdW1lbnQoe1xuICAgICAgY29udGVudDogW3sgdGV4dCB9XSxcbiAgICAgIG1ldGFkYXRhXG4gICAgfSk7XG4gIH1cbiAgLy8gQ29uc3RydWN0IGEgRG9jdW1lbnQgZnJvbSBhIHNpbmdsZSBtZWRpYSBpdGVtXG4gIHN0YXRpYyBmcm9tTWVkaWEodXJsLCBjb250ZW50VHlwZSwgbWV0YWRhdGEpIHtcbiAgICByZXR1cm4gbmV3IERvY3VtZW50KHtcbiAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAge1xuICAgICAgICAgIG1lZGlhOiB7XG4gICAgICAgICAgICBjb250ZW50VHlwZSxcbiAgICAgICAgICAgIHVybFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIG1ldGFkYXRhXG4gICAgfSk7XG4gIH1cbiAgLy8gQ29uc3RydWN0IGEgRG9jdW1lbnQgZnJvbSBjb250ZW50XG4gIHN0YXRpYyBmcm9tRGF0YShkYXRhLCBkYXRhVHlwZSwgbWV0YWRhdGEpIHtcbiAgICBpZiAoZGF0YVR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5mcm9tVGV4dChkYXRhLCBtZXRhZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZyb21NZWRpYShkYXRhLCBkYXRhVHlwZSwgbWV0YWRhdGEpO1xuICB9XG4gIC8qKlxuICAgKiBDb25jYXRlbmF0ZXMgYWxsIGB0ZXh0YCBwYXJ0cyBwcmVzZW50IGluIHRoZSBkb2N1bWVudCB3aXRoIG5vIGRlbGltaXRlci5cbiAgICogQHJldHVybnMgQSBzdHJpbmcgb2YgYWxsIGNvbmNhdGVuYXRlZCB0ZXh0IHBhcnRzLlxuICAgKi9cbiAgZ2V0IHRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5tYXAoKHBhcnQpID0+IHBhcnQudGV4dCB8fCBcIlwiKS5qb2luKFwiXCIpO1xuICB9XG4gIC8qKlxuICAgKiBNZWRpYSBhcnJheSBnZXR0ZXIuXG4gICAqIEByZXR1cm5zIHRoZSBhcnJheSBvZiBtZWRpYSBwYXJ0cy5cbiAgICovXG4gIGdldCBtZWRpYSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50LmZpbHRlcigocGFydCkgPT4gcGFydC5tZWRpYSAmJiAhcGFydC50ZXh0KS5tYXAoKHBhcnQpID0+IHBhcnQubWVkaWEpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBkb2N1bWVudC4gRWl0aGVyIHRleHQgb3IgbWVkaWEgdXJsLlxuICAgKi9cbiAgZ2V0IGRhdGEoKSB7XG4gICAgaWYgKHRoaXMudGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICB9XG4gICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lZGlhWzBdLnVybDtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGNvbnRlbnRUeXBlIG9mIHRoZSBkYXRhIHRoYXQgaXMgcmV0dXJuZWQgYnkgZGF0YSgpXG4gICAqL1xuICBnZXQgZGF0YVR5cGUoKSB7XG4gICAgaWYgKHRoaXMudGV4dCkge1xuICAgICAgcmV0dXJuIFwidGV4dFwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5tZWRpYSAmJiB0aGlzLm1lZGlhWzBdLmNvbnRlbnRUeXBlKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZWRpYVswXS5jb250ZW50VHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRlbnQ6IGRlZXBDb3B5KHRoaXMuY29udGVudCksXG4gICAgICBtZXRhZGF0YTogZGVlcENvcHkodGhpcy5tZXRhZGF0YSlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBFbWJlZGRlcnMgbWF5IHJldHVybiBtdWx0aXBsZSBlbWJlZGRpbmdzIGZvciBhIHNpbmdsZSBkb2N1bWVudC5cbiAgICogQnV0IHN0b3JhZ2Ugc3RpbGwgcmVxdWlyZXMgYSAxOjEgcmVsYXRpb25zaGlwLiBTbyB3ZSBjcmVhdGUgYW5cbiAgICogYXJyYXkgb2YgRG9jdW1lbnRzIGZyb20gYSBzaW5nbGUgZG9jdW1lbnQgLSBvbmUgcGVyIGVtYmVkZGluZy5cbiAgICogQHBhcmFtIGVtYmVkZGluZ3MgVGhlIGVtYmVkZGluZ3MgdG8gY3JlYXRlIHRoZSBkb2N1bWVudHMgZnJvbS5cbiAgICogQHJldHVybnMgYW4gYXJyYXkgb2YgZG9jdW1lbnRzIGJhc2VkIG9uIHRoaXMgZG9jdW1lbnQgYW5kIHRoZSBlbWJlZGRpbmdzLlxuICAgKi9cbiAgZ2V0RW1iZWRkaW5nRG9jdW1lbnRzKGVtYmVkZGluZ3MpIHtcbiAgICBjb25zdCBkb2N1bWVudHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVtYmVkZGluZyBvZiBlbWJlZGRpbmdzKSB7XG4gICAgICBjb25zdCBqc29uRG9jID0gdGhpcy50b0pTT04oKTtcbiAgICAgIGlmIChlbWJlZGRpbmcubWV0YWRhdGEpIHtcbiAgICAgICAgaWYgKCFqc29uRG9jLm1ldGFkYXRhKSB7XG4gICAgICAgICAganNvbkRvYy5tZXRhZGF0YSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGpzb25Eb2MubWV0YWRhdGEuZW1iZWRNZXRhZGF0YSA9IGVtYmVkZGluZy5tZXRhZGF0YTtcbiAgICAgIH1cbiAgICAgIGRvY3VtZW50cy5wdXNoKG5ldyBEb2N1bWVudChqc29uRG9jKSk7XG4gICAgfVxuICAgIGNoZWNrVW5pcXVlRG9jdW1lbnRzKGRvY3VtZW50cyk7XG4gICAgcmV0dXJuIGRvY3VtZW50cztcbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tVbmlxdWVEb2N1bWVudHMoZG9jdW1lbnRzKSB7XG4gIGNvbnN0IHNlZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IGRvYyBvZiBkb2N1bWVudHMpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gSlNPTi5zdHJpbmdpZnkoZG9jKTtcbiAgICBpZiAoc2Vlbi5oYXMoc2VyaWFsaXplZCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJXYXJuaW5nOiBlbWJlZGRpbmcgZG9jdW1lbnRzIGFyZSBub3QgdW5pcXVlLiBBcmUgeW91IG1pc3NpbmcgZW1iZWQgbWV0YWRhdGE/XCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNlZW4uYWRkKHNlcmlhbGl6ZWQpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIEN1c3RvbVBhcnRTY2hlbWEsXG4gIERhdGFQYXJ0U2NoZW1hLFxuICBEb2N1bWVudCxcbiAgRG9jdW1lbnREYXRhU2NoZW1hLFxuICBNZWRpYVBhcnRTY2hlbWEsXG4gIE1lZGlhU2NoZW1hLFxuICBQYXJ0U2NoZW1hLFxuICBSZWFzb25pbmdQYXJ0U2NoZW1hLFxuICBSZXNvdXJjZVBhcnRTY2hlbWEsXG4gIFRleHRQYXJ0U2NoZW1hLFxuICBUb29sUmVxdWVzdFBhcnRTY2hlbWEsXG4gIFRvb2xSZXF1ZXN0U2NoZW1hLFxuICBUb29sUmVzcG9uc2VQYXJ0U2NoZW1hLFxuICBUb29sUmVzcG9uc2VTY2hlbWEsXG4gIGNoZWNrVW5pcXVlRG9jdW1lbnRzXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvY3VtZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/document.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/embedder.js":
/*!****************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/embedder.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar embedder_exports = {};\n__export(embedder_exports, {\n  EmbedderInfoSchema: () => EmbedderInfoSchema,\n  EmbeddingSchema: () => EmbeddingSchema,\n  defineEmbedder: () => defineEmbedder,\n  embed: () => embed,\n  embedMany: () => embedMany,\n  embedder: () => embedder,\n  embedderActionMetadata: () => embedderActionMetadata,\n  embedderRef: () => embedderRef\n});\nmodule.exports = __toCommonJS(embedder_exports);\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nvar import_schema = __webpack_require__(/*! @genkit-ai/core/schema */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/schema.js\");\nvar import_document = __webpack_require__(/*! ./document.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/document.js\");\nconst EmbeddingSchema = import_core.z.object({\n  embedding: import_core.z.array(import_core.z.number()),\n  metadata: import_core.z.record(import_core.z.string(), import_core.z.unknown()).optional()\n});\nconst EmbedRequestSchema = import_core.z.object({\n  input: import_core.z.array(import_document.DocumentDataSchema),\n  options: import_core.z.any().optional()\n});\nconst EmbedResponseSchema = import_core.z.object({\n  embeddings: import_core.z.array(EmbeddingSchema)\n  // TODO: stats, etc.\n});\nfunction withMetadata(embedder2, configSchema) {\n  const withMeta = embedder2;\n  withMeta.__configSchema = configSchema;\n  return withMeta;\n}\nfunction embedder(options, runner) {\n  const embedder2 = (0, import_core.action)(\n    embedderActionOptions(options),\n    (i, opts) => runner(\n      {\n        input: i.input.map((dd) => new import_document.Document(dd)),\n        options: i.options\n      },\n      opts\n    )\n  );\n  const ewm = withMetadata(\n    embedder2,\n    options.configSchema\n  );\n  return ewm;\n}\nfunction embedderActionOptions(options) {\n  return {\n    actionType: \"embedder\",\n    name: options.name,\n    inputSchema: EmbedRequestSchema,\n    outputSchema: EmbedResponseSchema,\n    metadata: {\n      type: \"embedder\",\n      info: options.info,\n      embedder: {\n        customOptions: options.configSchema ? (0, import_schema.toJsonSchema)({ schema: options.configSchema }) : void 0\n      }\n    }\n  };\n}\nfunction defineEmbedder(registry, options, runner) {\n  const embedder2 = (0, import_core.defineAction)(\n    registry,\n    embedderActionOptions(options),\n    (i) => runner(\n      i.input.map((dd) => new import_document.Document(dd)),\n      i.options\n    )\n  );\n  const ewm = withMetadata(\n    embedder2,\n    options.configSchema\n  );\n  return ewm;\n}\nasync function embed(registry, params) {\n  const embedder2 = await resolveEmbedder(registry, params);\n  if (!embedder2.embedderAction) {\n    let embedderId;\n    if (typeof params.embedder === \"string\") {\n      embedderId = params.embedder;\n    } else if (params.embedder?.__action?.name) {\n      embedderId = params.embedder.__action.name;\n    } else {\n      embedderId = params.embedder.name;\n    }\n    throw new Error(`Unable to resolve embedder ${embedderId}`);\n  }\n  const response = await embedder2.embedderAction({\n    input: typeof params.content === \"string\" ? [import_document.Document.fromText(params.content, params.metadata)] : [params.content],\n    options: {\n      version: embedder2.version,\n      ...embedder2.config,\n      ...params.options\n    }\n  });\n  return response.embeddings;\n}\nasync function resolveEmbedder(registry, params) {\n  if (typeof params.embedder === \"string\") {\n    return {\n      embedderAction: await registry.lookupAction(\n        `/embedder/${params.embedder}`\n      )\n    };\n  } else if (Object.hasOwnProperty.call(params.embedder, \"__action\")) {\n    return {\n      embedderAction: params.embedder\n    };\n  } else if (Object.hasOwnProperty.call(params.embedder, \"name\")) {\n    const ref = params.embedder;\n    return {\n      embedderAction: await registry.lookupAction(\n        `/embedder/${params.embedder.name}`\n      ),\n      config: {\n        ...ref.config\n      },\n      version: ref.version\n    };\n  }\n  throw new Error(`failed to resolve embedder ${params.embedder}`);\n}\nasync function embedMany(registry, params) {\n  let embedder2;\n  if (typeof params.embedder === \"string\") {\n    embedder2 = await registry.lookupAction(`/embedder/${params.embedder}`);\n  } else if (Object.hasOwnProperty.call(params.embedder, \"info\")) {\n    embedder2 = await registry.lookupAction(\n      `/embedder/${params.embedder.name}`\n    );\n  } else {\n    embedder2 = params.embedder;\n  }\n  if (!embedder2) {\n    throw new Error(\"Unable to utilize the provided embedder\");\n  }\n  const response = await embedder2({\n    input: params.content.map(\n      (i) => typeof i === \"string\" ? import_document.Document.fromText(i, params.metadata) : i\n    ),\n    options: params.options\n  });\n  return response.embeddings;\n}\nconst EmbedderInfoSchema = import_core.z.object({\n  /** Friendly label for this model (e.g. \"Google AI - Gemini Pro\") */\n  label: import_core.z.string().optional(),\n  /** Supported model capabilities. */\n  supports: import_core.z.object({\n    /** Model can input this type of data. */\n    input: import_core.z.array(import_core.z.enum([\"text\", \"image\", \"video\"])).optional(),\n    /** Model can support multiple languages */\n    multilingual: import_core.z.boolean().optional()\n  }).optional(),\n  /** Embedding dimension */\n  dimensions: import_core.z.number().optional()\n});\nfunction embedderRef(options) {\n  let name = options.name;\n  if (options.namespace && !name.startsWith(options.namespace + \"/\")) {\n    name = `${options.namespace}/${name}`;\n  }\n  return { ...options, name };\n}\nfunction embedderActionMetadata({\n  name,\n  info,\n  configSchema\n}) {\n  return {\n    actionType: \"embedder\",\n    name,\n    inputJsonSchema: (0, import_schema.toJsonSchema)({ schema: EmbedRequestSchema }),\n    outputJsonSchema: (0, import_schema.toJsonSchema)({ schema: EmbedResponseSchema }),\n    metadata: {\n      embedder: {\n        ...info,\n        customOptions: configSchema ? (0, import_schema.toJsonSchema)({ schema: configSchema }) : void 0\n      }\n    }\n  };\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=embedder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9lbWJlZGRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMscUZBQWlCO0FBQzNDLG9CQUFvQixtQkFBTyxDQUFDLDZGQUF3QjtBQUNwRCxzQkFBc0IsbUJBQU8sQ0FBQyxvRkFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsOEJBQThCO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxrREFBa0QsV0FBVztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxnQkFBZ0I7QUFDekUsSUFBSTtBQUNKO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQkFBa0IsR0FBRyxLQUFLO0FBQ3hDO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDRCQUE0QjtBQUNuRix3REFBd0QsNkJBQTZCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxzQkFBc0I7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FTTDtBQUNEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEtSYW1hY2hhXFxEb2N1bWVudHNcXFN1c3RBSW5leCBHSXQgQ29kZVxcbm9kZV9tb2R1bGVzXFxAZ2Vua2l0LWFpXFxhaVxcbGliXFxlbWJlZGRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgZW1iZWRkZXJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZW1iZWRkZXJfZXhwb3J0cywge1xuICBFbWJlZGRlckluZm9TY2hlbWE6ICgpID0+IEVtYmVkZGVySW5mb1NjaGVtYSxcbiAgRW1iZWRkaW5nU2NoZW1hOiAoKSA9PiBFbWJlZGRpbmdTY2hlbWEsXG4gIGRlZmluZUVtYmVkZGVyOiAoKSA9PiBkZWZpbmVFbWJlZGRlcixcbiAgZW1iZWQ6ICgpID0+IGVtYmVkLFxuICBlbWJlZE1hbnk6ICgpID0+IGVtYmVkTWFueSxcbiAgZW1iZWRkZXI6ICgpID0+IGVtYmVkZGVyLFxuICBlbWJlZGRlckFjdGlvbk1ldGFkYXRhOiAoKSA9PiBlbWJlZGRlckFjdGlvbk1ldGFkYXRhLFxuICBlbWJlZGRlclJlZjogKCkgPT4gZW1iZWRkZXJSZWZcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoZW1iZWRkZXJfZXhwb3J0cyk7XG52YXIgaW1wb3J0X2NvcmUgPSByZXF1aXJlKFwiQGdlbmtpdC1haS9jb3JlXCIpO1xudmFyIGltcG9ydF9zY2hlbWEgPSByZXF1aXJlKFwiQGdlbmtpdC1haS9jb3JlL3NjaGVtYVwiKTtcbnZhciBpbXBvcnRfZG9jdW1lbnQgPSByZXF1aXJlKFwiLi9kb2N1bWVudC5qc1wiKTtcbmNvbnN0IEVtYmVkZGluZ1NjaGVtYSA9IGltcG9ydF9jb3JlLnoub2JqZWN0KHtcbiAgZW1iZWRkaW5nOiBpbXBvcnRfY29yZS56LmFycmF5KGltcG9ydF9jb3JlLnoubnVtYmVyKCkpLFxuICBtZXRhZGF0YTogaW1wb3J0X2NvcmUuei5yZWNvcmQoaW1wb3J0X2NvcmUuei5zdHJpbmcoKSwgaW1wb3J0X2NvcmUuei51bmtub3duKCkpLm9wdGlvbmFsKClcbn0pO1xuY29uc3QgRW1iZWRSZXF1ZXN0U2NoZW1hID0gaW1wb3J0X2NvcmUuei5vYmplY3Qoe1xuICBpbnB1dDogaW1wb3J0X2NvcmUuei5hcnJheShpbXBvcnRfZG9jdW1lbnQuRG9jdW1lbnREYXRhU2NoZW1hKSxcbiAgb3B0aW9uczogaW1wb3J0X2NvcmUuei5hbnkoKS5vcHRpb25hbCgpXG59KTtcbmNvbnN0IEVtYmVkUmVzcG9uc2VTY2hlbWEgPSBpbXBvcnRfY29yZS56Lm9iamVjdCh7XG4gIGVtYmVkZGluZ3M6IGltcG9ydF9jb3JlLnouYXJyYXkoRW1iZWRkaW5nU2NoZW1hKVxuICAvLyBUT0RPOiBzdGF0cywgZXRjLlxufSk7XG5mdW5jdGlvbiB3aXRoTWV0YWRhdGEoZW1iZWRkZXIyLCBjb25maWdTY2hlbWEpIHtcbiAgY29uc3Qgd2l0aE1ldGEgPSBlbWJlZGRlcjI7XG4gIHdpdGhNZXRhLl9fY29uZmlnU2NoZW1hID0gY29uZmlnU2NoZW1hO1xuICByZXR1cm4gd2l0aE1ldGE7XG59XG5mdW5jdGlvbiBlbWJlZGRlcihvcHRpb25zLCBydW5uZXIpIHtcbiAgY29uc3QgZW1iZWRkZXIyID0gKDAsIGltcG9ydF9jb3JlLmFjdGlvbikoXG4gICAgZW1iZWRkZXJBY3Rpb25PcHRpb25zKG9wdGlvbnMpLFxuICAgIChpLCBvcHRzKSA9PiBydW5uZXIoXG4gICAgICB7XG4gICAgICAgIGlucHV0OiBpLmlucHV0Lm1hcCgoZGQpID0+IG5ldyBpbXBvcnRfZG9jdW1lbnQuRG9jdW1lbnQoZGQpKSxcbiAgICAgICAgb3B0aW9uczogaS5vcHRpb25zXG4gICAgICB9LFxuICAgICAgb3B0c1xuICAgIClcbiAgKTtcbiAgY29uc3QgZXdtID0gd2l0aE1ldGFkYXRhKFxuICAgIGVtYmVkZGVyMixcbiAgICBvcHRpb25zLmNvbmZpZ1NjaGVtYVxuICApO1xuICByZXR1cm4gZXdtO1xufVxuZnVuY3Rpb24gZW1iZWRkZXJBY3Rpb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBhY3Rpb25UeXBlOiBcImVtYmVkZGVyXCIsXG4gICAgbmFtZTogb3B0aW9ucy5uYW1lLFxuICAgIGlucHV0U2NoZW1hOiBFbWJlZFJlcXVlc3RTY2hlbWEsXG4gICAgb3V0cHV0U2NoZW1hOiBFbWJlZFJlc3BvbnNlU2NoZW1hLFxuICAgIG1ldGFkYXRhOiB7XG4gICAgICB0eXBlOiBcImVtYmVkZGVyXCIsXG4gICAgICBpbmZvOiBvcHRpb25zLmluZm8sXG4gICAgICBlbWJlZGRlcjoge1xuICAgICAgICBjdXN0b21PcHRpb25zOiBvcHRpb25zLmNvbmZpZ1NjaGVtYSA/ICgwLCBpbXBvcnRfc2NoZW1hLnRvSnNvblNjaGVtYSkoeyBzY2hlbWE6IG9wdGlvbnMuY29uZmlnU2NoZW1hIH0pIDogdm9pZCAwXG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZGVmaW5lRW1iZWRkZXIocmVnaXN0cnksIG9wdGlvbnMsIHJ1bm5lcikge1xuICBjb25zdCBlbWJlZGRlcjIgPSAoMCwgaW1wb3J0X2NvcmUuZGVmaW5lQWN0aW9uKShcbiAgICByZWdpc3RyeSxcbiAgICBlbWJlZGRlckFjdGlvbk9wdGlvbnMob3B0aW9ucyksXG4gICAgKGkpID0+IHJ1bm5lcihcbiAgICAgIGkuaW5wdXQubWFwKChkZCkgPT4gbmV3IGltcG9ydF9kb2N1bWVudC5Eb2N1bWVudChkZCkpLFxuICAgICAgaS5vcHRpb25zXG4gICAgKVxuICApO1xuICBjb25zdCBld20gPSB3aXRoTWV0YWRhdGEoXG4gICAgZW1iZWRkZXIyLFxuICAgIG9wdGlvbnMuY29uZmlnU2NoZW1hXG4gICk7XG4gIHJldHVybiBld207XG59XG5hc3luYyBmdW5jdGlvbiBlbWJlZChyZWdpc3RyeSwgcGFyYW1zKSB7XG4gIGNvbnN0IGVtYmVkZGVyMiA9IGF3YWl0IHJlc29sdmVFbWJlZGRlcihyZWdpc3RyeSwgcGFyYW1zKTtcbiAgaWYgKCFlbWJlZGRlcjIuZW1iZWRkZXJBY3Rpb24pIHtcbiAgICBsZXQgZW1iZWRkZXJJZDtcbiAgICBpZiAodHlwZW9mIHBhcmFtcy5lbWJlZGRlciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZW1iZWRkZXJJZCA9IHBhcmFtcy5lbWJlZGRlcjtcbiAgICB9IGVsc2UgaWYgKHBhcmFtcy5lbWJlZGRlcj8uX19hY3Rpb24/Lm5hbWUpIHtcbiAgICAgIGVtYmVkZGVySWQgPSBwYXJhbXMuZW1iZWRkZXIuX19hY3Rpb24ubmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1iZWRkZXJJZCA9IHBhcmFtcy5lbWJlZGRlci5uYW1lO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byByZXNvbHZlIGVtYmVkZGVyICR7ZW1iZWRkZXJJZH1gKTtcbiAgfVxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGVtYmVkZGVyMi5lbWJlZGRlckFjdGlvbih7XG4gICAgaW5wdXQ6IHR5cGVvZiBwYXJhbXMuY29udGVudCA9PT0gXCJzdHJpbmdcIiA/IFtpbXBvcnRfZG9jdW1lbnQuRG9jdW1lbnQuZnJvbVRleHQocGFyYW1zLmNvbnRlbnQsIHBhcmFtcy5tZXRhZGF0YSldIDogW3BhcmFtcy5jb250ZW50XSxcbiAgICBvcHRpb25zOiB7XG4gICAgICB2ZXJzaW9uOiBlbWJlZGRlcjIudmVyc2lvbixcbiAgICAgIC4uLmVtYmVkZGVyMi5jb25maWcsXG4gICAgICAuLi5wYXJhbXMub3B0aW9uc1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXNwb25zZS5lbWJlZGRpbmdzO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUVtYmVkZGVyKHJlZ2lzdHJ5LCBwYXJhbXMpIHtcbiAgaWYgKHR5cGVvZiBwYXJhbXMuZW1iZWRkZXIgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZW1iZWRkZXJBY3Rpb246IGF3YWl0IHJlZ2lzdHJ5Lmxvb2t1cEFjdGlvbihcbiAgICAgICAgYC9lbWJlZGRlci8ke3BhcmFtcy5lbWJlZGRlcn1gXG4gICAgICApXG4gICAgfTtcbiAgfSBlbHNlIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbXMuZW1iZWRkZXIsIFwiX19hY3Rpb25cIikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZW1iZWRkZXJBY3Rpb246IHBhcmFtcy5lbWJlZGRlclxuICAgIH07XG4gIH0gZWxzZSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocGFyYW1zLmVtYmVkZGVyLCBcIm5hbWVcIikpIHtcbiAgICBjb25zdCByZWYgPSBwYXJhbXMuZW1iZWRkZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVtYmVkZGVyQWN0aW9uOiBhd2FpdCByZWdpc3RyeS5sb29rdXBBY3Rpb24oXG4gICAgICAgIGAvZW1iZWRkZXIvJHtwYXJhbXMuZW1iZWRkZXIubmFtZX1gXG4gICAgICApLFxuICAgICAgY29uZmlnOiB7XG4gICAgICAgIC4uLnJlZi5jb25maWdcbiAgICAgIH0sXG4gICAgICB2ZXJzaW9uOiByZWYudmVyc2lvblxuICAgIH07XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gcmVzb2x2ZSBlbWJlZGRlciAke3BhcmFtcy5lbWJlZGRlcn1gKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGVtYmVkTWFueShyZWdpc3RyeSwgcGFyYW1zKSB7XG4gIGxldCBlbWJlZGRlcjI7XG4gIGlmICh0eXBlb2YgcGFyYW1zLmVtYmVkZGVyID09PSBcInN0cmluZ1wiKSB7XG4gICAgZW1iZWRkZXIyID0gYXdhaXQgcmVnaXN0cnkubG9va3VwQWN0aW9uKGAvZW1iZWRkZXIvJHtwYXJhbXMuZW1iZWRkZXJ9YCk7XG4gIH0gZWxzZSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocGFyYW1zLmVtYmVkZGVyLCBcImluZm9cIikpIHtcbiAgICBlbWJlZGRlcjIgPSBhd2FpdCByZWdpc3RyeS5sb29rdXBBY3Rpb24oXG4gICAgICBgL2VtYmVkZGVyLyR7cGFyYW1zLmVtYmVkZGVyLm5hbWV9YFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgZW1iZWRkZXIyID0gcGFyYW1zLmVtYmVkZGVyO1xuICB9XG4gIGlmICghZW1iZWRkZXIyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHV0aWxpemUgdGhlIHByb3ZpZGVkIGVtYmVkZGVyXCIpO1xuICB9XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZW1iZWRkZXIyKHtcbiAgICBpbnB1dDogcGFyYW1zLmNvbnRlbnQubWFwKFxuICAgICAgKGkpID0+IHR5cGVvZiBpID09PSBcInN0cmluZ1wiID8gaW1wb3J0X2RvY3VtZW50LkRvY3VtZW50LmZyb21UZXh0KGksIHBhcmFtcy5tZXRhZGF0YSkgOiBpXG4gICAgKSxcbiAgICBvcHRpb25zOiBwYXJhbXMub3B0aW9uc1xuICB9KTtcbiAgcmV0dXJuIHJlc3BvbnNlLmVtYmVkZGluZ3M7XG59XG5jb25zdCBFbWJlZGRlckluZm9TY2hlbWEgPSBpbXBvcnRfY29yZS56Lm9iamVjdCh7XG4gIC8qKiBGcmllbmRseSBsYWJlbCBmb3IgdGhpcyBtb2RlbCAoZS5nLiBcIkdvb2dsZSBBSSAtIEdlbWluaSBQcm9cIikgKi9cbiAgbGFiZWw6IGltcG9ydF9jb3JlLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgLyoqIFN1cHBvcnRlZCBtb2RlbCBjYXBhYmlsaXRpZXMuICovXG4gIHN1cHBvcnRzOiBpbXBvcnRfY29yZS56Lm9iamVjdCh7XG4gICAgLyoqIE1vZGVsIGNhbiBpbnB1dCB0aGlzIHR5cGUgb2YgZGF0YS4gKi9cbiAgICBpbnB1dDogaW1wb3J0X2NvcmUuei5hcnJheShpbXBvcnRfY29yZS56LmVudW0oW1widGV4dFwiLCBcImltYWdlXCIsIFwidmlkZW9cIl0pKS5vcHRpb25hbCgpLFxuICAgIC8qKiBNb2RlbCBjYW4gc3VwcG9ydCBtdWx0aXBsZSBsYW5ndWFnZXMgKi9cbiAgICBtdWx0aWxpbmd1YWw6IGltcG9ydF9jb3JlLnouYm9vbGVhbigpLm9wdGlvbmFsKClcbiAgfSkub3B0aW9uYWwoKSxcbiAgLyoqIEVtYmVkZGluZyBkaW1lbnNpb24gKi9cbiAgZGltZW5zaW9uczogaW1wb3J0X2NvcmUuei5udW1iZXIoKS5vcHRpb25hbCgpXG59KTtcbmZ1bmN0aW9uIGVtYmVkZGVyUmVmKG9wdGlvbnMpIHtcbiAgbGV0IG5hbWUgPSBvcHRpb25zLm5hbWU7XG4gIGlmIChvcHRpb25zLm5hbWVzcGFjZSAmJiAhbmFtZS5zdGFydHNXaXRoKG9wdGlvbnMubmFtZXNwYWNlICsgXCIvXCIpKSB7XG4gICAgbmFtZSA9IGAke29wdGlvbnMubmFtZXNwYWNlfS8ke25hbWV9YDtcbiAgfVxuICByZXR1cm4geyAuLi5vcHRpb25zLCBuYW1lIH07XG59XG5mdW5jdGlvbiBlbWJlZGRlckFjdGlvbk1ldGFkYXRhKHtcbiAgbmFtZSxcbiAgaW5mbyxcbiAgY29uZmlnU2NoZW1hXG59KSB7XG4gIHJldHVybiB7XG4gICAgYWN0aW9uVHlwZTogXCJlbWJlZGRlclwiLFxuICAgIG5hbWUsXG4gICAgaW5wdXRKc29uU2NoZW1hOiAoMCwgaW1wb3J0X3NjaGVtYS50b0pzb25TY2hlbWEpKHsgc2NoZW1hOiBFbWJlZFJlcXVlc3RTY2hlbWEgfSksXG4gICAgb3V0cHV0SnNvblNjaGVtYTogKDAsIGltcG9ydF9zY2hlbWEudG9Kc29uU2NoZW1hKSh7IHNjaGVtYTogRW1iZWRSZXNwb25zZVNjaGVtYSB9KSxcbiAgICBtZXRhZGF0YToge1xuICAgICAgZW1iZWRkZXI6IHtcbiAgICAgICAgLi4uaW5mbyxcbiAgICAgICAgY3VzdG9tT3B0aW9uczogY29uZmlnU2NoZW1hID8gKDAsIGltcG9ydF9zY2hlbWEudG9Kc29uU2NoZW1hKSh7IHNjaGVtYTogY29uZmlnU2NoZW1hIH0pIDogdm9pZCAwXG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIEVtYmVkZGVySW5mb1NjaGVtYSxcbiAgRW1iZWRkaW5nU2NoZW1hLFxuICBkZWZpbmVFbWJlZGRlcixcbiAgZW1iZWQsXG4gIGVtYmVkTWFueSxcbiAgZW1iZWRkZXIsXG4gIGVtYmVkZGVyQWN0aW9uTWV0YWRhdGEsXG4gIGVtYmVkZGVyUmVmXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVtYmVkZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/embedder.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/evaluator.js":
/*!*****************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/evaluator.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar evaluator_exports = {};\n__export(evaluator_exports, {\n  ATTR_PREFIX: () => ATTR_PREFIX,\n  BaseDataPointSchema: () => BaseDataPointSchema,\n  BaseEvalDataPointSchema: () => BaseEvalDataPointSchema,\n  EVALUATOR_METADATA_KEY_DEFINITION: () => EVALUATOR_METADATA_KEY_DEFINITION,\n  EVALUATOR_METADATA_KEY_DISPLAY_NAME: () => EVALUATOR_METADATA_KEY_DISPLAY_NAME,\n  EVALUATOR_METADATA_KEY_IS_BILLED: () => EVALUATOR_METADATA_KEY_IS_BILLED,\n  EvalResponseSchema: () => EvalResponseSchema,\n  EvalResponsesSchema: () => EvalResponsesSchema,\n  EvalStatusEnum: () => EvalStatusEnum,\n  EvaluatorInfoSchema: () => EvaluatorInfoSchema,\n  SPAN_STATE_ATTR: () => SPAN_STATE_ATTR,\n  ScoreSchema: () => ScoreSchema,\n  defineEvaluator: () => defineEvaluator,\n  evaluate: () => evaluate,\n  evaluator: () => evaluator,\n  evaluatorRef: () => evaluatorRef\n});\nmodule.exports = __toCommonJS(evaluator_exports);\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nvar import_logging = __webpack_require__(/*! @genkit-ai/core/logging */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/logging.js\");\nvar import_schema = __webpack_require__(/*! @genkit-ai/core/schema */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/schema.js\");\nvar import_tracing = __webpack_require__(/*! @genkit-ai/core/tracing */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing.js\");\nvar import_crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst ATTR_PREFIX = \"genkit\";\nconst SPAN_STATE_ATTR = ATTR_PREFIX + \":state\";\nconst BaseDataPointSchema = import_core.z.object({\n  input: import_core.z.unknown(),\n  output: import_core.z.unknown().optional(),\n  context: import_core.z.array(import_core.z.unknown()).optional(),\n  reference: import_core.z.unknown().optional(),\n  testCaseId: import_core.z.string().optional(),\n  traceIds: import_core.z.array(import_core.z.string()).optional()\n});\nconst BaseEvalDataPointSchema = BaseDataPointSchema.extend({\n  testCaseId: import_core.z.string()\n});\nconst EvalStatusEnumSchema = import_core.z.enum([\"UNKNOWN\", \"PASS\", \"FAIL\"]);\nvar EvalStatusEnum = /* @__PURE__ */ ((EvalStatusEnum2) => {\n  EvalStatusEnum2[\"UNKNOWN\"] = \"UNKNOWN\";\n  EvalStatusEnum2[\"PASS\"] = \"PASS\";\n  EvalStatusEnum2[\"FAIL\"] = \"FAIL\";\n  return EvalStatusEnum2;\n})(EvalStatusEnum || {});\nconst ScoreSchema = import_core.z.object({\n  id: import_core.z.string().describe(\n    \"Optional ID to differentiate different scores if applying in a single evaluation\"\n  ).optional(),\n  score: import_core.z.union([import_core.z.number(), import_core.z.string(), import_core.z.boolean()]).optional(),\n  status: EvalStatusEnumSchema.optional(),\n  error: import_core.z.string().optional(),\n  details: import_core.z.object({\n    reasoning: import_core.z.string().optional()\n  }).passthrough().optional()\n});\nconst EVALUATOR_METADATA_KEY_DISPLAY_NAME = \"evaluatorDisplayName\";\nconst EVALUATOR_METADATA_KEY_DEFINITION = \"evaluatorDefinition\";\nconst EVALUATOR_METADATA_KEY_IS_BILLED = \"evaluatorIsBilled\";\nconst EvalResponseSchema = import_core.z.object({\n  sampleIndex: import_core.z.number().optional(),\n  testCaseId: import_core.z.string(),\n  traceId: import_core.z.string().optional(),\n  spanId: import_core.z.string().optional(),\n  evaluation: import_core.z.union([ScoreSchema, import_core.z.array(ScoreSchema)])\n});\nconst EvalResponsesSchema = import_core.z.array(EvalResponseSchema);\nfunction withMetadata(evaluator2, dataPointType, configSchema) {\n  const withMeta = evaluator2;\n  withMeta.__dataPointType = dataPointType;\n  withMeta.__configSchema = configSchema;\n  return withMeta;\n}\nconst EvalRequestSchema = import_core.z.object({\n  dataset: import_core.z.array(BaseDataPointSchema),\n  evalRunId: import_core.z.string(),\n  options: import_core.z.unknown()\n});\nfunction defineEvaluator(registry, options, runner) {\n  const e = evaluator(options, runner);\n  registry.registerAction(\"evaluator\", e);\n  return e;\n}\nfunction evaluator(options, runner) {\n  const evalMetadata = {};\n  evalMetadata[EVALUATOR_METADATA_KEY_IS_BILLED] = options.isBilled == void 0 ? true : options.isBilled;\n  evalMetadata[EVALUATOR_METADATA_KEY_DISPLAY_NAME] = options.displayName;\n  evalMetadata[EVALUATOR_METADATA_KEY_DEFINITION] = options.definition;\n  if (options.configSchema) {\n    evalMetadata[\"customOptions\"] = (0, import_schema.toJsonSchema)({\n      schema: options.configSchema\n    });\n  }\n  const evaluator2 = (0, import_core.action)(\n    {\n      actionType: \"evaluator\",\n      name: options.name,\n      inputSchema: EvalRequestSchema.extend({\n        dataset: options.dataPointType ? import_core.z.array(options.dataPointType) : import_core.z.array(BaseDataPointSchema),\n        options: options.configSchema ?? import_core.z.unknown(),\n        evalRunId: import_core.z.string(),\n        batchSize: import_core.z.number().optional()\n      }),\n      outputSchema: EvalResponsesSchema,\n      metadata: {\n        type: \"evaluator\",\n        evaluator: evalMetadata\n      }\n    },\n    async (i) => {\n      const evalResponses = [];\n      const batches = getBatchedArray(i.dataset, i.batchSize);\n      for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {\n        const batch = batches[batchIndex];\n        try {\n          await (0, import_tracing.runInNewSpan)(\n            {\n              metadata: {\n                name: i.batchSize ? `Batch ${batchIndex}` : `Test Case ${batch[0].testCaseId}`,\n                metadata: { \"evaluator:evalRunId\": i.evalRunId }\n              },\n              labels: {\n                [import_tracing.SPAN_TYPE_ATTR]: \"evaluator\"\n              }\n            },\n            async (metadata, otSpan) => {\n              const spanId = otSpan.spanContext().spanId;\n              const traceId = otSpan.spanContext().traceId;\n              const evalRunPromises = batch.map((d, index) => {\n                const sampleIndex = i.batchSize ? i.batchSize * batchIndex + index : batchIndex;\n                const datapoint = d;\n                metadata.input = {\n                  input: datapoint.input,\n                  output: datapoint.output,\n                  context: datapoint.context\n                };\n                const evalOutputPromise = runner(datapoint, i.options).then((result) => ({\n                  ...result,\n                  traceId,\n                  spanId,\n                  sampleIndex\n                })).catch((error) => {\n                  return {\n                    sampleIndex,\n                    spanId,\n                    traceId,\n                    testCaseId: datapoint.testCaseId,\n                    evaluation: {\n                      error: `Evaluation of test case ${datapoint.testCaseId} failed: \n${error}`\n                    }\n                  };\n                });\n                return evalOutputPromise;\n              });\n              const allResults = await Promise.all(evalRunPromises);\n              metadata.output = allResults.length === 1 ? allResults[0] : allResults;\n              allResults.map((result) => {\n                evalResponses.push(result);\n              });\n            }\n          );\n        } catch (e) {\n          import_logging.logger.error(\n            `Evaluation of batch ${batchIndex} failed: \n${e.stack}`\n          );\n          continue;\n        }\n      }\n      return evalResponses;\n    }\n  );\n  const ewm = withMetadata(\n    evaluator2,\n    options.dataPointType,\n    options.configSchema\n  );\n  return ewm;\n}\nasync function evaluate(registry, params) {\n  let evaluator2;\n  if (typeof params.evaluator === \"string\") {\n    evaluator2 = await registry.lookupAction(`/evaluator/${params.evaluator}`);\n  } else if (Object.hasOwnProperty.call(params.evaluator, \"info\")) {\n    evaluator2 = await registry.lookupAction(\n      `/evaluator/${params.evaluator.name}`\n    );\n  } else {\n    evaluator2 = params.evaluator;\n  }\n  if (!evaluator2) {\n    throw new Error(\"Unable to utilize the provided evaluator\");\n  }\n  return await evaluator2({\n    dataset: params.dataset,\n    options: params.options,\n    evalRunId: params.evalRunId ?? (0, import_crypto.randomUUID)()\n  });\n}\nconst EvaluatorInfoSchema = import_core.z.object({\n  /** Friendly label for this evaluator */\n  label: import_core.z.string().optional(),\n  metrics: import_core.z.array(import_core.z.string())\n});\nfunction evaluatorRef(options) {\n  return { ...options };\n}\nfunction getBatchedArray(arr, batchSize) {\n  let size;\n  if (!batchSize) {\n    size = 1;\n  } else {\n    size = batchSize;\n  }\n  const batches = [];\n  for (var i = 0; i < arr.length; i += size) {\n    batches.push(\n      arr.slice(i, i + size).map((d) => ({\n        ...d,\n        testCaseId: d.testCaseId ?? (0, import_crypto.randomUUID)()\n      }))\n    );\n  }\n  return batches;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=evaluator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9ldmFsdWF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxxRkFBaUI7QUFDM0MscUJBQXFCLG1CQUFPLENBQUMsK0ZBQXlCO0FBQ3RELG9CQUFvQixtQkFBTyxDQUFDLDZGQUF3QjtBQUNwRCxxQkFBcUIsbUJBQU8sQ0FBQywrRkFBeUI7QUFDdEQsb0JBQW9CLG1CQUFPLENBQUMsc0JBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2QkFBNkI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxXQUFXLGlCQUFpQixvQkFBb0I7QUFDN0YsNEJBQTRCO0FBQzVCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHNCQUFzQjtBQUM5RSxFQUFFLE1BQU07QUFDUjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQyxFQUFFLFFBQVE7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGlCQUFpQjtBQUM1RSxJQUFJO0FBQ0o7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQWlCTDtBQUNEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEtSYW1hY2hhXFxEb2N1bWVudHNcXFN1c3RBSW5leCBHSXQgQ29kZVxcbm9kZV9tb2R1bGVzXFxAZ2Vua2l0LWFpXFxhaVxcbGliXFxldmFsdWF0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIGV2YWx1YXRvcl9leHBvcnRzID0ge307XG5fX2V4cG9ydChldmFsdWF0b3JfZXhwb3J0cywge1xuICBBVFRSX1BSRUZJWDogKCkgPT4gQVRUUl9QUkVGSVgsXG4gIEJhc2VEYXRhUG9pbnRTY2hlbWE6ICgpID0+IEJhc2VEYXRhUG9pbnRTY2hlbWEsXG4gIEJhc2VFdmFsRGF0YVBvaW50U2NoZW1hOiAoKSA9PiBCYXNlRXZhbERhdGFQb2ludFNjaGVtYSxcbiAgRVZBTFVBVE9SX01FVEFEQVRBX0tFWV9ERUZJTklUSU9OOiAoKSA9PiBFVkFMVUFUT1JfTUVUQURBVEFfS0VZX0RFRklOSVRJT04sXG4gIEVWQUxVQVRPUl9NRVRBREFUQV9LRVlfRElTUExBWV9OQU1FOiAoKSA9PiBFVkFMVUFUT1JfTUVUQURBVEFfS0VZX0RJU1BMQVlfTkFNRSxcbiAgRVZBTFVBVE9SX01FVEFEQVRBX0tFWV9JU19CSUxMRUQ6ICgpID0+IEVWQUxVQVRPUl9NRVRBREFUQV9LRVlfSVNfQklMTEVELFxuICBFdmFsUmVzcG9uc2VTY2hlbWE6ICgpID0+IEV2YWxSZXNwb25zZVNjaGVtYSxcbiAgRXZhbFJlc3BvbnNlc1NjaGVtYTogKCkgPT4gRXZhbFJlc3BvbnNlc1NjaGVtYSxcbiAgRXZhbFN0YXR1c0VudW06ICgpID0+IEV2YWxTdGF0dXNFbnVtLFxuICBFdmFsdWF0b3JJbmZvU2NoZW1hOiAoKSA9PiBFdmFsdWF0b3JJbmZvU2NoZW1hLFxuICBTUEFOX1NUQVRFX0FUVFI6ICgpID0+IFNQQU5fU1RBVEVfQVRUUixcbiAgU2NvcmVTY2hlbWE6ICgpID0+IFNjb3JlU2NoZW1hLFxuICBkZWZpbmVFdmFsdWF0b3I6ICgpID0+IGRlZmluZUV2YWx1YXRvcixcbiAgZXZhbHVhdGU6ICgpID0+IGV2YWx1YXRlLFxuICBldmFsdWF0b3I6ICgpID0+IGV2YWx1YXRvcixcbiAgZXZhbHVhdG9yUmVmOiAoKSA9PiBldmFsdWF0b3JSZWZcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoZXZhbHVhdG9yX2V4cG9ydHMpO1xudmFyIGltcG9ydF9jb3JlID0gcmVxdWlyZShcIkBnZW5raXQtYWkvY29yZVwiKTtcbnZhciBpbXBvcnRfbG9nZ2luZyA9IHJlcXVpcmUoXCJAZ2Vua2l0LWFpL2NvcmUvbG9nZ2luZ1wiKTtcbnZhciBpbXBvcnRfc2NoZW1hID0gcmVxdWlyZShcIkBnZW5raXQtYWkvY29yZS9zY2hlbWFcIik7XG52YXIgaW1wb3J0X3RyYWNpbmcgPSByZXF1aXJlKFwiQGdlbmtpdC1haS9jb3JlL3RyYWNpbmdcIik7XG52YXIgaW1wb3J0X2NyeXB0byA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG5jb25zdCBBVFRSX1BSRUZJWCA9IFwiZ2Vua2l0XCI7XG5jb25zdCBTUEFOX1NUQVRFX0FUVFIgPSBBVFRSX1BSRUZJWCArIFwiOnN0YXRlXCI7XG5jb25zdCBCYXNlRGF0YVBvaW50U2NoZW1hID0gaW1wb3J0X2NvcmUuei5vYmplY3Qoe1xuICBpbnB1dDogaW1wb3J0X2NvcmUuei51bmtub3duKCksXG4gIG91dHB1dDogaW1wb3J0X2NvcmUuei51bmtub3duKCkub3B0aW9uYWwoKSxcbiAgY29udGV4dDogaW1wb3J0X2NvcmUuei5hcnJheShpbXBvcnRfY29yZS56LnVua25vd24oKSkub3B0aW9uYWwoKSxcbiAgcmVmZXJlbmNlOiBpbXBvcnRfY29yZS56LnVua25vd24oKS5vcHRpb25hbCgpLFxuICB0ZXN0Q2FzZUlkOiBpbXBvcnRfY29yZS56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIHRyYWNlSWRzOiBpbXBvcnRfY29yZS56LmFycmF5KGltcG9ydF9jb3JlLnouc3RyaW5nKCkpLm9wdGlvbmFsKClcbn0pO1xuY29uc3QgQmFzZUV2YWxEYXRhUG9pbnRTY2hlbWEgPSBCYXNlRGF0YVBvaW50U2NoZW1hLmV4dGVuZCh7XG4gIHRlc3RDYXNlSWQ6IGltcG9ydF9jb3JlLnouc3RyaW5nKClcbn0pO1xuY29uc3QgRXZhbFN0YXR1c0VudW1TY2hlbWEgPSBpbXBvcnRfY29yZS56LmVudW0oW1wiVU5LTk9XTlwiLCBcIlBBU1NcIiwgXCJGQUlMXCJdKTtcbnZhciBFdmFsU3RhdHVzRW51bSA9IC8qIEBfX1BVUkVfXyAqLyAoKEV2YWxTdGF0dXNFbnVtMikgPT4ge1xuICBFdmFsU3RhdHVzRW51bTJbXCJVTktOT1dOXCJdID0gXCJVTktOT1dOXCI7XG4gIEV2YWxTdGF0dXNFbnVtMltcIlBBU1NcIl0gPSBcIlBBU1NcIjtcbiAgRXZhbFN0YXR1c0VudW0yW1wiRkFJTFwiXSA9IFwiRkFJTFwiO1xuICByZXR1cm4gRXZhbFN0YXR1c0VudW0yO1xufSkoRXZhbFN0YXR1c0VudW0gfHwge30pO1xuY29uc3QgU2NvcmVTY2hlbWEgPSBpbXBvcnRfY29yZS56Lm9iamVjdCh7XG4gIGlkOiBpbXBvcnRfY29yZS56LnN0cmluZygpLmRlc2NyaWJlKFxuICAgIFwiT3B0aW9uYWwgSUQgdG8gZGlmZmVyZW50aWF0ZSBkaWZmZXJlbnQgc2NvcmVzIGlmIGFwcGx5aW5nIGluIGEgc2luZ2xlIGV2YWx1YXRpb25cIlxuICApLm9wdGlvbmFsKCksXG4gIHNjb3JlOiBpbXBvcnRfY29yZS56LnVuaW9uKFtpbXBvcnRfY29yZS56Lm51bWJlcigpLCBpbXBvcnRfY29yZS56LnN0cmluZygpLCBpbXBvcnRfY29yZS56LmJvb2xlYW4oKV0pLm9wdGlvbmFsKCksXG4gIHN0YXR1czogRXZhbFN0YXR1c0VudW1TY2hlbWEub3B0aW9uYWwoKSxcbiAgZXJyb3I6IGltcG9ydF9jb3JlLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgZGV0YWlsczogaW1wb3J0X2NvcmUuei5vYmplY3Qoe1xuICAgIHJlYXNvbmluZzogaW1wb3J0X2NvcmUuei5zdHJpbmcoKS5vcHRpb25hbCgpXG4gIH0pLnBhc3N0aHJvdWdoKCkub3B0aW9uYWwoKVxufSk7XG5jb25zdCBFVkFMVUFUT1JfTUVUQURBVEFfS0VZX0RJU1BMQVlfTkFNRSA9IFwiZXZhbHVhdG9yRGlzcGxheU5hbWVcIjtcbmNvbnN0IEVWQUxVQVRPUl9NRVRBREFUQV9LRVlfREVGSU5JVElPTiA9IFwiZXZhbHVhdG9yRGVmaW5pdGlvblwiO1xuY29uc3QgRVZBTFVBVE9SX01FVEFEQVRBX0tFWV9JU19CSUxMRUQgPSBcImV2YWx1YXRvcklzQmlsbGVkXCI7XG5jb25zdCBFdmFsUmVzcG9uc2VTY2hlbWEgPSBpbXBvcnRfY29yZS56Lm9iamVjdCh7XG4gIHNhbXBsZUluZGV4OiBpbXBvcnRfY29yZS56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gIHRlc3RDYXNlSWQ6IGltcG9ydF9jb3JlLnouc3RyaW5nKCksXG4gIHRyYWNlSWQ6IGltcG9ydF9jb3JlLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgc3BhbklkOiBpbXBvcnRfY29yZS56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIGV2YWx1YXRpb246IGltcG9ydF9jb3JlLnoudW5pb24oW1Njb3JlU2NoZW1hLCBpbXBvcnRfY29yZS56LmFycmF5KFNjb3JlU2NoZW1hKV0pXG59KTtcbmNvbnN0IEV2YWxSZXNwb25zZXNTY2hlbWEgPSBpbXBvcnRfY29yZS56LmFycmF5KEV2YWxSZXNwb25zZVNjaGVtYSk7XG5mdW5jdGlvbiB3aXRoTWV0YWRhdGEoZXZhbHVhdG9yMiwgZGF0YVBvaW50VHlwZSwgY29uZmlnU2NoZW1hKSB7XG4gIGNvbnN0IHdpdGhNZXRhID0gZXZhbHVhdG9yMjtcbiAgd2l0aE1ldGEuX19kYXRhUG9pbnRUeXBlID0gZGF0YVBvaW50VHlwZTtcbiAgd2l0aE1ldGEuX19jb25maWdTY2hlbWEgPSBjb25maWdTY2hlbWE7XG4gIHJldHVybiB3aXRoTWV0YTtcbn1cbmNvbnN0IEV2YWxSZXF1ZXN0U2NoZW1hID0gaW1wb3J0X2NvcmUuei5vYmplY3Qoe1xuICBkYXRhc2V0OiBpbXBvcnRfY29yZS56LmFycmF5KEJhc2VEYXRhUG9pbnRTY2hlbWEpLFxuICBldmFsUnVuSWQ6IGltcG9ydF9jb3JlLnouc3RyaW5nKCksXG4gIG9wdGlvbnM6IGltcG9ydF9jb3JlLnoudW5rbm93bigpXG59KTtcbmZ1bmN0aW9uIGRlZmluZUV2YWx1YXRvcihyZWdpc3RyeSwgb3B0aW9ucywgcnVubmVyKSB7XG4gIGNvbnN0IGUgPSBldmFsdWF0b3Iob3B0aW9ucywgcnVubmVyKTtcbiAgcmVnaXN0cnkucmVnaXN0ZXJBY3Rpb24oXCJldmFsdWF0b3JcIiwgZSk7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gZXZhbHVhdG9yKG9wdGlvbnMsIHJ1bm5lcikge1xuICBjb25zdCBldmFsTWV0YWRhdGEgPSB7fTtcbiAgZXZhbE1ldGFkYXRhW0VWQUxVQVRPUl9NRVRBREFUQV9LRVlfSVNfQklMTEVEXSA9IG9wdGlvbnMuaXNCaWxsZWQgPT0gdm9pZCAwID8gdHJ1ZSA6IG9wdGlvbnMuaXNCaWxsZWQ7XG4gIGV2YWxNZXRhZGF0YVtFVkFMVUFUT1JfTUVUQURBVEFfS0VZX0RJU1BMQVlfTkFNRV0gPSBvcHRpb25zLmRpc3BsYXlOYW1lO1xuICBldmFsTWV0YWRhdGFbRVZBTFVBVE9SX01FVEFEQVRBX0tFWV9ERUZJTklUSU9OXSA9IG9wdGlvbnMuZGVmaW5pdGlvbjtcbiAgaWYgKG9wdGlvbnMuY29uZmlnU2NoZW1hKSB7XG4gICAgZXZhbE1ldGFkYXRhW1wiY3VzdG9tT3B0aW9uc1wiXSA9ICgwLCBpbXBvcnRfc2NoZW1hLnRvSnNvblNjaGVtYSkoe1xuICAgICAgc2NoZW1hOiBvcHRpb25zLmNvbmZpZ1NjaGVtYVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGV2YWx1YXRvcjIgPSAoMCwgaW1wb3J0X2NvcmUuYWN0aW9uKShcbiAgICB7XG4gICAgICBhY3Rpb25UeXBlOiBcImV2YWx1YXRvclwiLFxuICAgICAgbmFtZTogb3B0aW9ucy5uYW1lLFxuICAgICAgaW5wdXRTY2hlbWE6IEV2YWxSZXF1ZXN0U2NoZW1hLmV4dGVuZCh7XG4gICAgICAgIGRhdGFzZXQ6IG9wdGlvbnMuZGF0YVBvaW50VHlwZSA/IGltcG9ydF9jb3JlLnouYXJyYXkob3B0aW9ucy5kYXRhUG9pbnRUeXBlKSA6IGltcG9ydF9jb3JlLnouYXJyYXkoQmFzZURhdGFQb2ludFNjaGVtYSksXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMuY29uZmlnU2NoZW1hID8/IGltcG9ydF9jb3JlLnoudW5rbm93bigpLFxuICAgICAgICBldmFsUnVuSWQ6IGltcG9ydF9jb3JlLnouc3RyaW5nKCksXG4gICAgICAgIGJhdGNoU2l6ZTogaW1wb3J0X2NvcmUuei5udW1iZXIoKS5vcHRpb25hbCgpXG4gICAgICB9KSxcbiAgICAgIG91dHB1dFNjaGVtYTogRXZhbFJlc3BvbnNlc1NjaGVtYSxcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIHR5cGU6IFwiZXZhbHVhdG9yXCIsXG4gICAgICAgIGV2YWx1YXRvcjogZXZhbE1ldGFkYXRhXG4gICAgICB9XG4gICAgfSxcbiAgICBhc3luYyAoaSkgPT4ge1xuICAgICAgY29uc3QgZXZhbFJlc3BvbnNlcyA9IFtdO1xuICAgICAgY29uc3QgYmF0Y2hlcyA9IGdldEJhdGNoZWRBcnJheShpLmRhdGFzZXQsIGkuYmF0Y2hTaXplKTtcbiAgICAgIGZvciAobGV0IGJhdGNoSW5kZXggPSAwOyBiYXRjaEluZGV4IDwgYmF0Y2hlcy5sZW5ndGg7IGJhdGNoSW5kZXgrKykge1xuICAgICAgICBjb25zdCBiYXRjaCA9IGJhdGNoZXNbYmF0Y2hJbmRleF07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgKDAsIGltcG9ydF90cmFjaW5nLnJ1bkluTmV3U3BhbikoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogaS5iYXRjaFNpemUgPyBgQmF0Y2ggJHtiYXRjaEluZGV4fWAgOiBgVGVzdCBDYXNlICR7YmF0Y2hbMF0udGVzdENhc2VJZH1gLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiB7IFwiZXZhbHVhdG9yOmV2YWxSdW5JZFwiOiBpLmV2YWxSdW5JZCB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGxhYmVsczoge1xuICAgICAgICAgICAgICAgIFtpbXBvcnRfdHJhY2luZy5TUEFOX1RZUEVfQVRUUl06IFwiZXZhbHVhdG9yXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFzeW5jIChtZXRhZGF0YSwgb3RTcGFuKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHNwYW5JZCA9IG90U3Bhbi5zcGFuQ29udGV4dCgpLnNwYW5JZDtcbiAgICAgICAgICAgICAgY29uc3QgdHJhY2VJZCA9IG90U3Bhbi5zcGFuQ29udGV4dCgpLnRyYWNlSWQ7XG4gICAgICAgICAgICAgIGNvbnN0IGV2YWxSdW5Qcm9taXNlcyA9IGJhdGNoLm1hcCgoZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzYW1wbGVJbmRleCA9IGkuYmF0Y2hTaXplID8gaS5iYXRjaFNpemUgKiBiYXRjaEluZGV4ICsgaW5kZXggOiBiYXRjaEluZGV4O1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFwb2ludCA9IGQ7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEuaW5wdXQgPSB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogZGF0YXBvaW50LmlucHV0LFxuICAgICAgICAgICAgICAgICAgb3V0cHV0OiBkYXRhcG9pbnQub3V0cHV0LFxuICAgICAgICAgICAgICAgICAgY29udGV4dDogZGF0YXBvaW50LmNvbnRleHRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2YWxPdXRwdXRQcm9taXNlID0gcnVubmVyKGRhdGFwb2ludCwgaS5vcHRpb25zKS50aGVuKChyZXN1bHQpID0+ICh7XG4gICAgICAgICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICAgICAgICB0cmFjZUlkLFxuICAgICAgICAgICAgICAgICAgc3BhbklkLFxuICAgICAgICAgICAgICAgICAgc2FtcGxlSW5kZXhcbiAgICAgICAgICAgICAgICB9KSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzYW1wbGVJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgc3BhbklkLFxuICAgICAgICAgICAgICAgICAgICB0cmFjZUlkLFxuICAgICAgICAgICAgICAgICAgICB0ZXN0Q2FzZUlkOiBkYXRhcG9pbnQudGVzdENhc2VJZCxcbiAgICAgICAgICAgICAgICAgICAgZXZhbHVhdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBgRXZhbHVhdGlvbiBvZiB0ZXN0IGNhc2UgJHtkYXRhcG9pbnQudGVzdENhc2VJZH0gZmFpbGVkOiBcbiR7ZXJyb3J9YFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBldmFsT3V0cHV0UHJvbWlzZTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IGFsbFJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChldmFsUnVuUHJvbWlzZXMpO1xuICAgICAgICAgICAgICBtZXRhZGF0YS5vdXRwdXQgPSBhbGxSZXN1bHRzLmxlbmd0aCA9PT0gMSA/IGFsbFJlc3VsdHNbMF0gOiBhbGxSZXN1bHRzO1xuICAgICAgICAgICAgICBhbGxSZXN1bHRzLm1hcCgocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgZXZhbFJlc3BvbnNlcy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpbXBvcnRfbG9nZ2luZy5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICBgRXZhbHVhdGlvbiBvZiBiYXRjaCAke2JhdGNoSW5kZXh9IGZhaWxlZDogXG4ke2Uuc3RhY2t9YFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBldmFsUmVzcG9uc2VzO1xuICAgIH1cbiAgKTtcbiAgY29uc3QgZXdtID0gd2l0aE1ldGFkYXRhKFxuICAgIGV2YWx1YXRvcjIsXG4gICAgb3B0aW9ucy5kYXRhUG9pbnRUeXBlLFxuICAgIG9wdGlvbnMuY29uZmlnU2NoZW1hXG4gICk7XG4gIHJldHVybiBld207XG59XG5hc3luYyBmdW5jdGlvbiBldmFsdWF0ZShyZWdpc3RyeSwgcGFyYW1zKSB7XG4gIGxldCBldmFsdWF0b3IyO1xuICBpZiAodHlwZW9mIHBhcmFtcy5ldmFsdWF0b3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICBldmFsdWF0b3IyID0gYXdhaXQgcmVnaXN0cnkubG9va3VwQWN0aW9uKGAvZXZhbHVhdG9yLyR7cGFyYW1zLmV2YWx1YXRvcn1gKTtcbiAgfSBlbHNlIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbXMuZXZhbHVhdG9yLCBcImluZm9cIikpIHtcbiAgICBldmFsdWF0b3IyID0gYXdhaXQgcmVnaXN0cnkubG9va3VwQWN0aW9uKFxuICAgICAgYC9ldmFsdWF0b3IvJHtwYXJhbXMuZXZhbHVhdG9yLm5hbWV9YFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgZXZhbHVhdG9yMiA9IHBhcmFtcy5ldmFsdWF0b3I7XG4gIH1cbiAgaWYgKCFldmFsdWF0b3IyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHV0aWxpemUgdGhlIHByb3ZpZGVkIGV2YWx1YXRvclwiKTtcbiAgfVxuICByZXR1cm4gYXdhaXQgZXZhbHVhdG9yMih7XG4gICAgZGF0YXNldDogcGFyYW1zLmRhdGFzZXQsXG4gICAgb3B0aW9uczogcGFyYW1zLm9wdGlvbnMsXG4gICAgZXZhbFJ1bklkOiBwYXJhbXMuZXZhbFJ1bklkID8/ICgwLCBpbXBvcnRfY3J5cHRvLnJhbmRvbVVVSUQpKClcbiAgfSk7XG59XG5jb25zdCBFdmFsdWF0b3JJbmZvU2NoZW1hID0gaW1wb3J0X2NvcmUuei5vYmplY3Qoe1xuICAvKiogRnJpZW5kbHkgbGFiZWwgZm9yIHRoaXMgZXZhbHVhdG9yICovXG4gIGxhYmVsOiBpbXBvcnRfY29yZS56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIG1ldHJpY3M6IGltcG9ydF9jb3JlLnouYXJyYXkoaW1wb3J0X2NvcmUuei5zdHJpbmcoKSlcbn0pO1xuZnVuY3Rpb24gZXZhbHVhdG9yUmVmKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHsgLi4ub3B0aW9ucyB9O1xufVxuZnVuY3Rpb24gZ2V0QmF0Y2hlZEFycmF5KGFyciwgYmF0Y2hTaXplKSB7XG4gIGxldCBzaXplO1xuICBpZiAoIWJhdGNoU2l6ZSkge1xuICAgIHNpemUgPSAxO1xuICB9IGVsc2Uge1xuICAgIHNpemUgPSBiYXRjaFNpemU7XG4gIH1cbiAgY29uc3QgYmF0Y2hlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gc2l6ZSkge1xuICAgIGJhdGNoZXMucHVzaChcbiAgICAgIGFyci5zbGljZShpLCBpICsgc2l6ZSkubWFwKChkKSA9PiAoe1xuICAgICAgICAuLi5kLFxuICAgICAgICB0ZXN0Q2FzZUlkOiBkLnRlc3RDYXNlSWQgPz8gKDAsIGltcG9ydF9jcnlwdG8ucmFuZG9tVVVJRCkoKVxuICAgICAgfSkpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gYmF0Y2hlcztcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBBVFRSX1BSRUZJWCxcbiAgQmFzZURhdGFQb2ludFNjaGVtYSxcbiAgQmFzZUV2YWxEYXRhUG9pbnRTY2hlbWEsXG4gIEVWQUxVQVRPUl9NRVRBREFUQV9LRVlfREVGSU5JVElPTixcbiAgRVZBTFVBVE9SX01FVEFEQVRBX0tFWV9ESVNQTEFZX05BTUUsXG4gIEVWQUxVQVRPUl9NRVRBREFUQV9LRVlfSVNfQklMTEVELFxuICBFdmFsUmVzcG9uc2VTY2hlbWEsXG4gIEV2YWxSZXNwb25zZXNTY2hlbWEsXG4gIEV2YWxTdGF0dXNFbnVtLFxuICBFdmFsdWF0b3JJbmZvU2NoZW1hLFxuICBTUEFOX1NUQVRFX0FUVFIsXG4gIFNjb3JlU2NoZW1hLFxuICBkZWZpbmVFdmFsdWF0b3IsXG4gIGV2YWx1YXRlLFxuICBldmFsdWF0b3IsXG4gIGV2YWx1YXRvclJlZlxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmFsdWF0b3IuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/evaluator.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/extract.js":
/*!***************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/extract.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar extract_exports = {};\n__export(extract_exports, {\n  extractItems: () => extractItems,\n  extractJson: () => extractJson,\n  parsePartialJson: () => parsePartialJson\n});\nmodule.exports = __toCommonJS(extract_exports);\nvar import_json5 = __toESM(__webpack_require__(/*! json5 */ \"(action-browser)/./node_modules/json5/dist/index.mjs\"));\nvar import_partial_json = __webpack_require__(/*! partial-json */ \"(action-browser)/./node_modules/partial-json/dist/index.js\");\nfunction parsePartialJson(jsonString) {\n  return import_json5.default.parse(JSON.stringify((0, import_partial_json.parse)(jsonString, import_partial_json.Allow.ALL)));\n}\nfunction extractJson(text, throwOnBadJson) {\n  let openingChar;\n  let closingChar;\n  let startPos;\n  let nestingCount = 0;\n  let inString = false;\n  let escapeNext = false;\n  for (let i = 0; i < text.length; i++) {\n    const char = text[i].replace(/\\u00A0/g, \" \");\n    if (escapeNext) {\n      escapeNext = false;\n      continue;\n    }\n    if (char === \"\\\\\") {\n      escapeNext = true;\n      continue;\n    }\n    if (char === '\"') {\n      inString = !inString;\n      continue;\n    }\n    if (inString) {\n      continue;\n    }\n    if (!openingChar && (char === \"{\" || char === \"[\")) {\n      openingChar = char;\n      closingChar = char === \"{\" ? \"}\" : \"]\";\n      startPos = i;\n      nestingCount++;\n    } else if (char === openingChar) {\n      nestingCount++;\n    } else if (char === closingChar) {\n      nestingCount--;\n      if (!nestingCount) {\n        return import_json5.default.parse(text.substring(startPos || 0, i + 1));\n      }\n    }\n  }\n  if (startPos !== void 0 && nestingCount > 0) {\n    try {\n      return parsePartialJson(text.substring(startPos));\n    } catch {\n      if (throwOnBadJson) {\n        throw new Error(`Invalid JSON extracted from model output: ${text}`);\n      }\n      return null;\n    }\n  }\n  if (throwOnBadJson) {\n    throw new Error(`Invalid JSON extracted from model output: ${text}`);\n  }\n  return null;\n}\nfunction extractItems(text, cursor = 0) {\n  const items = [];\n  let currentCursor = cursor;\n  if (cursor === 0) {\n    const arrayStart = text.indexOf(\"[\");\n    if (arrayStart === -1) {\n      return { items: [], cursor: text.length };\n    }\n    currentCursor = arrayStart + 1;\n  }\n  let objectStart = -1;\n  let braceCount = 0;\n  let inString = false;\n  let escapeNext = false;\n  for (let i = currentCursor; i < text.length; i++) {\n    const char = text[i];\n    if (escapeNext) {\n      escapeNext = false;\n      continue;\n    }\n    if (char === \"\\\\\") {\n      escapeNext = true;\n      continue;\n    }\n    if (char === '\"') {\n      inString = !inString;\n      continue;\n    }\n    if (inString) {\n      continue;\n    }\n    if (char === \"{\") {\n      if (braceCount === 0) {\n        objectStart = i;\n      }\n      braceCount++;\n    } else if (char === \"}\") {\n      braceCount--;\n      if (braceCount === 0 && objectStart !== -1) {\n        try {\n          const obj = import_json5.default.parse(text.substring(objectStart, i + 1));\n          items.push(obj);\n          currentCursor = i + 1;\n          objectStart = -1;\n        } catch {\n        }\n      }\n    } else if (char === \"]\" && braceCount === 0) {\n      break;\n    }\n  }\n  return {\n    items,\n    cursor: currentCursor\n  };\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=extract.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9leHRyYWN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDhCQUE4QjtBQUN2RztBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwyQkFBMkIsbUJBQU8sQ0FBQyxtRUFBTztBQUMxQywwQkFBMEIsbUJBQU8sQ0FBQyxnRkFBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHFFQUFxRSxLQUFLO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsS0FBSztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUJBQWlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxvQkFBb0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBSUw7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcYWlcXGxpYlxcZXh0cmFjdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgZXh0cmFjdF9leHBvcnRzID0ge307XG5fX2V4cG9ydChleHRyYWN0X2V4cG9ydHMsIHtcbiAgZXh0cmFjdEl0ZW1zOiAoKSA9PiBleHRyYWN0SXRlbXMsXG4gIGV4dHJhY3RKc29uOiAoKSA9PiBleHRyYWN0SnNvbixcbiAgcGFyc2VQYXJ0aWFsSnNvbjogKCkgPT4gcGFyc2VQYXJ0aWFsSnNvblxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhleHRyYWN0X2V4cG9ydHMpO1xudmFyIGltcG9ydF9qc29uNSA9IF9fdG9FU00ocmVxdWlyZShcImpzb241XCIpKTtcbnZhciBpbXBvcnRfcGFydGlhbF9qc29uID0gcmVxdWlyZShcInBhcnRpYWwtanNvblwiKTtcbmZ1bmN0aW9uIHBhcnNlUGFydGlhbEpzb24oanNvblN0cmluZykge1xuICByZXR1cm4gaW1wb3J0X2pzb241LmRlZmF1bHQucGFyc2UoSlNPTi5zdHJpbmdpZnkoKDAsIGltcG9ydF9wYXJ0aWFsX2pzb24ucGFyc2UpKGpzb25TdHJpbmcsIGltcG9ydF9wYXJ0aWFsX2pzb24uQWxsb3cuQUxMKSkpO1xufVxuZnVuY3Rpb24gZXh0cmFjdEpzb24odGV4dCwgdGhyb3dPbkJhZEpzb24pIHtcbiAgbGV0IG9wZW5pbmdDaGFyO1xuICBsZXQgY2xvc2luZ0NoYXI7XG4gIGxldCBzdGFydFBvcztcbiAgbGV0IG5lc3RpbmdDb3VudCA9IDA7XG4gIGxldCBpblN0cmluZyA9IGZhbHNlO1xuICBsZXQgZXNjYXBlTmV4dCA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gdGV4dFtpXS5yZXBsYWNlKC9cXHUwMEEwL2csIFwiIFwiKTtcbiAgICBpZiAoZXNjYXBlTmV4dCkge1xuICAgICAgZXNjYXBlTmV4dCA9IGZhbHNlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjaGFyID09PSBcIlxcXFxcIikge1xuICAgICAgZXNjYXBlTmV4dCA9IHRydWU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNoYXIgPT09ICdcIicpIHtcbiAgICAgIGluU3RyaW5nID0gIWluU3RyaW5nO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpblN0cmluZykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICghb3BlbmluZ0NoYXIgJiYgKGNoYXIgPT09IFwie1wiIHx8IGNoYXIgPT09IFwiW1wiKSkge1xuICAgICAgb3BlbmluZ0NoYXIgPSBjaGFyO1xuICAgICAgY2xvc2luZ0NoYXIgPSBjaGFyID09PSBcIntcIiA/IFwifVwiIDogXCJdXCI7XG4gICAgICBzdGFydFBvcyA9IGk7XG4gICAgICBuZXN0aW5nQ291bnQrKztcbiAgICB9IGVsc2UgaWYgKGNoYXIgPT09IG9wZW5pbmdDaGFyKSB7XG4gICAgICBuZXN0aW5nQ291bnQrKztcbiAgICB9IGVsc2UgaWYgKGNoYXIgPT09IGNsb3NpbmdDaGFyKSB7XG4gICAgICBuZXN0aW5nQ291bnQtLTtcbiAgICAgIGlmICghbmVzdGluZ0NvdW50KSB7XG4gICAgICAgIHJldHVybiBpbXBvcnRfanNvbjUuZGVmYXVsdC5wYXJzZSh0ZXh0LnN1YnN0cmluZyhzdGFydFBvcyB8fCAwLCBpICsgMSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoc3RhcnRQb3MgIT09IHZvaWQgMCAmJiBuZXN0aW5nQ291bnQgPiAwKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBwYXJzZVBhcnRpYWxKc29uKHRleHQuc3Vic3RyaW5nKHN0YXJ0UG9zKSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBpZiAodGhyb3dPbkJhZEpzb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEpTT04gZXh0cmFjdGVkIGZyb20gbW9kZWwgb3V0cHV0OiAke3RleHR9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgaWYgKHRocm93T25CYWRKc29uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEpTT04gZXh0cmFjdGVkIGZyb20gbW9kZWwgb3V0cHV0OiAke3RleHR9YCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBleHRyYWN0SXRlbXModGV4dCwgY3Vyc29yID0gMCkge1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBsZXQgY3VycmVudEN1cnNvciA9IGN1cnNvcjtcbiAgaWYgKGN1cnNvciA9PT0gMCkge1xuICAgIGNvbnN0IGFycmF5U3RhcnQgPSB0ZXh0LmluZGV4T2YoXCJbXCIpO1xuICAgIGlmIChhcnJheVN0YXJ0ID09PSAtMSkge1xuICAgICAgcmV0dXJuIHsgaXRlbXM6IFtdLCBjdXJzb3I6IHRleHQubGVuZ3RoIH07XG4gICAgfVxuICAgIGN1cnJlbnRDdXJzb3IgPSBhcnJheVN0YXJ0ICsgMTtcbiAgfVxuICBsZXQgb2JqZWN0U3RhcnQgPSAtMTtcbiAgbGV0IGJyYWNlQ291bnQgPSAwO1xuICBsZXQgaW5TdHJpbmcgPSBmYWxzZTtcbiAgbGV0IGVzY2FwZU5leHQgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IGN1cnJlbnRDdXJzb3I7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhciA9IHRleHRbaV07XG4gICAgaWYgKGVzY2FwZU5leHQpIHtcbiAgICAgIGVzY2FwZU5leHQgPSBmYWxzZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY2hhciA9PT0gXCJcXFxcXCIpIHtcbiAgICAgIGVzY2FwZU5leHQgPSB0cnVlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjaGFyID09PSAnXCInKSB7XG4gICAgICBpblN0cmluZyA9ICFpblN0cmluZztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaW5TdHJpbmcpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY2hhciA9PT0gXCJ7XCIpIHtcbiAgICAgIGlmIChicmFjZUNvdW50ID09PSAwKSB7XG4gICAgICAgIG9iamVjdFN0YXJ0ID0gaTtcbiAgICAgIH1cbiAgICAgIGJyYWNlQ291bnQrKztcbiAgICB9IGVsc2UgaWYgKGNoYXIgPT09IFwifVwiKSB7XG4gICAgICBicmFjZUNvdW50LS07XG4gICAgICBpZiAoYnJhY2VDb3VudCA9PT0gMCAmJiBvYmplY3RTdGFydCAhPT0gLTEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBvYmogPSBpbXBvcnRfanNvbjUuZGVmYXVsdC5wYXJzZSh0ZXh0LnN1YnN0cmluZyhvYmplY3RTdGFydCwgaSArIDEpKTtcbiAgICAgICAgICBpdGVtcy5wdXNoKG9iaik7XG4gICAgICAgICAgY3VycmVudEN1cnNvciA9IGkgKyAxO1xuICAgICAgICAgIG9iamVjdFN0YXJ0ID0gLTE7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaGFyID09PSBcIl1cIiAmJiBicmFjZUNvdW50ID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpdGVtcyxcbiAgICBjdXJzb3I6IGN1cnJlbnRDdXJzb3JcbiAgfTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBleHRyYWN0SXRlbXMsXG4gIGV4dHJhY3RKc29uLFxuICBwYXJzZVBhcnRpYWxKc29uXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dHJhY3QuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/extract.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/formats/array.js":
/*!*********************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/formats/array.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar array_exports = {};\n__export(array_exports, {\n  arrayFormatter: () => arrayFormatter\n});\nmodule.exports = __toCommonJS(array_exports);\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nvar import_extract = __webpack_require__(/*! ../extract */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/extract.js\");\nconst arrayFormatter = {\n  name: \"array\",\n  config: {\n    contentType: \"application/json\",\n    constrained: true\n  },\n  handler: (schema) => {\n    if (schema && schema.type !== \"array\") {\n      throw new import_core.GenkitError({\n        status: \"INVALID_ARGUMENT\",\n        message: `Must supply an 'array' schema type when using the 'items' parser format.`\n      });\n    }\n    let instructions;\n    if (schema) {\n      instructions = `Output should be a JSON array conforming to the following schema:\n    \n\\`\\`\\`\n${JSON.stringify(schema)}\n\\`\\`\\`\n    `;\n    }\n    return {\n      parseChunk: (chunk) => {\n        const cursor = chunk.previousChunks?.length ? (0, import_extract.extractItems)(chunk.previousText).cursor : 0;\n        const { items } = (0, import_extract.extractItems)(chunk.accumulatedText, cursor);\n        return items;\n      },\n      parseMessage: (message) => {\n        const { items } = (0, import_extract.extractItems)(message.text, 0);\n        return items;\n      },\n      instructions\n    };\n  }\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=array.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9mb3JtYXRzL2FycmF5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMscUZBQWlCO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLGdGQUFZO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUVMO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcS1JhbWFjaGFcXERvY3VtZW50c1xcU3VzdEFJbmV4IEdJdCBDb2RlXFxub2RlX21vZHVsZXNcXEBnZW5raXQtYWlcXGFpXFxsaWJcXGZvcm1hdHNcXGFycmF5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBhcnJheV9leHBvcnRzID0ge307XG5fX2V4cG9ydChhcnJheV9leHBvcnRzLCB7XG4gIGFycmF5Rm9ybWF0dGVyOiAoKSA9PiBhcnJheUZvcm1hdHRlclxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhhcnJheV9leHBvcnRzKTtcbnZhciBpbXBvcnRfY29yZSA9IHJlcXVpcmUoXCJAZ2Vua2l0LWFpL2NvcmVcIik7XG52YXIgaW1wb3J0X2V4dHJhY3QgPSByZXF1aXJlKFwiLi4vZXh0cmFjdFwiKTtcbmNvbnN0IGFycmF5Rm9ybWF0dGVyID0ge1xuICBuYW1lOiBcImFycmF5XCIsXG4gIGNvbmZpZzoge1xuICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBjb25zdHJhaW5lZDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoc2NoZW1hKSA9PiB7XG4gICAgaWYgKHNjaGVtYSAmJiBzY2hlbWEudHlwZSAhPT0gXCJhcnJheVwiKSB7XG4gICAgICB0aHJvdyBuZXcgaW1wb3J0X2NvcmUuR2Vua2l0RXJyb3Ioe1xuICAgICAgICBzdGF0dXM6IFwiSU5WQUxJRF9BUkdVTUVOVFwiLFxuICAgICAgICBtZXNzYWdlOiBgTXVzdCBzdXBwbHkgYW4gJ2FycmF5JyBzY2hlbWEgdHlwZSB3aGVuIHVzaW5nIHRoZSAnaXRlbXMnIHBhcnNlciBmb3JtYXQuYFxuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBpbnN0cnVjdGlvbnM7XG4gICAgaWYgKHNjaGVtYSkge1xuICAgICAgaW5zdHJ1Y3Rpb25zID0gYE91dHB1dCBzaG91bGQgYmUgYSBKU09OIGFycmF5IGNvbmZvcm1pbmcgdG8gdGhlIGZvbGxvd2luZyBzY2hlbWE6XG4gICAgXG5cXGBcXGBcXGBcbiR7SlNPTi5zdHJpbmdpZnkoc2NoZW1hKX1cblxcYFxcYFxcYFxuICAgIGA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwYXJzZUNodW5rOiAoY2h1bmspID0+IHtcbiAgICAgICAgY29uc3QgY3Vyc29yID0gY2h1bmsucHJldmlvdXNDaHVua3M/Lmxlbmd0aCA/ICgwLCBpbXBvcnRfZXh0cmFjdC5leHRyYWN0SXRlbXMpKGNodW5rLnByZXZpb3VzVGV4dCkuY3Vyc29yIDogMDtcbiAgICAgICAgY29uc3QgeyBpdGVtcyB9ID0gKDAsIGltcG9ydF9leHRyYWN0LmV4dHJhY3RJdGVtcykoY2h1bmsuYWNjdW11bGF0ZWRUZXh0LCBjdXJzb3IpO1xuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgICB9LFxuICAgICAgcGFyc2VNZXNzYWdlOiAobWVzc2FnZSkgPT4ge1xuICAgICAgICBjb25zdCB7IGl0ZW1zIH0gPSAoMCwgaW1wb3J0X2V4dHJhY3QuZXh0cmFjdEl0ZW1zKShtZXNzYWdlLnRleHQsIDApO1xuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgICB9LFxuICAgICAgaW5zdHJ1Y3Rpb25zXG4gICAgfTtcbiAgfVxufTtcbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBhcnJheUZvcm1hdHRlclxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/formats/array.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/formats/enum.js":
/*!********************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/formats/enum.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar enum_exports = {};\n__export(enum_exports, {\n  enumFormatter: () => enumFormatter\n});\nmodule.exports = __toCommonJS(enum_exports);\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nconst enumFormatter = {\n  name: \"enum\",\n  config: {\n    contentType: \"text/enum\",\n    constrained: true\n  },\n  handler: (schema) => {\n    if (schema && schema.type !== \"string\" && schema.type !== \"enum\") {\n      throw new import_core.GenkitError({\n        status: \"INVALID_ARGUMENT\",\n        message: `Must supply a 'string' or 'enum' schema type when using the enum parser format.`\n      });\n    }\n    let instructions;\n    if (schema?.enum) {\n      instructions = `Output should be ONLY one of the following enum values. Do not output any additional information or add quotes.\n\n${schema.enum.map((v) => v.toString()).join(\"\\n\")}`;\n    }\n    return {\n      parseMessage: (message) => {\n        return message.text.replace(/['\"]/g, \"\").trim();\n      },\n      instructions\n    };\n  }\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=enum.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9mb3JtYXRzL2VudW0uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxxRkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsZ0RBQWdEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBRUw7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcYWlcXGxpYlxcZm9ybWF0c1xcZW51bS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgZW51bV9leHBvcnRzID0ge307XG5fX2V4cG9ydChlbnVtX2V4cG9ydHMsIHtcbiAgZW51bUZvcm1hdHRlcjogKCkgPT4gZW51bUZvcm1hdHRlclxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhlbnVtX2V4cG9ydHMpO1xudmFyIGltcG9ydF9jb3JlID0gcmVxdWlyZShcIkBnZW5raXQtYWkvY29yZVwiKTtcbmNvbnN0IGVudW1Gb3JtYXR0ZXIgPSB7XG4gIG5hbWU6IFwiZW51bVwiLFxuICBjb25maWc6IHtcbiAgICBjb250ZW50VHlwZTogXCJ0ZXh0L2VudW1cIixcbiAgICBjb25zdHJhaW5lZDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoc2NoZW1hKSA9PiB7XG4gICAgaWYgKHNjaGVtYSAmJiBzY2hlbWEudHlwZSAhPT0gXCJzdHJpbmdcIiAmJiBzY2hlbWEudHlwZSAhPT0gXCJlbnVtXCIpIHtcbiAgICAgIHRocm93IG5ldyBpbXBvcnRfY29yZS5HZW5raXRFcnJvcih7XG4gICAgICAgIHN0YXR1czogXCJJTlZBTElEX0FSR1VNRU5UXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBNdXN0IHN1cHBseSBhICdzdHJpbmcnIG9yICdlbnVtJyBzY2hlbWEgdHlwZSB3aGVuIHVzaW5nIHRoZSBlbnVtIHBhcnNlciBmb3JtYXQuYFxuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBpbnN0cnVjdGlvbnM7XG4gICAgaWYgKHNjaGVtYT8uZW51bSkge1xuICAgICAgaW5zdHJ1Y3Rpb25zID0gYE91dHB1dCBzaG91bGQgYmUgT05MWSBvbmUgb2YgdGhlIGZvbGxvd2luZyBlbnVtIHZhbHVlcy4gRG8gbm90IG91dHB1dCBhbnkgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBvciBhZGQgcXVvdGVzLlxuXG4ke3NjaGVtYS5lbnVtLm1hcCgodikgPT4gdi50b1N0cmluZygpKS5qb2luKFwiXFxuXCIpfWA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwYXJzZU1lc3NhZ2U6IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlLnRleHQucmVwbGFjZSgvWydcIl0vZywgXCJcIikudHJpbSgpO1xuICAgICAgfSxcbiAgICAgIGluc3RydWN0aW9uc1xuICAgIH07XG4gIH1cbn07XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgZW51bUZvcm1hdHRlclxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnVtLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/formats/enum.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/formats/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/formats/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar formats_exports = {};\n__export(formats_exports, {\n  DEFAULT_FORMATS: () => DEFAULT_FORMATS,\n  configureFormats: () => configureFormats,\n  defineFormat: () => defineFormat,\n  injectInstructions: () => injectInstructions,\n  resolveFormat: () => resolveFormat,\n  resolveInstructions: () => resolveInstructions\n});\nmodule.exports = __toCommonJS(formats_exports);\nvar import_array = __webpack_require__(/*! ./array.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/formats/array.js\");\nvar import_enum = __webpack_require__(/*! ./enum.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/formats/enum.js\");\nvar import_json = __webpack_require__(/*! ./json.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/formats/json.js\");\nvar import_jsonl = __webpack_require__(/*! ./jsonl.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/formats/jsonl.js\");\nvar import_text = __webpack_require__(/*! ./text.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/formats/text.js\");\nfunction defineFormat(registry, options, handler) {\n  const { name, ...config } = options;\n  const formatter = { config, handler };\n  registry.registerValue(\"format\", name, formatter);\n  return formatter;\n}\nasync function resolveFormat(registry, outputOpts) {\n  if (!outputOpts) return void 0;\n  if ((outputOpts.jsonSchema || outputOpts.schema) && !outputOpts.format) {\n    return registry.lookupValue(\"format\", \"json\");\n  }\n  if (outputOpts.format) {\n    return registry.lookupValue(\"format\", outputOpts.format);\n  }\n  return void 0;\n}\nfunction resolveInstructions(format, schema, instructionsOption) {\n  if (typeof instructionsOption === \"string\") return instructionsOption;\n  if (instructionsOption === false) return void 0;\n  if (!format) return void 0;\n  return format.handler(schema).instructions;\n}\nfunction injectInstructions(messages, instructions) {\n  if (!instructions) return messages;\n  if (messages.find(\n    (m2) => m2.content.find(\n      (p) => p.metadata?.purpose === \"output\" && !p.metadata?.pending\n    )\n  )) {\n    return messages;\n  }\n  const newPart = {\n    text: instructions,\n    metadata: { purpose: \"output\" }\n  };\n  let targetIndex = messages.findIndex((m2) => m2.role === \"system\");\n  if (targetIndex < 0)\n    targetIndex = messages.map((m2) => m2.role).lastIndexOf(\"user\");\n  if (targetIndex < 0) return messages;\n  const m = {\n    ...messages[targetIndex],\n    content: [...messages[targetIndex].content]\n  };\n  const partIndex = m.content.findIndex(\n    (p) => p.metadata?.purpose === \"output\" && p.metadata?.pending\n  );\n  if (partIndex > 0) {\n    m.content.splice(partIndex, 1, newPart);\n  } else {\n    m.content.push(newPart);\n  }\n  const outMessages = [...messages];\n  outMessages.splice(targetIndex, 1, m);\n  return outMessages;\n}\nconst DEFAULT_FORMATS = [\n  import_json.jsonFormatter,\n  import_array.arrayFormatter,\n  import_text.textFormatter,\n  import_enum.enumFormatter,\n  import_jsonl.jsonlFormatter\n];\nfunction configureFormats(registry) {\n  for (const format of DEFAULT_FORMATS) {\n    defineFormat(\n      registry,\n      { name: format.name, ...format.config },\n      format.handler\n    );\n  }\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9mb3JtYXRzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLHNGQUFZO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLG9GQUFXO0FBQ3JDLGtCQUFrQixtQkFBTyxDQUFDLG9GQUFXO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLHNGQUFZO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLG9GQUFXO0FBQ3JDO0FBQ0EsVUFBVSxrQkFBa0I7QUFDNUIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFDQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQU9MO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcS1JhbWFjaGFcXERvY3VtZW50c1xcU3VzdEFJbmV4IEdJdCBDb2RlXFxub2RlX21vZHVsZXNcXEBnZW5raXQtYWlcXGFpXFxsaWJcXGZvcm1hdHNcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBmb3JtYXRzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGZvcm1hdHNfZXhwb3J0cywge1xuICBERUZBVUxUX0ZPUk1BVFM6ICgpID0+IERFRkFVTFRfRk9STUFUUyxcbiAgY29uZmlndXJlRm9ybWF0czogKCkgPT4gY29uZmlndXJlRm9ybWF0cyxcbiAgZGVmaW5lRm9ybWF0OiAoKSA9PiBkZWZpbmVGb3JtYXQsXG4gIGluamVjdEluc3RydWN0aW9uczogKCkgPT4gaW5qZWN0SW5zdHJ1Y3Rpb25zLFxuICByZXNvbHZlRm9ybWF0OiAoKSA9PiByZXNvbHZlRm9ybWF0LFxuICByZXNvbHZlSW5zdHJ1Y3Rpb25zOiAoKSA9PiByZXNvbHZlSW5zdHJ1Y3Rpb25zXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKGZvcm1hdHNfZXhwb3J0cyk7XG52YXIgaW1wb3J0X2FycmF5ID0gcmVxdWlyZShcIi4vYXJyYXkuanNcIik7XG52YXIgaW1wb3J0X2VudW0gPSByZXF1aXJlKFwiLi9lbnVtLmpzXCIpO1xudmFyIGltcG9ydF9qc29uID0gcmVxdWlyZShcIi4vanNvbi5qc1wiKTtcbnZhciBpbXBvcnRfanNvbmwgPSByZXF1aXJlKFwiLi9qc29ubC5qc1wiKTtcbnZhciBpbXBvcnRfdGV4dCA9IHJlcXVpcmUoXCIuL3RleHQuanNcIik7XG5mdW5jdGlvbiBkZWZpbmVGb3JtYXQocmVnaXN0cnksIG9wdGlvbnMsIGhhbmRsZXIpIHtcbiAgY29uc3QgeyBuYW1lLCAuLi5jb25maWcgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGZvcm1hdHRlciA9IHsgY29uZmlnLCBoYW5kbGVyIH07XG4gIHJlZ2lzdHJ5LnJlZ2lzdGVyVmFsdWUoXCJmb3JtYXRcIiwgbmFtZSwgZm9ybWF0dGVyKTtcbiAgcmV0dXJuIGZvcm1hdHRlcjtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVGb3JtYXQocmVnaXN0cnksIG91dHB1dE9wdHMpIHtcbiAgaWYgKCFvdXRwdXRPcHRzKSByZXR1cm4gdm9pZCAwO1xuICBpZiAoKG91dHB1dE9wdHMuanNvblNjaGVtYSB8fCBvdXRwdXRPcHRzLnNjaGVtYSkgJiYgIW91dHB1dE9wdHMuZm9ybWF0KSB7XG4gICAgcmV0dXJuIHJlZ2lzdHJ5Lmxvb2t1cFZhbHVlKFwiZm9ybWF0XCIsIFwianNvblwiKTtcbiAgfVxuICBpZiAob3V0cHV0T3B0cy5mb3JtYXQpIHtcbiAgICByZXR1cm4gcmVnaXN0cnkubG9va3VwVmFsdWUoXCJmb3JtYXRcIiwgb3V0cHV0T3B0cy5mb3JtYXQpO1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5mdW5jdGlvbiByZXNvbHZlSW5zdHJ1Y3Rpb25zKGZvcm1hdCwgc2NoZW1hLCBpbnN0cnVjdGlvbnNPcHRpb24pIHtcbiAgaWYgKHR5cGVvZiBpbnN0cnVjdGlvbnNPcHRpb24gPT09IFwic3RyaW5nXCIpIHJldHVybiBpbnN0cnVjdGlvbnNPcHRpb247XG4gIGlmIChpbnN0cnVjdGlvbnNPcHRpb24gPT09IGZhbHNlKSByZXR1cm4gdm9pZCAwO1xuICBpZiAoIWZvcm1hdCkgcmV0dXJuIHZvaWQgMDtcbiAgcmV0dXJuIGZvcm1hdC5oYW5kbGVyKHNjaGVtYSkuaW5zdHJ1Y3Rpb25zO1xufVxuZnVuY3Rpb24gaW5qZWN0SW5zdHJ1Y3Rpb25zKG1lc3NhZ2VzLCBpbnN0cnVjdGlvbnMpIHtcbiAgaWYgKCFpbnN0cnVjdGlvbnMpIHJldHVybiBtZXNzYWdlcztcbiAgaWYgKG1lc3NhZ2VzLmZpbmQoXG4gICAgKG0yKSA9PiBtMi5jb250ZW50LmZpbmQoXG4gICAgICAocCkgPT4gcC5tZXRhZGF0YT8ucHVycG9zZSA9PT0gXCJvdXRwdXRcIiAmJiAhcC5tZXRhZGF0YT8ucGVuZGluZ1xuICAgIClcbiAgKSkge1xuICAgIHJldHVybiBtZXNzYWdlcztcbiAgfVxuICBjb25zdCBuZXdQYXJ0ID0ge1xuICAgIHRleHQ6IGluc3RydWN0aW9ucyxcbiAgICBtZXRhZGF0YTogeyBwdXJwb3NlOiBcIm91dHB1dFwiIH1cbiAgfTtcbiAgbGV0IHRhcmdldEluZGV4ID0gbWVzc2FnZXMuZmluZEluZGV4KChtMikgPT4gbTIucm9sZSA9PT0gXCJzeXN0ZW1cIik7XG4gIGlmICh0YXJnZXRJbmRleCA8IDApXG4gICAgdGFyZ2V0SW5kZXggPSBtZXNzYWdlcy5tYXAoKG0yKSA9PiBtMi5yb2xlKS5sYXN0SW5kZXhPZihcInVzZXJcIik7XG4gIGlmICh0YXJnZXRJbmRleCA8IDApIHJldHVybiBtZXNzYWdlcztcbiAgY29uc3QgbSA9IHtcbiAgICAuLi5tZXNzYWdlc1t0YXJnZXRJbmRleF0sXG4gICAgY29udGVudDogWy4uLm1lc3NhZ2VzW3RhcmdldEluZGV4XS5jb250ZW50XVxuICB9O1xuICBjb25zdCBwYXJ0SW5kZXggPSBtLmNvbnRlbnQuZmluZEluZGV4KFxuICAgIChwKSA9PiBwLm1ldGFkYXRhPy5wdXJwb3NlID09PSBcIm91dHB1dFwiICYmIHAubWV0YWRhdGE/LnBlbmRpbmdcbiAgKTtcbiAgaWYgKHBhcnRJbmRleCA+IDApIHtcbiAgICBtLmNvbnRlbnQuc3BsaWNlKHBhcnRJbmRleCwgMSwgbmV3UGFydCk7XG4gIH0gZWxzZSB7XG4gICAgbS5jb250ZW50LnB1c2gobmV3UGFydCk7XG4gIH1cbiAgY29uc3Qgb3V0TWVzc2FnZXMgPSBbLi4ubWVzc2FnZXNdO1xuICBvdXRNZXNzYWdlcy5zcGxpY2UodGFyZ2V0SW5kZXgsIDEsIG0pO1xuICByZXR1cm4gb3V0TWVzc2FnZXM7XG59XG5jb25zdCBERUZBVUxUX0ZPUk1BVFMgPSBbXG4gIGltcG9ydF9qc29uLmpzb25Gb3JtYXR0ZXIsXG4gIGltcG9ydF9hcnJheS5hcnJheUZvcm1hdHRlcixcbiAgaW1wb3J0X3RleHQudGV4dEZvcm1hdHRlcixcbiAgaW1wb3J0X2VudW0uZW51bUZvcm1hdHRlcixcbiAgaW1wb3J0X2pzb25sLmpzb25sRm9ybWF0dGVyXG5dO1xuZnVuY3Rpb24gY29uZmlndXJlRm9ybWF0cyhyZWdpc3RyeSkge1xuICBmb3IgKGNvbnN0IGZvcm1hdCBvZiBERUZBVUxUX0ZPUk1BVFMpIHtcbiAgICBkZWZpbmVGb3JtYXQoXG4gICAgICByZWdpc3RyeSxcbiAgICAgIHsgbmFtZTogZm9ybWF0Lm5hbWUsIC4uLmZvcm1hdC5jb25maWcgfSxcbiAgICAgIGZvcm1hdC5oYW5kbGVyXG4gICAgKTtcbiAgfVxufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIERFRkFVTFRfRk9STUFUUyxcbiAgY29uZmlndXJlRm9ybWF0cyxcbiAgZGVmaW5lRm9ybWF0LFxuICBpbmplY3RJbnN0cnVjdGlvbnMsXG4gIHJlc29sdmVGb3JtYXQsXG4gIHJlc29sdmVJbnN0cnVjdGlvbnNcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/formats/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/formats/json.js":
/*!********************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/formats/json.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar json_exports = {};\n__export(json_exports, {\n  jsonFormatter: () => jsonFormatter\n});\nmodule.exports = __toCommonJS(json_exports);\nvar import_extract = __webpack_require__(/*! ../extract */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/extract.js\");\nconst jsonFormatter = {\n  name: \"json\",\n  config: {\n    format: \"json\",\n    contentType: \"application/json\",\n    constrained: true,\n    defaultInstructions: false\n  },\n  handler: (schema) => {\n    let instructions;\n    if (schema) {\n      instructions = `Output should be in JSON format and conform to the following schema:\n\n\\`\\`\\`\n${JSON.stringify(schema)}\n\\`\\`\\`\n`;\n    }\n    return {\n      parseChunk: (chunk) => {\n        return (0, import_extract.extractJson)(chunk.accumulatedText);\n      },\n      parseMessage: (message) => {\n        return (0, import_extract.extractJson)(message.text);\n      },\n      instructions\n    };\n  }\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=json.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9mb3JtYXRzL2pzb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxnRkFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUVMO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcS1JhbWFjaGFcXERvY3VtZW50c1xcU3VzdEFJbmV4IEdJdCBDb2RlXFxub2RlX21vZHVsZXNcXEBnZW5raXQtYWlcXGFpXFxsaWJcXGZvcm1hdHNcXGpzb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIGpzb25fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoanNvbl9leHBvcnRzLCB7XG4gIGpzb25Gb3JtYXR0ZXI6ICgpID0+IGpzb25Gb3JtYXR0ZXJcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoanNvbl9leHBvcnRzKTtcbnZhciBpbXBvcnRfZXh0cmFjdCA9IHJlcXVpcmUoXCIuLi9leHRyYWN0XCIpO1xuY29uc3QganNvbkZvcm1hdHRlciA9IHtcbiAgbmFtZTogXCJqc29uXCIsXG4gIGNvbmZpZzoge1xuICAgIGZvcm1hdDogXCJqc29uXCIsXG4gICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIGNvbnN0cmFpbmVkOiB0cnVlLFxuICAgIGRlZmF1bHRJbnN0cnVjdGlvbnM6IGZhbHNlXG4gIH0sXG4gIGhhbmRsZXI6IChzY2hlbWEpID0+IHtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25zO1xuICAgIGlmIChzY2hlbWEpIHtcbiAgICAgIGluc3RydWN0aW9ucyA9IGBPdXRwdXQgc2hvdWxkIGJlIGluIEpTT04gZm9ybWF0IGFuZCBjb25mb3JtIHRvIHRoZSBmb2xsb3dpbmcgc2NoZW1hOlxuXG5cXGBcXGBcXGBcbiR7SlNPTi5zdHJpbmdpZnkoc2NoZW1hKX1cblxcYFxcYFxcYFxuYDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcnNlQ2h1bms6IChjaHVuaykgPT4ge1xuICAgICAgICByZXR1cm4gKDAsIGltcG9ydF9leHRyYWN0LmV4dHJhY3RKc29uKShjaHVuay5hY2N1bXVsYXRlZFRleHQpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlTWVzc2FnZTogKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgcmV0dXJuICgwLCBpbXBvcnRfZXh0cmFjdC5leHRyYWN0SnNvbikobWVzc2FnZS50ZXh0KTtcbiAgICAgIH0sXG4gICAgICBpbnN0cnVjdGlvbnNcbiAgICB9O1xuICB9XG59O1xuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIGpzb25Gb3JtYXR0ZXJcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/formats/json.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/formats/jsonl.js":
/*!*********************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/formats/jsonl.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar jsonl_exports = {};\n__export(jsonl_exports, {\n  jsonlFormatter: () => jsonlFormatter\n});\nmodule.exports = __toCommonJS(jsonl_exports);\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nvar import_json5 = __toESM(__webpack_require__(/*! json5 */ \"(action-browser)/./node_modules/json5/dist/index.mjs\"));\nvar import_extract = __webpack_require__(/*! ../extract */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/extract.js\");\nfunction objectLines(text) {\n  return text.split(\"\\n\").map((line) => line.trim()).filter((line) => line.startsWith(\"{\"));\n}\nconst jsonlFormatter = {\n  name: \"jsonl\",\n  config: {\n    contentType: \"application/jsonl\"\n  },\n  handler: (schema) => {\n    if (schema && (schema.type !== \"array\" || schema.items?.type !== \"object\")) {\n      throw new import_core.GenkitError({\n        status: \"INVALID_ARGUMENT\",\n        message: `Must supply an 'array' schema type containing 'object' items when using the 'jsonl' parser format.`\n      });\n    }\n    let instructions;\n    if (schema?.items) {\n      instructions = `Output should be JSONL format, a sequence of JSON objects (one per line) separated by a newline \\`\\\\n\\` character. Each line should be a JSON object conforming to the following schema:\n\n\\`\\`\\`\n${JSON.stringify(schema.items)}\n\\`\\`\\`\n    `;\n    }\n    return {\n      parseChunk: (chunk) => {\n        const results = [];\n        const text = chunk.accumulatedText;\n        let startIndex = 0;\n        if (chunk.previousChunks?.length) {\n          const lastNewline = chunk.previousText.lastIndexOf(\"\\n\");\n          if (lastNewline !== -1) {\n            startIndex = lastNewline + 1;\n          }\n        }\n        const lines = text.slice(startIndex).split(\"\\n\");\n        for (const line of lines) {\n          const trimmed = line.trim();\n          if (trimmed.startsWith(\"{\")) {\n            try {\n              const result = import_json5.default.parse(trimmed);\n              if (result) {\n                results.push(result);\n              }\n            } catch (e) {\n              break;\n            }\n          }\n        }\n        return results;\n      },\n      parseMessage: (message) => {\n        const items = objectLines(message.text).map((l) => (0, import_extract.extractJson)(l)).filter((l) => !!l);\n        return items;\n      },\n      instructions\n    };\n  }\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=jsonl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9mb3JtYXRzL2pzb25sLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDhCQUE4QjtBQUN2RztBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHFGQUFpQjtBQUMzQywyQkFBMkIsbUJBQU8sQ0FBQyxtRUFBTztBQUMxQyxxQkFBcUIsbUJBQU8sQ0FBQyxnRkFBWTtBQUN6QztBQUNBLHdGQUF3RjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBRUw7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcYWlcXGxpYlxcZm9ybWF0c1xcanNvbmwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgLy8gSWYgdGhlIGltcG9ydGVyIGlzIGluIG5vZGUgY29tcGF0aWJpbGl0eSBtb2RlIG9yIHRoaXMgaXMgbm90IGFuIEVTTVxuICAvLyBmaWxlIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIHRvIGEgQ29tbW9uSlMgZmlsZSB1c2luZyBhIEJhYmVsLVxuICAvLyBjb21wYXRpYmxlIHRyYW5zZm9ybSAoaS5lLiBcIl9fZXNNb2R1bGVcIiBoYXMgbm90IGJlZW4gc2V0KSwgdGhlbiBzZXRcbiAgLy8gXCJkZWZhdWx0XCIgdG8gdGhlIENvbW1vbkpTIFwibW9kdWxlLmV4cG9ydHNcIiBmb3Igbm9kZSBjb21wYXRpYmlsaXR5LlxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIGpzb25sX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGpzb25sX2V4cG9ydHMsIHtcbiAganNvbmxGb3JtYXR0ZXI6ICgpID0+IGpzb25sRm9ybWF0dGVyXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKGpzb25sX2V4cG9ydHMpO1xudmFyIGltcG9ydF9jb3JlID0gcmVxdWlyZShcIkBnZW5raXQtYWkvY29yZVwiKTtcbnZhciBpbXBvcnRfanNvbjUgPSBfX3RvRVNNKHJlcXVpcmUoXCJqc29uNVwiKSk7XG52YXIgaW1wb3J0X2V4dHJhY3QgPSByZXF1aXJlKFwiLi4vZXh0cmFjdFwiKTtcbmZ1bmN0aW9uIG9iamVjdExpbmVzKHRleHQpIHtcbiAgcmV0dXJuIHRleHQuc3BsaXQoXCJcXG5cIikubWFwKChsaW5lKSA9PiBsaW5lLnRyaW0oKSkuZmlsdGVyKChsaW5lKSA9PiBsaW5lLnN0YXJ0c1dpdGgoXCJ7XCIpKTtcbn1cbmNvbnN0IGpzb25sRm9ybWF0dGVyID0ge1xuICBuYW1lOiBcImpzb25sXCIsXG4gIGNvbmZpZzoge1xuICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25sXCJcbiAgfSxcbiAgaGFuZGxlcjogKHNjaGVtYSkgPT4ge1xuICAgIGlmIChzY2hlbWEgJiYgKHNjaGVtYS50eXBlICE9PSBcImFycmF5XCIgfHwgc2NoZW1hLml0ZW1zPy50eXBlICE9PSBcIm9iamVjdFwiKSkge1xuICAgICAgdGhyb3cgbmV3IGltcG9ydF9jb3JlLkdlbmtpdEVycm9yKHtcbiAgICAgICAgc3RhdHVzOiBcIklOVkFMSURfQVJHVU1FTlRcIixcbiAgICAgICAgbWVzc2FnZTogYE11c3Qgc3VwcGx5IGFuICdhcnJheScgc2NoZW1hIHR5cGUgY29udGFpbmluZyAnb2JqZWN0JyBpdGVtcyB3aGVuIHVzaW5nIHRoZSAnanNvbmwnIHBhcnNlciBmb3JtYXQuYFxuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBpbnN0cnVjdGlvbnM7XG4gICAgaWYgKHNjaGVtYT8uaXRlbXMpIHtcbiAgICAgIGluc3RydWN0aW9ucyA9IGBPdXRwdXQgc2hvdWxkIGJlIEpTT05MIGZvcm1hdCwgYSBzZXF1ZW5jZSBvZiBKU09OIG9iamVjdHMgKG9uZSBwZXIgbGluZSkgc2VwYXJhdGVkIGJ5IGEgbmV3bGluZSBcXGBcXFxcblxcYCBjaGFyYWN0ZXIuIEVhY2ggbGluZSBzaG91bGQgYmUgYSBKU09OIG9iamVjdCBjb25mb3JtaW5nIHRvIHRoZSBmb2xsb3dpbmcgc2NoZW1hOlxuXG5cXGBcXGBcXGBcbiR7SlNPTi5zdHJpbmdpZnkoc2NoZW1hLml0ZW1zKX1cblxcYFxcYFxcYFxuICAgIGA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwYXJzZUNodW5rOiAoY2h1bmspID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBjb25zdCB0ZXh0ID0gY2h1bmsuYWNjdW11bGF0ZWRUZXh0O1xuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IDA7XG4gICAgICAgIGlmIChjaHVuay5wcmV2aW91c0NodW5rcz8ubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgbGFzdE5ld2xpbmUgPSBjaHVuay5wcmV2aW91c1RleHQubGFzdEluZGV4T2YoXCJcXG5cIik7XG4gICAgICAgICAgaWYgKGxhc3ROZXdsaW5lICE9PSAtMSkge1xuICAgICAgICAgICAgc3RhcnRJbmRleCA9IGxhc3ROZXdsaW5lICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGluZXMgPSB0ZXh0LnNsaWNlKHN0YXJ0SW5kZXgpLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgICBjb25zdCB0cmltbWVkID0gbGluZS50cmltKCk7XG4gICAgICAgICAgaWYgKHRyaW1tZWQuc3RhcnRzV2l0aChcIntcIikpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGltcG9ydF9qc29uNS5kZWZhdWx0LnBhcnNlKHRyaW1tZWQpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfSxcbiAgICAgIHBhcnNlTWVzc2FnZTogKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBvYmplY3RMaW5lcyhtZXNzYWdlLnRleHQpLm1hcCgobCkgPT4gKDAsIGltcG9ydF9leHRyYWN0LmV4dHJhY3RKc29uKShsKSkuZmlsdGVyKChsKSA9PiAhIWwpO1xuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgICB9LFxuICAgICAgaW5zdHJ1Y3Rpb25zXG4gICAgfTtcbiAgfVxufTtcbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBqc29ubEZvcm1hdHRlclxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29ubC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/formats/jsonl.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/formats/text.js":
/*!********************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/formats/text.js ***!
  \********************************************************/
/***/ ((module) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar text_exports = {};\n__export(text_exports, {\n  textFormatter: () => textFormatter\n});\nmodule.exports = __toCommonJS(text_exports);\nconst textFormatter = {\n  name: \"text\",\n  config: {\n    contentType: \"text/plain\"\n  },\n  handler: () => {\n    return {\n      parseChunk: (chunk) => {\n        return chunk.text;\n      },\n      parseMessage: (message) => {\n        return message.text;\n      }\n    };\n  }\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=text.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9mb3JtYXRzL3RleHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FFTDtBQUNEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEtSYW1hY2hhXFxEb2N1bWVudHNcXFN1c3RBSW5leCBHSXQgQ29kZVxcbm9kZV9tb2R1bGVzXFxAZ2Vua2l0LWFpXFxhaVxcbGliXFxmb3JtYXRzXFx0ZXh0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciB0ZXh0X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHRleHRfZXhwb3J0cywge1xuICB0ZXh0Rm9ybWF0dGVyOiAoKSA9PiB0ZXh0Rm9ybWF0dGVyXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHRleHRfZXhwb3J0cyk7XG5jb25zdCB0ZXh0Rm9ybWF0dGVyID0ge1xuICBuYW1lOiBcInRleHRcIixcbiAgY29uZmlnOiB7XG4gICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpblwiXG4gIH0sXG4gIGhhbmRsZXI6ICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgcGFyc2VDaHVuazogKGNodW5rKSA9PiB7XG4gICAgICAgIHJldHVybiBjaHVuay50ZXh0O1xuICAgICAgfSxcbiAgICAgIHBhcnNlTWVzc2FnZTogKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2UudGV4dDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIHRleHRGb3JtYXR0ZXJcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4dC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/formats/text.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/generate.js":
/*!****************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/generate.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar generate_exports = {};\n__export(generate_exports, {\n  GenerateResponse: () => import_response.GenerateResponse,\n  GenerateResponseChunk: () => import_chunk.GenerateResponseChunk,\n  GenerationBlockedError: () => GenerationBlockedError,\n  GenerationResponseError: () => GenerationResponseError,\n  generate: () => generate,\n  generateOperation: () => generateOperation,\n  generateStream: () => generateStream,\n  tagAsPreamble: () => tagAsPreamble,\n  toGenerateActionOptions: () => toGenerateActionOptions,\n  toGenerateRequest: () => toGenerateRequest\n});\nmodule.exports = __toCommonJS(generate_exports);\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nvar import_async = __webpack_require__(/*! @genkit-ai/core/async */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/async.js\");\nvar import_registry = __webpack_require__(/*! @genkit-ai/core/registry */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/registry.js\");\nvar import_schema = __webpack_require__(/*! @genkit-ai/core/schema */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/schema.js\");\nvar import_formats = __webpack_require__(/*! ./formats/index.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/formats/index.js\");\nvar import_action = __webpack_require__(/*! ./generate/action.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/generate/action.js\");\nvar import_chunk = __webpack_require__(/*! ./generate/chunk.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/generate/chunk.js\");\nvar import_response = __webpack_require__(/*! ./generate/response.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/generate/response.js\");\nvar import_message = __webpack_require__(/*! ./message.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/message.js\");\nvar import_model = __webpack_require__(/*! ./model.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/model.js\");\nvar import_prompt = __webpack_require__(/*! ./prompt.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/prompt.js\");\nvar import_resource = __webpack_require__(/*! ./resource.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/resource.js\");\nvar import_tool = __webpack_require__(/*! ./tool.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/tool.js\");\nasync function toGenerateRequest(registry, options) {\n  const messages = [];\n  if (options.system) {\n    messages.push({\n      role: \"system\",\n      content: import_message.Message.parseContent(options.system)\n    });\n  }\n  if (options.messages) {\n    messages.push(...options.messages.map((m) => import_message.Message.parseData(m)));\n  }\n  if (options.prompt) {\n    messages.push({\n      role: \"user\",\n      content: import_message.Message.parseContent(options.prompt)\n    });\n  }\n  if (messages.length === 0) {\n    throw new import_core.GenkitError({\n      status: \"INVALID_ARGUMENT\",\n      message: \"at least one message is required in generate request\"\n    });\n  }\n  if (options.resume && !(messages.at(-1)?.role === \"model\" && messages.at(-1)?.content.find((p) => !!p.toolRequest))) {\n    throw new import_core.GenkitError({\n      status: \"FAILED_PRECONDITION\",\n      message: `Last message must be a 'model' role with at least one tool request to 'resume' generation.`,\n      detail: messages.at(-1)\n    });\n  }\n  let tools;\n  if (options.tools) {\n    tools = await (0, import_tool.resolveTools)(registry, options.tools);\n  }\n  const resolvedSchema = (0, import_schema.toJsonSchema)({\n    schema: options.output?.schema,\n    jsonSchema: options.output?.jsonSchema\n  });\n  const resolvedFormat = await (0, import_formats.resolveFormat)(registry, options.output);\n  const instructions = (0, import_formats.resolveInstructions)(\n    resolvedFormat,\n    resolvedSchema,\n    options?.output?.instructions\n  );\n  const out = {\n    messages: (0, import_action.shouldInjectFormatInstructions)(\n      resolvedFormat?.config,\n      options.output\n    ) ? (0, import_formats.injectInstructions)(messages, instructions) : messages,\n    config: options.config,\n    docs: options.docs,\n    tools: tools?.map(import_tool.toToolDefinition) || [],\n    output: {\n      ...resolvedFormat?.config || {},\n      ...options.output,\n      schema: resolvedSchema\n    }\n  };\n  if (!out?.output?.schema) delete out?.output?.schema;\n  return out;\n}\nclass GenerationResponseError extends import_core.GenkitError {\n  detail;\n  constructor(response, message, status, detail) {\n    super({\n      status: status || \"FAILED_PRECONDITION\",\n      message\n    });\n    this.detail = { response, ...detail };\n  }\n}\nasync function toolsToActionRefs(registry, toolOpt) {\n  if (!toolOpt) return;\n  const tools = [];\n  for (const t of toolOpt) {\n    if (typeof t === \"string\") {\n      tools.push(await resolveFullToolName(registry, t));\n    } else if ((0, import_core.isAction)(t) || (0, import_tool.isDynamicTool)(t)) {\n      tools.push(`/${t.__action.metadata?.type}/${t.__action.name}`);\n    } else if ((0, import_prompt.isExecutablePrompt)(t)) {\n      const promptToolAction = await t.asTool();\n      tools.push(`/prompt/${promptToolAction.__action.name}`);\n    } else {\n      throw new Error(`Unable to determine type of tool: ${JSON.stringify(t)}`);\n    }\n  }\n  return tools;\n}\nfunction messagesFromOptions(options) {\n  const messages = [];\n  if (options.system) {\n    messages.push({\n      role: \"system\",\n      content: import_message.Message.parseContent(options.system)\n    });\n  }\n  if (options.messages) {\n    messages.push(...options.messages);\n  }\n  if (options.prompt) {\n    messages.push({\n      role: \"user\",\n      content: import_message.Message.parseContent(options.prompt)\n    });\n  }\n  if (messages.length === 0) {\n    throw new import_core.GenkitError({\n      status: \"INVALID_ARGUMENT\",\n      message: \"at least one message is required in generate request\"\n    });\n  }\n  return messages;\n}\nclass GenerationBlockedError extends GenerationResponseError {\n}\nasync function generate(registry, options) {\n  const resolvedOptions = {\n    ...await Promise.resolve(options)\n  };\n  const resolvedFormat = await (0, import_formats.resolveFormat)(registry, resolvedOptions.output);\n  registry = maybeRegisterDynamicTools(registry, resolvedOptions);\n  registry = maybeRegisterDynamicResources(registry, resolvedOptions);\n  const params = await toGenerateActionOptions(registry, resolvedOptions);\n  const tools = await toolsToActionRefs(registry, resolvedOptions.tools);\n  const streamingCallback = stripNoop(\n    resolvedOptions.onChunk ?? resolvedOptions.streamingCallback\n  );\n  const response = await (0, import_core.runWithContext)(\n    resolvedOptions.context,\n    () => (0, import_action.generateHelper)(registry, {\n      rawRequest: params,\n      middleware: resolvedOptions.use,\n      abortSignal: resolvedOptions.abortSignal,\n      streamingCallback\n    })\n  );\n  const request = await toGenerateRequest(registry, {\n    ...resolvedOptions,\n    tools\n  });\n  return new import_response.GenerateResponse(response, {\n    request: response.request ?? request,\n    parser: resolvedFormat?.handler(request.output?.schema).parseMessage\n  });\n}\nasync function generateOperation(registry, options) {\n  (0, import_core.assertUnstable)(registry, \"beta\", \"generateOperation is a beta feature.\");\n  options = await options;\n  const resolvedModel = await (0, import_model.resolveModel)(registry, options.model);\n  if (!resolvedModel.modelAction.__action.metadata?.model.supports?.longRunning) {\n    throw new import_core.GenkitError({\n      status: \"INVALID_ARGUMENT\",\n      message: `Model '${resolvedModel.modelAction.__action.name}' does not support long running operations.`\n    });\n  }\n  const { operation } = await generate(registry, options);\n  if (!operation) {\n    throw new import_core.GenkitError({\n      status: \"FAILED_PRECONDITION\",\n      message: `Model '${resolvedModel.modelAction.__action.name}' did not return an operation.`\n    });\n  }\n  return operation;\n}\nfunction maybeRegisterDynamicTools(registry, options) {\n  let hasDynamicTools = false;\n  options?.tools?.forEach((t) => {\n    if ((0, import_tool.isDynamicTool)(t)) {\n      if (!hasDynamicTools) {\n        hasDynamicTools = true;\n        registry = import_registry.Registry.withParent(registry);\n      }\n      registry.registerAction(\"tool\", t);\n    }\n  });\n  return registry;\n}\nfunction maybeRegisterDynamicResources(registry, options) {\n  let hasDynamicResources = false;\n  options?.resources?.forEach((r) => {\n    if ((0, import_resource.isDynamicResourceAction)(r)) {\n      if (!hasDynamicResources) {\n        hasDynamicResources = true;\n        registry = import_registry.Registry.withParent(registry);\n      }\n      registry.registerAction(\"resource\", r);\n    }\n  });\n  return registry;\n}\nasync function toGenerateActionOptions(registry, options) {\n  const resolvedModel = await (0, import_model.resolveModel)(registry, options.model);\n  const tools = await toolsToActionRefs(registry, options.tools);\n  const messages = messagesFromOptions(options);\n  const resolvedSchema = (0, import_schema.toJsonSchema)({\n    schema: options.output?.schema,\n    jsonSchema: options.output?.jsonSchema\n  });\n  if ((options.output?.schema || options.output?.jsonSchema) && !options.output?.format) {\n    options.output.format = \"json\";\n  }\n  const params = {\n    model: resolvedModel.modelAction.__action.name,\n    docs: options.docs,\n    messages,\n    tools,\n    toolChoice: options.toolChoice,\n    config: {\n      version: resolvedModel.version,\n      ...stripUndefinedOptions(resolvedModel.config),\n      ...stripUndefinedOptions(options.config)\n    },\n    output: options.output && {\n      ...options.output,\n      format: options.output.format,\n      jsonSchema: resolvedSchema\n    },\n    // coerce reply and restart into arrays for the action schema\n    resume: options.resume && {\n      respond: [options.resume.respond || []].flat(),\n      restart: [options.resume.restart || []].flat(),\n      metadata: options.resume.metadata\n    },\n    returnToolRequests: options.returnToolRequests,\n    maxTurns: options.maxTurns,\n    stepName: options.stepName\n  };\n  if (Object.keys(params.config).length === 0 && !options.config) {\n    delete params.config;\n  }\n  return params;\n}\nfunction stripNoop(callback) {\n  if (callback === import_core.sentinelNoopStreamingCallback) {\n    return void 0;\n  }\n  return callback;\n}\nfunction stripUndefinedOptions(input) {\n  if (!input) return input;\n  const copy = { ...input };\n  Object.keys(input).forEach((key) => {\n    if (copy[key] === void 0) {\n      delete copy[key];\n    }\n  });\n  return copy;\n}\nasync function resolveFullToolName(registry, name) {\n  if (await registry.lookupAction(`/tool/${name}`)) {\n    return `/tool/${name}`;\n  } else if (await registry.lookupAction(`/prompt/${name}`)) {\n    return `/prompt/${name}`;\n  } else {\n    throw new Error(`Unable to determine type of of tool: ${name}`);\n  }\n}\nfunction generateStream(registry, options) {\n  const channel = new import_async.Channel();\n  const generated = Promise.resolve(options).then(\n    (resolvedOptions) => generate(registry, {\n      ...resolvedOptions,\n      onChunk: (chunk) => channel.send(chunk)\n    })\n  );\n  generated.then(\n    () => channel.close(),\n    (err) => channel.error(err)\n  );\n  return {\n    response: generated,\n    stream: channel\n  };\n}\nfunction tagAsPreamble(msgs) {\n  if (!msgs) {\n    return void 0;\n  }\n  return msgs.map((m) => ({\n    ...m,\n    metadata: {\n      ...m.metadata,\n      preamble: true\n    }\n  }));\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=generate.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9nZW5lcmF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHFGQUFpQjtBQUMzQyxtQkFBbUIsbUJBQU8sQ0FBQywyRkFBdUI7QUFDbEQsc0JBQXNCLG1CQUFPLENBQUMsaUdBQTBCO0FBQ3hELG9CQUFvQixtQkFBTyxDQUFDLDZGQUF3QjtBQUNwRCxxQkFBcUIsbUJBQU8sQ0FBQyw4RkFBb0I7QUFDakQsb0JBQW9CLG1CQUFPLENBQUMsa0dBQXNCO0FBQ2xELG1CQUFtQixtQkFBTyxDQUFDLGdHQUFxQjtBQUNoRCxzQkFBc0IsbUJBQU8sQ0FBQyxzR0FBd0I7QUFDdEQscUJBQXFCLG1CQUFPLENBQUMsa0ZBQWM7QUFDM0MsbUJBQW1CLG1CQUFPLENBQUMsOEVBQVk7QUFDdkMsb0JBQW9CLG1CQUFPLENBQUMsZ0ZBQWE7QUFDekMsc0JBQXNCLG1CQUFPLENBQUMsb0ZBQWU7QUFDN0Msa0JBQWtCLG1CQUFPLENBQUMsNEVBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04scUJBQXFCLDBCQUEwQixHQUFHLGdCQUFnQjtBQUNsRSxNQUFNO0FBQ047QUFDQSw0QkFBNEIsK0JBQStCO0FBQzNELE1BQU07QUFDTiwyREFBMkQsa0JBQWtCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0NBQXdDO0FBQ2pFLEtBQUs7QUFDTDtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0NBQXdDO0FBQ2pFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsS0FBSztBQUNoRCxvQkFBb0IsS0FBSztBQUN6QixJQUFJLGdEQUFnRCxLQUFLO0FBQ3pELHNCQUFzQixLQUFLO0FBQzNCLElBQUk7QUFDSiw0REFBNEQsS0FBSztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU0sQ0FXTDtBQUNEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEtSYW1hY2hhXFxEb2N1bWVudHNcXFN1c3RBSW5leCBHSXQgQ29kZVxcbm9kZV9tb2R1bGVzXFxAZ2Vua2l0LWFpXFxhaVxcbGliXFxnZW5lcmF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgZ2VuZXJhdGVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZ2VuZXJhdGVfZXhwb3J0cywge1xuICBHZW5lcmF0ZVJlc3BvbnNlOiAoKSA9PiBpbXBvcnRfcmVzcG9uc2UuR2VuZXJhdGVSZXNwb25zZSxcbiAgR2VuZXJhdGVSZXNwb25zZUNodW5rOiAoKSA9PiBpbXBvcnRfY2h1bmsuR2VuZXJhdGVSZXNwb25zZUNodW5rLFxuICBHZW5lcmF0aW9uQmxvY2tlZEVycm9yOiAoKSA9PiBHZW5lcmF0aW9uQmxvY2tlZEVycm9yLFxuICBHZW5lcmF0aW9uUmVzcG9uc2VFcnJvcjogKCkgPT4gR2VuZXJhdGlvblJlc3BvbnNlRXJyb3IsXG4gIGdlbmVyYXRlOiAoKSA9PiBnZW5lcmF0ZSxcbiAgZ2VuZXJhdGVPcGVyYXRpb246ICgpID0+IGdlbmVyYXRlT3BlcmF0aW9uLFxuICBnZW5lcmF0ZVN0cmVhbTogKCkgPT4gZ2VuZXJhdGVTdHJlYW0sXG4gIHRhZ0FzUHJlYW1ibGU6ICgpID0+IHRhZ0FzUHJlYW1ibGUsXG4gIHRvR2VuZXJhdGVBY3Rpb25PcHRpb25zOiAoKSA9PiB0b0dlbmVyYXRlQWN0aW9uT3B0aW9ucyxcbiAgdG9HZW5lcmF0ZVJlcXVlc3Q6ICgpID0+IHRvR2VuZXJhdGVSZXF1ZXN0XG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKGdlbmVyYXRlX2V4cG9ydHMpO1xudmFyIGltcG9ydF9jb3JlID0gcmVxdWlyZShcIkBnZW5raXQtYWkvY29yZVwiKTtcbnZhciBpbXBvcnRfYXN5bmMgPSByZXF1aXJlKFwiQGdlbmtpdC1haS9jb3JlL2FzeW5jXCIpO1xudmFyIGltcG9ydF9yZWdpc3RyeSA9IHJlcXVpcmUoXCJAZ2Vua2l0LWFpL2NvcmUvcmVnaXN0cnlcIik7XG52YXIgaW1wb3J0X3NjaGVtYSA9IHJlcXVpcmUoXCJAZ2Vua2l0LWFpL2NvcmUvc2NoZW1hXCIpO1xudmFyIGltcG9ydF9mb3JtYXRzID0gcmVxdWlyZShcIi4vZm9ybWF0cy9pbmRleC5qc1wiKTtcbnZhciBpbXBvcnRfYWN0aW9uID0gcmVxdWlyZShcIi4vZ2VuZXJhdGUvYWN0aW9uLmpzXCIpO1xudmFyIGltcG9ydF9jaHVuayA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlL2NodW5rLmpzXCIpO1xudmFyIGltcG9ydF9yZXNwb25zZSA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlL3Jlc3BvbnNlLmpzXCIpO1xudmFyIGltcG9ydF9tZXNzYWdlID0gcmVxdWlyZShcIi4vbWVzc2FnZS5qc1wiKTtcbnZhciBpbXBvcnRfbW9kZWwgPSByZXF1aXJlKFwiLi9tb2RlbC5qc1wiKTtcbnZhciBpbXBvcnRfcHJvbXB0ID0gcmVxdWlyZShcIi4vcHJvbXB0LmpzXCIpO1xudmFyIGltcG9ydF9yZXNvdXJjZSA9IHJlcXVpcmUoXCIuL3Jlc291cmNlLmpzXCIpO1xudmFyIGltcG9ydF90b29sID0gcmVxdWlyZShcIi4vdG9vbC5qc1wiKTtcbmFzeW5jIGZ1bmN0aW9uIHRvR2VuZXJhdGVSZXF1ZXN0KHJlZ2lzdHJ5LCBvcHRpb25zKSB7XG4gIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gIGlmIChvcHRpb25zLnN5c3RlbSkge1xuICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgIGNvbnRlbnQ6IGltcG9ydF9tZXNzYWdlLk1lc3NhZ2UucGFyc2VDb250ZW50KG9wdGlvbnMuc3lzdGVtKVxuICAgIH0pO1xuICB9XG4gIGlmIChvcHRpb25zLm1lc3NhZ2VzKSB7XG4gICAgbWVzc2FnZXMucHVzaCguLi5vcHRpb25zLm1lc3NhZ2VzLm1hcCgobSkgPT4gaW1wb3J0X21lc3NhZ2UuTWVzc2FnZS5wYXJzZURhdGEobSkpKTtcbiAgfVxuICBpZiAob3B0aW9ucy5wcm9tcHQpIHtcbiAgICBtZXNzYWdlcy5wdXNoKHtcbiAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgY29udGVudDogaW1wb3J0X21lc3NhZ2UuTWVzc2FnZS5wYXJzZUNvbnRlbnQob3B0aW9ucy5wcm9tcHQpXG4gICAgfSk7XG4gIH1cbiAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBpbXBvcnRfY29yZS5HZW5raXRFcnJvcih7XG4gICAgICBzdGF0dXM6IFwiSU5WQUxJRF9BUkdVTUVOVFwiLFxuICAgICAgbWVzc2FnZTogXCJhdCBsZWFzdCBvbmUgbWVzc2FnZSBpcyByZXF1aXJlZCBpbiBnZW5lcmF0ZSByZXF1ZXN0XCJcbiAgICB9KTtcbiAgfVxuICBpZiAob3B0aW9ucy5yZXN1bWUgJiYgIShtZXNzYWdlcy5hdCgtMSk/LnJvbGUgPT09IFwibW9kZWxcIiAmJiBtZXNzYWdlcy5hdCgtMSk/LmNvbnRlbnQuZmluZCgocCkgPT4gISFwLnRvb2xSZXF1ZXN0KSkpIHtcbiAgICB0aHJvdyBuZXcgaW1wb3J0X2NvcmUuR2Vua2l0RXJyb3Ioe1xuICAgICAgc3RhdHVzOiBcIkZBSUxFRF9QUkVDT05ESVRJT05cIixcbiAgICAgIG1lc3NhZ2U6IGBMYXN0IG1lc3NhZ2UgbXVzdCBiZSBhICdtb2RlbCcgcm9sZSB3aXRoIGF0IGxlYXN0IG9uZSB0b29sIHJlcXVlc3QgdG8gJ3Jlc3VtZScgZ2VuZXJhdGlvbi5gLFxuICAgICAgZGV0YWlsOiBtZXNzYWdlcy5hdCgtMSlcbiAgICB9KTtcbiAgfVxuICBsZXQgdG9vbHM7XG4gIGlmIChvcHRpb25zLnRvb2xzKSB7XG4gICAgdG9vbHMgPSBhd2FpdCAoMCwgaW1wb3J0X3Rvb2wucmVzb2x2ZVRvb2xzKShyZWdpc3RyeSwgb3B0aW9ucy50b29scyk7XG4gIH1cbiAgY29uc3QgcmVzb2x2ZWRTY2hlbWEgPSAoMCwgaW1wb3J0X3NjaGVtYS50b0pzb25TY2hlbWEpKHtcbiAgICBzY2hlbWE6IG9wdGlvbnMub3V0cHV0Py5zY2hlbWEsXG4gICAganNvblNjaGVtYTogb3B0aW9ucy5vdXRwdXQ/Lmpzb25TY2hlbWFcbiAgfSk7XG4gIGNvbnN0IHJlc29sdmVkRm9ybWF0ID0gYXdhaXQgKDAsIGltcG9ydF9mb3JtYXRzLnJlc29sdmVGb3JtYXQpKHJlZ2lzdHJ5LCBvcHRpb25zLm91dHB1dCk7XG4gIGNvbnN0IGluc3RydWN0aW9ucyA9ICgwLCBpbXBvcnRfZm9ybWF0cy5yZXNvbHZlSW5zdHJ1Y3Rpb25zKShcbiAgICByZXNvbHZlZEZvcm1hdCxcbiAgICByZXNvbHZlZFNjaGVtYSxcbiAgICBvcHRpb25zPy5vdXRwdXQ/Lmluc3RydWN0aW9uc1xuICApO1xuICBjb25zdCBvdXQgPSB7XG4gICAgbWVzc2FnZXM6ICgwLCBpbXBvcnRfYWN0aW9uLnNob3VsZEluamVjdEZvcm1hdEluc3RydWN0aW9ucykoXG4gICAgICByZXNvbHZlZEZvcm1hdD8uY29uZmlnLFxuICAgICAgb3B0aW9ucy5vdXRwdXRcbiAgICApID8gKDAsIGltcG9ydF9mb3JtYXRzLmluamVjdEluc3RydWN0aW9ucykobWVzc2FnZXMsIGluc3RydWN0aW9ucykgOiBtZXNzYWdlcyxcbiAgICBjb25maWc6IG9wdGlvbnMuY29uZmlnLFxuICAgIGRvY3M6IG9wdGlvbnMuZG9jcyxcbiAgICB0b29sczogdG9vbHM/Lm1hcChpbXBvcnRfdG9vbC50b1Rvb2xEZWZpbml0aW9uKSB8fCBbXSxcbiAgICBvdXRwdXQ6IHtcbiAgICAgIC4uLnJlc29sdmVkRm9ybWF0Py5jb25maWcgfHwge30sXG4gICAgICAuLi5vcHRpb25zLm91dHB1dCxcbiAgICAgIHNjaGVtYTogcmVzb2x2ZWRTY2hlbWFcbiAgICB9XG4gIH07XG4gIGlmICghb3V0Py5vdXRwdXQ/LnNjaGVtYSkgZGVsZXRlIG91dD8ub3V0cHV0Py5zY2hlbWE7XG4gIHJldHVybiBvdXQ7XG59XG5jbGFzcyBHZW5lcmF0aW9uUmVzcG9uc2VFcnJvciBleHRlbmRzIGltcG9ydF9jb3JlLkdlbmtpdEVycm9yIHtcbiAgZGV0YWlsO1xuICBjb25zdHJ1Y3RvcihyZXNwb25zZSwgbWVzc2FnZSwgc3RhdHVzLCBkZXRhaWwpIHtcbiAgICBzdXBlcih7XG4gICAgICBzdGF0dXM6IHN0YXR1cyB8fCBcIkZBSUxFRF9QUkVDT05ESVRJT05cIixcbiAgICAgIG1lc3NhZ2VcbiAgICB9KTtcbiAgICB0aGlzLmRldGFpbCA9IHsgcmVzcG9uc2UsIC4uLmRldGFpbCB9O1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiB0b29sc1RvQWN0aW9uUmVmcyhyZWdpc3RyeSwgdG9vbE9wdCkge1xuICBpZiAoIXRvb2xPcHQpIHJldHVybjtcbiAgY29uc3QgdG9vbHMgPSBbXTtcbiAgZm9yIChjb25zdCB0IG9mIHRvb2xPcHQpIHtcbiAgICBpZiAodHlwZW9mIHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRvb2xzLnB1c2goYXdhaXQgcmVzb2x2ZUZ1bGxUb29sTmFtZShyZWdpc3RyeSwgdCkpO1xuICAgIH0gZWxzZSBpZiAoKDAsIGltcG9ydF9jb3JlLmlzQWN0aW9uKSh0KSB8fCAoMCwgaW1wb3J0X3Rvb2wuaXNEeW5hbWljVG9vbCkodCkpIHtcbiAgICAgIHRvb2xzLnB1c2goYC8ke3QuX19hY3Rpb24ubWV0YWRhdGE/LnR5cGV9LyR7dC5fX2FjdGlvbi5uYW1lfWApO1xuICAgIH0gZWxzZSBpZiAoKDAsIGltcG9ydF9wcm9tcHQuaXNFeGVjdXRhYmxlUHJvbXB0KSh0KSkge1xuICAgICAgY29uc3QgcHJvbXB0VG9vbEFjdGlvbiA9IGF3YWl0IHQuYXNUb29sKCk7XG4gICAgICB0b29scy5wdXNoKGAvcHJvbXB0LyR7cHJvbXB0VG9vbEFjdGlvbi5fX2FjdGlvbi5uYW1lfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBkZXRlcm1pbmUgdHlwZSBvZiB0b29sOiAke0pTT04uc3RyaW5naWZ5KHQpfWApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9vbHM7XG59XG5mdW5jdGlvbiBtZXNzYWdlc0Zyb21PcHRpb25zKG9wdGlvbnMpIHtcbiAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgaWYgKG9wdGlvbnMuc3lzdGVtKSB7XG4gICAgbWVzc2FnZXMucHVzaCh7XG4gICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgICAgY29udGVudDogaW1wb3J0X21lc3NhZ2UuTWVzc2FnZS5wYXJzZUNvbnRlbnQob3B0aW9ucy5zeXN0ZW0pXG4gICAgfSk7XG4gIH1cbiAgaWYgKG9wdGlvbnMubWVzc2FnZXMpIHtcbiAgICBtZXNzYWdlcy5wdXNoKC4uLm9wdGlvbnMubWVzc2FnZXMpO1xuICB9XG4gIGlmIChvcHRpb25zLnByb21wdCkge1xuICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICBjb250ZW50OiBpbXBvcnRfbWVzc2FnZS5NZXNzYWdlLnBhcnNlQ29udGVudChvcHRpb25zLnByb21wdClcbiAgICB9KTtcbiAgfVxuICBpZiAobWVzc2FnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IGltcG9ydF9jb3JlLkdlbmtpdEVycm9yKHtcbiAgICAgIHN0YXR1czogXCJJTlZBTElEX0FSR1VNRU5UXCIsXG4gICAgICBtZXNzYWdlOiBcImF0IGxlYXN0IG9uZSBtZXNzYWdlIGlzIHJlcXVpcmVkIGluIGdlbmVyYXRlIHJlcXVlc3RcIlxuICAgIH0pO1xuICB9XG4gIHJldHVybiBtZXNzYWdlcztcbn1cbmNsYXNzIEdlbmVyYXRpb25CbG9ja2VkRXJyb3IgZXh0ZW5kcyBHZW5lcmF0aW9uUmVzcG9uc2VFcnJvciB7XG59XG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZShyZWdpc3RyeSwgb3B0aW9ucykge1xuICBjb25zdCByZXNvbHZlZE9wdGlvbnMgPSB7XG4gICAgLi4uYXdhaXQgUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMpXG4gIH07XG4gIGNvbnN0IHJlc29sdmVkRm9ybWF0ID0gYXdhaXQgKDAsIGltcG9ydF9mb3JtYXRzLnJlc29sdmVGb3JtYXQpKHJlZ2lzdHJ5LCByZXNvbHZlZE9wdGlvbnMub3V0cHV0KTtcbiAgcmVnaXN0cnkgPSBtYXliZVJlZ2lzdGVyRHluYW1pY1Rvb2xzKHJlZ2lzdHJ5LCByZXNvbHZlZE9wdGlvbnMpO1xuICByZWdpc3RyeSA9IG1heWJlUmVnaXN0ZXJEeW5hbWljUmVzb3VyY2VzKHJlZ2lzdHJ5LCByZXNvbHZlZE9wdGlvbnMpO1xuICBjb25zdCBwYXJhbXMgPSBhd2FpdCB0b0dlbmVyYXRlQWN0aW9uT3B0aW9ucyhyZWdpc3RyeSwgcmVzb2x2ZWRPcHRpb25zKTtcbiAgY29uc3QgdG9vbHMgPSBhd2FpdCB0b29sc1RvQWN0aW9uUmVmcyhyZWdpc3RyeSwgcmVzb2x2ZWRPcHRpb25zLnRvb2xzKTtcbiAgY29uc3Qgc3RyZWFtaW5nQ2FsbGJhY2sgPSBzdHJpcE5vb3AoXG4gICAgcmVzb2x2ZWRPcHRpb25zLm9uQ2h1bmsgPz8gcmVzb2x2ZWRPcHRpb25zLnN0cmVhbWluZ0NhbGxiYWNrXG4gICk7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgKDAsIGltcG9ydF9jb3JlLnJ1bldpdGhDb250ZXh0KShcbiAgICByZXNvbHZlZE9wdGlvbnMuY29udGV4dCxcbiAgICAoKSA9PiAoMCwgaW1wb3J0X2FjdGlvbi5nZW5lcmF0ZUhlbHBlcikocmVnaXN0cnksIHtcbiAgICAgIHJhd1JlcXVlc3Q6IHBhcmFtcyxcbiAgICAgIG1pZGRsZXdhcmU6IHJlc29sdmVkT3B0aW9ucy51c2UsXG4gICAgICBhYm9ydFNpZ25hbDogcmVzb2x2ZWRPcHRpb25zLmFib3J0U2lnbmFsLFxuICAgICAgc3RyZWFtaW5nQ2FsbGJhY2tcbiAgICB9KVxuICApO1xuICBjb25zdCByZXF1ZXN0ID0gYXdhaXQgdG9HZW5lcmF0ZVJlcXVlc3QocmVnaXN0cnksIHtcbiAgICAuLi5yZXNvbHZlZE9wdGlvbnMsXG4gICAgdG9vbHNcbiAgfSk7XG4gIHJldHVybiBuZXcgaW1wb3J0X3Jlc3BvbnNlLkdlbmVyYXRlUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgICByZXF1ZXN0OiByZXNwb25zZS5yZXF1ZXN0ID8/IHJlcXVlc3QsXG4gICAgcGFyc2VyOiByZXNvbHZlZEZvcm1hdD8uaGFuZGxlcihyZXF1ZXN0Lm91dHB1dD8uc2NoZW1hKS5wYXJzZU1lc3NhZ2VcbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZU9wZXJhdGlvbihyZWdpc3RyeSwgb3B0aW9ucykge1xuICAoMCwgaW1wb3J0X2NvcmUuYXNzZXJ0VW5zdGFibGUpKHJlZ2lzdHJ5LCBcImJldGFcIiwgXCJnZW5lcmF0ZU9wZXJhdGlvbiBpcyBhIGJldGEgZmVhdHVyZS5cIik7XG4gIG9wdGlvbnMgPSBhd2FpdCBvcHRpb25zO1xuICBjb25zdCByZXNvbHZlZE1vZGVsID0gYXdhaXQgKDAsIGltcG9ydF9tb2RlbC5yZXNvbHZlTW9kZWwpKHJlZ2lzdHJ5LCBvcHRpb25zLm1vZGVsKTtcbiAgaWYgKCFyZXNvbHZlZE1vZGVsLm1vZGVsQWN0aW9uLl9fYWN0aW9uLm1ldGFkYXRhPy5tb2RlbC5zdXBwb3J0cz8ubG9uZ1J1bm5pbmcpIHtcbiAgICB0aHJvdyBuZXcgaW1wb3J0X2NvcmUuR2Vua2l0RXJyb3Ioe1xuICAgICAgc3RhdHVzOiBcIklOVkFMSURfQVJHVU1FTlRcIixcbiAgICAgIG1lc3NhZ2U6IGBNb2RlbCAnJHtyZXNvbHZlZE1vZGVsLm1vZGVsQWN0aW9uLl9fYWN0aW9uLm5hbWV9JyBkb2VzIG5vdCBzdXBwb3J0IGxvbmcgcnVubmluZyBvcGVyYXRpb25zLmBcbiAgICB9KTtcbiAgfVxuICBjb25zdCB7IG9wZXJhdGlvbiB9ID0gYXdhaXQgZ2VuZXJhdGUocmVnaXN0cnksIG9wdGlvbnMpO1xuICBpZiAoIW9wZXJhdGlvbikge1xuICAgIHRocm93IG5ldyBpbXBvcnRfY29yZS5HZW5raXRFcnJvcih7XG4gICAgICBzdGF0dXM6IFwiRkFJTEVEX1BSRUNPTkRJVElPTlwiLFxuICAgICAgbWVzc2FnZTogYE1vZGVsICcke3Jlc29sdmVkTW9kZWwubW9kZWxBY3Rpb24uX19hY3Rpb24ubmFtZX0nIGRpZCBub3QgcmV0dXJuIGFuIG9wZXJhdGlvbi5gXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG9wZXJhdGlvbjtcbn1cbmZ1bmN0aW9uIG1heWJlUmVnaXN0ZXJEeW5hbWljVG9vbHMocmVnaXN0cnksIG9wdGlvbnMpIHtcbiAgbGV0IGhhc0R5bmFtaWNUb29scyA9IGZhbHNlO1xuICBvcHRpb25zPy50b29scz8uZm9yRWFjaCgodCkgPT4ge1xuICAgIGlmICgoMCwgaW1wb3J0X3Rvb2wuaXNEeW5hbWljVG9vbCkodCkpIHtcbiAgICAgIGlmICghaGFzRHluYW1pY1Rvb2xzKSB7XG4gICAgICAgIGhhc0R5bmFtaWNUb29scyA9IHRydWU7XG4gICAgICAgIHJlZ2lzdHJ5ID0gaW1wb3J0X3JlZ2lzdHJ5LlJlZ2lzdHJ5LndpdGhQYXJlbnQocmVnaXN0cnkpO1xuICAgICAgfVxuICAgICAgcmVnaXN0cnkucmVnaXN0ZXJBY3Rpb24oXCJ0b29sXCIsIHQpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZWdpc3RyeTtcbn1cbmZ1bmN0aW9uIG1heWJlUmVnaXN0ZXJEeW5hbWljUmVzb3VyY2VzKHJlZ2lzdHJ5LCBvcHRpb25zKSB7XG4gIGxldCBoYXNEeW5hbWljUmVzb3VyY2VzID0gZmFsc2U7XG4gIG9wdGlvbnM/LnJlc291cmNlcz8uZm9yRWFjaCgocikgPT4ge1xuICAgIGlmICgoMCwgaW1wb3J0X3Jlc291cmNlLmlzRHluYW1pY1Jlc291cmNlQWN0aW9uKShyKSkge1xuICAgICAgaWYgKCFoYXNEeW5hbWljUmVzb3VyY2VzKSB7XG4gICAgICAgIGhhc0R5bmFtaWNSZXNvdXJjZXMgPSB0cnVlO1xuICAgICAgICByZWdpc3RyeSA9IGltcG9ydF9yZWdpc3RyeS5SZWdpc3RyeS53aXRoUGFyZW50KHJlZ2lzdHJ5KTtcbiAgICAgIH1cbiAgICAgIHJlZ2lzdHJ5LnJlZ2lzdGVyQWN0aW9uKFwicmVzb3VyY2VcIiwgcik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlZ2lzdHJ5O1xufVxuYXN5bmMgZnVuY3Rpb24gdG9HZW5lcmF0ZUFjdGlvbk9wdGlvbnMocmVnaXN0cnksIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzb2x2ZWRNb2RlbCA9IGF3YWl0ICgwLCBpbXBvcnRfbW9kZWwucmVzb2x2ZU1vZGVsKShyZWdpc3RyeSwgb3B0aW9ucy5tb2RlbCk7XG4gIGNvbnN0IHRvb2xzID0gYXdhaXQgdG9vbHNUb0FjdGlvblJlZnMocmVnaXN0cnksIG9wdGlvbnMudG9vbHMpO1xuICBjb25zdCBtZXNzYWdlcyA9IG1lc3NhZ2VzRnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gIGNvbnN0IHJlc29sdmVkU2NoZW1hID0gKDAsIGltcG9ydF9zY2hlbWEudG9Kc29uU2NoZW1hKSh7XG4gICAgc2NoZW1hOiBvcHRpb25zLm91dHB1dD8uc2NoZW1hLFxuICAgIGpzb25TY2hlbWE6IG9wdGlvbnMub3V0cHV0Py5qc29uU2NoZW1hXG4gIH0pO1xuICBpZiAoKG9wdGlvbnMub3V0cHV0Py5zY2hlbWEgfHwgb3B0aW9ucy5vdXRwdXQ/Lmpzb25TY2hlbWEpICYmICFvcHRpb25zLm91dHB1dD8uZm9ybWF0KSB7XG4gICAgb3B0aW9ucy5vdXRwdXQuZm9ybWF0ID0gXCJqc29uXCI7XG4gIH1cbiAgY29uc3QgcGFyYW1zID0ge1xuICAgIG1vZGVsOiByZXNvbHZlZE1vZGVsLm1vZGVsQWN0aW9uLl9fYWN0aW9uLm5hbWUsXG4gICAgZG9jczogb3B0aW9ucy5kb2NzLFxuICAgIG1lc3NhZ2VzLFxuICAgIHRvb2xzLFxuICAgIHRvb2xDaG9pY2U6IG9wdGlvbnMudG9vbENob2ljZSxcbiAgICBjb25maWc6IHtcbiAgICAgIHZlcnNpb246IHJlc29sdmVkTW9kZWwudmVyc2lvbixcbiAgICAgIC4uLnN0cmlwVW5kZWZpbmVkT3B0aW9ucyhyZXNvbHZlZE1vZGVsLmNvbmZpZyksXG4gICAgICAuLi5zdHJpcFVuZGVmaW5lZE9wdGlvbnMob3B0aW9ucy5jb25maWcpXG4gICAgfSxcbiAgICBvdXRwdXQ6IG9wdGlvbnMub3V0cHV0ICYmIHtcbiAgICAgIC4uLm9wdGlvbnMub3V0cHV0LFxuICAgICAgZm9ybWF0OiBvcHRpb25zLm91dHB1dC5mb3JtYXQsXG4gICAgICBqc29uU2NoZW1hOiByZXNvbHZlZFNjaGVtYVxuICAgIH0sXG4gICAgLy8gY29lcmNlIHJlcGx5IGFuZCByZXN0YXJ0IGludG8gYXJyYXlzIGZvciB0aGUgYWN0aW9uIHNjaGVtYVxuICAgIHJlc3VtZTogb3B0aW9ucy5yZXN1bWUgJiYge1xuICAgICAgcmVzcG9uZDogW29wdGlvbnMucmVzdW1lLnJlc3BvbmQgfHwgW11dLmZsYXQoKSxcbiAgICAgIHJlc3RhcnQ6IFtvcHRpb25zLnJlc3VtZS5yZXN0YXJ0IHx8IFtdXS5mbGF0KCksXG4gICAgICBtZXRhZGF0YTogb3B0aW9ucy5yZXN1bWUubWV0YWRhdGFcbiAgICB9LFxuICAgIHJldHVyblRvb2xSZXF1ZXN0czogb3B0aW9ucy5yZXR1cm5Ub29sUmVxdWVzdHMsXG4gICAgbWF4VHVybnM6IG9wdGlvbnMubWF4VHVybnMsXG4gICAgc3RlcE5hbWU6IG9wdGlvbnMuc3RlcE5hbWVcbiAgfTtcbiAgaWYgKE9iamVjdC5rZXlzKHBhcmFtcy5jb25maWcpLmxlbmd0aCA9PT0gMCAmJiAhb3B0aW9ucy5jb25maWcpIHtcbiAgICBkZWxldGUgcGFyYW1zLmNvbmZpZztcbiAgfVxuICByZXR1cm4gcGFyYW1zO1xufVxuZnVuY3Rpb24gc3RyaXBOb29wKGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayA9PT0gaW1wb3J0X2NvcmUuc2VudGluZWxOb29wU3RyZWFtaW5nQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBjYWxsYmFjaztcbn1cbmZ1bmN0aW9uIHN0cmlwVW5kZWZpbmVkT3B0aW9ucyhpbnB1dCkge1xuICBpZiAoIWlucHV0KSByZXR1cm4gaW5wdXQ7XG4gIGNvbnN0IGNvcHkgPSB7IC4uLmlucHV0IH07XG4gIE9iamVjdC5rZXlzKGlucHV0KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAoY29weVtrZXldID09PSB2b2lkIDApIHtcbiAgICAgIGRlbGV0ZSBjb3B5W2tleV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNvcHk7XG59XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlRnVsbFRvb2xOYW1lKHJlZ2lzdHJ5LCBuYW1lKSB7XG4gIGlmIChhd2FpdCByZWdpc3RyeS5sb29rdXBBY3Rpb24oYC90b29sLyR7bmFtZX1gKSkge1xuICAgIHJldHVybiBgL3Rvb2wvJHtuYW1lfWA7XG4gIH0gZWxzZSBpZiAoYXdhaXQgcmVnaXN0cnkubG9va3VwQWN0aW9uKGAvcHJvbXB0LyR7bmFtZX1gKSkge1xuICAgIHJldHVybiBgL3Byb21wdC8ke25hbWV9YDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBkZXRlcm1pbmUgdHlwZSBvZiBvZiB0b29sOiAke25hbWV9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdlbmVyYXRlU3RyZWFtKHJlZ2lzdHJ5LCBvcHRpb25zKSB7XG4gIGNvbnN0IGNoYW5uZWwgPSBuZXcgaW1wb3J0X2FzeW5jLkNoYW5uZWwoKTtcbiAgY29uc3QgZ2VuZXJhdGVkID0gUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMpLnRoZW4oXG4gICAgKHJlc29sdmVkT3B0aW9ucykgPT4gZ2VuZXJhdGUocmVnaXN0cnksIHtcbiAgICAgIC4uLnJlc29sdmVkT3B0aW9ucyxcbiAgICAgIG9uQ2h1bms6IChjaHVuaykgPT4gY2hhbm5lbC5zZW5kKGNodW5rKVxuICAgIH0pXG4gICk7XG4gIGdlbmVyYXRlZC50aGVuKFxuICAgICgpID0+IGNoYW5uZWwuY2xvc2UoKSxcbiAgICAoZXJyKSA9PiBjaGFubmVsLmVycm9yKGVycilcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICByZXNwb25zZTogZ2VuZXJhdGVkLFxuICAgIHN0cmVhbTogY2hhbm5lbFxuICB9O1xufVxuZnVuY3Rpb24gdGFnQXNQcmVhbWJsZShtc2dzKSB7XG4gIGlmICghbXNncykge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIG1zZ3MubWFwKChtKSA9PiAoe1xuICAgIC4uLm0sXG4gICAgbWV0YWRhdGE6IHtcbiAgICAgIC4uLm0ubWV0YWRhdGEsXG4gICAgICBwcmVhbWJsZTogdHJ1ZVxuICAgIH1cbiAgfSkpO1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdlbmVyYXRlUmVzcG9uc2UsXG4gIEdlbmVyYXRlUmVzcG9uc2VDaHVuayxcbiAgR2VuZXJhdGlvbkJsb2NrZWRFcnJvcixcbiAgR2VuZXJhdGlvblJlc3BvbnNlRXJyb3IsXG4gIGdlbmVyYXRlLFxuICBnZW5lcmF0ZU9wZXJhdGlvbixcbiAgZ2VuZXJhdGVTdHJlYW0sXG4gIHRhZ0FzUHJlYW1ibGUsXG4gIHRvR2VuZXJhdGVBY3Rpb25PcHRpb25zLFxuICB0b0dlbmVyYXRlUmVxdWVzdFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmF0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/generate.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/generate/action.js":
/*!***********************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/generate/action.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar action_exports = {};\n__export(action_exports, {\n  defineGenerateAction: () => defineGenerateAction,\n  generateHelper: () => generateHelper,\n  inferRoleFromParts: () => inferRoleFromParts,\n  shouldInjectFormatInstructions: () => shouldInjectFormatInstructions\n});\nmodule.exports = __toCommonJS(action_exports);\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nvar import_logging = __webpack_require__(/*! @genkit-ai/core/logging */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/logging.js\");\nvar import_tracing = __webpack_require__(/*! @genkit-ai/core/tracing */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing.js\");\nvar import_formats = __webpack_require__(/*! ../formats/index.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/formats/index.js\");\nvar import_generate = __webpack_require__(/*! ../generate.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/generate.js\");\nvar import_chunk = __webpack_require__(/*! ../generate/chunk.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/generate/chunk.js\");\nvar import_model = __webpack_require__(/*! ../model.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/model.js\");\nvar import_resource = __webpack_require__(/*! ../resource.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/resource.js\");\nvar import_tool = __webpack_require__(/*! ../tool.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/tool.js\");\nvar import_resolve_tool_requests = __webpack_require__(/*! ./resolve-tool-requests.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/generate/resolve-tool-requests.js\");\nfunction defineGenerateAction(registry) {\n  return (0, import_core.defineAction)(\n    registry,\n    {\n      actionType: \"util\",\n      name: \"generate\",\n      inputSchema: import_model.GenerateActionOptionsSchema,\n      outputSchema: import_model.GenerateResponseSchema,\n      streamSchema: import_model.GenerateResponseChunkSchema\n    },\n    async (request, { streamingRequested, sendChunk }) => {\n      const generateFn = (sendChunk2) => generate(registry, {\n        rawRequest: request,\n        currentTurn: 0,\n        messageIndex: 0,\n        // Generate util action does not support middleware. Maybe when we add named/registered middleware....\n        middleware: [],\n        streamingCallback: sendChunk2\n      });\n      return streamingRequested ? generateFn(\n        (c) => sendChunk(c.toJSON ? c.toJSON() : c)\n      ) : generateFn();\n    }\n  );\n}\nasync function generateHelper(registry, options) {\n  const currentTurn = options.currentTurn ?? 0;\n  const messageIndex = options.messageIndex ?? 0;\n  return await (0, import_tracing.runInNewSpan)(\n    registry,\n    {\n      metadata: {\n        name: options.rawRequest.stepName || \"generate\"\n      },\n      labels: {\n        [import_tracing.SPAN_TYPE_ATTR]: \"util\"\n      }\n    },\n    async (metadata) => {\n      metadata.name = options.rawRequest.stepName || \"generate\";\n      metadata.input = options.rawRequest;\n      const output = await generate(registry, {\n        rawRequest: options.rawRequest,\n        middleware: options.middleware,\n        currentTurn,\n        messageIndex,\n        abortSignal: options.abortSignal,\n        streamingCallback: options.streamingCallback\n      });\n      metadata.output = JSON.stringify(output);\n      return output;\n    }\n  );\n}\nasync function resolveParameters(registry, request) {\n  const [model, tools, format] = await Promise.all([\n    (0, import_model.resolveModel)(registry, request.model, { warnDeprecated: true }).then(\n      (r) => r.modelAction\n    ),\n    (0, import_tool.resolveTools)(registry, request.tools),\n    (0, import_formats.resolveFormat)(registry, request.output)\n  ]);\n  return { model, tools, format };\n}\nfunction applyFormat(rawRequest, resolvedFormat) {\n  const outRequest = { ...rawRequest };\n  if (rawRequest.output?.jsonSchema && !rawRequest.output?.format) {\n    outRequest.output = { ...rawRequest.output, format: \"json\" };\n  }\n  const instructions = (0, import_formats.resolveInstructions)(\n    resolvedFormat,\n    outRequest.output?.jsonSchema,\n    outRequest?.output?.instructions\n  );\n  if (resolvedFormat) {\n    if (shouldInjectFormatInstructions(resolvedFormat.config, rawRequest?.output)) {\n      outRequest.messages = (0, import_formats.injectInstructions)(\n        outRequest.messages,\n        instructions\n      );\n    }\n    outRequest.output = {\n      // use output config from the format\n      ...resolvedFormat.config,\n      // if anything is set explicitly, use that\n      ...outRequest.output\n    };\n  }\n  return outRequest;\n}\nfunction shouldInjectFormatInstructions(formatConfig, rawRequestConfig) {\n  return formatConfig?.defaultInstructions !== false || rawRequestConfig?.instructions;\n}\nfunction applyTransferPreamble(rawRequest, transferPreamble) {\n  if (!transferPreamble) {\n    return rawRequest;\n  }\n  return (0, import_core.stripUndefinedProps)({\n    ...rawRequest,\n    messages: [\n      ...(0, import_generate.tagAsPreamble)(transferPreamble.messages),\n      ...rawRequest.messages.filter((m) => !m.metadata?.preamble)\n    ],\n    toolChoice: transferPreamble.toolChoice || rawRequest.toolChoice,\n    tools: transferPreamble.tools || rawRequest.tools,\n    config: transferPreamble.config || rawRequest.config\n  });\n}\nasync function generate(registry, {\n  rawRequest,\n  middleware,\n  currentTurn,\n  messageIndex,\n  abortSignal,\n  streamingCallback\n}) {\n  const { model, tools, format } = await resolveParameters(\n    registry,\n    rawRequest\n  );\n  rawRequest = applyFormat(rawRequest, format);\n  rawRequest = await applyResources(registry, rawRequest);\n  await (0, import_resolve_tool_requests.assertValidToolNames)(tools);\n  const {\n    revisedRequest,\n    interruptedResponse,\n    toolMessage: resumedToolMessage\n  } = await (0, import_resolve_tool_requests.resolveResumeOption)(registry, rawRequest);\n  if (interruptedResponse) {\n    throw new import_core.GenkitError({\n      status: \"FAILED_PRECONDITION\",\n      message: \"One or more tools triggered an interrupt during a restarted execution.\",\n      detail: { message: interruptedResponse.message }\n    });\n  }\n  rawRequest = revisedRequest;\n  const request = await actionToGenerateRequest(\n    rawRequest,\n    tools,\n    format,\n    model\n  );\n  const previousChunks = [];\n  let chunkRole = \"model\";\n  const makeChunk = (role, chunk) => {\n    if (role !== chunkRole && previousChunks.length) messageIndex++;\n    chunkRole = role;\n    const prevToSend = [...previousChunks];\n    previousChunks.push(chunk);\n    return new import_chunk.GenerateResponseChunk(chunk, {\n      index: messageIndex,\n      role,\n      previousChunks: prevToSend,\n      parser: format?.handler(request.output?.schema).parseChunk\n    });\n  };\n  if (resumedToolMessage && streamingCallback) {\n    streamingCallback(makeChunk(\"tool\", resumedToolMessage));\n  }\n  var response;\n  const dispatch = async (index, req) => {\n    if (!middleware || index === middleware.length) {\n      return await model(req, {\n        abortSignal,\n        onChunk: streamingCallback && ((chunk) => streamingCallback && streamingCallback(makeChunk(\"model\", chunk)))\n      });\n    }\n    const currentMiddleware = middleware[index];\n    return currentMiddleware(\n      req,\n      async (modifiedReq) => dispatch(index + 1, modifiedReq || req)\n    );\n  };\n  const modelResponse = await dispatch(0, request);\n  if (model.__action.actionType === \"background-model\") {\n    response = new import_generate.GenerateResponse(\n      { operation: modelResponse },\n      {\n        request,\n        parser: format?.handler(request.output?.schema).parseMessage\n      }\n    );\n  } else {\n    response = new import_generate.GenerateResponse(modelResponse, {\n      request,\n      parser: format?.handler(request.output?.schema).parseMessage\n    });\n  }\n  if (model.__action.actionType === \"background-model\") {\n    return response.toJSON();\n  }\n  response.assertValid();\n  const generatedMessage = response.message;\n  const toolRequests = generatedMessage.content.filter(\n    (part) => !!part.toolRequest\n  );\n  if (rawRequest.returnToolRequests || toolRequests.length === 0) {\n    if (toolRequests.length === 0) response.assertValidSchema(request);\n    return response.toJSON();\n  }\n  const maxIterations = rawRequest.maxTurns ?? 5;\n  if (currentTurn + 1 > maxIterations) {\n    throw new import_generate.GenerationResponseError(\n      response,\n      `Exceeded maximum tool call iterations (${maxIterations})`,\n      \"ABORTED\",\n      { request }\n    );\n  }\n  const { revisedModelMessage, toolMessage, transferPreamble } = await (0, import_resolve_tool_requests.resolveToolRequests)(registry, rawRequest, generatedMessage);\n  if (revisedModelMessage) {\n    return {\n      ...response.toJSON(),\n      finishReason: \"interrupted\",\n      finishMessage: \"One or more tool calls resulted in interrupts.\",\n      message: revisedModelMessage\n    };\n  }\n  streamingCallback?.(\n    makeChunk(\"tool\", {\n      content: toolMessage.content\n    })\n  );\n  let nextRequest = {\n    ...rawRequest,\n    messages: [...rawRequest.messages, generatedMessage.toJSON(), toolMessage]\n  };\n  nextRequest = applyTransferPreamble(nextRequest, transferPreamble);\n  return await generateHelper(registry, {\n    rawRequest: nextRequest,\n    middleware,\n    currentTurn: currentTurn + 1,\n    messageIndex: messageIndex + 1,\n    streamingCallback,\n    abortSignal\n  });\n}\nasync function actionToGenerateRequest(options, resolvedTools, resolvedFormat, model) {\n  const modelInfo = model.__action.metadata?.model;\n  if ((options.tools?.length ?? 0) > 0 && modelInfo?.supports && !modelInfo?.supports?.tools) {\n    import_logging.logger.warn(\n      `The model '${model.__action.name}' does not support tools (you set: ${options.tools?.length} tools). The model may not behave the way you expect.`\n    );\n  }\n  if (options.toolChoice && modelInfo?.supports && !modelInfo?.supports?.toolChoice) {\n    import_logging.logger.warn(\n      `The model '${model.__action.name}' does not support the 'toolChoice' option (you set: ${options.toolChoice}). The model may not behave the way you expect.`\n    );\n  }\n  const out = {\n    messages: options.messages,\n    config: options.config,\n    docs: options.docs,\n    tools: resolvedTools?.map(import_tool.toToolDefinition) || [],\n    output: (0, import_core.stripUndefinedProps)({\n      constrained: options.output?.constrained,\n      contentType: options.output?.contentType,\n      format: options.output?.format,\n      schema: options.output?.jsonSchema\n    })\n  };\n  if (options.toolChoice) {\n    out.toolChoice = options.toolChoice;\n  }\n  if (out.output && !out.output.schema) delete out.output.schema;\n  return out;\n}\nfunction inferRoleFromParts(parts) {\n  const uniqueRoles = /* @__PURE__ */ new Set();\n  for (const part of parts) {\n    const role = getRoleFromPart(part);\n    uniqueRoles.add(role);\n    if (uniqueRoles.size > 1) {\n      throw new Error(\"Contents contain mixed roles\");\n    }\n  }\n  return Array.from(uniqueRoles)[0];\n}\nfunction getRoleFromPart(part) {\n  if (part.toolRequest !== void 0) return \"model\";\n  if (part.toolResponse !== void 0) return \"tool\";\n  if (part.text !== void 0) return \"user\";\n  if (part.media !== void 0) return \"user\";\n  if (part.data !== void 0) return \"user\";\n  throw new Error(\"No recognized fields in content\");\n}\nasync function applyResources(registry, rawRequest) {\n  if (!rawRequest.messages.find((m) => !!m.content.find((c) => c.resource))) {\n    return rawRequest;\n  }\n  const updatedMessages = [];\n  for (const m of rawRequest.messages) {\n    if (!m.content.find((c) => c.resource)) {\n      updatedMessages.push(m);\n      continue;\n    }\n    const updatedContent = [];\n    for (const p of m.content) {\n      if (!p.resource) {\n        updatedContent.push(p);\n        continue;\n      }\n      const resource = await (0, import_resource.findMatchingResource)(registry, p.resource);\n      if (!resource) {\n        throw new import_core.GenkitError({\n          status: \"NOT_FOUND\",\n          message: `failed to find matching resource for ${p.resource.uri}`\n        });\n      }\n      const resourceParts = await resource(p.resource);\n      updatedContent.push(...resourceParts.content);\n    }\n    updatedMessages.push({\n      ...m,\n      content: updatedContent\n    });\n  }\n  return {\n    ...rawRequest,\n    messages: updatedMessages\n  };\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=action.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9nZW5lcmF0ZS9hY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxxRkFBaUI7QUFDM0MscUJBQXFCLG1CQUFPLENBQUMsK0ZBQXlCO0FBQ3RELHFCQUFxQixtQkFBTyxDQUFDLCtGQUF5QjtBQUN0RCxxQkFBcUIsbUJBQU8sQ0FBQywrRkFBcUI7QUFDbEQsc0JBQXNCLG1CQUFPLENBQUMscUZBQWdCO0FBQzlDLG1CQUFtQixtQkFBTyxDQUFDLGlHQUFzQjtBQUNqRCxtQkFBbUIsbUJBQU8sQ0FBQywrRUFBYTtBQUN4QyxzQkFBc0IsbUJBQU8sQ0FBQyxxRkFBZ0I7QUFDOUMsa0JBQWtCLG1CQUFPLENBQUMsNkVBQVk7QUFDdEMsbUNBQW1DLG1CQUFPLENBQUMsdUhBQTRCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxzQkFBc0IsK0JBQStCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELHNCQUFzQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFVBQVUsdUJBQXVCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwQkFBMEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxjQUFjO0FBQzlEO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVLHFEQUFxRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CLHFDQUFxQyx1QkFBdUI7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CLHVEQUF1RCxtQkFBbUI7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGVBQWU7QUFDMUUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUtMO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcS1JhbWFjaGFcXERvY3VtZW50c1xcU3VzdEFJbmV4IEdJdCBDb2RlXFxub2RlX21vZHVsZXNcXEBnZW5raXQtYWlcXGFpXFxsaWJcXGdlbmVyYXRlXFxhY3Rpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIGFjdGlvbl9leHBvcnRzID0ge307XG5fX2V4cG9ydChhY3Rpb25fZXhwb3J0cywge1xuICBkZWZpbmVHZW5lcmF0ZUFjdGlvbjogKCkgPT4gZGVmaW5lR2VuZXJhdGVBY3Rpb24sXG4gIGdlbmVyYXRlSGVscGVyOiAoKSA9PiBnZW5lcmF0ZUhlbHBlcixcbiAgaW5mZXJSb2xlRnJvbVBhcnRzOiAoKSA9PiBpbmZlclJvbGVGcm9tUGFydHMsXG4gIHNob3VsZEluamVjdEZvcm1hdEluc3RydWN0aW9uczogKCkgPT4gc2hvdWxkSW5qZWN0Rm9ybWF0SW5zdHJ1Y3Rpb25zXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKGFjdGlvbl9leHBvcnRzKTtcbnZhciBpbXBvcnRfY29yZSA9IHJlcXVpcmUoXCJAZ2Vua2l0LWFpL2NvcmVcIik7XG52YXIgaW1wb3J0X2xvZ2dpbmcgPSByZXF1aXJlKFwiQGdlbmtpdC1haS9jb3JlL2xvZ2dpbmdcIik7XG52YXIgaW1wb3J0X3RyYWNpbmcgPSByZXF1aXJlKFwiQGdlbmtpdC1haS9jb3JlL3RyYWNpbmdcIik7XG52YXIgaW1wb3J0X2Zvcm1hdHMgPSByZXF1aXJlKFwiLi4vZm9ybWF0cy9pbmRleC5qc1wiKTtcbnZhciBpbXBvcnRfZ2VuZXJhdGUgPSByZXF1aXJlKFwiLi4vZ2VuZXJhdGUuanNcIik7XG52YXIgaW1wb3J0X2NodW5rID0gcmVxdWlyZShcIi4uL2dlbmVyYXRlL2NodW5rLmpzXCIpO1xudmFyIGltcG9ydF9tb2RlbCA9IHJlcXVpcmUoXCIuLi9tb2RlbC5qc1wiKTtcbnZhciBpbXBvcnRfcmVzb3VyY2UgPSByZXF1aXJlKFwiLi4vcmVzb3VyY2UuanNcIik7XG52YXIgaW1wb3J0X3Rvb2wgPSByZXF1aXJlKFwiLi4vdG9vbC5qc1wiKTtcbnZhciBpbXBvcnRfcmVzb2x2ZV90b29sX3JlcXVlc3RzID0gcmVxdWlyZShcIi4vcmVzb2x2ZS10b29sLXJlcXVlc3RzLmpzXCIpO1xuZnVuY3Rpb24gZGVmaW5lR2VuZXJhdGVBY3Rpb24ocmVnaXN0cnkpIHtcbiAgcmV0dXJuICgwLCBpbXBvcnRfY29yZS5kZWZpbmVBY3Rpb24pKFxuICAgIHJlZ2lzdHJ5LFxuICAgIHtcbiAgICAgIGFjdGlvblR5cGU6IFwidXRpbFwiLFxuICAgICAgbmFtZTogXCJnZW5lcmF0ZVwiLFxuICAgICAgaW5wdXRTY2hlbWE6IGltcG9ydF9tb2RlbC5HZW5lcmF0ZUFjdGlvbk9wdGlvbnNTY2hlbWEsXG4gICAgICBvdXRwdXRTY2hlbWE6IGltcG9ydF9tb2RlbC5HZW5lcmF0ZVJlc3BvbnNlU2NoZW1hLFxuICAgICAgc3RyZWFtU2NoZW1hOiBpbXBvcnRfbW9kZWwuR2VuZXJhdGVSZXNwb25zZUNodW5rU2NoZW1hXG4gICAgfSxcbiAgICBhc3luYyAocmVxdWVzdCwgeyBzdHJlYW1pbmdSZXF1ZXN0ZWQsIHNlbmRDaHVuayB9KSA9PiB7XG4gICAgICBjb25zdCBnZW5lcmF0ZUZuID0gKHNlbmRDaHVuazIpID0+IGdlbmVyYXRlKHJlZ2lzdHJ5LCB7XG4gICAgICAgIHJhd1JlcXVlc3Q6IHJlcXVlc3QsXG4gICAgICAgIGN1cnJlbnRUdXJuOiAwLFxuICAgICAgICBtZXNzYWdlSW5kZXg6IDAsXG4gICAgICAgIC8vIEdlbmVyYXRlIHV0aWwgYWN0aW9uIGRvZXMgbm90IHN1cHBvcnQgbWlkZGxld2FyZS4gTWF5YmUgd2hlbiB3ZSBhZGQgbmFtZWQvcmVnaXN0ZXJlZCBtaWRkbGV3YXJlLi4uLlxuICAgICAgICBtaWRkbGV3YXJlOiBbXSxcbiAgICAgICAgc3RyZWFtaW5nQ2FsbGJhY2s6IHNlbmRDaHVuazJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN0cmVhbWluZ1JlcXVlc3RlZCA/IGdlbmVyYXRlRm4oXG4gICAgICAgIChjKSA9PiBzZW5kQ2h1bmsoYy50b0pTT04gPyBjLnRvSlNPTigpIDogYylcbiAgICAgICkgOiBnZW5lcmF0ZUZuKCk7XG4gICAgfVxuICApO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVIZWxwZXIocmVnaXN0cnksIG9wdGlvbnMpIHtcbiAgY29uc3QgY3VycmVudFR1cm4gPSBvcHRpb25zLmN1cnJlbnRUdXJuID8/IDA7XG4gIGNvbnN0IG1lc3NhZ2VJbmRleCA9IG9wdGlvbnMubWVzc2FnZUluZGV4ID8/IDA7XG4gIHJldHVybiBhd2FpdCAoMCwgaW1wb3J0X3RyYWNpbmcucnVuSW5OZXdTcGFuKShcbiAgICByZWdpc3RyeSxcbiAgICB7XG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICBuYW1lOiBvcHRpb25zLnJhd1JlcXVlc3Quc3RlcE5hbWUgfHwgXCJnZW5lcmF0ZVwiXG4gICAgICB9LFxuICAgICAgbGFiZWxzOiB7XG4gICAgICAgIFtpbXBvcnRfdHJhY2luZy5TUEFOX1RZUEVfQVRUUl06IFwidXRpbFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBhc3luYyAobWV0YWRhdGEpID0+IHtcbiAgICAgIG1ldGFkYXRhLm5hbWUgPSBvcHRpb25zLnJhd1JlcXVlc3Quc3RlcE5hbWUgfHwgXCJnZW5lcmF0ZVwiO1xuICAgICAgbWV0YWRhdGEuaW5wdXQgPSBvcHRpb25zLnJhd1JlcXVlc3Q7XG4gICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCBnZW5lcmF0ZShyZWdpc3RyeSwge1xuICAgICAgICByYXdSZXF1ZXN0OiBvcHRpb25zLnJhd1JlcXVlc3QsXG4gICAgICAgIG1pZGRsZXdhcmU6IG9wdGlvbnMubWlkZGxld2FyZSxcbiAgICAgICAgY3VycmVudFR1cm4sXG4gICAgICAgIG1lc3NhZ2VJbmRleCxcbiAgICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWwsXG4gICAgICAgIHN0cmVhbWluZ0NhbGxiYWNrOiBvcHRpb25zLnN0cmVhbWluZ0NhbGxiYWNrXG4gICAgICB9KTtcbiAgICAgIG1ldGFkYXRhLm91dHB1dCA9IEpTT04uc3RyaW5naWZ5KG91dHB1dCk7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVQYXJhbWV0ZXJzKHJlZ2lzdHJ5LCByZXF1ZXN0KSB7XG4gIGNvbnN0IFttb2RlbCwgdG9vbHMsIGZvcm1hdF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgKDAsIGltcG9ydF9tb2RlbC5yZXNvbHZlTW9kZWwpKHJlZ2lzdHJ5LCByZXF1ZXN0Lm1vZGVsLCB7IHdhcm5EZXByZWNhdGVkOiB0cnVlIH0pLnRoZW4oXG4gICAgICAocikgPT4gci5tb2RlbEFjdGlvblxuICAgICksXG4gICAgKDAsIGltcG9ydF90b29sLnJlc29sdmVUb29scykocmVnaXN0cnksIHJlcXVlc3QudG9vbHMpLFxuICAgICgwLCBpbXBvcnRfZm9ybWF0cy5yZXNvbHZlRm9ybWF0KShyZWdpc3RyeSwgcmVxdWVzdC5vdXRwdXQpXG4gIF0pO1xuICByZXR1cm4geyBtb2RlbCwgdG9vbHMsIGZvcm1hdCB9O1xufVxuZnVuY3Rpb24gYXBwbHlGb3JtYXQocmF3UmVxdWVzdCwgcmVzb2x2ZWRGb3JtYXQpIHtcbiAgY29uc3Qgb3V0UmVxdWVzdCA9IHsgLi4ucmF3UmVxdWVzdCB9O1xuICBpZiAocmF3UmVxdWVzdC5vdXRwdXQ/Lmpzb25TY2hlbWEgJiYgIXJhd1JlcXVlc3Qub3V0cHV0Py5mb3JtYXQpIHtcbiAgICBvdXRSZXF1ZXN0Lm91dHB1dCA9IHsgLi4ucmF3UmVxdWVzdC5vdXRwdXQsIGZvcm1hdDogXCJqc29uXCIgfTtcbiAgfVxuICBjb25zdCBpbnN0cnVjdGlvbnMgPSAoMCwgaW1wb3J0X2Zvcm1hdHMucmVzb2x2ZUluc3RydWN0aW9ucykoXG4gICAgcmVzb2x2ZWRGb3JtYXQsXG4gICAgb3V0UmVxdWVzdC5vdXRwdXQ/Lmpzb25TY2hlbWEsXG4gICAgb3V0UmVxdWVzdD8ub3V0cHV0Py5pbnN0cnVjdGlvbnNcbiAgKTtcbiAgaWYgKHJlc29sdmVkRm9ybWF0KSB7XG4gICAgaWYgKHNob3VsZEluamVjdEZvcm1hdEluc3RydWN0aW9ucyhyZXNvbHZlZEZvcm1hdC5jb25maWcsIHJhd1JlcXVlc3Q/Lm91dHB1dCkpIHtcbiAgICAgIG91dFJlcXVlc3QubWVzc2FnZXMgPSAoMCwgaW1wb3J0X2Zvcm1hdHMuaW5qZWN0SW5zdHJ1Y3Rpb25zKShcbiAgICAgICAgb3V0UmVxdWVzdC5tZXNzYWdlcyxcbiAgICAgICAgaW5zdHJ1Y3Rpb25zXG4gICAgICApO1xuICAgIH1cbiAgICBvdXRSZXF1ZXN0Lm91dHB1dCA9IHtcbiAgICAgIC8vIHVzZSBvdXRwdXQgY29uZmlnIGZyb20gdGhlIGZvcm1hdFxuICAgICAgLi4ucmVzb2x2ZWRGb3JtYXQuY29uZmlnLFxuICAgICAgLy8gaWYgYW55dGhpbmcgaXMgc2V0IGV4cGxpY2l0bHksIHVzZSB0aGF0XG4gICAgICAuLi5vdXRSZXF1ZXN0Lm91dHB1dFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG91dFJlcXVlc3Q7XG59XG5mdW5jdGlvbiBzaG91bGRJbmplY3RGb3JtYXRJbnN0cnVjdGlvbnMoZm9ybWF0Q29uZmlnLCByYXdSZXF1ZXN0Q29uZmlnKSB7XG4gIHJldHVybiBmb3JtYXRDb25maWc/LmRlZmF1bHRJbnN0cnVjdGlvbnMgIT09IGZhbHNlIHx8IHJhd1JlcXVlc3RDb25maWc/Lmluc3RydWN0aW9ucztcbn1cbmZ1bmN0aW9uIGFwcGx5VHJhbnNmZXJQcmVhbWJsZShyYXdSZXF1ZXN0LCB0cmFuc2ZlclByZWFtYmxlKSB7XG4gIGlmICghdHJhbnNmZXJQcmVhbWJsZSkge1xuICAgIHJldHVybiByYXdSZXF1ZXN0O1xuICB9XG4gIHJldHVybiAoMCwgaW1wb3J0X2NvcmUuc3RyaXBVbmRlZmluZWRQcm9wcykoe1xuICAgIC4uLnJhd1JlcXVlc3QsXG4gICAgbWVzc2FnZXM6IFtcbiAgICAgIC4uLigwLCBpbXBvcnRfZ2VuZXJhdGUudGFnQXNQcmVhbWJsZSkodHJhbnNmZXJQcmVhbWJsZS5tZXNzYWdlcyksXG4gICAgICAuLi5yYXdSZXF1ZXN0Lm1lc3NhZ2VzLmZpbHRlcigobSkgPT4gIW0ubWV0YWRhdGE/LnByZWFtYmxlKVxuICAgIF0sXG4gICAgdG9vbENob2ljZTogdHJhbnNmZXJQcmVhbWJsZS50b29sQ2hvaWNlIHx8IHJhd1JlcXVlc3QudG9vbENob2ljZSxcbiAgICB0b29sczogdHJhbnNmZXJQcmVhbWJsZS50b29scyB8fCByYXdSZXF1ZXN0LnRvb2xzLFxuICAgIGNvbmZpZzogdHJhbnNmZXJQcmVhbWJsZS5jb25maWcgfHwgcmF3UmVxdWVzdC5jb25maWdcbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZShyZWdpc3RyeSwge1xuICByYXdSZXF1ZXN0LFxuICBtaWRkbGV3YXJlLFxuICBjdXJyZW50VHVybixcbiAgbWVzc2FnZUluZGV4LFxuICBhYm9ydFNpZ25hbCxcbiAgc3RyZWFtaW5nQ2FsbGJhY2tcbn0pIHtcbiAgY29uc3QgeyBtb2RlbCwgdG9vbHMsIGZvcm1hdCB9ID0gYXdhaXQgcmVzb2x2ZVBhcmFtZXRlcnMoXG4gICAgcmVnaXN0cnksXG4gICAgcmF3UmVxdWVzdFxuICApO1xuICByYXdSZXF1ZXN0ID0gYXBwbHlGb3JtYXQocmF3UmVxdWVzdCwgZm9ybWF0KTtcbiAgcmF3UmVxdWVzdCA9IGF3YWl0IGFwcGx5UmVzb3VyY2VzKHJlZ2lzdHJ5LCByYXdSZXF1ZXN0KTtcbiAgYXdhaXQgKDAsIGltcG9ydF9yZXNvbHZlX3Rvb2xfcmVxdWVzdHMuYXNzZXJ0VmFsaWRUb29sTmFtZXMpKHRvb2xzKTtcbiAgY29uc3Qge1xuICAgIHJldmlzZWRSZXF1ZXN0LFxuICAgIGludGVycnVwdGVkUmVzcG9uc2UsXG4gICAgdG9vbE1lc3NhZ2U6IHJlc3VtZWRUb29sTWVzc2FnZVxuICB9ID0gYXdhaXQgKDAsIGltcG9ydF9yZXNvbHZlX3Rvb2xfcmVxdWVzdHMucmVzb2x2ZVJlc3VtZU9wdGlvbikocmVnaXN0cnksIHJhd1JlcXVlc3QpO1xuICBpZiAoaW50ZXJydXB0ZWRSZXNwb25zZSkge1xuICAgIHRocm93IG5ldyBpbXBvcnRfY29yZS5HZW5raXRFcnJvcih7XG4gICAgICBzdGF0dXM6IFwiRkFJTEVEX1BSRUNPTkRJVElPTlwiLFxuICAgICAgbWVzc2FnZTogXCJPbmUgb3IgbW9yZSB0b29scyB0cmlnZ2VyZWQgYW4gaW50ZXJydXB0IGR1cmluZyBhIHJlc3RhcnRlZCBleGVjdXRpb24uXCIsXG4gICAgICBkZXRhaWw6IHsgbWVzc2FnZTogaW50ZXJydXB0ZWRSZXNwb25zZS5tZXNzYWdlIH1cbiAgICB9KTtcbiAgfVxuICByYXdSZXF1ZXN0ID0gcmV2aXNlZFJlcXVlc3Q7XG4gIGNvbnN0IHJlcXVlc3QgPSBhd2FpdCBhY3Rpb25Ub0dlbmVyYXRlUmVxdWVzdChcbiAgICByYXdSZXF1ZXN0LFxuICAgIHRvb2xzLFxuICAgIGZvcm1hdCxcbiAgICBtb2RlbFxuICApO1xuICBjb25zdCBwcmV2aW91c0NodW5rcyA9IFtdO1xuICBsZXQgY2h1bmtSb2xlID0gXCJtb2RlbFwiO1xuICBjb25zdCBtYWtlQ2h1bmsgPSAocm9sZSwgY2h1bmspID0+IHtcbiAgICBpZiAocm9sZSAhPT0gY2h1bmtSb2xlICYmIHByZXZpb3VzQ2h1bmtzLmxlbmd0aCkgbWVzc2FnZUluZGV4Kys7XG4gICAgY2h1bmtSb2xlID0gcm9sZTtcbiAgICBjb25zdCBwcmV2VG9TZW5kID0gWy4uLnByZXZpb3VzQ2h1bmtzXTtcbiAgICBwcmV2aW91c0NodW5rcy5wdXNoKGNodW5rKTtcbiAgICByZXR1cm4gbmV3IGltcG9ydF9jaHVuay5HZW5lcmF0ZVJlc3BvbnNlQ2h1bmsoY2h1bmssIHtcbiAgICAgIGluZGV4OiBtZXNzYWdlSW5kZXgsXG4gICAgICByb2xlLFxuICAgICAgcHJldmlvdXNDaHVua3M6IHByZXZUb1NlbmQsXG4gICAgICBwYXJzZXI6IGZvcm1hdD8uaGFuZGxlcihyZXF1ZXN0Lm91dHB1dD8uc2NoZW1hKS5wYXJzZUNodW5rXG4gICAgfSk7XG4gIH07XG4gIGlmIChyZXN1bWVkVG9vbE1lc3NhZ2UgJiYgc3RyZWFtaW5nQ2FsbGJhY2spIHtcbiAgICBzdHJlYW1pbmdDYWxsYmFjayhtYWtlQ2h1bmsoXCJ0b29sXCIsIHJlc3VtZWRUb29sTWVzc2FnZSkpO1xuICB9XG4gIHZhciByZXNwb25zZTtcbiAgY29uc3QgZGlzcGF0Y2ggPSBhc3luYyAoaW5kZXgsIHJlcSkgPT4ge1xuICAgIGlmICghbWlkZGxld2FyZSB8fCBpbmRleCA9PT0gbWlkZGxld2FyZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBhd2FpdCBtb2RlbChyZXEsIHtcbiAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgIG9uQ2h1bms6IHN0cmVhbWluZ0NhbGxiYWNrICYmICgoY2h1bmspID0+IHN0cmVhbWluZ0NhbGxiYWNrICYmIHN0cmVhbWluZ0NhbGxiYWNrKG1ha2VDaHVuayhcIm1vZGVsXCIsIGNodW5rKSkpXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudE1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlW2luZGV4XTtcbiAgICByZXR1cm4gY3VycmVudE1pZGRsZXdhcmUoXG4gICAgICByZXEsXG4gICAgICBhc3luYyAobW9kaWZpZWRSZXEpID0+IGRpc3BhdGNoKGluZGV4ICsgMSwgbW9kaWZpZWRSZXEgfHwgcmVxKVxuICAgICk7XG4gIH07XG4gIGNvbnN0IG1vZGVsUmVzcG9uc2UgPSBhd2FpdCBkaXNwYXRjaCgwLCByZXF1ZXN0KTtcbiAgaWYgKG1vZGVsLl9fYWN0aW9uLmFjdGlvblR5cGUgPT09IFwiYmFja2dyb3VuZC1tb2RlbFwiKSB7XG4gICAgcmVzcG9uc2UgPSBuZXcgaW1wb3J0X2dlbmVyYXRlLkdlbmVyYXRlUmVzcG9uc2UoXG4gICAgICB7IG9wZXJhdGlvbjogbW9kZWxSZXNwb25zZSB9LFxuICAgICAge1xuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBwYXJzZXI6IGZvcm1hdD8uaGFuZGxlcihyZXF1ZXN0Lm91dHB1dD8uc2NoZW1hKS5wYXJzZU1lc3NhZ2VcbiAgICAgIH1cbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJlc3BvbnNlID0gbmV3IGltcG9ydF9nZW5lcmF0ZS5HZW5lcmF0ZVJlc3BvbnNlKG1vZGVsUmVzcG9uc2UsIHtcbiAgICAgIHJlcXVlc3QsXG4gICAgICBwYXJzZXI6IGZvcm1hdD8uaGFuZGxlcihyZXF1ZXN0Lm91dHB1dD8uc2NoZW1hKS5wYXJzZU1lc3NhZ2VcbiAgICB9KTtcbiAgfVxuICBpZiAobW9kZWwuX19hY3Rpb24uYWN0aW9uVHlwZSA9PT0gXCJiYWNrZ3JvdW5kLW1vZGVsXCIpIHtcbiAgICByZXR1cm4gcmVzcG9uc2UudG9KU09OKCk7XG4gIH1cbiAgcmVzcG9uc2UuYXNzZXJ0VmFsaWQoKTtcbiAgY29uc3QgZ2VuZXJhdGVkTWVzc2FnZSA9IHJlc3BvbnNlLm1lc3NhZ2U7XG4gIGNvbnN0IHRvb2xSZXF1ZXN0cyA9IGdlbmVyYXRlZE1lc3NhZ2UuY29udGVudC5maWx0ZXIoXG4gICAgKHBhcnQpID0+ICEhcGFydC50b29sUmVxdWVzdFxuICApO1xuICBpZiAocmF3UmVxdWVzdC5yZXR1cm5Ub29sUmVxdWVzdHMgfHwgdG9vbFJlcXVlc3RzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmICh0b29sUmVxdWVzdHMubGVuZ3RoID09PSAwKSByZXNwb25zZS5hc3NlcnRWYWxpZFNjaGVtYShyZXF1ZXN0KTtcbiAgICByZXR1cm4gcmVzcG9uc2UudG9KU09OKCk7XG4gIH1cbiAgY29uc3QgbWF4SXRlcmF0aW9ucyA9IHJhd1JlcXVlc3QubWF4VHVybnMgPz8gNTtcbiAgaWYgKGN1cnJlbnRUdXJuICsgMSA+IG1heEl0ZXJhdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgaW1wb3J0X2dlbmVyYXRlLkdlbmVyYXRpb25SZXNwb25zZUVycm9yKFxuICAgICAgcmVzcG9uc2UsXG4gICAgICBgRXhjZWVkZWQgbWF4aW11bSB0b29sIGNhbGwgaXRlcmF0aW9ucyAoJHttYXhJdGVyYXRpb25zfSlgLFxuICAgICAgXCJBQk9SVEVEXCIsXG4gICAgICB7IHJlcXVlc3QgfVxuICAgICk7XG4gIH1cbiAgY29uc3QgeyByZXZpc2VkTW9kZWxNZXNzYWdlLCB0b29sTWVzc2FnZSwgdHJhbnNmZXJQcmVhbWJsZSB9ID0gYXdhaXQgKDAsIGltcG9ydF9yZXNvbHZlX3Rvb2xfcmVxdWVzdHMucmVzb2x2ZVRvb2xSZXF1ZXN0cykocmVnaXN0cnksIHJhd1JlcXVlc3QsIGdlbmVyYXRlZE1lc3NhZ2UpO1xuICBpZiAocmV2aXNlZE1vZGVsTWVzc2FnZSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXNwb25zZS50b0pTT04oKSxcbiAgICAgIGZpbmlzaFJlYXNvbjogXCJpbnRlcnJ1cHRlZFwiLFxuICAgICAgZmluaXNoTWVzc2FnZTogXCJPbmUgb3IgbW9yZSB0b29sIGNhbGxzIHJlc3VsdGVkIGluIGludGVycnVwdHMuXCIsXG4gICAgICBtZXNzYWdlOiByZXZpc2VkTW9kZWxNZXNzYWdlXG4gICAgfTtcbiAgfVxuICBzdHJlYW1pbmdDYWxsYmFjaz8uKFxuICAgIG1ha2VDaHVuayhcInRvb2xcIiwge1xuICAgICAgY29udGVudDogdG9vbE1lc3NhZ2UuY29udGVudFxuICAgIH0pXG4gICk7XG4gIGxldCBuZXh0UmVxdWVzdCA9IHtcbiAgICAuLi5yYXdSZXF1ZXN0LFxuICAgIG1lc3NhZ2VzOiBbLi4ucmF3UmVxdWVzdC5tZXNzYWdlcywgZ2VuZXJhdGVkTWVzc2FnZS50b0pTT04oKSwgdG9vbE1lc3NhZ2VdXG4gIH07XG4gIG5leHRSZXF1ZXN0ID0gYXBwbHlUcmFuc2ZlclByZWFtYmxlKG5leHRSZXF1ZXN0LCB0cmFuc2ZlclByZWFtYmxlKTtcbiAgcmV0dXJuIGF3YWl0IGdlbmVyYXRlSGVscGVyKHJlZ2lzdHJ5LCB7XG4gICAgcmF3UmVxdWVzdDogbmV4dFJlcXVlc3QsXG4gICAgbWlkZGxld2FyZSxcbiAgICBjdXJyZW50VHVybjogY3VycmVudFR1cm4gKyAxLFxuICAgIG1lc3NhZ2VJbmRleDogbWVzc2FnZUluZGV4ICsgMSxcbiAgICBzdHJlYW1pbmdDYWxsYmFjayxcbiAgICBhYm9ydFNpZ25hbFxuICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFjdGlvblRvR2VuZXJhdGVSZXF1ZXN0KG9wdGlvbnMsIHJlc29sdmVkVG9vbHMsIHJlc29sdmVkRm9ybWF0LCBtb2RlbCkge1xuICBjb25zdCBtb2RlbEluZm8gPSBtb2RlbC5fX2FjdGlvbi5tZXRhZGF0YT8ubW9kZWw7XG4gIGlmICgob3B0aW9ucy50b29scz8ubGVuZ3RoID8/IDApID4gMCAmJiBtb2RlbEluZm8/LnN1cHBvcnRzICYmICFtb2RlbEluZm8/LnN1cHBvcnRzPy50b29scykge1xuICAgIGltcG9ydF9sb2dnaW5nLmxvZ2dlci53YXJuKFxuICAgICAgYFRoZSBtb2RlbCAnJHttb2RlbC5fX2FjdGlvbi5uYW1lfScgZG9lcyBub3Qgc3VwcG9ydCB0b29scyAoeW91IHNldDogJHtvcHRpb25zLnRvb2xzPy5sZW5ndGh9IHRvb2xzKS4gVGhlIG1vZGVsIG1heSBub3QgYmVoYXZlIHRoZSB3YXkgeW91IGV4cGVjdC5gXG4gICAgKTtcbiAgfVxuICBpZiAob3B0aW9ucy50b29sQ2hvaWNlICYmIG1vZGVsSW5mbz8uc3VwcG9ydHMgJiYgIW1vZGVsSW5mbz8uc3VwcG9ydHM/LnRvb2xDaG9pY2UpIHtcbiAgICBpbXBvcnRfbG9nZ2luZy5sb2dnZXIud2FybihcbiAgICAgIGBUaGUgbW9kZWwgJyR7bW9kZWwuX19hY3Rpb24ubmFtZX0nIGRvZXMgbm90IHN1cHBvcnQgdGhlICd0b29sQ2hvaWNlJyBvcHRpb24gKHlvdSBzZXQ6ICR7b3B0aW9ucy50b29sQ2hvaWNlfSkuIFRoZSBtb2RlbCBtYXkgbm90IGJlaGF2ZSB0aGUgd2F5IHlvdSBleHBlY3QuYFxuICAgICk7XG4gIH1cbiAgY29uc3Qgb3V0ID0ge1xuICAgIG1lc3NhZ2VzOiBvcHRpb25zLm1lc3NhZ2VzLFxuICAgIGNvbmZpZzogb3B0aW9ucy5jb25maWcsXG4gICAgZG9jczogb3B0aW9ucy5kb2NzLFxuICAgIHRvb2xzOiByZXNvbHZlZFRvb2xzPy5tYXAoaW1wb3J0X3Rvb2wudG9Ub29sRGVmaW5pdGlvbikgfHwgW10sXG4gICAgb3V0cHV0OiAoMCwgaW1wb3J0X2NvcmUuc3RyaXBVbmRlZmluZWRQcm9wcykoe1xuICAgICAgY29uc3RyYWluZWQ6IG9wdGlvbnMub3V0cHV0Py5jb25zdHJhaW5lZCxcbiAgICAgIGNvbnRlbnRUeXBlOiBvcHRpb25zLm91dHB1dD8uY29udGVudFR5cGUsXG4gICAgICBmb3JtYXQ6IG9wdGlvbnMub3V0cHV0Py5mb3JtYXQsXG4gICAgICBzY2hlbWE6IG9wdGlvbnMub3V0cHV0Py5qc29uU2NoZW1hXG4gICAgfSlcbiAgfTtcbiAgaWYgKG9wdGlvbnMudG9vbENob2ljZSkge1xuICAgIG91dC50b29sQ2hvaWNlID0gb3B0aW9ucy50b29sQ2hvaWNlO1xuICB9XG4gIGlmIChvdXQub3V0cHV0ICYmICFvdXQub3V0cHV0LnNjaGVtYSkgZGVsZXRlIG91dC5vdXRwdXQuc2NoZW1hO1xuICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gaW5mZXJSb2xlRnJvbVBhcnRzKHBhcnRzKSB7XG4gIGNvbnN0IHVuaXF1ZVJvbGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgY29uc3Qgcm9sZSA9IGdldFJvbGVGcm9tUGFydChwYXJ0KTtcbiAgICB1bmlxdWVSb2xlcy5hZGQocm9sZSk7XG4gICAgaWYgKHVuaXF1ZVJvbGVzLnNpemUgPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250ZW50cyBjb250YWluIG1peGVkIHJvbGVzXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbSh1bmlxdWVSb2xlcylbMF07XG59XG5mdW5jdGlvbiBnZXRSb2xlRnJvbVBhcnQocGFydCkge1xuICBpZiAocGFydC50b29sUmVxdWVzdCAhPT0gdm9pZCAwKSByZXR1cm4gXCJtb2RlbFwiO1xuICBpZiAocGFydC50b29sUmVzcG9uc2UgIT09IHZvaWQgMCkgcmV0dXJuIFwidG9vbFwiO1xuICBpZiAocGFydC50ZXh0ICE9PSB2b2lkIDApIHJldHVybiBcInVzZXJcIjtcbiAgaWYgKHBhcnQubWVkaWEgIT09IHZvaWQgMCkgcmV0dXJuIFwidXNlclwiO1xuICBpZiAocGFydC5kYXRhICE9PSB2b2lkIDApIHJldHVybiBcInVzZXJcIjtcbiAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVjb2duaXplZCBmaWVsZHMgaW4gY29udGVudFwiKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFwcGx5UmVzb3VyY2VzKHJlZ2lzdHJ5LCByYXdSZXF1ZXN0KSB7XG4gIGlmICghcmF3UmVxdWVzdC5tZXNzYWdlcy5maW5kKChtKSA9PiAhIW0uY29udGVudC5maW5kKChjKSA9PiBjLnJlc291cmNlKSkpIHtcbiAgICByZXR1cm4gcmF3UmVxdWVzdDtcbiAgfVxuICBjb25zdCB1cGRhdGVkTWVzc2FnZXMgPSBbXTtcbiAgZm9yIChjb25zdCBtIG9mIHJhd1JlcXVlc3QubWVzc2FnZXMpIHtcbiAgICBpZiAoIW0uY29udGVudC5maW5kKChjKSA9PiBjLnJlc291cmNlKSkge1xuICAgICAgdXBkYXRlZE1lc3NhZ2VzLnB1c2gobSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlZENvbnRlbnQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHAgb2YgbS5jb250ZW50KSB7XG4gICAgICBpZiAoIXAucmVzb3VyY2UpIHtcbiAgICAgICAgdXBkYXRlZENvbnRlbnQucHVzaChwKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNvdXJjZSA9IGF3YWl0ICgwLCBpbXBvcnRfcmVzb3VyY2UuZmluZE1hdGNoaW5nUmVzb3VyY2UpKHJlZ2lzdHJ5LCBwLnJlc291cmNlKTtcbiAgICAgIGlmICghcmVzb3VyY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IGltcG9ydF9jb3JlLkdlbmtpdEVycm9yKHtcbiAgICAgICAgICBzdGF0dXM6IFwiTk9UX0ZPVU5EXCIsXG4gICAgICAgICAgbWVzc2FnZTogYGZhaWxlZCB0byBmaW5kIG1hdGNoaW5nIHJlc291cmNlIGZvciAke3AucmVzb3VyY2UudXJpfWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNvdXJjZVBhcnRzID0gYXdhaXQgcmVzb3VyY2UocC5yZXNvdXJjZSk7XG4gICAgICB1cGRhdGVkQ29udGVudC5wdXNoKC4uLnJlc291cmNlUGFydHMuY29udGVudCk7XG4gICAgfVxuICAgIHVwZGF0ZWRNZXNzYWdlcy5wdXNoKHtcbiAgICAgIC4uLm0sXG4gICAgICBjb250ZW50OiB1cGRhdGVkQ29udGVudFxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4ucmF3UmVxdWVzdCxcbiAgICBtZXNzYWdlczogdXBkYXRlZE1lc3NhZ2VzXG4gIH07XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVmaW5lR2VuZXJhdGVBY3Rpb24sXG4gIGdlbmVyYXRlSGVscGVyLFxuICBpbmZlclJvbGVGcm9tUGFydHMsXG4gIHNob3VsZEluamVjdEZvcm1hdEluc3RydWN0aW9uc1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/generate/action.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/generate/chunk.js":
/*!**********************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/generate/chunk.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar chunk_exports = {};\n__export(chunk_exports, {\n  GenerateResponseChunk: () => GenerateResponseChunk\n});\nmodule.exports = __toCommonJS(chunk_exports);\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nvar import_extract = __webpack_require__(/*! ../extract.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/extract.js\");\nclass GenerateResponseChunk {\n  /** The index of the message this chunk corresponds to, starting with `0` for the first model response of the generation. */\n  index;\n  /** The role of the message this chunk corresponds to. Will always be `model` or `tool`. */\n  role;\n  /** The content generated in this chunk. */\n  content;\n  /** Custom model-specific data for this chunk. */\n  custom;\n  /** Accumulated chunks for partial output extraction. */\n  previousChunks;\n  /** The parser to be used to parse `output` from this chunk. */\n  parser;\n  constructor(data, options) {\n    this.content = data.content || [];\n    this.custom = data.custom;\n    this.previousChunks = options.previousChunks ? [...options.previousChunks] : void 0;\n    this.index = options.index;\n    this.role = options.role;\n    this.parser = options.parser;\n  }\n  /**\n   * Concatenates all `text` parts present in the chunk with no delimiter.\n   * @returns A string of all concatenated text parts.\n   */\n  get text() {\n    return this.content.map((part) => part.text || \"\").join(\"\");\n  }\n  /**\n   * Concatenates all `reasoning` parts present in the chunk with no delimiter.\n   * @returns A string of all concatenated reasoning parts.\n   */\n  get reasoning() {\n    return this.content.map((part) => part.reasoning || \"\").join(\"\");\n  }\n  /**\n   * Concatenates all `text` parts of all chunks from the response thus far.\n   * @returns A string of all concatenated chunk text content.\n   */\n  get accumulatedText() {\n    return this.previousText + this.text;\n  }\n  /**\n   * Concatenates all `text` parts of all preceding chunks.\n   */\n  get previousText() {\n    if (!this.previousChunks)\n      throw new import_core.GenkitError({\n        status: \"FAILED_PRECONDITION\",\n        message: \"Cannot compose accumulated text without previous chunks.\"\n      });\n    return this.previousChunks?.map((c) => c.content.map((p) => p.text || \"\").join(\"\")).join(\"\");\n  }\n  /**\n   * Returns the first media part detected in the chunk. Useful for extracting\n   * (for example) an image from a generation expected to create one.\n   * @returns The first detected `media` part in the chunk.\n   */\n  get media() {\n    return this.content.find((part) => part.media)?.media || null;\n  }\n  /**\n   * Returns the first detected `data` part of a chunk.\n   * @returns The first `data` part detected in the chunk (if any).\n   */\n  get data() {\n    return this.content.find((part) => part.data)?.data;\n  }\n  /**\n   * Returns all tool request found in this chunk.\n   * @returns Array of all tool request found in this chunk.\n   */\n  get toolRequests() {\n    return this.content.filter(\n      (part) => !!part.toolRequest\n    );\n  }\n  /**\n   * Parses the chunk into the desired output format using the parser associated\n   * with the generate request, or falls back to naive JSON parsing otherwise.\n   */\n  get output() {\n    if (this.parser) return this.parser(this);\n    return this.data || (0, import_extract.extractJson)(this.accumulatedText);\n  }\n  toJSON() {\n    const data = {\n      role: this.role,\n      index: this.index,\n      content: this.content\n    };\n    if (this.custom) {\n      data.custom = this.custom;\n    }\n    return data;\n  }\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=chunk.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9nZW5lcmF0ZS9jaHVuay5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHFGQUFpQjtBQUMzQyxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBRUw7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcYWlcXGxpYlxcZ2VuZXJhdGVcXGNodW5rLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBjaHVua19leHBvcnRzID0ge307XG5fX2V4cG9ydChjaHVua19leHBvcnRzLCB7XG4gIEdlbmVyYXRlUmVzcG9uc2VDaHVuazogKCkgPT4gR2VuZXJhdGVSZXNwb25zZUNodW5rXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKGNodW5rX2V4cG9ydHMpO1xudmFyIGltcG9ydF9jb3JlID0gcmVxdWlyZShcIkBnZW5raXQtYWkvY29yZVwiKTtcbnZhciBpbXBvcnRfZXh0cmFjdCA9IHJlcXVpcmUoXCIuLi9leHRyYWN0LmpzXCIpO1xuY2xhc3MgR2VuZXJhdGVSZXNwb25zZUNodW5rIHtcbiAgLyoqIFRoZSBpbmRleCBvZiB0aGUgbWVzc2FnZSB0aGlzIGNodW5rIGNvcnJlc3BvbmRzIHRvLCBzdGFydGluZyB3aXRoIGAwYCBmb3IgdGhlIGZpcnN0IG1vZGVsIHJlc3BvbnNlIG9mIHRoZSBnZW5lcmF0aW9uLiAqL1xuICBpbmRleDtcbiAgLyoqIFRoZSByb2xlIG9mIHRoZSBtZXNzYWdlIHRoaXMgY2h1bmsgY29ycmVzcG9uZHMgdG8uIFdpbGwgYWx3YXlzIGJlIGBtb2RlbGAgb3IgYHRvb2xgLiAqL1xuICByb2xlO1xuICAvKiogVGhlIGNvbnRlbnQgZ2VuZXJhdGVkIGluIHRoaXMgY2h1bmsuICovXG4gIGNvbnRlbnQ7XG4gIC8qKiBDdXN0b20gbW9kZWwtc3BlY2lmaWMgZGF0YSBmb3IgdGhpcyBjaHVuay4gKi9cbiAgY3VzdG9tO1xuICAvKiogQWNjdW11bGF0ZWQgY2h1bmtzIGZvciBwYXJ0aWFsIG91dHB1dCBleHRyYWN0aW9uLiAqL1xuICBwcmV2aW91c0NodW5rcztcbiAgLyoqIFRoZSBwYXJzZXIgdG8gYmUgdXNlZCB0byBwYXJzZSBgb3V0cHV0YCBmcm9tIHRoaXMgY2h1bmsuICovXG4gIHBhcnNlcjtcbiAgY29uc3RydWN0b3IoZGF0YSwgb3B0aW9ucykge1xuICAgIHRoaXMuY29udGVudCA9IGRhdGEuY29udGVudCB8fCBbXTtcbiAgICB0aGlzLmN1c3RvbSA9IGRhdGEuY3VzdG9tO1xuICAgIHRoaXMucHJldmlvdXNDaHVua3MgPSBvcHRpb25zLnByZXZpb3VzQ2h1bmtzID8gWy4uLm9wdGlvbnMucHJldmlvdXNDaHVua3NdIDogdm9pZCAwO1xuICAgIHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuICAgIHRoaXMucm9sZSA9IG9wdGlvbnMucm9sZTtcbiAgICB0aGlzLnBhcnNlciA9IG9wdGlvbnMucGFyc2VyO1xuICB9XG4gIC8qKlxuICAgKiBDb25jYXRlbmF0ZXMgYWxsIGB0ZXh0YCBwYXJ0cyBwcmVzZW50IGluIHRoZSBjaHVuayB3aXRoIG5vIGRlbGltaXRlci5cbiAgICogQHJldHVybnMgQSBzdHJpbmcgb2YgYWxsIGNvbmNhdGVuYXRlZCB0ZXh0IHBhcnRzLlxuICAgKi9cbiAgZ2V0IHRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5tYXAoKHBhcnQpID0+IHBhcnQudGV4dCB8fCBcIlwiKS5qb2luKFwiXCIpO1xuICB9XG4gIC8qKlxuICAgKiBDb25jYXRlbmF0ZXMgYWxsIGByZWFzb25pbmdgIHBhcnRzIHByZXNlbnQgaW4gdGhlIGNodW5rIHdpdGggbm8gZGVsaW1pdGVyLlxuICAgKiBAcmV0dXJucyBBIHN0cmluZyBvZiBhbGwgY29uY2F0ZW5hdGVkIHJlYXNvbmluZyBwYXJ0cy5cbiAgICovXG4gIGdldCByZWFzb25pbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5tYXAoKHBhcnQpID0+IHBhcnQucmVhc29uaW5nIHx8IFwiXCIpLmpvaW4oXCJcIik7XG4gIH1cbiAgLyoqXG4gICAqIENvbmNhdGVuYXRlcyBhbGwgYHRleHRgIHBhcnRzIG9mIGFsbCBjaHVua3MgZnJvbSB0aGUgcmVzcG9uc2UgdGh1cyBmYXIuXG4gICAqIEByZXR1cm5zIEEgc3RyaW5nIG9mIGFsbCBjb25jYXRlbmF0ZWQgY2h1bmsgdGV4dCBjb250ZW50LlxuICAgKi9cbiAgZ2V0IGFjY3VtdWxhdGVkVGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcmV2aW91c1RleHQgKyB0aGlzLnRleHQ7XG4gIH1cbiAgLyoqXG4gICAqIENvbmNhdGVuYXRlcyBhbGwgYHRleHRgIHBhcnRzIG9mIGFsbCBwcmVjZWRpbmcgY2h1bmtzLlxuICAgKi9cbiAgZ2V0IHByZXZpb3VzVGV4dCgpIHtcbiAgICBpZiAoIXRoaXMucHJldmlvdXNDaHVua3MpXG4gICAgICB0aHJvdyBuZXcgaW1wb3J0X2NvcmUuR2Vua2l0RXJyb3Ioe1xuICAgICAgICBzdGF0dXM6IFwiRkFJTEVEX1BSRUNPTkRJVElPTlwiLFxuICAgICAgICBtZXNzYWdlOiBcIkNhbm5vdCBjb21wb3NlIGFjY3VtdWxhdGVkIHRleHQgd2l0aG91dCBwcmV2aW91cyBjaHVua3MuXCJcbiAgICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnByZXZpb3VzQ2h1bmtzPy5tYXAoKGMpID0+IGMuY29udGVudC5tYXAoKHApID0+IHAudGV4dCB8fCBcIlwiKS5qb2luKFwiXCIpKS5qb2luKFwiXCIpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBtZWRpYSBwYXJ0IGRldGVjdGVkIGluIHRoZSBjaHVuay4gVXNlZnVsIGZvciBleHRyYWN0aW5nXG4gICAqIChmb3IgZXhhbXBsZSkgYW4gaW1hZ2UgZnJvbSBhIGdlbmVyYXRpb24gZXhwZWN0ZWQgdG8gY3JlYXRlIG9uZS5cbiAgICogQHJldHVybnMgVGhlIGZpcnN0IGRldGVjdGVkIGBtZWRpYWAgcGFydCBpbiB0aGUgY2h1bmsuXG4gICAqL1xuICBnZXQgbWVkaWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5maW5kKChwYXJ0KSA9PiBwYXJ0Lm1lZGlhKT8ubWVkaWEgfHwgbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgZGV0ZWN0ZWQgYGRhdGFgIHBhcnQgb2YgYSBjaHVuay5cbiAgICogQHJldHVybnMgVGhlIGZpcnN0IGBkYXRhYCBwYXJ0IGRldGVjdGVkIGluIHRoZSBjaHVuayAoaWYgYW55KS5cbiAgICovXG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZmluZCgocGFydCkgPT4gcGFydC5kYXRhKT8uZGF0YTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgdG9vbCByZXF1ZXN0IGZvdW5kIGluIHRoaXMgY2h1bmsuXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIGFsbCB0b29sIHJlcXVlc3QgZm91bmQgaW4gdGhpcyBjaHVuay5cbiAgICovXG4gIGdldCB0b29sUmVxdWVzdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5maWx0ZXIoXG4gICAgICAocGFydCkgPT4gISFwYXJ0LnRvb2xSZXF1ZXN0XG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIHRoZSBjaHVuayBpbnRvIHRoZSBkZXNpcmVkIG91dHB1dCBmb3JtYXQgdXNpbmcgdGhlIHBhcnNlciBhc3NvY2lhdGVkXG4gICAqIHdpdGggdGhlIGdlbmVyYXRlIHJlcXVlc3QsIG9yIGZhbGxzIGJhY2sgdG8gbmFpdmUgSlNPTiBwYXJzaW5nIG90aGVyd2lzZS5cbiAgICovXG4gIGdldCBvdXRwdXQoKSB7XG4gICAgaWYgKHRoaXMucGFyc2VyKSByZXR1cm4gdGhpcy5wYXJzZXIodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuZGF0YSB8fCAoMCwgaW1wb3J0X2V4dHJhY3QuZXh0cmFjdEpzb24pKHRoaXMuYWNjdW11bGF0ZWRUZXh0KTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIHJvbGU6IHRoaXMucm9sZSxcbiAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxuICAgICAgY29udGVudDogdGhpcy5jb250ZW50XG4gICAgfTtcbiAgICBpZiAodGhpcy5jdXN0b20pIHtcbiAgICAgIGRhdGEuY3VzdG9tID0gdGhpcy5jdXN0b207XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgR2VuZXJhdGVSZXNwb25zZUNodW5rXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/generate/chunk.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/generate/resolve-tool-requests.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/generate/resolve-tool-requests.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar resolve_tool_requests_exports = {};\n__export(resolve_tool_requests_exports, {\n  assertValidToolNames: () => assertValidToolNames,\n  resolveRestartedTools: () => resolveRestartedTools,\n  resolveResumeOption: () => resolveResumeOption,\n  resolveToolRequest: () => resolveToolRequest,\n  resolveToolRequests: () => resolveToolRequests,\n  toPendingOutput: () => toPendingOutput,\n  toToolMap: () => toToolMap\n});\nmodule.exports = __toCommonJS(resolve_tool_requests_exports);\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nvar import_logging = __webpack_require__(/*! @genkit-ai/core/logging */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/logging.js\");\nvar import_prompt = __webpack_require__(/*! ../prompt.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/prompt.js\");\nvar import_tool = __webpack_require__(/*! ../tool.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/tool.js\");\nfunction toToolMap(tools) {\n  assertValidToolNames(tools);\n  const out = {};\n  for (const tool of tools) {\n    const name = tool.__action.name;\n    const shortName = name.substring(name.lastIndexOf(\"/\") + 1);\n    out[shortName] = tool;\n  }\n  return out;\n}\nfunction assertValidToolNames(tools) {\n  const nameMap = {};\n  for (const tool of tools) {\n    const name = tool.__action.name;\n    const shortName = name.substring(name.lastIndexOf(\"/\") + 1);\n    if (nameMap[shortName]) {\n      throw new import_core.GenkitError({\n        status: \"INVALID_ARGUMENT\",\n        message: `Cannot provide two tools with the same name: '${name}' and '${nameMap[shortName]}'`\n      });\n    }\n    nameMap[shortName] = name;\n  }\n}\nfunction toRunOptions(part) {\n  const out = { metadata: part.metadata };\n  if (part.metadata?.resumed) out.resumed = part.metadata.resumed;\n  return out;\n}\nfunction toPendingOutput(part, response) {\n  return {\n    ...part,\n    metadata: {\n      ...part.metadata,\n      pendingOutput: response.toolResponse.output\n    }\n  };\n}\nasync function resolveToolRequest(rawRequest, part, toolMap, runOptions) {\n  const tool = toolMap[part.toolRequest.name];\n  if (!tool) {\n    throw new import_core.GenkitError({\n      status: \"NOT_FOUND\",\n      message: `Tool ${part.toolRequest.name} not found`,\n      detail: { request: rawRequest }\n    });\n  }\n  if ((0, import_prompt.isPromptAction)(tool)) {\n    const preamble = await tool(part.toolRequest.input);\n    const response = {\n      toolResponse: {\n        name: part.toolRequest.name,\n        ref: part.toolRequest.ref,\n        output: `transferred to ${part.toolRequest.name}`\n      }\n    };\n    return { preamble, response };\n  }\n  try {\n    const output = await tool(part.toolRequest.input, toRunOptions(part));\n    const response = (0, import_core.stripUndefinedProps)({\n      toolResponse: {\n        name: part.toolRequest.name,\n        ref: part.toolRequest.ref,\n        output\n      }\n    });\n    return { response };\n  } catch (e) {\n    if (e instanceof import_tool.ToolInterruptError || // There's an inexplicable case when the above type check fails, only in tests.\n    e.name === \"ToolInterruptError\") {\n      const ie = e;\n      import_logging.logger.debug(\n        `tool '${toolMap[part.toolRequest?.name].__action.name}' triggered an interrupt${ie.metadata ? `: ${JSON.stringify(ie.metadata)}` : \"\"}`\n      );\n      const interrupt = {\n        toolRequest: part.toolRequest,\n        metadata: { ...part.metadata, interrupt: ie.metadata || true }\n      };\n      return { interrupt };\n    }\n    throw e;\n  }\n}\nasync function resolveToolRequests(registry, rawRequest, generatedMessage) {\n  const toolMap = toToolMap(await (0, import_tool.resolveTools)(registry, rawRequest.tools));\n  const responseParts = [];\n  let hasInterrupts = false;\n  let transferPreamble;\n  const revisedModelMessage = {\n    ...generatedMessage,\n    content: [...generatedMessage.content]\n  };\n  await Promise.all(\n    revisedModelMessage.content.map(async (part, i) => {\n      if (!part.toolRequest) return;\n      const { preamble, response, interrupt } = await resolveToolRequest(\n        rawRequest,\n        part,\n        toolMap\n      );\n      if (preamble) {\n        if (transferPreamble) {\n          throw new import_core.GenkitError({\n            status: \"INVALID_ARGUMENT\",\n            message: `Model attempted to transfer to multiple prompt tools.`\n          });\n        }\n        transferPreamble = preamble;\n      }\n      if (response) {\n        responseParts.push(response);\n        revisedModelMessage.content.splice(\n          i,\n          1,\n          toPendingOutput(part, response)\n        );\n      }\n      if (interrupt) {\n        revisedModelMessage.content.splice(i, 1, interrupt);\n        hasInterrupts = true;\n      }\n    })\n  );\n  if (hasInterrupts) {\n    return { revisedModelMessage };\n  }\n  return {\n    toolMessage: { role: \"tool\", content: responseParts },\n    transferPreamble\n  };\n}\nfunction findCorrespondingToolRequest(parts, part) {\n  const name = part.toolRequest?.name || part.toolResponse?.name;\n  const ref = part.toolRequest?.ref || part.toolResponse?.ref;\n  return parts.find(\n    (p) => p.toolRequest?.name === name && p.toolRequest?.ref === ref\n  );\n}\nfunction findCorrespondingToolResponse(parts, part) {\n  const name = part.toolRequest?.name || part.toolResponse?.name;\n  const ref = part.toolRequest?.ref || part.toolResponse?.ref;\n  return parts.find(\n    (p) => p.toolResponse?.name === name && p.toolResponse?.ref === ref\n  );\n}\nasync function resolveResumedToolRequest(rawRequest, part, toolMap) {\n  if (part.metadata?.pendingOutput) {\n    const { pendingOutput, ...metadata } = part.metadata;\n    const toolResponse = {\n      toolResponse: {\n        name: part.toolRequest.name,\n        ref: part.toolRequest.ref,\n        output: pendingOutput\n      },\n      metadata: { ...metadata, source: \"pending\" }\n    };\n    return (0, import_core.stripUndefinedProps)({\n      toolResponse,\n      toolRequest: { ...part, metadata }\n    });\n  }\n  const providedResponse = findCorrespondingToolResponse(\n    rawRequest.resume?.respond || [],\n    part\n  );\n  if (providedResponse) {\n    const toolResponse = providedResponse;\n    const { interrupt, ...metadata } = part.metadata || {};\n    return (0, import_core.stripUndefinedProps)({\n      toolResponse,\n      toolRequest: {\n        ...part,\n        metadata: { ...metadata, resolvedInterrupt: interrupt }\n      }\n    });\n  }\n  const restartRequest = findCorrespondingToolRequest(\n    rawRequest.resume?.restart || [],\n    part\n  );\n  if (restartRequest) {\n    const { response, interrupt, preamble } = await resolveToolRequest(\n      rawRequest,\n      restartRequest,\n      toolMap\n    );\n    if (preamble) {\n      throw new import_core.GenkitError({\n        status: \"INTERNAL\",\n        message: `Prompt tool '${restartRequest.toolRequest.name}' executed inside 'restart' resolution. This should never happen.`\n      });\n    }\n    if (interrupt) return { interrupt };\n    if (response) {\n      const toolResponse = response;\n      const { interrupt: interrupt2, ...metadata } = part.metadata || {};\n      return (0, import_core.stripUndefinedProps)({\n        toolResponse,\n        toolRequest: {\n          ...part,\n          metadata: { ...metadata, resolvedInterrupt: interrupt2 }\n        }\n      });\n    }\n  }\n  throw new import_core.GenkitError({\n    status: \"INVALID_ARGUMENT\",\n    message: `Unresolved tool request '${part.toolRequest.name}${part.toolRequest.ref ? `#${part.toolRequest.ref}` : \"\"}' was not handled by the 'resume' argument. You must supply replies or restarts for all interrupted tool requests.'`\n  });\n}\nasync function resolveResumeOption(registry, rawRequest) {\n  if (!rawRequest.resume) return { revisedRequest: rawRequest };\n  const toolMap = toToolMap(await (0, import_tool.resolveTools)(registry, rawRequest.tools));\n  const messages = rawRequest.messages;\n  const lastMessage = messages.at(-1);\n  if (!lastMessage || lastMessage.role !== \"model\" || !lastMessage.content.find((p) => p.toolRequest)) {\n    throw new import_core.GenkitError({\n      status: \"FAILED_PRECONDITION\",\n      message: `Cannot 'resume' generation unless the previous message is a model message with at least one tool request.`\n    });\n  }\n  const toolResponses = [];\n  let interrupted = false;\n  lastMessage.content = await Promise.all(\n    lastMessage.content.map(async (part) => {\n      if (!(0, import_tool.isToolRequest)(part)) return part;\n      const resolved = await resolveResumedToolRequest(\n        rawRequest,\n        part,\n        toolMap\n      );\n      if (resolved.interrupt) {\n        interrupted = true;\n        return resolved.interrupt;\n      }\n      toolResponses.push(resolved.toolResponse);\n      return resolved.toolRequest;\n    })\n  );\n  if (interrupted) {\n    return {\n      interruptedResponse: {\n        finishReason: \"interrupted\",\n        finishMessage: \"One or more tools triggered interrupts while resuming generation. The model was not called.\",\n        message: lastMessage\n      }\n    };\n  }\n  const numToolRequests = lastMessage.content.filter(\n    (p) => !!p.toolRequest\n  ).length;\n  if (toolResponses.length !== numToolRequests) {\n    throw new import_core.GenkitError({\n      status: \"FAILED_PRECONDITION\",\n      message: `Expected ${numToolRequests} tool responses but resolved to ${toolResponses.length}.`,\n      detail: { toolResponses, message: lastMessage }\n    });\n  }\n  const toolMessage = {\n    role: \"tool\",\n    content: toolResponses,\n    metadata: {\n      resumed: rawRequest.resume.metadata || true\n    }\n  };\n  return (0, import_core.stripUndefinedProps)({\n    revisedRequest: {\n      ...rawRequest,\n      resume: void 0,\n      messages: [...messages, toolMessage]\n    },\n    toolMessage\n  });\n}\nasync function resolveRestartedTools(registry, rawRequest) {\n  const toolMap = toToolMap(await (0, import_tool.resolveTools)(registry, rawRequest.tools));\n  const lastMessage = rawRequest.messages.at(-1);\n  if (!lastMessage || lastMessage.role !== \"model\") return [];\n  const restarts = lastMessage.content.filter(\n    (p) => p.toolRequest && p.metadata?.resumed\n  );\n  return await Promise.all(\n    restarts.map(async (p) => {\n      const { response, interrupt } = await resolveToolRequest(\n        rawRequest,\n        p,\n        toolMap\n      );\n      if (interrupt) return interrupt;\n      return toPendingOutput(p, response);\n    })\n  );\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=resolve-tool-requests.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9nZW5lcmF0ZS9yZXNvbHZlLXRvb2wtcmVxdWVzdHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxxRkFBaUI7QUFDM0MscUJBQXFCLG1CQUFPLENBQUMsK0ZBQXlCO0FBQ3RELG9CQUFvQixtQkFBTyxDQUFDLGlGQUFjO0FBQzFDLGtCQUFrQixtQkFBTyxDQUFDLDZFQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxLQUFLLFNBQVMsbUJBQW1CO0FBQ25HLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msc0JBQXNCO0FBQ3hEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGFBQWE7QUFDYixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOENBQThDLDBCQUEwQixtQkFBbUIsNEJBQTRCLE9BQU87QUFDL0k7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQ0FBZ0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxtQkFBbUIsc0NBQXNDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0NBQWdDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdDQUFnQztBQUNqRSxPQUFPO0FBQ1A7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLGNBQWMscUNBQXFDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHNCQUFzQixFQUFFLDJCQUEyQixxQkFBcUIsT0FBTztBQUN4SCxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQixpQ0FBaUMscUJBQXFCO0FBQ2xHLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQVFMO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcS1JhbWFjaGFcXERvY3VtZW50c1xcU3VzdEFJbmV4IEdJdCBDb2RlXFxub2RlX21vZHVsZXNcXEBnZW5raXQtYWlcXGFpXFxsaWJcXGdlbmVyYXRlXFxyZXNvbHZlLXRvb2wtcmVxdWVzdHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIHJlc29sdmVfdG9vbF9yZXF1ZXN0c19leHBvcnRzID0ge307XG5fX2V4cG9ydChyZXNvbHZlX3Rvb2xfcmVxdWVzdHNfZXhwb3J0cywge1xuICBhc3NlcnRWYWxpZFRvb2xOYW1lczogKCkgPT4gYXNzZXJ0VmFsaWRUb29sTmFtZXMsXG4gIHJlc29sdmVSZXN0YXJ0ZWRUb29sczogKCkgPT4gcmVzb2x2ZVJlc3RhcnRlZFRvb2xzLFxuICByZXNvbHZlUmVzdW1lT3B0aW9uOiAoKSA9PiByZXNvbHZlUmVzdW1lT3B0aW9uLFxuICByZXNvbHZlVG9vbFJlcXVlc3Q6ICgpID0+IHJlc29sdmVUb29sUmVxdWVzdCxcbiAgcmVzb2x2ZVRvb2xSZXF1ZXN0czogKCkgPT4gcmVzb2x2ZVRvb2xSZXF1ZXN0cyxcbiAgdG9QZW5kaW5nT3V0cHV0OiAoKSA9PiB0b1BlbmRpbmdPdXRwdXQsXG4gIHRvVG9vbE1hcDogKCkgPT4gdG9Ub29sTWFwXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHJlc29sdmVfdG9vbF9yZXF1ZXN0c19leHBvcnRzKTtcbnZhciBpbXBvcnRfY29yZSA9IHJlcXVpcmUoXCJAZ2Vua2l0LWFpL2NvcmVcIik7XG52YXIgaW1wb3J0X2xvZ2dpbmcgPSByZXF1aXJlKFwiQGdlbmtpdC1haS9jb3JlL2xvZ2dpbmdcIik7XG52YXIgaW1wb3J0X3Byb21wdCA9IHJlcXVpcmUoXCIuLi9wcm9tcHQuanNcIik7XG52YXIgaW1wb3J0X3Rvb2wgPSByZXF1aXJlKFwiLi4vdG9vbC5qc1wiKTtcbmZ1bmN0aW9uIHRvVG9vbE1hcCh0b29scykge1xuICBhc3NlcnRWYWxpZFRvb2xOYW1lcyh0b29scyk7XG4gIGNvbnN0IG91dCA9IHt9O1xuICBmb3IgKGNvbnN0IHRvb2wgb2YgdG9vbHMpIHtcbiAgICBjb25zdCBuYW1lID0gdG9vbC5fX2FjdGlvbi5uYW1lO1xuICAgIGNvbnN0IHNob3J0TmFtZSA9IG5hbWUuc3Vic3RyaW5nKG5hbWUubGFzdEluZGV4T2YoXCIvXCIpICsgMSk7XG4gICAgb3V0W3Nob3J0TmFtZV0gPSB0b29sO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBhc3NlcnRWYWxpZFRvb2xOYW1lcyh0b29scykge1xuICBjb25zdCBuYW1lTWFwID0ge307XG4gIGZvciAoY29uc3QgdG9vbCBvZiB0b29scykge1xuICAgIGNvbnN0IG5hbWUgPSB0b29sLl9fYWN0aW9uLm5hbWU7XG4gICAgY29uc3Qgc2hvcnROYW1lID0gbmFtZS5zdWJzdHJpbmcobmFtZS5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcbiAgICBpZiAobmFtZU1hcFtzaG9ydE5hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgaW1wb3J0X2NvcmUuR2Vua2l0RXJyb3Ioe1xuICAgICAgICBzdGF0dXM6IFwiSU5WQUxJRF9BUkdVTUVOVFwiLFxuICAgICAgICBtZXNzYWdlOiBgQ2Fubm90IHByb3ZpZGUgdHdvIHRvb2xzIHdpdGggdGhlIHNhbWUgbmFtZTogJyR7bmFtZX0nIGFuZCAnJHtuYW1lTWFwW3Nob3J0TmFtZV19J2BcbiAgICAgIH0pO1xuICAgIH1cbiAgICBuYW1lTWFwW3Nob3J0TmFtZV0gPSBuYW1lO1xuICB9XG59XG5mdW5jdGlvbiB0b1J1bk9wdGlvbnMocGFydCkge1xuICBjb25zdCBvdXQgPSB7IG1ldGFkYXRhOiBwYXJ0Lm1ldGFkYXRhIH07XG4gIGlmIChwYXJ0Lm1ldGFkYXRhPy5yZXN1bWVkKSBvdXQucmVzdW1lZCA9IHBhcnQubWV0YWRhdGEucmVzdW1lZDtcbiAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIHRvUGVuZGluZ091dHB1dChwYXJ0LCByZXNwb25zZSkge1xuICByZXR1cm4ge1xuICAgIC4uLnBhcnQsXG4gICAgbWV0YWRhdGE6IHtcbiAgICAgIC4uLnBhcnQubWV0YWRhdGEsXG4gICAgICBwZW5kaW5nT3V0cHV0OiByZXNwb25zZS50b29sUmVzcG9uc2Uub3V0cHV0XG4gICAgfVxuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVRvb2xSZXF1ZXN0KHJhd1JlcXVlc3QsIHBhcnQsIHRvb2xNYXAsIHJ1bk9wdGlvbnMpIHtcbiAgY29uc3QgdG9vbCA9IHRvb2xNYXBbcGFydC50b29sUmVxdWVzdC5uYW1lXTtcbiAgaWYgKCF0b29sKSB7XG4gICAgdGhyb3cgbmV3IGltcG9ydF9jb3JlLkdlbmtpdEVycm9yKHtcbiAgICAgIHN0YXR1czogXCJOT1RfRk9VTkRcIixcbiAgICAgIG1lc3NhZ2U6IGBUb29sICR7cGFydC50b29sUmVxdWVzdC5uYW1lfSBub3QgZm91bmRgLFxuICAgICAgZGV0YWlsOiB7IHJlcXVlc3Q6IHJhd1JlcXVlc3QgfVxuICAgIH0pO1xuICB9XG4gIGlmICgoMCwgaW1wb3J0X3Byb21wdC5pc1Byb21wdEFjdGlvbikodG9vbCkpIHtcbiAgICBjb25zdCBwcmVhbWJsZSA9IGF3YWl0IHRvb2wocGFydC50b29sUmVxdWVzdC5pbnB1dCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICB0b29sUmVzcG9uc2U6IHtcbiAgICAgICAgbmFtZTogcGFydC50b29sUmVxdWVzdC5uYW1lLFxuICAgICAgICByZWY6IHBhcnQudG9vbFJlcXVlc3QucmVmLFxuICAgICAgICBvdXRwdXQ6IGB0cmFuc2ZlcnJlZCB0byAke3BhcnQudG9vbFJlcXVlc3QubmFtZX1gXG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4geyBwcmVhbWJsZSwgcmVzcG9uc2UgfTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHRvb2wocGFydC50b29sUmVxdWVzdC5pbnB1dCwgdG9SdW5PcHRpb25zKHBhcnQpKTtcbiAgICBjb25zdCByZXNwb25zZSA9ICgwLCBpbXBvcnRfY29yZS5zdHJpcFVuZGVmaW5lZFByb3BzKSh7XG4gICAgICB0b29sUmVzcG9uc2U6IHtcbiAgICAgICAgbmFtZTogcGFydC50b29sUmVxdWVzdC5uYW1lLFxuICAgICAgICByZWY6IHBhcnQudG9vbFJlcXVlc3QucmVmLFxuICAgICAgICBvdXRwdXRcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4geyByZXNwb25zZSB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBpbXBvcnRfdG9vbC5Ub29sSW50ZXJydXB0RXJyb3IgfHwgLy8gVGhlcmUncyBhbiBpbmV4cGxpY2FibGUgY2FzZSB3aGVuIHRoZSBhYm92ZSB0eXBlIGNoZWNrIGZhaWxzLCBvbmx5IGluIHRlc3RzLlxuICAgIGUubmFtZSA9PT0gXCJUb29sSW50ZXJydXB0RXJyb3JcIikge1xuICAgICAgY29uc3QgaWUgPSBlO1xuICAgICAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLmRlYnVnKFxuICAgICAgICBgdG9vbCAnJHt0b29sTWFwW3BhcnQudG9vbFJlcXVlc3Q/Lm5hbWVdLl9fYWN0aW9uLm5hbWV9JyB0cmlnZ2VyZWQgYW4gaW50ZXJydXB0JHtpZS5tZXRhZGF0YSA/IGA6ICR7SlNPTi5zdHJpbmdpZnkoaWUubWV0YWRhdGEpfWAgOiBcIlwifWBcbiAgICAgICk7XG4gICAgICBjb25zdCBpbnRlcnJ1cHQgPSB7XG4gICAgICAgIHRvb2xSZXF1ZXN0OiBwYXJ0LnRvb2xSZXF1ZXN0LFxuICAgICAgICBtZXRhZGF0YTogeyAuLi5wYXJ0Lm1ldGFkYXRhLCBpbnRlcnJ1cHQ6IGllLm1ldGFkYXRhIHx8IHRydWUgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7IGludGVycnVwdCB9O1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlVG9vbFJlcXVlc3RzKHJlZ2lzdHJ5LCByYXdSZXF1ZXN0LCBnZW5lcmF0ZWRNZXNzYWdlKSB7XG4gIGNvbnN0IHRvb2xNYXAgPSB0b1Rvb2xNYXAoYXdhaXQgKDAsIGltcG9ydF90b29sLnJlc29sdmVUb29scykocmVnaXN0cnksIHJhd1JlcXVlc3QudG9vbHMpKTtcbiAgY29uc3QgcmVzcG9uc2VQYXJ0cyA9IFtdO1xuICBsZXQgaGFzSW50ZXJydXB0cyA9IGZhbHNlO1xuICBsZXQgdHJhbnNmZXJQcmVhbWJsZTtcbiAgY29uc3QgcmV2aXNlZE1vZGVsTWVzc2FnZSA9IHtcbiAgICAuLi5nZW5lcmF0ZWRNZXNzYWdlLFxuICAgIGNvbnRlbnQ6IFsuLi5nZW5lcmF0ZWRNZXNzYWdlLmNvbnRlbnRdXG4gIH07XG4gIGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHJldmlzZWRNb2RlbE1lc3NhZ2UuY29udGVudC5tYXAoYXN5bmMgKHBhcnQsIGkpID0+IHtcbiAgICAgIGlmICghcGFydC50b29sUmVxdWVzdCkgcmV0dXJuO1xuICAgICAgY29uc3QgeyBwcmVhbWJsZSwgcmVzcG9uc2UsIGludGVycnVwdCB9ID0gYXdhaXQgcmVzb2x2ZVRvb2xSZXF1ZXN0KFxuICAgICAgICByYXdSZXF1ZXN0LFxuICAgICAgICBwYXJ0LFxuICAgICAgICB0b29sTWFwXG4gICAgICApO1xuICAgICAgaWYgKHByZWFtYmxlKSB7XG4gICAgICAgIGlmICh0cmFuc2ZlclByZWFtYmxlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGltcG9ydF9jb3JlLkdlbmtpdEVycm9yKHtcbiAgICAgICAgICAgIHN0YXR1czogXCJJTlZBTElEX0FSR1VNRU5UXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBgTW9kZWwgYXR0ZW1wdGVkIHRvIHRyYW5zZmVyIHRvIG11bHRpcGxlIHByb21wdCB0b29scy5gXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNmZXJQcmVhbWJsZSA9IHByZWFtYmxlO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgIHJlc3BvbnNlUGFydHMucHVzaChyZXNwb25zZSk7XG4gICAgICAgIHJldmlzZWRNb2RlbE1lc3NhZ2UuY29udGVudC5zcGxpY2UoXG4gICAgICAgICAgaSxcbiAgICAgICAgICAxLFxuICAgICAgICAgIHRvUGVuZGluZ091dHB1dChwYXJ0LCByZXNwb25zZSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnRlcnJ1cHQpIHtcbiAgICAgICAgcmV2aXNlZE1vZGVsTWVzc2FnZS5jb250ZW50LnNwbGljZShpLCAxLCBpbnRlcnJ1cHQpO1xuICAgICAgICBoYXNJbnRlcnJ1cHRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KVxuICApO1xuICBpZiAoaGFzSW50ZXJydXB0cykge1xuICAgIHJldHVybiB7IHJldmlzZWRNb2RlbE1lc3NhZ2UgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRvb2xNZXNzYWdlOiB7IHJvbGU6IFwidG9vbFwiLCBjb250ZW50OiByZXNwb25zZVBhcnRzIH0sXG4gICAgdHJhbnNmZXJQcmVhbWJsZVxuICB9O1xufVxuZnVuY3Rpb24gZmluZENvcnJlc3BvbmRpbmdUb29sUmVxdWVzdChwYXJ0cywgcGFydCkge1xuICBjb25zdCBuYW1lID0gcGFydC50b29sUmVxdWVzdD8ubmFtZSB8fCBwYXJ0LnRvb2xSZXNwb25zZT8ubmFtZTtcbiAgY29uc3QgcmVmID0gcGFydC50b29sUmVxdWVzdD8ucmVmIHx8IHBhcnQudG9vbFJlc3BvbnNlPy5yZWY7XG4gIHJldHVybiBwYXJ0cy5maW5kKFxuICAgIChwKSA9PiBwLnRvb2xSZXF1ZXN0Py5uYW1lID09PSBuYW1lICYmIHAudG9vbFJlcXVlc3Q/LnJlZiA9PT0gcmVmXG4gICk7XG59XG5mdW5jdGlvbiBmaW5kQ29ycmVzcG9uZGluZ1Rvb2xSZXNwb25zZShwYXJ0cywgcGFydCkge1xuICBjb25zdCBuYW1lID0gcGFydC50b29sUmVxdWVzdD8ubmFtZSB8fCBwYXJ0LnRvb2xSZXNwb25zZT8ubmFtZTtcbiAgY29uc3QgcmVmID0gcGFydC50b29sUmVxdWVzdD8ucmVmIHx8IHBhcnQudG9vbFJlc3BvbnNlPy5yZWY7XG4gIHJldHVybiBwYXJ0cy5maW5kKFxuICAgIChwKSA9PiBwLnRvb2xSZXNwb25zZT8ubmFtZSA9PT0gbmFtZSAmJiBwLnRvb2xSZXNwb25zZT8ucmVmID09PSByZWZcbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVSZXN1bWVkVG9vbFJlcXVlc3QocmF3UmVxdWVzdCwgcGFydCwgdG9vbE1hcCkge1xuICBpZiAocGFydC5tZXRhZGF0YT8ucGVuZGluZ091dHB1dCkge1xuICAgIGNvbnN0IHsgcGVuZGluZ091dHB1dCwgLi4ubWV0YWRhdGEgfSA9IHBhcnQubWV0YWRhdGE7XG4gICAgY29uc3QgdG9vbFJlc3BvbnNlID0ge1xuICAgICAgdG9vbFJlc3BvbnNlOiB7XG4gICAgICAgIG5hbWU6IHBhcnQudG9vbFJlcXVlc3QubmFtZSxcbiAgICAgICAgcmVmOiBwYXJ0LnRvb2xSZXF1ZXN0LnJlZixcbiAgICAgICAgb3V0cHV0OiBwZW5kaW5nT3V0cHV0XG4gICAgICB9LFxuICAgICAgbWV0YWRhdGE6IHsgLi4ubWV0YWRhdGEsIHNvdXJjZTogXCJwZW5kaW5nXCIgfVxuICAgIH07XG4gICAgcmV0dXJuICgwLCBpbXBvcnRfY29yZS5zdHJpcFVuZGVmaW5lZFByb3BzKSh7XG4gICAgICB0b29sUmVzcG9uc2UsXG4gICAgICB0b29sUmVxdWVzdDogeyAuLi5wYXJ0LCBtZXRhZGF0YSB9XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgcHJvdmlkZWRSZXNwb25zZSA9IGZpbmRDb3JyZXNwb25kaW5nVG9vbFJlc3BvbnNlKFxuICAgIHJhd1JlcXVlc3QucmVzdW1lPy5yZXNwb25kIHx8IFtdLFxuICAgIHBhcnRcbiAgKTtcbiAgaWYgKHByb3ZpZGVkUmVzcG9uc2UpIHtcbiAgICBjb25zdCB0b29sUmVzcG9uc2UgPSBwcm92aWRlZFJlc3BvbnNlO1xuICAgIGNvbnN0IHsgaW50ZXJydXB0LCAuLi5tZXRhZGF0YSB9ID0gcGFydC5tZXRhZGF0YSB8fCB7fTtcbiAgICByZXR1cm4gKDAsIGltcG9ydF9jb3JlLnN0cmlwVW5kZWZpbmVkUHJvcHMpKHtcbiAgICAgIHRvb2xSZXNwb25zZSxcbiAgICAgIHRvb2xSZXF1ZXN0OiB7XG4gICAgICAgIC4uLnBhcnQsXG4gICAgICAgIG1ldGFkYXRhOiB7IC4uLm1ldGFkYXRhLCByZXNvbHZlZEludGVycnVwdDogaW50ZXJydXB0IH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb25zdCByZXN0YXJ0UmVxdWVzdCA9IGZpbmRDb3JyZXNwb25kaW5nVG9vbFJlcXVlc3QoXG4gICAgcmF3UmVxdWVzdC5yZXN1bWU/LnJlc3RhcnQgfHwgW10sXG4gICAgcGFydFxuICApO1xuICBpZiAocmVzdGFydFJlcXVlc3QpIHtcbiAgICBjb25zdCB7IHJlc3BvbnNlLCBpbnRlcnJ1cHQsIHByZWFtYmxlIH0gPSBhd2FpdCByZXNvbHZlVG9vbFJlcXVlc3QoXG4gICAgICByYXdSZXF1ZXN0LFxuICAgICAgcmVzdGFydFJlcXVlc3QsXG4gICAgICB0b29sTWFwXG4gICAgKTtcbiAgICBpZiAocHJlYW1ibGUpIHtcbiAgICAgIHRocm93IG5ldyBpbXBvcnRfY29yZS5HZW5raXRFcnJvcih7XG4gICAgICAgIHN0YXR1czogXCJJTlRFUk5BTFwiLFxuICAgICAgICBtZXNzYWdlOiBgUHJvbXB0IHRvb2wgJyR7cmVzdGFydFJlcXVlc3QudG9vbFJlcXVlc3QubmFtZX0nIGV4ZWN1dGVkIGluc2lkZSAncmVzdGFydCcgcmVzb2x1dGlvbi4gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLmBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaW50ZXJydXB0KSByZXR1cm4geyBpbnRlcnJ1cHQgfTtcbiAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgIGNvbnN0IHRvb2xSZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgY29uc3QgeyBpbnRlcnJ1cHQ6IGludGVycnVwdDIsIC4uLm1ldGFkYXRhIH0gPSBwYXJ0Lm1ldGFkYXRhIHx8IHt9O1xuICAgICAgcmV0dXJuICgwLCBpbXBvcnRfY29yZS5zdHJpcFVuZGVmaW5lZFByb3BzKSh7XG4gICAgICAgIHRvb2xSZXNwb25zZSxcbiAgICAgICAgdG9vbFJlcXVlc3Q6IHtcbiAgICAgICAgICAuLi5wYXJ0LFxuICAgICAgICAgIG1ldGFkYXRhOiB7IC4uLm1ldGFkYXRhLCByZXNvbHZlZEludGVycnVwdDogaW50ZXJydXB0MiB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgaW1wb3J0X2NvcmUuR2Vua2l0RXJyb3Ioe1xuICAgIHN0YXR1czogXCJJTlZBTElEX0FSR1VNRU5UXCIsXG4gICAgbWVzc2FnZTogYFVucmVzb2x2ZWQgdG9vbCByZXF1ZXN0ICcke3BhcnQudG9vbFJlcXVlc3QubmFtZX0ke3BhcnQudG9vbFJlcXVlc3QucmVmID8gYCMke3BhcnQudG9vbFJlcXVlc3QucmVmfWAgOiBcIlwifScgd2FzIG5vdCBoYW5kbGVkIGJ5IHRoZSAncmVzdW1lJyBhcmd1bWVudC4gWW91IG11c3Qgc3VwcGx5IHJlcGxpZXMgb3IgcmVzdGFydHMgZm9yIGFsbCBpbnRlcnJ1cHRlZCB0b29sIHJlcXVlc3RzLidgXG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVJlc3VtZU9wdGlvbihyZWdpc3RyeSwgcmF3UmVxdWVzdCkge1xuICBpZiAoIXJhd1JlcXVlc3QucmVzdW1lKSByZXR1cm4geyByZXZpc2VkUmVxdWVzdDogcmF3UmVxdWVzdCB9O1xuICBjb25zdCB0b29sTWFwID0gdG9Ub29sTWFwKGF3YWl0ICgwLCBpbXBvcnRfdG9vbC5yZXNvbHZlVG9vbHMpKHJlZ2lzdHJ5LCByYXdSZXF1ZXN0LnRvb2xzKSk7XG4gIGNvbnN0IG1lc3NhZ2VzID0gcmF3UmVxdWVzdC5tZXNzYWdlcztcbiAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlcy5hdCgtMSk7XG4gIGlmICghbGFzdE1lc3NhZ2UgfHwgbGFzdE1lc3NhZ2Uucm9sZSAhPT0gXCJtb2RlbFwiIHx8ICFsYXN0TWVzc2FnZS5jb250ZW50LmZpbmQoKHApID0+IHAudG9vbFJlcXVlc3QpKSB7XG4gICAgdGhyb3cgbmV3IGltcG9ydF9jb3JlLkdlbmtpdEVycm9yKHtcbiAgICAgIHN0YXR1czogXCJGQUlMRURfUFJFQ09ORElUSU9OXCIsXG4gICAgICBtZXNzYWdlOiBgQ2Fubm90ICdyZXN1bWUnIGdlbmVyYXRpb24gdW5sZXNzIHRoZSBwcmV2aW91cyBtZXNzYWdlIGlzIGEgbW9kZWwgbWVzc2FnZSB3aXRoIGF0IGxlYXN0IG9uZSB0b29sIHJlcXVlc3QuYFxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHRvb2xSZXNwb25zZXMgPSBbXTtcbiAgbGV0IGludGVycnVwdGVkID0gZmFsc2U7XG4gIGxhc3RNZXNzYWdlLmNvbnRlbnQgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBsYXN0TWVzc2FnZS5jb250ZW50Lm1hcChhc3luYyAocGFydCkgPT4ge1xuICAgICAgaWYgKCEoMCwgaW1wb3J0X3Rvb2wuaXNUb29sUmVxdWVzdCkocGFydCkpIHJldHVybiBwYXJ0O1xuICAgICAgY29uc3QgcmVzb2x2ZWQgPSBhd2FpdCByZXNvbHZlUmVzdW1lZFRvb2xSZXF1ZXN0KFxuICAgICAgICByYXdSZXF1ZXN0LFxuICAgICAgICBwYXJ0LFxuICAgICAgICB0b29sTWFwXG4gICAgICApO1xuICAgICAgaWYgKHJlc29sdmVkLmludGVycnVwdCkge1xuICAgICAgICBpbnRlcnJ1cHRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiByZXNvbHZlZC5pbnRlcnJ1cHQ7XG4gICAgICB9XG4gICAgICB0b29sUmVzcG9uc2VzLnB1c2gocmVzb2x2ZWQudG9vbFJlc3BvbnNlKTtcbiAgICAgIHJldHVybiByZXNvbHZlZC50b29sUmVxdWVzdDtcbiAgICB9KVxuICApO1xuICBpZiAoaW50ZXJydXB0ZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW50ZXJydXB0ZWRSZXNwb25zZToge1xuICAgICAgICBmaW5pc2hSZWFzb246IFwiaW50ZXJydXB0ZWRcIixcbiAgICAgICAgZmluaXNoTWVzc2FnZTogXCJPbmUgb3IgbW9yZSB0b29scyB0cmlnZ2VyZWQgaW50ZXJydXB0cyB3aGlsZSByZXN1bWluZyBnZW5lcmF0aW9uLiBUaGUgbW9kZWwgd2FzIG5vdCBjYWxsZWQuXCIsXG4gICAgICAgIG1lc3NhZ2U6IGxhc3RNZXNzYWdlXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBjb25zdCBudW1Ub29sUmVxdWVzdHMgPSBsYXN0TWVzc2FnZS5jb250ZW50LmZpbHRlcihcbiAgICAocCkgPT4gISFwLnRvb2xSZXF1ZXN0XG4gICkubGVuZ3RoO1xuICBpZiAodG9vbFJlc3BvbnNlcy5sZW5ndGggIT09IG51bVRvb2xSZXF1ZXN0cykge1xuICAgIHRocm93IG5ldyBpbXBvcnRfY29yZS5HZW5raXRFcnJvcih7XG4gICAgICBzdGF0dXM6IFwiRkFJTEVEX1BSRUNPTkRJVElPTlwiLFxuICAgICAgbWVzc2FnZTogYEV4cGVjdGVkICR7bnVtVG9vbFJlcXVlc3RzfSB0b29sIHJlc3BvbnNlcyBidXQgcmVzb2x2ZWQgdG8gJHt0b29sUmVzcG9uc2VzLmxlbmd0aH0uYCxcbiAgICAgIGRldGFpbDogeyB0b29sUmVzcG9uc2VzLCBtZXNzYWdlOiBsYXN0TWVzc2FnZSB9XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgdG9vbE1lc3NhZ2UgPSB7XG4gICAgcm9sZTogXCJ0b29sXCIsXG4gICAgY29udGVudDogdG9vbFJlc3BvbnNlcyxcbiAgICBtZXRhZGF0YToge1xuICAgICAgcmVzdW1lZDogcmF3UmVxdWVzdC5yZXN1bWUubWV0YWRhdGEgfHwgdHJ1ZVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuICgwLCBpbXBvcnRfY29yZS5zdHJpcFVuZGVmaW5lZFByb3BzKSh7XG4gICAgcmV2aXNlZFJlcXVlc3Q6IHtcbiAgICAgIC4uLnJhd1JlcXVlc3QsXG4gICAgICByZXN1bWU6IHZvaWQgMCxcbiAgICAgIG1lc3NhZ2VzOiBbLi4ubWVzc2FnZXMsIHRvb2xNZXNzYWdlXVxuICAgIH0sXG4gICAgdG9vbE1lc3NhZ2VcbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlUmVzdGFydGVkVG9vbHMocmVnaXN0cnksIHJhd1JlcXVlc3QpIHtcbiAgY29uc3QgdG9vbE1hcCA9IHRvVG9vbE1hcChhd2FpdCAoMCwgaW1wb3J0X3Rvb2wucmVzb2x2ZVRvb2xzKShyZWdpc3RyeSwgcmF3UmVxdWVzdC50b29scykpO1xuICBjb25zdCBsYXN0TWVzc2FnZSA9IHJhd1JlcXVlc3QubWVzc2FnZXMuYXQoLTEpO1xuICBpZiAoIWxhc3RNZXNzYWdlIHx8IGxhc3RNZXNzYWdlLnJvbGUgIT09IFwibW9kZWxcIikgcmV0dXJuIFtdO1xuICBjb25zdCByZXN0YXJ0cyA9IGxhc3RNZXNzYWdlLmNvbnRlbnQuZmlsdGVyKFxuICAgIChwKSA9PiBwLnRvb2xSZXF1ZXN0ICYmIHAubWV0YWRhdGE/LnJlc3VtZWRcbiAgKTtcbiAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHJlc3RhcnRzLm1hcChhc3luYyAocCkgPT4ge1xuICAgICAgY29uc3QgeyByZXNwb25zZSwgaW50ZXJydXB0IH0gPSBhd2FpdCByZXNvbHZlVG9vbFJlcXVlc3QoXG4gICAgICAgIHJhd1JlcXVlc3QsXG4gICAgICAgIHAsXG4gICAgICAgIHRvb2xNYXBcbiAgICAgICk7XG4gICAgICBpZiAoaW50ZXJydXB0KSByZXR1cm4gaW50ZXJydXB0O1xuICAgICAgcmV0dXJuIHRvUGVuZGluZ091dHB1dChwLCByZXNwb25zZSk7XG4gICAgfSlcbiAgKTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBhc3NlcnRWYWxpZFRvb2xOYW1lcyxcbiAgcmVzb2x2ZVJlc3RhcnRlZFRvb2xzLFxuICByZXNvbHZlUmVzdW1lT3B0aW9uLFxuICByZXNvbHZlVG9vbFJlcXVlc3QsXG4gIHJlc29sdmVUb29sUmVxdWVzdHMsXG4gIHRvUGVuZGluZ091dHB1dCxcbiAgdG9Ub29sTWFwXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmUtdG9vbC1yZXF1ZXN0cy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/generate/resolve-tool-requests.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/generate/response.js":
/*!*************************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/generate/response.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar response_exports = {};\n__export(response_exports, {\n  GenerateResponse: () => GenerateResponse\n});\nmodule.exports = __toCommonJS(response_exports);\nvar import_schema = __webpack_require__(/*! @genkit-ai/core/schema */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/schema.js\");\nvar import_generate = __webpack_require__(/*! ../generate.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/generate.js\");\nvar import_message = __webpack_require__(/*! ../message.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/message.js\");\nclass GenerateResponse {\n  /** The generated message. */\n  message;\n  /** The reason generation stopped for this request. */\n  finishReason;\n  /** Additional information about why the model stopped generating, if any. */\n  finishMessage;\n  /** Usage information. */\n  usage;\n  /** Provider-specific response data. */\n  custom;\n  /** Provider-specific response data. */\n  raw;\n  /** The request that generated this response. */\n  request;\n  /** Model generation long running operation. */\n  operation;\n  /** Name of the model used. */\n  model;\n  /** The parser for output parsing of this response. */\n  parser;\n  constructor(response, options) {\n    const generatedMessage = response.message || response.candidates?.[0]?.message;\n    if (generatedMessage) {\n      this.message = new import_message.Message(generatedMessage, {\n        parser: options?.parser\n      });\n    }\n    this.finishReason = response.finishReason || response.candidates?.[0]?.finishReason;\n    this.finishMessage = response.finishMessage || response.candidates?.[0]?.finishMessage;\n    this.usage = response.usage || {};\n    this.custom = response.custom || {};\n    this.raw = response.raw || this.custom;\n    this.request = options?.request;\n    this.operation = response?.operation;\n  }\n  /**\n   * Throws an error if the response does not contain valid output.\n   */\n  assertValid() {\n    if (this.finishReason === \"blocked\") {\n      throw new import_generate.GenerationBlockedError(\n        this,\n        `Generation blocked${this.finishMessage ? `: ${this.finishMessage}` : \".\"}`\n      );\n    }\n    if (!this.message && !this.operation) {\n      throw new import_generate.GenerationResponseError(\n        this,\n        `Model did not generate a message. Finish reason: '${this.finishReason}': ${this.finishMessage}`\n      );\n    }\n  }\n  /**\n   * Throws an error if the response does not conform to expected schema.\n   */\n  assertValidSchema(request) {\n    if (request?.output?.schema || this.request?.output?.schema) {\n      const o = this.output;\n      (0, import_schema.parseSchema)(o, {\n        jsonSchema: request?.output?.schema || this.request?.output?.schema\n      });\n    }\n  }\n  isValid(request) {\n    try {\n      this.assertValid();\n      this.assertValidSchema(request);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\n   * If the generated message contains a `data` part, it is returned. Otherwise,\n   * the `output()` method extracts the first valid JSON object or array from the text\n   * contained in the selected candidate's message and returns it.\n   *\n   * @returns The structured output contained in the selected candidate.\n   */\n  get output() {\n    return this.message?.output || null;\n  }\n  /**\n   * Concatenates all `text` parts present in the generated message with no delimiter.\n   * @returns A string of all concatenated text parts.\n   */\n  get text() {\n    return this.message?.text || \"\";\n  }\n  /**\n   * Concatenates all `reasoning` parts present in the generated message with no delimiter.\n   * @returns A string of all concatenated reasoning parts.\n   */\n  get reasoning() {\n    return this.message?.reasoning || \"\";\n  }\n  /**\n   * Returns the first detected media part in the generated message. Useful for\n   * extracting (for example) an image from a generation expected to create one.\n   * @returns The first detected `media` part in the candidate.\n   */\n  get media() {\n    return this.message?.media || null;\n  }\n  /**\n   * Returns the first detected `data` part of the generated message.\n   * @returns The first `data` part detected in the candidate (if any).\n   */\n  get data() {\n    return this.message?.data || null;\n  }\n  /**\n   * Returns all tool request found in the generated message.\n   * @returns Array of all tool request found in the candidate.\n   */\n  get toolRequests() {\n    return this.message?.toolRequests || [];\n  }\n  /**\n   * Returns all tool requests annotated as interrupts found in the generated message.\n   * @returns A list of ToolRequestParts.\n   */\n  get interrupts() {\n    return this.message?.interrupts || [];\n  }\n  /**\n   * Returns the message history for the request by concatenating the model\n   * response to the list of messages from the request. The result of this\n   * method can be safely serialized to JSON for persistence in a database.\n   * @returns A serializable list of messages compatible with `generate({history})`.\n   */\n  get messages() {\n    if (!this.request)\n      throw new Error(\n        \"Can't construct history for response without request reference.\"\n      );\n    if (!this.message)\n      throw new Error(\n        \"Can't construct history for response without generated message.\"\n      );\n    return [...this.request?.messages, this.message.toJSON()];\n  }\n  toJSON() {\n    const out = {\n      message: this.message?.toJSON(),\n      finishReason: this.finishReason,\n      finishMessage: this.finishMessage,\n      usage: this.usage,\n      custom: this.custom.toJSON?.() || this.custom,\n      request: this.request,\n      operation: this.operation\n    };\n    if (!out.finishMessage) delete out.finishMessage;\n    if (!out.request) delete out.request;\n    if (!out.operation) delete out.operation;\n    return out;\n  }\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=response.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9nZW5lcmF0ZS9yZXNwb25zZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLDZGQUF3QjtBQUNwRCxzQkFBc0IsbUJBQU8sQ0FBQyxxRkFBZ0I7QUFDOUMscUJBQXFCLG1CQUFPLENBQUMsbUZBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwwQkFBMEIsbUJBQW1CLFFBQVE7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxrQkFBa0IsS0FBSyxtQkFBbUI7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsUUFBUTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUVMO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcS1JhbWFjaGFcXERvY3VtZW50c1xcU3VzdEFJbmV4IEdJdCBDb2RlXFxub2RlX21vZHVsZXNcXEBnZW5raXQtYWlcXGFpXFxsaWJcXGdlbmVyYXRlXFxyZXNwb25zZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgcmVzcG9uc2VfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocmVzcG9uc2VfZXhwb3J0cywge1xuICBHZW5lcmF0ZVJlc3BvbnNlOiAoKSA9PiBHZW5lcmF0ZVJlc3BvbnNlXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHJlc3BvbnNlX2V4cG9ydHMpO1xudmFyIGltcG9ydF9zY2hlbWEgPSByZXF1aXJlKFwiQGdlbmtpdC1haS9jb3JlL3NjaGVtYVwiKTtcbnZhciBpbXBvcnRfZ2VuZXJhdGUgPSByZXF1aXJlKFwiLi4vZ2VuZXJhdGUuanNcIik7XG52YXIgaW1wb3J0X21lc3NhZ2UgPSByZXF1aXJlKFwiLi4vbWVzc2FnZS5qc1wiKTtcbmNsYXNzIEdlbmVyYXRlUmVzcG9uc2Uge1xuICAvKiogVGhlIGdlbmVyYXRlZCBtZXNzYWdlLiAqL1xuICBtZXNzYWdlO1xuICAvKiogVGhlIHJlYXNvbiBnZW5lcmF0aW9uIHN0b3BwZWQgZm9yIHRoaXMgcmVxdWVzdC4gKi9cbiAgZmluaXNoUmVhc29uO1xuICAvKiogQWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB3aHkgdGhlIG1vZGVsIHN0b3BwZWQgZ2VuZXJhdGluZywgaWYgYW55LiAqL1xuICBmaW5pc2hNZXNzYWdlO1xuICAvKiogVXNhZ2UgaW5mb3JtYXRpb24uICovXG4gIHVzYWdlO1xuICAvKiogUHJvdmlkZXItc3BlY2lmaWMgcmVzcG9uc2UgZGF0YS4gKi9cbiAgY3VzdG9tO1xuICAvKiogUHJvdmlkZXItc3BlY2lmaWMgcmVzcG9uc2UgZGF0YS4gKi9cbiAgcmF3O1xuICAvKiogVGhlIHJlcXVlc3QgdGhhdCBnZW5lcmF0ZWQgdGhpcyByZXNwb25zZS4gKi9cbiAgcmVxdWVzdDtcbiAgLyoqIE1vZGVsIGdlbmVyYXRpb24gbG9uZyBydW5uaW5nIG9wZXJhdGlvbi4gKi9cbiAgb3BlcmF0aW9uO1xuICAvKiogTmFtZSBvZiB0aGUgbW9kZWwgdXNlZC4gKi9cbiAgbW9kZWw7XG4gIC8qKiBUaGUgcGFyc2VyIGZvciBvdXRwdXQgcGFyc2luZyBvZiB0aGlzIHJlc3BvbnNlLiAqL1xuICBwYXJzZXI7XG4gIGNvbnN0cnVjdG9yKHJlc3BvbnNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZ2VuZXJhdGVkTWVzc2FnZSA9IHJlc3BvbnNlLm1lc3NhZ2UgfHwgcmVzcG9uc2UuY2FuZGlkYXRlcz8uWzBdPy5tZXNzYWdlO1xuICAgIGlmIChnZW5lcmF0ZWRNZXNzYWdlKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBuZXcgaW1wb3J0X21lc3NhZ2UuTWVzc2FnZShnZW5lcmF0ZWRNZXNzYWdlLCB7XG4gICAgICAgIHBhcnNlcjogb3B0aW9ucz8ucGFyc2VyXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5maW5pc2hSZWFzb24gPSByZXNwb25zZS5maW5pc2hSZWFzb24gfHwgcmVzcG9uc2UuY2FuZGlkYXRlcz8uWzBdPy5maW5pc2hSZWFzb247XG4gICAgdGhpcy5maW5pc2hNZXNzYWdlID0gcmVzcG9uc2UuZmluaXNoTWVzc2FnZSB8fCByZXNwb25zZS5jYW5kaWRhdGVzPy5bMF0/LmZpbmlzaE1lc3NhZ2U7XG4gICAgdGhpcy51c2FnZSA9IHJlc3BvbnNlLnVzYWdlIHx8IHt9O1xuICAgIHRoaXMuY3VzdG9tID0gcmVzcG9uc2UuY3VzdG9tIHx8IHt9O1xuICAgIHRoaXMucmF3ID0gcmVzcG9uc2UucmF3IHx8IHRoaXMuY3VzdG9tO1xuICAgIHRoaXMucmVxdWVzdCA9IG9wdGlvbnM/LnJlcXVlc3Q7XG4gICAgdGhpcy5vcGVyYXRpb24gPSByZXNwb25zZT8ub3BlcmF0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHJlc3BvbnNlIGRvZXMgbm90IGNvbnRhaW4gdmFsaWQgb3V0cHV0LlxuICAgKi9cbiAgYXNzZXJ0VmFsaWQoKSB7XG4gICAgaWYgKHRoaXMuZmluaXNoUmVhc29uID09PSBcImJsb2NrZWRcIikge1xuICAgICAgdGhyb3cgbmV3IGltcG9ydF9nZW5lcmF0ZS5HZW5lcmF0aW9uQmxvY2tlZEVycm9yKFxuICAgICAgICB0aGlzLFxuICAgICAgICBgR2VuZXJhdGlvbiBibG9ja2VkJHt0aGlzLmZpbmlzaE1lc3NhZ2UgPyBgOiAke3RoaXMuZmluaXNoTWVzc2FnZX1gIDogXCIuXCJ9YFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm1lc3NhZ2UgJiYgIXRoaXMub3BlcmF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgaW1wb3J0X2dlbmVyYXRlLkdlbmVyYXRpb25SZXNwb25zZUVycm9yKFxuICAgICAgICB0aGlzLFxuICAgICAgICBgTW9kZWwgZGlkIG5vdCBnZW5lcmF0ZSBhIG1lc3NhZ2UuIEZpbmlzaCByZWFzb246ICcke3RoaXMuZmluaXNoUmVhc29ufSc6ICR7dGhpcy5maW5pc2hNZXNzYWdlfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHJlc3BvbnNlIGRvZXMgbm90IGNvbmZvcm0gdG8gZXhwZWN0ZWQgc2NoZW1hLlxuICAgKi9cbiAgYXNzZXJ0VmFsaWRTY2hlbWEocmVxdWVzdCkge1xuICAgIGlmIChyZXF1ZXN0Py5vdXRwdXQ/LnNjaGVtYSB8fCB0aGlzLnJlcXVlc3Q/Lm91dHB1dD8uc2NoZW1hKSB7XG4gICAgICBjb25zdCBvID0gdGhpcy5vdXRwdXQ7XG4gICAgICAoMCwgaW1wb3J0X3NjaGVtYS5wYXJzZVNjaGVtYSkobywge1xuICAgICAgICBqc29uU2NoZW1hOiByZXF1ZXN0Py5vdXRwdXQ/LnNjaGVtYSB8fCB0aGlzLnJlcXVlc3Q/Lm91dHB1dD8uc2NoZW1hXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaXNWYWxpZChyZXF1ZXN0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuYXNzZXJ0VmFsaWQoKTtcbiAgICAgIHRoaXMuYXNzZXJ0VmFsaWRTY2hlbWEocmVxdWVzdCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJZiB0aGUgZ2VuZXJhdGVkIG1lc3NhZ2UgY29udGFpbnMgYSBgZGF0YWAgcGFydCwgaXQgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSxcbiAgICogdGhlIGBvdXRwdXQoKWAgbWV0aG9kIGV4dHJhY3RzIHRoZSBmaXJzdCB2YWxpZCBKU09OIG9iamVjdCBvciBhcnJheSBmcm9tIHRoZSB0ZXh0XG4gICAqIGNvbnRhaW5lZCBpbiB0aGUgc2VsZWN0ZWQgY2FuZGlkYXRlJ3MgbWVzc2FnZSBhbmQgcmV0dXJucyBpdC5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIHN0cnVjdHVyZWQgb3V0cHV0IGNvbnRhaW5lZCBpbiB0aGUgc2VsZWN0ZWQgY2FuZGlkYXRlLlxuICAgKi9cbiAgZ2V0IG91dHB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlPy5vdXRwdXQgfHwgbnVsbDtcbiAgfVxuICAvKipcbiAgICogQ29uY2F0ZW5hdGVzIGFsbCBgdGV4dGAgcGFydHMgcHJlc2VudCBpbiB0aGUgZ2VuZXJhdGVkIG1lc3NhZ2Ugd2l0aCBubyBkZWxpbWl0ZXIuXG4gICAqIEByZXR1cm5zIEEgc3RyaW5nIG9mIGFsbCBjb25jYXRlbmF0ZWQgdGV4dCBwYXJ0cy5cbiAgICovXG4gIGdldCB0ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2U/LnRleHQgfHwgXCJcIjtcbiAgfVxuICAvKipcbiAgICogQ29uY2F0ZW5hdGVzIGFsbCBgcmVhc29uaW5nYCBwYXJ0cyBwcmVzZW50IGluIHRoZSBnZW5lcmF0ZWQgbWVzc2FnZSB3aXRoIG5vIGRlbGltaXRlci5cbiAgICogQHJldHVybnMgQSBzdHJpbmcgb2YgYWxsIGNvbmNhdGVuYXRlZCByZWFzb25pbmcgcGFydHMuXG4gICAqL1xuICBnZXQgcmVhc29uaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2U/LnJlYXNvbmluZyB8fCBcIlwiO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBkZXRlY3RlZCBtZWRpYSBwYXJ0IGluIHRoZSBnZW5lcmF0ZWQgbWVzc2FnZS4gVXNlZnVsIGZvclxuICAgKiBleHRyYWN0aW5nIChmb3IgZXhhbXBsZSkgYW4gaW1hZ2UgZnJvbSBhIGdlbmVyYXRpb24gZXhwZWN0ZWQgdG8gY3JlYXRlIG9uZS5cbiAgICogQHJldHVybnMgVGhlIGZpcnN0IGRldGVjdGVkIGBtZWRpYWAgcGFydCBpbiB0aGUgY2FuZGlkYXRlLlxuICAgKi9cbiAgZ2V0IG1lZGlhKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2U/Lm1lZGlhIHx8IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IGRldGVjdGVkIGBkYXRhYCBwYXJ0IG9mIHRoZSBnZW5lcmF0ZWQgbWVzc2FnZS5cbiAgICogQHJldHVybnMgVGhlIGZpcnN0IGBkYXRhYCBwYXJ0IGRldGVjdGVkIGluIHRoZSBjYW5kaWRhdGUgKGlmIGFueSkuXG4gICAqL1xuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlPy5kYXRhIHx8IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIHRvb2wgcmVxdWVzdCBmb3VuZCBpbiB0aGUgZ2VuZXJhdGVkIG1lc3NhZ2UuXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIGFsbCB0b29sIHJlcXVlc3QgZm91bmQgaW4gdGhlIGNhbmRpZGF0ZS5cbiAgICovXG4gIGdldCB0b29sUmVxdWVzdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZT8udG9vbFJlcXVlc3RzIHx8IFtdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCB0b29sIHJlcXVlc3RzIGFubm90YXRlZCBhcyBpbnRlcnJ1cHRzIGZvdW5kIGluIHRoZSBnZW5lcmF0ZWQgbWVzc2FnZS5cbiAgICogQHJldHVybnMgQSBsaXN0IG9mIFRvb2xSZXF1ZXN0UGFydHMuXG4gICAqL1xuICBnZXQgaW50ZXJydXB0cygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlPy5pbnRlcnJ1cHRzIHx8IFtdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtZXNzYWdlIGhpc3RvcnkgZm9yIHRoZSByZXF1ZXN0IGJ5IGNvbmNhdGVuYXRpbmcgdGhlIG1vZGVsXG4gICAqIHJlc3BvbnNlIHRvIHRoZSBsaXN0IG9mIG1lc3NhZ2VzIGZyb20gdGhlIHJlcXVlc3QuIFRoZSByZXN1bHQgb2YgdGhpc1xuICAgKiBtZXRob2QgY2FuIGJlIHNhZmVseSBzZXJpYWxpemVkIHRvIEpTT04gZm9yIHBlcnNpc3RlbmNlIGluIGEgZGF0YWJhc2UuXG4gICAqIEByZXR1cm5zIEEgc2VyaWFsaXphYmxlIGxpc3Qgb2YgbWVzc2FnZXMgY29tcGF0aWJsZSB3aXRoIGBnZW5lcmF0ZSh7aGlzdG9yeX0pYC5cbiAgICovXG4gIGdldCBtZXNzYWdlcygpIHtcbiAgICBpZiAoIXRoaXMucmVxdWVzdClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJDYW4ndCBjb25zdHJ1Y3QgaGlzdG9yeSBmb3IgcmVzcG9uc2Ugd2l0aG91dCByZXF1ZXN0IHJlZmVyZW5jZS5cIlxuICAgICAgKTtcbiAgICBpZiAoIXRoaXMubWVzc2FnZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJDYW4ndCBjb25zdHJ1Y3QgaGlzdG9yeSBmb3IgcmVzcG9uc2Ugd2l0aG91dCBnZW5lcmF0ZWQgbWVzc2FnZS5cIlxuICAgICAgKTtcbiAgICByZXR1cm4gWy4uLnRoaXMucmVxdWVzdD8ubWVzc2FnZXMsIHRoaXMubWVzc2FnZS50b0pTT04oKV07XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IG91dCA9IHtcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZT8udG9KU09OKCksXG4gICAgICBmaW5pc2hSZWFzb246IHRoaXMuZmluaXNoUmVhc29uLFxuICAgICAgZmluaXNoTWVzc2FnZTogdGhpcy5maW5pc2hNZXNzYWdlLFxuICAgICAgdXNhZ2U6IHRoaXMudXNhZ2UsXG4gICAgICBjdXN0b206IHRoaXMuY3VzdG9tLnRvSlNPTj8uKCkgfHwgdGhpcy5jdXN0b20sXG4gICAgICByZXF1ZXN0OiB0aGlzLnJlcXVlc3QsXG4gICAgICBvcGVyYXRpb246IHRoaXMub3BlcmF0aW9uXG4gICAgfTtcbiAgICBpZiAoIW91dC5maW5pc2hNZXNzYWdlKSBkZWxldGUgb3V0LmZpbmlzaE1lc3NhZ2U7XG4gICAgaWYgKCFvdXQucmVxdWVzdCkgZGVsZXRlIG91dC5yZXF1ZXN0O1xuICAgIGlmICghb3V0Lm9wZXJhdGlvbikgZGVsZXRlIG91dC5vcGVyYXRpb247XG4gICAgcmV0dXJuIG91dDtcbiAgfVxufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdlbmVyYXRlUmVzcG9uc2Vcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzcG9uc2UuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/generate/response.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar index_exports = {};\n__export(index_exports, {\n  BaseDataPointSchema: () => import_evaluator.BaseDataPointSchema,\n  Document: () => import_document.Document,\n  DocumentDataSchema: () => import_document.DocumentDataSchema,\n  EvalStatusEnum: () => import_evaluator.EvalStatusEnum,\n  GenerateResponse: () => import_generate.GenerateResponse,\n  GenerateResponseChunk: () => import_generate.GenerateResponseChunk,\n  GenerateResponseChunkSchema: () => import_model.GenerateResponseChunkSchema,\n  GenerationBlockedError: () => import_generate.GenerationBlockedError,\n  GenerationCommonConfigSchema: () => import_model.GenerationCommonConfigSchema,\n  GenerationResponseError: () => import_generate.GenerationResponseError,\n  Message: () => import_message.Message,\n  MessageSchema: () => import_model.MessageSchema,\n  ModelRequestSchema: () => import_model.ModelRequestSchema,\n  ModelResponseSchema: () => import_model.ModelResponseSchema,\n  PartSchema: () => import_model.PartSchema,\n  ResourceInputSchema: () => import_resource.ResourceInputSchema,\n  ResourceOutputSchema: () => import_resource.ResourceOutputSchema,\n  RoleSchema: () => import_model.RoleSchema,\n  ToolInterruptError: () => import_tool.ToolInterruptError,\n  asTool: () => import_tool.asTool,\n  checkOperation: () => import_check_operation.checkOperation,\n  defineHelper: () => import_prompt.defineHelper,\n  defineInterrupt: () => import_tool.defineInterrupt,\n  definePartial: () => import_prompt.definePartial,\n  definePrompt: () => import_prompt.definePrompt,\n  defineResource: () => import_resource.defineResource,\n  defineTool: () => import_tool.defineTool,\n  dynamicResource: () => import_resource.dynamicResource,\n  embed: () => import_embedder.embed,\n  embedderActionMetadata: () => import_embedder.embedderActionMetadata,\n  embedderRef: () => import_embedder.embedderRef,\n  evaluate: () => import_evaluator.evaluate,\n  evaluatorRef: () => import_evaluator.evaluatorRef,\n  generate: () => import_generate.generate,\n  generateOperation: () => import_generate.generateOperation,\n  generateStream: () => import_generate.generateStream,\n  index: () => import_retriever.index,\n  indexerRef: () => import_retriever.indexerRef,\n  interrupt: () => import_tool.interrupt,\n  isDynamicResourceAction: () => import_resource.isDynamicResourceAction,\n  isExecutablePrompt: () => import_prompt.isExecutablePrompt,\n  loadPromptFolder: () => import_prompt.loadPromptFolder,\n  modelActionMetadata: () => import_model.modelActionMetadata,\n  modelRef: () => import_model.modelRef,\n  prompt: () => import_prompt.prompt,\n  rerank: () => import_reranker.rerank,\n  rerankerRef: () => import_reranker.rerankerRef,\n  resource: () => import_resource.resource,\n  retrieve: () => import_retriever.retrieve,\n  retrieverRef: () => import_retriever.retrieverRef,\n  tagAsPreamble: () => import_generate.tagAsPreamble,\n  toGenerateRequest: () => import_generate.toGenerateRequest\n});\nmodule.exports = __toCommonJS(index_exports);\nvar import_check_operation = __webpack_require__(/*! ./check-operation.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/check-operation.js\");\nvar import_document = __webpack_require__(/*! ./document.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/document.js\");\nvar import_embedder = __webpack_require__(/*! ./embedder.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/embedder.js\");\nvar import_evaluator = __webpack_require__(/*! ./evaluator.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/evaluator.js\");\nvar import_generate = __webpack_require__(/*! ./generate.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/generate.js\");\nvar import_message = __webpack_require__(/*! ./message.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/message.js\");\nvar import_model = __webpack_require__(/*! ./model.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/model.js\");\nvar import_prompt = __webpack_require__(/*! ./prompt.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/prompt.js\");\nvar import_reranker = __webpack_require__(/*! ./reranker.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/reranker.js\");\nvar import_resource = __webpack_require__(/*! ./resource.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/resource.js\");\nvar import_retriever = __webpack_require__(/*! ./retriever.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/retriever.js\");\nvar import_tool = __webpack_require__(/*! ./tool.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/tool.js\");\n__reExport(index_exports, __webpack_require__(/*! ./types.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/types.js\"), module.exports);\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNkJBQTZCLG1CQUFPLENBQUMsa0dBQXNCO0FBQzNELHNCQUFzQixtQkFBTyxDQUFDLG9GQUFlO0FBQzdDLHNCQUFzQixtQkFBTyxDQUFDLG9GQUFlO0FBQzdDLHVCQUF1QixtQkFBTyxDQUFDLHNGQUFnQjtBQUMvQyxzQkFBc0IsbUJBQU8sQ0FBQyxvRkFBZTtBQUM3QyxxQkFBcUIsbUJBQU8sQ0FBQyxrRkFBYztBQUMzQyxtQkFBbUIsbUJBQU8sQ0FBQyw4RUFBWTtBQUN2QyxvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBYTtBQUN6QyxzQkFBc0IsbUJBQU8sQ0FBQyxvRkFBZTtBQUM3QyxzQkFBc0IsbUJBQU8sQ0FBQyxvRkFBZTtBQUM3Qyx1QkFBdUIsbUJBQU8sQ0FBQyxzRkFBZ0I7QUFDL0Msa0JBQWtCLG1CQUFPLENBQUMsNEVBQVc7QUFDckMsMEJBQTBCLG1CQUFPLENBQUMsOEVBQVk7QUFDOUM7QUFDQSxNQUFNLENBc0RMO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcS1JhbWFjaGFcXERvY3VtZW50c1xcU3VzdEFJbmV4IEdJdCBDb2RlXFxub2RlX21vZHVsZXNcXEBnZW5raXQtYWlcXGFpXFxsaWJcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZCwgc2Vjb25kVGFyZ2V0KSA9PiAoX19jb3B5UHJvcHModGFyZ2V0LCBtb2QsIFwiZGVmYXVsdFwiKSwgc2Vjb25kVGFyZ2V0ICYmIF9fY29weVByb3BzKHNlY29uZFRhcmdldCwgbW9kLCBcImRlZmF1bHRcIikpO1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgaW5kZXhfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoaW5kZXhfZXhwb3J0cywge1xuICBCYXNlRGF0YVBvaW50U2NoZW1hOiAoKSA9PiBpbXBvcnRfZXZhbHVhdG9yLkJhc2VEYXRhUG9pbnRTY2hlbWEsXG4gIERvY3VtZW50OiAoKSA9PiBpbXBvcnRfZG9jdW1lbnQuRG9jdW1lbnQsXG4gIERvY3VtZW50RGF0YVNjaGVtYTogKCkgPT4gaW1wb3J0X2RvY3VtZW50LkRvY3VtZW50RGF0YVNjaGVtYSxcbiAgRXZhbFN0YXR1c0VudW06ICgpID0+IGltcG9ydF9ldmFsdWF0b3IuRXZhbFN0YXR1c0VudW0sXG4gIEdlbmVyYXRlUmVzcG9uc2U6ICgpID0+IGltcG9ydF9nZW5lcmF0ZS5HZW5lcmF0ZVJlc3BvbnNlLFxuICBHZW5lcmF0ZVJlc3BvbnNlQ2h1bms6ICgpID0+IGltcG9ydF9nZW5lcmF0ZS5HZW5lcmF0ZVJlc3BvbnNlQ2h1bmssXG4gIEdlbmVyYXRlUmVzcG9uc2VDaHVua1NjaGVtYTogKCkgPT4gaW1wb3J0X21vZGVsLkdlbmVyYXRlUmVzcG9uc2VDaHVua1NjaGVtYSxcbiAgR2VuZXJhdGlvbkJsb2NrZWRFcnJvcjogKCkgPT4gaW1wb3J0X2dlbmVyYXRlLkdlbmVyYXRpb25CbG9ja2VkRXJyb3IsXG4gIEdlbmVyYXRpb25Db21tb25Db25maWdTY2hlbWE6ICgpID0+IGltcG9ydF9tb2RlbC5HZW5lcmF0aW9uQ29tbW9uQ29uZmlnU2NoZW1hLFxuICBHZW5lcmF0aW9uUmVzcG9uc2VFcnJvcjogKCkgPT4gaW1wb3J0X2dlbmVyYXRlLkdlbmVyYXRpb25SZXNwb25zZUVycm9yLFxuICBNZXNzYWdlOiAoKSA9PiBpbXBvcnRfbWVzc2FnZS5NZXNzYWdlLFxuICBNZXNzYWdlU2NoZW1hOiAoKSA9PiBpbXBvcnRfbW9kZWwuTWVzc2FnZVNjaGVtYSxcbiAgTW9kZWxSZXF1ZXN0U2NoZW1hOiAoKSA9PiBpbXBvcnRfbW9kZWwuTW9kZWxSZXF1ZXN0U2NoZW1hLFxuICBNb2RlbFJlc3BvbnNlU2NoZW1hOiAoKSA9PiBpbXBvcnRfbW9kZWwuTW9kZWxSZXNwb25zZVNjaGVtYSxcbiAgUGFydFNjaGVtYTogKCkgPT4gaW1wb3J0X21vZGVsLlBhcnRTY2hlbWEsXG4gIFJlc291cmNlSW5wdXRTY2hlbWE6ICgpID0+IGltcG9ydF9yZXNvdXJjZS5SZXNvdXJjZUlucHV0U2NoZW1hLFxuICBSZXNvdXJjZU91dHB1dFNjaGVtYTogKCkgPT4gaW1wb3J0X3Jlc291cmNlLlJlc291cmNlT3V0cHV0U2NoZW1hLFxuICBSb2xlU2NoZW1hOiAoKSA9PiBpbXBvcnRfbW9kZWwuUm9sZVNjaGVtYSxcbiAgVG9vbEludGVycnVwdEVycm9yOiAoKSA9PiBpbXBvcnRfdG9vbC5Ub29sSW50ZXJydXB0RXJyb3IsXG4gIGFzVG9vbDogKCkgPT4gaW1wb3J0X3Rvb2wuYXNUb29sLFxuICBjaGVja09wZXJhdGlvbjogKCkgPT4gaW1wb3J0X2NoZWNrX29wZXJhdGlvbi5jaGVja09wZXJhdGlvbixcbiAgZGVmaW5lSGVscGVyOiAoKSA9PiBpbXBvcnRfcHJvbXB0LmRlZmluZUhlbHBlcixcbiAgZGVmaW5lSW50ZXJydXB0OiAoKSA9PiBpbXBvcnRfdG9vbC5kZWZpbmVJbnRlcnJ1cHQsXG4gIGRlZmluZVBhcnRpYWw6ICgpID0+IGltcG9ydF9wcm9tcHQuZGVmaW5lUGFydGlhbCxcbiAgZGVmaW5lUHJvbXB0OiAoKSA9PiBpbXBvcnRfcHJvbXB0LmRlZmluZVByb21wdCxcbiAgZGVmaW5lUmVzb3VyY2U6ICgpID0+IGltcG9ydF9yZXNvdXJjZS5kZWZpbmVSZXNvdXJjZSxcbiAgZGVmaW5lVG9vbDogKCkgPT4gaW1wb3J0X3Rvb2wuZGVmaW5lVG9vbCxcbiAgZHluYW1pY1Jlc291cmNlOiAoKSA9PiBpbXBvcnRfcmVzb3VyY2UuZHluYW1pY1Jlc291cmNlLFxuICBlbWJlZDogKCkgPT4gaW1wb3J0X2VtYmVkZGVyLmVtYmVkLFxuICBlbWJlZGRlckFjdGlvbk1ldGFkYXRhOiAoKSA9PiBpbXBvcnRfZW1iZWRkZXIuZW1iZWRkZXJBY3Rpb25NZXRhZGF0YSxcbiAgZW1iZWRkZXJSZWY6ICgpID0+IGltcG9ydF9lbWJlZGRlci5lbWJlZGRlclJlZixcbiAgZXZhbHVhdGU6ICgpID0+IGltcG9ydF9ldmFsdWF0b3IuZXZhbHVhdGUsXG4gIGV2YWx1YXRvclJlZjogKCkgPT4gaW1wb3J0X2V2YWx1YXRvci5ldmFsdWF0b3JSZWYsXG4gIGdlbmVyYXRlOiAoKSA9PiBpbXBvcnRfZ2VuZXJhdGUuZ2VuZXJhdGUsXG4gIGdlbmVyYXRlT3BlcmF0aW9uOiAoKSA9PiBpbXBvcnRfZ2VuZXJhdGUuZ2VuZXJhdGVPcGVyYXRpb24sXG4gIGdlbmVyYXRlU3RyZWFtOiAoKSA9PiBpbXBvcnRfZ2VuZXJhdGUuZ2VuZXJhdGVTdHJlYW0sXG4gIGluZGV4OiAoKSA9PiBpbXBvcnRfcmV0cmlldmVyLmluZGV4LFxuICBpbmRleGVyUmVmOiAoKSA9PiBpbXBvcnRfcmV0cmlldmVyLmluZGV4ZXJSZWYsXG4gIGludGVycnVwdDogKCkgPT4gaW1wb3J0X3Rvb2wuaW50ZXJydXB0LFxuICBpc0R5bmFtaWNSZXNvdXJjZUFjdGlvbjogKCkgPT4gaW1wb3J0X3Jlc291cmNlLmlzRHluYW1pY1Jlc291cmNlQWN0aW9uLFxuICBpc0V4ZWN1dGFibGVQcm9tcHQ6ICgpID0+IGltcG9ydF9wcm9tcHQuaXNFeGVjdXRhYmxlUHJvbXB0LFxuICBsb2FkUHJvbXB0Rm9sZGVyOiAoKSA9PiBpbXBvcnRfcHJvbXB0LmxvYWRQcm9tcHRGb2xkZXIsXG4gIG1vZGVsQWN0aW9uTWV0YWRhdGE6ICgpID0+IGltcG9ydF9tb2RlbC5tb2RlbEFjdGlvbk1ldGFkYXRhLFxuICBtb2RlbFJlZjogKCkgPT4gaW1wb3J0X21vZGVsLm1vZGVsUmVmLFxuICBwcm9tcHQ6ICgpID0+IGltcG9ydF9wcm9tcHQucHJvbXB0LFxuICByZXJhbms6ICgpID0+IGltcG9ydF9yZXJhbmtlci5yZXJhbmssXG4gIHJlcmFua2VyUmVmOiAoKSA9PiBpbXBvcnRfcmVyYW5rZXIucmVyYW5rZXJSZWYsXG4gIHJlc291cmNlOiAoKSA9PiBpbXBvcnRfcmVzb3VyY2UucmVzb3VyY2UsXG4gIHJldHJpZXZlOiAoKSA9PiBpbXBvcnRfcmV0cmlldmVyLnJldHJpZXZlLFxuICByZXRyaWV2ZXJSZWY6ICgpID0+IGltcG9ydF9yZXRyaWV2ZXIucmV0cmlldmVyUmVmLFxuICB0YWdBc1ByZWFtYmxlOiAoKSA9PiBpbXBvcnRfZ2VuZXJhdGUudGFnQXNQcmVhbWJsZSxcbiAgdG9HZW5lcmF0ZVJlcXVlc3Q6ICgpID0+IGltcG9ydF9nZW5lcmF0ZS50b0dlbmVyYXRlUmVxdWVzdFxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhpbmRleF9leHBvcnRzKTtcbnZhciBpbXBvcnRfY2hlY2tfb3BlcmF0aW9uID0gcmVxdWlyZShcIi4vY2hlY2stb3BlcmF0aW9uLmpzXCIpO1xudmFyIGltcG9ydF9kb2N1bWVudCA9IHJlcXVpcmUoXCIuL2RvY3VtZW50LmpzXCIpO1xudmFyIGltcG9ydF9lbWJlZGRlciA9IHJlcXVpcmUoXCIuL2VtYmVkZGVyLmpzXCIpO1xudmFyIGltcG9ydF9ldmFsdWF0b3IgPSByZXF1aXJlKFwiLi9ldmFsdWF0b3IuanNcIik7XG52YXIgaW1wb3J0X2dlbmVyYXRlID0gcmVxdWlyZShcIi4vZ2VuZXJhdGUuanNcIik7XG52YXIgaW1wb3J0X21lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlLmpzXCIpO1xudmFyIGltcG9ydF9tb2RlbCA9IHJlcXVpcmUoXCIuL21vZGVsLmpzXCIpO1xudmFyIGltcG9ydF9wcm9tcHQgPSByZXF1aXJlKFwiLi9wcm9tcHQuanNcIik7XG52YXIgaW1wb3J0X3JlcmFua2VyID0gcmVxdWlyZShcIi4vcmVyYW5rZXIuanNcIik7XG52YXIgaW1wb3J0X3Jlc291cmNlID0gcmVxdWlyZShcIi4vcmVzb3VyY2UuanNcIik7XG52YXIgaW1wb3J0X3JldHJpZXZlciA9IHJlcXVpcmUoXCIuL3JldHJpZXZlci5qc1wiKTtcbnZhciBpbXBvcnRfdG9vbCA9IHJlcXVpcmUoXCIuL3Rvb2wuanNcIik7XG5fX3JlRXhwb3J0KGluZGV4X2V4cG9ydHMsIHJlcXVpcmUoXCIuL3R5cGVzLmpzXCIpLCBtb2R1bGUuZXhwb3J0cyk7XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgQmFzZURhdGFQb2ludFNjaGVtYSxcbiAgRG9jdW1lbnQsXG4gIERvY3VtZW50RGF0YVNjaGVtYSxcbiAgRXZhbFN0YXR1c0VudW0sXG4gIEdlbmVyYXRlUmVzcG9uc2UsXG4gIEdlbmVyYXRlUmVzcG9uc2VDaHVuayxcbiAgR2VuZXJhdGVSZXNwb25zZUNodW5rU2NoZW1hLFxuICBHZW5lcmF0aW9uQmxvY2tlZEVycm9yLFxuICBHZW5lcmF0aW9uQ29tbW9uQ29uZmlnU2NoZW1hLFxuICBHZW5lcmF0aW9uUmVzcG9uc2VFcnJvcixcbiAgTWVzc2FnZSxcbiAgTWVzc2FnZVNjaGVtYSxcbiAgTW9kZWxSZXF1ZXN0U2NoZW1hLFxuICBNb2RlbFJlc3BvbnNlU2NoZW1hLFxuICBQYXJ0U2NoZW1hLFxuICBSZXNvdXJjZUlucHV0U2NoZW1hLFxuICBSZXNvdXJjZU91dHB1dFNjaGVtYSxcbiAgUm9sZVNjaGVtYSxcbiAgVG9vbEludGVycnVwdEVycm9yLFxuICBhc1Rvb2wsXG4gIGNoZWNrT3BlcmF0aW9uLFxuICBkZWZpbmVIZWxwZXIsXG4gIGRlZmluZUludGVycnVwdCxcbiAgZGVmaW5lUGFydGlhbCxcbiAgZGVmaW5lUHJvbXB0LFxuICBkZWZpbmVSZXNvdXJjZSxcbiAgZGVmaW5lVG9vbCxcbiAgZHluYW1pY1Jlc291cmNlLFxuICBlbWJlZCxcbiAgZW1iZWRkZXJBY3Rpb25NZXRhZGF0YSxcbiAgZW1iZWRkZXJSZWYsXG4gIGV2YWx1YXRlLFxuICBldmFsdWF0b3JSZWYsXG4gIGdlbmVyYXRlLFxuICBnZW5lcmF0ZU9wZXJhdGlvbixcbiAgZ2VuZXJhdGVTdHJlYW0sXG4gIGluZGV4LFxuICBpbmRleGVyUmVmLFxuICBpbnRlcnJ1cHQsXG4gIGlzRHluYW1pY1Jlc291cmNlQWN0aW9uLFxuICBpc0V4ZWN1dGFibGVQcm9tcHQsXG4gIGxvYWRQcm9tcHRGb2xkZXIsXG4gIG1vZGVsQWN0aW9uTWV0YWRhdGEsXG4gIG1vZGVsUmVmLFxuICBwcm9tcHQsXG4gIHJlcmFuayxcbiAgcmVyYW5rZXJSZWYsXG4gIHJlc291cmNlLFxuICByZXRyaWV2ZSxcbiAgcmV0cmlldmVyUmVmLFxuICB0YWdBc1ByZWFtYmxlLFxuICB0b0dlbmVyYXRlUmVxdWVzdCxcbiAgLi4ucmVxdWlyZShcIi4vdHlwZXMuanNcIilcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/message.js":
/*!***************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/message.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar message_exports = {};\n__export(message_exports, {\n  Message: () => Message\n});\nmodule.exports = __toCommonJS(message_exports);\nvar import_extract = __webpack_require__(/*! ./extract */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/extract.js\");\nclass Message {\n  role;\n  content;\n  metadata;\n  parser;\n  static parseData(lenientMessage, defaultRole = \"user\") {\n    if (typeof lenientMessage === \"string\") {\n      return { role: defaultRole, content: [{ text: lenientMessage }] };\n    }\n    return {\n      ...lenientMessage,\n      content: Message.parseContent(lenientMessage.content)\n    };\n  }\n  static parse(lenientMessage) {\n    return new Message(Message.parseData(lenientMessage));\n  }\n  static parseContent(lenientPart) {\n    if (typeof lenientPart === \"string\") {\n      return [{ text: lenientPart }];\n    } else if (Array.isArray(lenientPart)) {\n      return lenientPart.map((p) => typeof p === \"string\" ? { text: p } : p);\n    } else {\n      return [lenientPart];\n    }\n  }\n  constructor(message, options) {\n    this.role = message.role;\n    this.content = message.content;\n    this.metadata = message.metadata;\n    this.parser = options?.parser;\n  }\n  /**\n   * Attempts to parse the content of the message according to the supplied\n   * output parser. Without a parser, returns `data` contained in the message or\n   * tries to parse JSON from the text of the message.\n   *\n   * @returns The structured output contained in the message.\n   */\n  get output() {\n    return this.parser?.(this) || this.data || (0, import_extract.extractJson)(this.text);\n  }\n  toolResponseParts() {\n    const res = this.content.filter((part) => !!part.toolResponse);\n    return res;\n  }\n  /**\n   * Concatenates all `text` parts present in the message with no delimiter.\n   * @returns A string of all concatenated text parts.\n   */\n  get text() {\n    return this.content.map((part) => part.text || \"\").join(\"\");\n  }\n  /**\n   * Concatenates all `reasoning` parts present in the message with no delimiter.\n   * @returns A string of all concatenated reasoning parts.\n   */\n  get reasoning() {\n    return this.content.map((part) => part.reasoning || \"\").join(\"\");\n  }\n  /**\n   * Returns the first media part detected in the message. Useful for extracting\n   * (for example) an image from a generation expected to create one.\n   * @returns The first detected `media` part in the message.\n   */\n  get media() {\n    return this.content.find((part) => part.media)?.media || null;\n  }\n  /**\n   * Returns the first detected `data` part of a message.\n   * @returns The first `data` part detected in the message (if any).\n   */\n  get data() {\n    return this.content.find((part) => part.data)?.data;\n  }\n  /**\n   * Returns all tool request found in this message.\n   * @returns Array of all tool request found in this message.\n   */\n  get toolRequests() {\n    return this.content.filter(\n      (part) => !!part.toolRequest\n    );\n  }\n  /**\n   * Returns all tool requests annotated with interrupt metadata.\n   * @returns Array of all interrupt tool requests.\n   */\n  get interrupts() {\n    return this.toolRequests.filter((t) => !!t.metadata?.interrupt);\n  }\n  /**\n   * Converts the Message to a plain JS object.\n   * @returns Plain JS object representing the data contained in the message.\n   */\n  toJSON() {\n    const out = {\n      role: this.role,\n      content: [...this.content]\n    };\n    if (this.metadata) out.metadata = this.metadata;\n    return out;\n  }\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=message.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9tZXNzYWdlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsK0VBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtCQUErQixzQkFBc0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkMsTUFBTTtBQUNOLDhEQUE4RCxVQUFVO0FBQ3hFLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FFTDtBQUNEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEtSYW1hY2hhXFxEb2N1bWVudHNcXFN1c3RBSW5leCBHSXQgQ29kZVxcbm9kZV9tb2R1bGVzXFxAZ2Vua2l0LWFpXFxhaVxcbGliXFxtZXNzYWdlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBtZXNzYWdlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG1lc3NhZ2VfZXhwb3J0cywge1xuICBNZXNzYWdlOiAoKSA9PiBNZXNzYWdlXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKG1lc3NhZ2VfZXhwb3J0cyk7XG52YXIgaW1wb3J0X2V4dHJhY3QgPSByZXF1aXJlKFwiLi9leHRyYWN0XCIpO1xuY2xhc3MgTWVzc2FnZSB7XG4gIHJvbGU7XG4gIGNvbnRlbnQ7XG4gIG1ldGFkYXRhO1xuICBwYXJzZXI7XG4gIHN0YXRpYyBwYXJzZURhdGEobGVuaWVudE1lc3NhZ2UsIGRlZmF1bHRSb2xlID0gXCJ1c2VyXCIpIHtcbiAgICBpZiAodHlwZW9mIGxlbmllbnRNZXNzYWdlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4geyByb2xlOiBkZWZhdWx0Um9sZSwgY29udGVudDogW3sgdGV4dDogbGVuaWVudE1lc3NhZ2UgfV0gfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmxlbmllbnRNZXNzYWdlLFxuICAgICAgY29udGVudDogTWVzc2FnZS5wYXJzZUNvbnRlbnQobGVuaWVudE1lc3NhZ2UuY29udGVudClcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBwYXJzZShsZW5pZW50TWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgTWVzc2FnZShNZXNzYWdlLnBhcnNlRGF0YShsZW5pZW50TWVzc2FnZSkpO1xuICB9XG4gIHN0YXRpYyBwYXJzZUNvbnRlbnQobGVuaWVudFBhcnQpIHtcbiAgICBpZiAodHlwZW9mIGxlbmllbnRQYXJ0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gW3sgdGV4dDogbGVuaWVudFBhcnQgfV07XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGxlbmllbnRQYXJ0KSkge1xuICAgICAgcmV0dXJuIGxlbmllbnRQYXJ0Lm1hcCgocCkgPT4gdHlwZW9mIHAgPT09IFwic3RyaW5nXCIgPyB7IHRleHQ6IHAgfSA6IHApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW2xlbmllbnRQYXJ0XTtcbiAgICB9XG4gIH1cbiAgY29uc3RydWN0b3IobWVzc2FnZSwgb3B0aW9ucykge1xuICAgIHRoaXMucm9sZSA9IG1lc3NhZ2Uucm9sZTtcbiAgICB0aGlzLmNvbnRlbnQgPSBtZXNzYWdlLmNvbnRlbnQ7XG4gICAgdGhpcy5tZXRhZGF0YSA9IG1lc3NhZ2UubWV0YWRhdGE7XG4gICAgdGhpcy5wYXJzZXIgPSBvcHRpb25zPy5wYXJzZXI7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIHBhcnNlIHRoZSBjb250ZW50IG9mIHRoZSBtZXNzYWdlIGFjY29yZGluZyB0byB0aGUgc3VwcGxpZWRcbiAgICogb3V0cHV0IHBhcnNlci4gV2l0aG91dCBhIHBhcnNlciwgcmV0dXJucyBgZGF0YWAgY29udGFpbmVkIGluIHRoZSBtZXNzYWdlIG9yXG4gICAqIHRyaWVzIHRvIHBhcnNlIEpTT04gZnJvbSB0aGUgdGV4dCBvZiB0aGUgbWVzc2FnZS5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIHN0cnVjdHVyZWQgb3V0cHV0IGNvbnRhaW5lZCBpbiB0aGUgbWVzc2FnZS5cbiAgICovXG4gIGdldCBvdXRwdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VyPy4odGhpcykgfHwgdGhpcy5kYXRhIHx8ICgwLCBpbXBvcnRfZXh0cmFjdC5leHRyYWN0SnNvbikodGhpcy50ZXh0KTtcbiAgfVxuICB0b29sUmVzcG9uc2VQYXJ0cygpIHtcbiAgICBjb25zdCByZXMgPSB0aGlzLmNvbnRlbnQuZmlsdGVyKChwYXJ0KSA9PiAhIXBhcnQudG9vbFJlc3BvbnNlKTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIC8qKlxuICAgKiBDb25jYXRlbmF0ZXMgYWxsIGB0ZXh0YCBwYXJ0cyBwcmVzZW50IGluIHRoZSBtZXNzYWdlIHdpdGggbm8gZGVsaW1pdGVyLlxuICAgKiBAcmV0dXJucyBBIHN0cmluZyBvZiBhbGwgY29uY2F0ZW5hdGVkIHRleHQgcGFydHMuXG4gICAqL1xuICBnZXQgdGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50Lm1hcCgocGFydCkgPT4gcGFydC50ZXh0IHx8IFwiXCIpLmpvaW4oXCJcIik7XG4gIH1cbiAgLyoqXG4gICAqIENvbmNhdGVuYXRlcyBhbGwgYHJlYXNvbmluZ2AgcGFydHMgcHJlc2VudCBpbiB0aGUgbWVzc2FnZSB3aXRoIG5vIGRlbGltaXRlci5cbiAgICogQHJldHVybnMgQSBzdHJpbmcgb2YgYWxsIGNvbmNhdGVuYXRlZCByZWFzb25pbmcgcGFydHMuXG4gICAqL1xuICBnZXQgcmVhc29uaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQubWFwKChwYXJ0KSA9PiBwYXJ0LnJlYXNvbmluZyB8fCBcIlwiKS5qb2luKFwiXCIpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBtZWRpYSBwYXJ0IGRldGVjdGVkIGluIHRoZSBtZXNzYWdlLiBVc2VmdWwgZm9yIGV4dHJhY3RpbmdcbiAgICogKGZvciBleGFtcGxlKSBhbiBpbWFnZSBmcm9tIGEgZ2VuZXJhdGlvbiBleHBlY3RlZCB0byBjcmVhdGUgb25lLlxuICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgZGV0ZWN0ZWQgYG1lZGlhYCBwYXJ0IGluIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgZ2V0IG1lZGlhKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZmluZCgocGFydCkgPT4gcGFydC5tZWRpYSk/Lm1lZGlhIHx8IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IGRldGVjdGVkIGBkYXRhYCBwYXJ0IG9mIGEgbWVzc2FnZS5cbiAgICogQHJldHVybnMgVGhlIGZpcnN0IGBkYXRhYCBwYXJ0IGRldGVjdGVkIGluIHRoZSBtZXNzYWdlIChpZiBhbnkpLlxuICAgKi9cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5maW5kKChwYXJ0KSA9PiBwYXJ0LmRhdGEpPy5kYXRhO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCB0b29sIHJlcXVlc3QgZm91bmQgaW4gdGhpcyBtZXNzYWdlLlxuICAgKiBAcmV0dXJucyBBcnJheSBvZiBhbGwgdG9vbCByZXF1ZXN0IGZvdW5kIGluIHRoaXMgbWVzc2FnZS5cbiAgICovXG4gIGdldCB0b29sUmVxdWVzdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5maWx0ZXIoXG4gICAgICAocGFydCkgPT4gISFwYXJ0LnRvb2xSZXF1ZXN0XG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgdG9vbCByZXF1ZXN0cyBhbm5vdGF0ZWQgd2l0aCBpbnRlcnJ1cHQgbWV0YWRhdGEuXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIGFsbCBpbnRlcnJ1cHQgdG9vbCByZXF1ZXN0cy5cbiAgICovXG4gIGdldCBpbnRlcnJ1cHRzKCkge1xuICAgIHJldHVybiB0aGlzLnRvb2xSZXF1ZXN0cy5maWx0ZXIoKHQpID0+ICEhdC5tZXRhZGF0YT8uaW50ZXJydXB0KTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIE1lc3NhZ2UgdG8gYSBwbGFpbiBKUyBvYmplY3QuXG4gICAqIEByZXR1cm5zIFBsYWluIEpTIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGRhdGEgY29udGFpbmVkIGluIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IG91dCA9IHtcbiAgICAgIHJvbGU6IHRoaXMucm9sZSxcbiAgICAgIGNvbnRlbnQ6IFsuLi50aGlzLmNvbnRlbnRdXG4gICAgfTtcbiAgICBpZiAodGhpcy5tZXRhZGF0YSkgb3V0Lm1ldGFkYXRhID0gdGhpcy5tZXRhZGF0YTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgTWVzc2FnZVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXNzYWdlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/message.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/model-types.js":
/*!*******************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/model-types.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar model_types_exports = {};\n__export(model_types_exports, {\n  CandidateErrorSchema: () => CandidateErrorSchema,\n  CandidateSchema: () => CandidateSchema,\n  FinishReasonSchema: () => FinishReasonSchema,\n  GenerateActionOptionsSchema: () => GenerateActionOptionsSchema,\n  GenerateActionOutputConfig: () => GenerateActionOutputConfig,\n  GenerateRequestSchema: () => GenerateRequestSchema,\n  GenerateResponseChunkSchema: () => GenerateResponseChunkSchema,\n  GenerateResponseSchema: () => GenerateResponseSchema,\n  GenerationCommonConfigDescriptions: () => GenerationCommonConfigDescriptions,\n  GenerationCommonConfigSchema: () => GenerationCommonConfigSchema,\n  GenerationUsageSchema: () => GenerationUsageSchema,\n  MessageSchema: () => MessageSchema,\n  ModelInfoSchema: () => ModelInfoSchema,\n  ModelRequestSchema: () => ModelRequestSchema,\n  ModelResponseChunkSchema: () => ModelResponseChunkSchema,\n  ModelResponseSchema: () => ModelResponseSchema,\n  OutputConfigSchema: () => OutputConfigSchema,\n  PartSchema: () => PartSchema,\n  RoleSchema: () => RoleSchema,\n  ToolDefinitionSchema: () => ToolDefinitionSchema\n});\nmodule.exports = __toCommonJS(model_types_exports);\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nvar import_document = __webpack_require__(/*! ./document.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/document.js\");\nconst PartSchema = import_core.z.union([\n  import_document.TextPartSchema,\n  import_document.MediaPartSchema,\n  import_document.ToolRequestPartSchema,\n  import_document.ToolResponsePartSchema,\n  import_document.DataPartSchema,\n  import_document.CustomPartSchema,\n  import_document.ReasoningPartSchema,\n  import_document.ResourcePartSchema\n]);\nconst RoleSchema = import_core.z.enum([\"system\", \"user\", \"model\", \"tool\"]);\nconst MessageSchema = import_core.z.object({\n  role: RoleSchema,\n  content: import_core.z.array(PartSchema),\n  metadata: import_core.z.record(import_core.z.unknown()).optional()\n});\nconst ModelInfoSchema = import_core.z.object({\n  /** Acceptable names for this model (e.g. different versions). */\n  versions: import_core.z.array(import_core.z.string()).optional(),\n  /** Friendly label for this model (e.g. \"Google AI - Gemini Pro\") */\n  label: import_core.z.string().optional(),\n  /** Model Specific configuration. */\n  configSchema: import_core.z.record(import_core.z.any()).optional(),\n  /** Supported model capabilities. */\n  supports: import_core.z.object({\n    /** Model can process historical messages passed with a prompt. */\n    multiturn: import_core.z.boolean().optional(),\n    /** Model can process media as part of the prompt (multimodal input). */\n    media: import_core.z.boolean().optional(),\n    /** Model can perform tool calls. */\n    tools: import_core.z.boolean().optional(),\n    /** Model can accept messages with role \"system\". */\n    systemRole: import_core.z.boolean().optional(),\n    /** Model can output this type of data. */\n    output: import_core.z.array(import_core.z.string()).optional(),\n    /** Model supports output in these content types. */\n    contentType: import_core.z.array(import_core.z.string()).optional(),\n    /** Model can natively support document-based context grounding. */\n    context: import_core.z.boolean().optional(),\n    /** Model can natively support constrained generation. */\n    constrained: import_core.z.enum([\"none\", \"all\", \"no-tools\"]).optional(),\n    /** Model supports controlling tool choice, e.g. forced tool calling. */\n    toolChoice: import_core.z.boolean().optional()\n  }).optional(),\n  /** At which stage of development this model is.\n   * - `featured` models are recommended for general use.\n   * - `stable` models are well-tested and reliable.\n   * - `unstable` models are experimental and may change.\n   * - `legacy` models are no longer recommended for new projects.\n   * - `deprecated` models are deprecated by the provider and may be removed in future versions.\n   */\n  stage: import_core.z.enum([\"featured\", \"stable\", \"unstable\", \"legacy\", \"deprecated\"]).optional()\n});\nconst ToolDefinitionSchema = import_core.z.object({\n  name: import_core.z.string(),\n  description: import_core.z.string(),\n  inputSchema: import_core.z.record(import_core.z.any()).describe(\"Valid JSON Schema representing the input of the tool.\").nullish(),\n  outputSchema: import_core.z.record(import_core.z.any()).describe(\"Valid JSON Schema describing the output of the tool.\").nullish(),\n  metadata: import_core.z.record(import_core.z.any()).describe(\"additional metadata for this tool definition\").optional()\n});\nconst GenerationCommonConfigDescriptions = {\n  temperature: \"Controls the degree of randomness in token selection. A lower value is good for a more predictable response. A higher value leads to more diverse or unexpected results.\",\n  maxOutputTokens: \"The maximum number of tokens to include in the response.\",\n  topK: \"The maximum number of tokens to consider when sampling.\",\n  topP: \"Decides how many possible words to consider. A higher value means that the model looks at more possible words, even the less likely ones, which makes the generated text more diverse.\"\n};\nconst GenerationCommonConfigSchema = import_core.z.object({\n  version: import_core.z.string().describe(\n    \"A specific version of a model family, e.g. `gemini-2.0-flash` for the `googleai` family.\"\n  ).optional(),\n  temperature: import_core.z.number().describe(GenerationCommonConfigDescriptions.temperature).optional(),\n  maxOutputTokens: import_core.z.number().describe(GenerationCommonConfigDescriptions.maxOutputTokens).optional(),\n  topK: import_core.z.number().describe(GenerationCommonConfigDescriptions.topK).optional(),\n  topP: import_core.z.number().describe(GenerationCommonConfigDescriptions.topP).optional(),\n  stopSequences: import_core.z.array(import_core.z.string()).max(5).describe(\n    \"Set of character sequences (up to 5) that will stop output generation.\"\n  ).optional()\n}).passthrough();\nconst OutputConfigSchema = import_core.z.object({\n  format: import_core.z.string().optional(),\n  schema: import_core.z.record(import_core.z.any()).optional(),\n  constrained: import_core.z.boolean().optional(),\n  contentType: import_core.z.string().optional()\n});\nconst ModelRequestSchema = import_core.z.object({\n  messages: import_core.z.array(MessageSchema),\n  config: import_core.z.any().optional(),\n  tools: import_core.z.array(ToolDefinitionSchema).optional(),\n  toolChoice: import_core.z.enum([\"auto\", \"required\", \"none\"]).optional(),\n  output: OutputConfigSchema.optional(),\n  docs: import_core.z.array(import_document.DocumentDataSchema).optional()\n});\nconst GenerateRequestSchema = ModelRequestSchema.extend({\n  /** @deprecated All responses now return a single candidate. This will always be `undefined`. */\n  candidates: import_core.z.number().optional()\n});\nconst GenerationUsageSchema = import_core.z.object({\n  inputTokens: import_core.z.number().optional(),\n  outputTokens: import_core.z.number().optional(),\n  totalTokens: import_core.z.number().optional(),\n  inputCharacters: import_core.z.number().optional(),\n  outputCharacters: import_core.z.number().optional(),\n  inputImages: import_core.z.number().optional(),\n  outputImages: import_core.z.number().optional(),\n  inputVideos: import_core.z.number().optional(),\n  outputVideos: import_core.z.number().optional(),\n  inputAudioFiles: import_core.z.number().optional(),\n  outputAudioFiles: import_core.z.number().optional(),\n  custom: import_core.z.record(import_core.z.number()).optional(),\n  thoughtsTokens: import_core.z.number().optional(),\n  cachedContentTokens: import_core.z.number().optional()\n});\nconst FinishReasonSchema = import_core.z.enum([\n  \"stop\",\n  \"length\",\n  \"blocked\",\n  \"interrupted\",\n  \"other\",\n  \"unknown\"\n]);\nconst CandidateSchema = import_core.z.object({\n  index: import_core.z.number(),\n  message: MessageSchema,\n  usage: GenerationUsageSchema.optional(),\n  finishReason: FinishReasonSchema,\n  finishMessage: import_core.z.string().optional(),\n  custom: import_core.z.unknown()\n});\nconst CandidateErrorSchema = import_core.z.object({\n  index: import_core.z.number(),\n  code: import_core.z.enum([\"blocked\", \"other\", \"unknown\"]),\n  message: import_core.z.string().optional()\n});\nconst ModelResponseSchema = import_core.z.object({\n  message: MessageSchema.optional(),\n  finishReason: FinishReasonSchema,\n  finishMessage: import_core.z.string().optional(),\n  latencyMs: import_core.z.number().optional(),\n  usage: GenerationUsageSchema.optional(),\n  /** @deprecated use `raw` instead */\n  custom: import_core.z.unknown(),\n  raw: import_core.z.unknown(),\n  request: GenerateRequestSchema.optional(),\n  operation: import_core.OperationSchema.optional()\n});\nconst GenerateResponseSchema = ModelResponseSchema.extend({\n  /** @deprecated All responses now return a single candidate. Only the first candidate will be used if supplied. Return `message`, `finishReason`, and `finishMessage` instead. */\n  candidates: import_core.z.array(CandidateSchema).optional(),\n  finishReason: FinishReasonSchema.optional()\n});\nconst ModelResponseChunkSchema = import_core.z.object({\n  role: RoleSchema.optional(),\n  /** index of the message this chunk belongs to. */\n  index: import_core.z.number().optional(),\n  /** The chunk of content to stream right now. */\n  content: import_core.z.array(PartSchema),\n  /** Model-specific extra information attached to this chunk. */\n  custom: import_core.z.unknown().optional(),\n  /** If true, the chunk includes all data from previous chunks. Otherwise, considered to be incremental. */\n  aggregated: import_core.z.boolean().optional()\n});\nconst GenerateResponseChunkSchema = ModelResponseChunkSchema;\nconst GenerateActionOutputConfig = import_core.z.object({\n  format: import_core.z.string().optional(),\n  contentType: import_core.z.string().optional(),\n  instructions: import_core.z.union([import_core.z.boolean(), import_core.z.string()]).optional(),\n  jsonSchema: import_core.z.any().optional(),\n  constrained: import_core.z.boolean().optional()\n});\nconst GenerateActionOptionsSchema = import_core.z.object({\n  /** A model name (e.g. `vertexai/gemini-1.0-pro`). */\n  model: import_core.z.string(),\n  /** Retrieved documents to be used as context for this generation. */\n  docs: import_core.z.array(import_document.DocumentDataSchema).optional(),\n  /** Conversation history for multi-turn prompting when supported by the underlying model. */\n  messages: import_core.z.array(MessageSchema),\n  /** List of registered tool names for this generation if supported by the underlying model. */\n  tools: import_core.z.array(import_core.z.string()).optional(),\n  /** Tool calling mode. `auto` lets the model decide whether to use tools, `required` forces the model to choose a tool, and `none` forces the model not to use any tools. Defaults to `auto`.  */\n  toolChoice: import_core.z.enum([\"auto\", \"required\", \"none\"]).optional(),\n  /** Configuration for the generation request. */\n  config: import_core.z.any().optional(),\n  /** Configuration for the desired output of the request. Defaults to the model's default output if unspecified. */\n  output: GenerateActionOutputConfig.optional(),\n  /** Options for resuming an interrupted generation. */\n  resume: import_core.z.object({\n    respond: import_core.z.array(import_document.ToolResponsePartSchema).optional(),\n    restart: import_core.z.array(import_document.ToolRequestPartSchema).optional(),\n    metadata: import_core.z.record(import_core.z.any()).optional()\n  }).optional(),\n  /** When true, return tool calls for manual processing instead of automatically resolving them. */\n  returnToolRequests: import_core.z.boolean().optional(),\n  /** Maximum number of tool call iterations that can be performed in a single generate call (default 5). */\n  maxTurns: import_core.z.number().optional(),\n  /** Custom step name for this generate call to display in trace views. Defaults to \"generate\". */\n  stepName: import_core.z.string().optional()\n});\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=model-types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9tb2RlbC10eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMscUZBQWlCO0FBQzNDLHNCQUFzQixtQkFBTyxDQUFDLG9GQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxNQUFNLENBcUJMO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcS1JhbWFjaGFcXERvY3VtZW50c1xcU3VzdEFJbmV4IEdJdCBDb2RlXFxub2RlX21vZHVsZXNcXEBnZW5raXQtYWlcXGFpXFxsaWJcXG1vZGVsLXR5cGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBtb2RlbF90eXBlc19leHBvcnRzID0ge307XG5fX2V4cG9ydChtb2RlbF90eXBlc19leHBvcnRzLCB7XG4gIENhbmRpZGF0ZUVycm9yU2NoZW1hOiAoKSA9PiBDYW5kaWRhdGVFcnJvclNjaGVtYSxcbiAgQ2FuZGlkYXRlU2NoZW1hOiAoKSA9PiBDYW5kaWRhdGVTY2hlbWEsXG4gIEZpbmlzaFJlYXNvblNjaGVtYTogKCkgPT4gRmluaXNoUmVhc29uU2NoZW1hLFxuICBHZW5lcmF0ZUFjdGlvbk9wdGlvbnNTY2hlbWE6ICgpID0+IEdlbmVyYXRlQWN0aW9uT3B0aW9uc1NjaGVtYSxcbiAgR2VuZXJhdGVBY3Rpb25PdXRwdXRDb25maWc6ICgpID0+IEdlbmVyYXRlQWN0aW9uT3V0cHV0Q29uZmlnLFxuICBHZW5lcmF0ZVJlcXVlc3RTY2hlbWE6ICgpID0+IEdlbmVyYXRlUmVxdWVzdFNjaGVtYSxcbiAgR2VuZXJhdGVSZXNwb25zZUNodW5rU2NoZW1hOiAoKSA9PiBHZW5lcmF0ZVJlc3BvbnNlQ2h1bmtTY2hlbWEsXG4gIEdlbmVyYXRlUmVzcG9uc2VTY2hlbWE6ICgpID0+IEdlbmVyYXRlUmVzcG9uc2VTY2hlbWEsXG4gIEdlbmVyYXRpb25Db21tb25Db25maWdEZXNjcmlwdGlvbnM6ICgpID0+IEdlbmVyYXRpb25Db21tb25Db25maWdEZXNjcmlwdGlvbnMsXG4gIEdlbmVyYXRpb25Db21tb25Db25maWdTY2hlbWE6ICgpID0+IEdlbmVyYXRpb25Db21tb25Db25maWdTY2hlbWEsXG4gIEdlbmVyYXRpb25Vc2FnZVNjaGVtYTogKCkgPT4gR2VuZXJhdGlvblVzYWdlU2NoZW1hLFxuICBNZXNzYWdlU2NoZW1hOiAoKSA9PiBNZXNzYWdlU2NoZW1hLFxuICBNb2RlbEluZm9TY2hlbWE6ICgpID0+IE1vZGVsSW5mb1NjaGVtYSxcbiAgTW9kZWxSZXF1ZXN0U2NoZW1hOiAoKSA9PiBNb2RlbFJlcXVlc3RTY2hlbWEsXG4gIE1vZGVsUmVzcG9uc2VDaHVua1NjaGVtYTogKCkgPT4gTW9kZWxSZXNwb25zZUNodW5rU2NoZW1hLFxuICBNb2RlbFJlc3BvbnNlU2NoZW1hOiAoKSA9PiBNb2RlbFJlc3BvbnNlU2NoZW1hLFxuICBPdXRwdXRDb25maWdTY2hlbWE6ICgpID0+IE91dHB1dENvbmZpZ1NjaGVtYSxcbiAgUGFydFNjaGVtYTogKCkgPT4gUGFydFNjaGVtYSxcbiAgUm9sZVNjaGVtYTogKCkgPT4gUm9sZVNjaGVtYSxcbiAgVG9vbERlZmluaXRpb25TY2hlbWE6ICgpID0+IFRvb2xEZWZpbml0aW9uU2NoZW1hXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKG1vZGVsX3R5cGVzX2V4cG9ydHMpO1xudmFyIGltcG9ydF9jb3JlID0gcmVxdWlyZShcIkBnZW5raXQtYWkvY29yZVwiKTtcbnZhciBpbXBvcnRfZG9jdW1lbnQgPSByZXF1aXJlKFwiLi9kb2N1bWVudC5qc1wiKTtcbmNvbnN0IFBhcnRTY2hlbWEgPSBpbXBvcnRfY29yZS56LnVuaW9uKFtcbiAgaW1wb3J0X2RvY3VtZW50LlRleHRQYXJ0U2NoZW1hLFxuICBpbXBvcnRfZG9jdW1lbnQuTWVkaWFQYXJ0U2NoZW1hLFxuICBpbXBvcnRfZG9jdW1lbnQuVG9vbFJlcXVlc3RQYXJ0U2NoZW1hLFxuICBpbXBvcnRfZG9jdW1lbnQuVG9vbFJlc3BvbnNlUGFydFNjaGVtYSxcbiAgaW1wb3J0X2RvY3VtZW50LkRhdGFQYXJ0U2NoZW1hLFxuICBpbXBvcnRfZG9jdW1lbnQuQ3VzdG9tUGFydFNjaGVtYSxcbiAgaW1wb3J0X2RvY3VtZW50LlJlYXNvbmluZ1BhcnRTY2hlbWEsXG4gIGltcG9ydF9kb2N1bWVudC5SZXNvdXJjZVBhcnRTY2hlbWFcbl0pO1xuY29uc3QgUm9sZVNjaGVtYSA9IGltcG9ydF9jb3JlLnouZW51bShbXCJzeXN0ZW1cIiwgXCJ1c2VyXCIsIFwibW9kZWxcIiwgXCJ0b29sXCJdKTtcbmNvbnN0IE1lc3NhZ2VTY2hlbWEgPSBpbXBvcnRfY29yZS56Lm9iamVjdCh7XG4gIHJvbGU6IFJvbGVTY2hlbWEsXG4gIGNvbnRlbnQ6IGltcG9ydF9jb3JlLnouYXJyYXkoUGFydFNjaGVtYSksXG4gIG1ldGFkYXRhOiBpbXBvcnRfY29yZS56LnJlY29yZChpbXBvcnRfY29yZS56LnVua25vd24oKSkub3B0aW9uYWwoKVxufSk7XG5jb25zdCBNb2RlbEluZm9TY2hlbWEgPSBpbXBvcnRfY29yZS56Lm9iamVjdCh7XG4gIC8qKiBBY2NlcHRhYmxlIG5hbWVzIGZvciB0aGlzIG1vZGVsIChlLmcuIGRpZmZlcmVudCB2ZXJzaW9ucykuICovXG4gIHZlcnNpb25zOiBpbXBvcnRfY29yZS56LmFycmF5KGltcG9ydF9jb3JlLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gIC8qKiBGcmllbmRseSBsYWJlbCBmb3IgdGhpcyBtb2RlbCAoZS5nLiBcIkdvb2dsZSBBSSAtIEdlbWluaSBQcm9cIikgKi9cbiAgbGFiZWw6IGltcG9ydF9jb3JlLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgLyoqIE1vZGVsIFNwZWNpZmljIGNvbmZpZ3VyYXRpb24uICovXG4gIGNvbmZpZ1NjaGVtYTogaW1wb3J0X2NvcmUuei5yZWNvcmQoaW1wb3J0X2NvcmUuei5hbnkoKSkub3B0aW9uYWwoKSxcbiAgLyoqIFN1cHBvcnRlZCBtb2RlbCBjYXBhYmlsaXRpZXMuICovXG4gIHN1cHBvcnRzOiBpbXBvcnRfY29yZS56Lm9iamVjdCh7XG4gICAgLyoqIE1vZGVsIGNhbiBwcm9jZXNzIGhpc3RvcmljYWwgbWVzc2FnZXMgcGFzc2VkIHdpdGggYSBwcm9tcHQuICovXG4gICAgbXVsdGl0dXJuOiBpbXBvcnRfY29yZS56LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgIC8qKiBNb2RlbCBjYW4gcHJvY2VzcyBtZWRpYSBhcyBwYXJ0IG9mIHRoZSBwcm9tcHQgKG11bHRpbW9kYWwgaW5wdXQpLiAqL1xuICAgIG1lZGlhOiBpbXBvcnRfY29yZS56LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgIC8qKiBNb2RlbCBjYW4gcGVyZm9ybSB0b29sIGNhbGxzLiAqL1xuICAgIHRvb2xzOiBpbXBvcnRfY29yZS56LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgIC8qKiBNb2RlbCBjYW4gYWNjZXB0IG1lc3NhZ2VzIHdpdGggcm9sZSBcInN5c3RlbVwiLiAqL1xuICAgIHN5c3RlbVJvbGU6IGltcG9ydF9jb3JlLnouYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgLyoqIE1vZGVsIGNhbiBvdXRwdXQgdGhpcyB0eXBlIG9mIGRhdGEuICovXG4gICAgb3V0cHV0OiBpbXBvcnRfY29yZS56LmFycmF5KGltcG9ydF9jb3JlLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgLyoqIE1vZGVsIHN1cHBvcnRzIG91dHB1dCBpbiB0aGVzZSBjb250ZW50IHR5cGVzLiAqL1xuICAgIGNvbnRlbnRUeXBlOiBpbXBvcnRfY29yZS56LmFycmF5KGltcG9ydF9jb3JlLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgLyoqIE1vZGVsIGNhbiBuYXRpdmVseSBzdXBwb3J0IGRvY3VtZW50LWJhc2VkIGNvbnRleHQgZ3JvdW5kaW5nLiAqL1xuICAgIGNvbnRleHQ6IGltcG9ydF9jb3JlLnouYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgLyoqIE1vZGVsIGNhbiBuYXRpdmVseSBzdXBwb3J0IGNvbnN0cmFpbmVkIGdlbmVyYXRpb24uICovXG4gICAgY29uc3RyYWluZWQ6IGltcG9ydF9jb3JlLnouZW51bShbXCJub25lXCIsIFwiYWxsXCIsIFwibm8tdG9vbHNcIl0pLm9wdGlvbmFsKCksXG4gICAgLyoqIE1vZGVsIHN1cHBvcnRzIGNvbnRyb2xsaW5nIHRvb2wgY2hvaWNlLCBlLmcuIGZvcmNlZCB0b29sIGNhbGxpbmcuICovXG4gICAgdG9vbENob2ljZTogaW1wb3J0X2NvcmUuei5ib29sZWFuKCkub3B0aW9uYWwoKVxuICB9KS5vcHRpb25hbCgpLFxuICAvKiogQXQgd2hpY2ggc3RhZ2Ugb2YgZGV2ZWxvcG1lbnQgdGhpcyBtb2RlbCBpcy5cbiAgICogLSBgZmVhdHVyZWRgIG1vZGVscyBhcmUgcmVjb21tZW5kZWQgZm9yIGdlbmVyYWwgdXNlLlxuICAgKiAtIGBzdGFibGVgIG1vZGVscyBhcmUgd2VsbC10ZXN0ZWQgYW5kIHJlbGlhYmxlLlxuICAgKiAtIGB1bnN0YWJsZWAgbW9kZWxzIGFyZSBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAqIC0gYGxlZ2FjeWAgbW9kZWxzIGFyZSBubyBsb25nZXIgcmVjb21tZW5kZWQgZm9yIG5ldyBwcm9qZWN0cy5cbiAgICogLSBgZGVwcmVjYXRlZGAgbW9kZWxzIGFyZSBkZXByZWNhdGVkIGJ5IHRoZSBwcm92aWRlciBhbmQgbWF5IGJlIHJlbW92ZWQgaW4gZnV0dXJlIHZlcnNpb25zLlxuICAgKi9cbiAgc3RhZ2U6IGltcG9ydF9jb3JlLnouZW51bShbXCJmZWF0dXJlZFwiLCBcInN0YWJsZVwiLCBcInVuc3RhYmxlXCIsIFwibGVnYWN5XCIsIFwiZGVwcmVjYXRlZFwiXSkub3B0aW9uYWwoKVxufSk7XG5jb25zdCBUb29sRGVmaW5pdGlvblNjaGVtYSA9IGltcG9ydF9jb3JlLnoub2JqZWN0KHtcbiAgbmFtZTogaW1wb3J0X2NvcmUuei5zdHJpbmcoKSxcbiAgZGVzY3JpcHRpb246IGltcG9ydF9jb3JlLnouc3RyaW5nKCksXG4gIGlucHV0U2NoZW1hOiBpbXBvcnRfY29yZS56LnJlY29yZChpbXBvcnRfY29yZS56LmFueSgpKS5kZXNjcmliZShcIlZhbGlkIEpTT04gU2NoZW1hIHJlcHJlc2VudGluZyB0aGUgaW5wdXQgb2YgdGhlIHRvb2wuXCIpLm51bGxpc2goKSxcbiAgb3V0cHV0U2NoZW1hOiBpbXBvcnRfY29yZS56LnJlY29yZChpbXBvcnRfY29yZS56LmFueSgpKS5kZXNjcmliZShcIlZhbGlkIEpTT04gU2NoZW1hIGRlc2NyaWJpbmcgdGhlIG91dHB1dCBvZiB0aGUgdG9vbC5cIikubnVsbGlzaCgpLFxuICBtZXRhZGF0YTogaW1wb3J0X2NvcmUuei5yZWNvcmQoaW1wb3J0X2NvcmUuei5hbnkoKSkuZGVzY3JpYmUoXCJhZGRpdGlvbmFsIG1ldGFkYXRhIGZvciB0aGlzIHRvb2wgZGVmaW5pdGlvblwiKS5vcHRpb25hbCgpXG59KTtcbmNvbnN0IEdlbmVyYXRpb25Db21tb25Db25maWdEZXNjcmlwdGlvbnMgPSB7XG4gIHRlbXBlcmF0dXJlOiBcIkNvbnRyb2xzIHRoZSBkZWdyZWUgb2YgcmFuZG9tbmVzcyBpbiB0b2tlbiBzZWxlY3Rpb24uIEEgbG93ZXIgdmFsdWUgaXMgZ29vZCBmb3IgYSBtb3JlIHByZWRpY3RhYmxlIHJlc3BvbnNlLiBBIGhpZ2hlciB2YWx1ZSBsZWFkcyB0byBtb3JlIGRpdmVyc2Ugb3IgdW5leHBlY3RlZCByZXN1bHRzLlwiLFxuICBtYXhPdXRwdXRUb2tlbnM6IFwiVGhlIG1heGltdW0gbnVtYmVyIG9mIHRva2VucyB0byBpbmNsdWRlIGluIHRoZSByZXNwb25zZS5cIixcbiAgdG9wSzogXCJUaGUgbWF4aW11bSBudW1iZXIgb2YgdG9rZW5zIHRvIGNvbnNpZGVyIHdoZW4gc2FtcGxpbmcuXCIsXG4gIHRvcFA6IFwiRGVjaWRlcyBob3cgbWFueSBwb3NzaWJsZSB3b3JkcyB0byBjb25zaWRlci4gQSBoaWdoZXIgdmFsdWUgbWVhbnMgdGhhdCB0aGUgbW9kZWwgbG9va3MgYXQgbW9yZSBwb3NzaWJsZSB3b3JkcywgZXZlbiB0aGUgbGVzcyBsaWtlbHkgb25lcywgd2hpY2ggbWFrZXMgdGhlIGdlbmVyYXRlZCB0ZXh0IG1vcmUgZGl2ZXJzZS5cIlxufTtcbmNvbnN0IEdlbmVyYXRpb25Db21tb25Db25maWdTY2hlbWEgPSBpbXBvcnRfY29yZS56Lm9iamVjdCh7XG4gIHZlcnNpb246IGltcG9ydF9jb3JlLnouc3RyaW5nKCkuZGVzY3JpYmUoXG4gICAgXCJBIHNwZWNpZmljIHZlcnNpb24gb2YgYSBtb2RlbCBmYW1pbHksIGUuZy4gYGdlbWluaS0yLjAtZmxhc2hgIGZvciB0aGUgYGdvb2dsZWFpYCBmYW1pbHkuXCJcbiAgKS5vcHRpb25hbCgpLFxuICB0ZW1wZXJhdHVyZTogaW1wb3J0X2NvcmUuei5udW1iZXIoKS5kZXNjcmliZShHZW5lcmF0aW9uQ29tbW9uQ29uZmlnRGVzY3JpcHRpb25zLnRlbXBlcmF0dXJlKS5vcHRpb25hbCgpLFxuICBtYXhPdXRwdXRUb2tlbnM6IGltcG9ydF9jb3JlLnoubnVtYmVyKCkuZGVzY3JpYmUoR2VuZXJhdGlvbkNvbW1vbkNvbmZpZ0Rlc2NyaXB0aW9ucy5tYXhPdXRwdXRUb2tlbnMpLm9wdGlvbmFsKCksXG4gIHRvcEs6IGltcG9ydF9jb3JlLnoubnVtYmVyKCkuZGVzY3JpYmUoR2VuZXJhdGlvbkNvbW1vbkNvbmZpZ0Rlc2NyaXB0aW9ucy50b3BLKS5vcHRpb25hbCgpLFxuICB0b3BQOiBpbXBvcnRfY29yZS56Lm51bWJlcigpLmRlc2NyaWJlKEdlbmVyYXRpb25Db21tb25Db25maWdEZXNjcmlwdGlvbnMudG9wUCkub3B0aW9uYWwoKSxcbiAgc3RvcFNlcXVlbmNlczogaW1wb3J0X2NvcmUuei5hcnJheShpbXBvcnRfY29yZS56LnN0cmluZygpKS5tYXgoNSkuZGVzY3JpYmUoXG4gICAgXCJTZXQgb2YgY2hhcmFjdGVyIHNlcXVlbmNlcyAodXAgdG8gNSkgdGhhdCB3aWxsIHN0b3Agb3V0cHV0IGdlbmVyYXRpb24uXCJcbiAgKS5vcHRpb25hbCgpXG59KS5wYXNzdGhyb3VnaCgpO1xuY29uc3QgT3V0cHV0Q29uZmlnU2NoZW1hID0gaW1wb3J0X2NvcmUuei5vYmplY3Qoe1xuICBmb3JtYXQ6IGltcG9ydF9jb3JlLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgc2NoZW1hOiBpbXBvcnRfY29yZS56LnJlY29yZChpbXBvcnRfY29yZS56LmFueSgpKS5vcHRpb25hbCgpLFxuICBjb25zdHJhaW5lZDogaW1wb3J0X2NvcmUuei5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgY29udGVudFR5cGU6IGltcG9ydF9jb3JlLnouc3RyaW5nKCkub3B0aW9uYWwoKVxufSk7XG5jb25zdCBNb2RlbFJlcXVlc3RTY2hlbWEgPSBpbXBvcnRfY29yZS56Lm9iamVjdCh7XG4gIG1lc3NhZ2VzOiBpbXBvcnRfY29yZS56LmFycmF5KE1lc3NhZ2VTY2hlbWEpLFxuICBjb25maWc6IGltcG9ydF9jb3JlLnouYW55KCkub3B0aW9uYWwoKSxcbiAgdG9vbHM6IGltcG9ydF9jb3JlLnouYXJyYXkoVG9vbERlZmluaXRpb25TY2hlbWEpLm9wdGlvbmFsKCksXG4gIHRvb2xDaG9pY2U6IGltcG9ydF9jb3JlLnouZW51bShbXCJhdXRvXCIsIFwicmVxdWlyZWRcIiwgXCJub25lXCJdKS5vcHRpb25hbCgpLFxuICBvdXRwdXQ6IE91dHB1dENvbmZpZ1NjaGVtYS5vcHRpb25hbCgpLFxuICBkb2NzOiBpbXBvcnRfY29yZS56LmFycmF5KGltcG9ydF9kb2N1bWVudC5Eb2N1bWVudERhdGFTY2hlbWEpLm9wdGlvbmFsKClcbn0pO1xuY29uc3QgR2VuZXJhdGVSZXF1ZXN0U2NoZW1hID0gTW9kZWxSZXF1ZXN0U2NoZW1hLmV4dGVuZCh7XG4gIC8qKiBAZGVwcmVjYXRlZCBBbGwgcmVzcG9uc2VzIG5vdyByZXR1cm4gYSBzaW5nbGUgY2FuZGlkYXRlLiBUaGlzIHdpbGwgYWx3YXlzIGJlIGB1bmRlZmluZWRgLiAqL1xuICBjYW5kaWRhdGVzOiBpbXBvcnRfY29yZS56Lm51bWJlcigpLm9wdGlvbmFsKClcbn0pO1xuY29uc3QgR2VuZXJhdGlvblVzYWdlU2NoZW1hID0gaW1wb3J0X2NvcmUuei5vYmplY3Qoe1xuICBpbnB1dFRva2VuczogaW1wb3J0X2NvcmUuei5udW1iZXIoKS5vcHRpb25hbCgpLFxuICBvdXRwdXRUb2tlbnM6IGltcG9ydF9jb3JlLnoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgdG90YWxUb2tlbnM6IGltcG9ydF9jb3JlLnoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgaW5wdXRDaGFyYWN0ZXJzOiBpbXBvcnRfY29yZS56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gIG91dHB1dENoYXJhY3RlcnM6IGltcG9ydF9jb3JlLnoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgaW5wdXRJbWFnZXM6IGltcG9ydF9jb3JlLnoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgb3V0cHV0SW1hZ2VzOiBpbXBvcnRfY29yZS56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gIGlucHV0VmlkZW9zOiBpbXBvcnRfY29yZS56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gIG91dHB1dFZpZGVvczogaW1wb3J0X2NvcmUuei5udW1iZXIoKS5vcHRpb25hbCgpLFxuICBpbnB1dEF1ZGlvRmlsZXM6IGltcG9ydF9jb3JlLnoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgb3V0cHV0QXVkaW9GaWxlczogaW1wb3J0X2NvcmUuei5udW1iZXIoKS5vcHRpb25hbCgpLFxuICBjdXN0b206IGltcG9ydF9jb3JlLnoucmVjb3JkKGltcG9ydF9jb3JlLnoubnVtYmVyKCkpLm9wdGlvbmFsKCksXG4gIHRob3VnaHRzVG9rZW5zOiBpbXBvcnRfY29yZS56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gIGNhY2hlZENvbnRlbnRUb2tlbnM6IGltcG9ydF9jb3JlLnoubnVtYmVyKCkub3B0aW9uYWwoKVxufSk7XG5jb25zdCBGaW5pc2hSZWFzb25TY2hlbWEgPSBpbXBvcnRfY29yZS56LmVudW0oW1xuICBcInN0b3BcIixcbiAgXCJsZW5ndGhcIixcbiAgXCJibG9ja2VkXCIsXG4gIFwiaW50ZXJydXB0ZWRcIixcbiAgXCJvdGhlclwiLFxuICBcInVua25vd25cIlxuXSk7XG5jb25zdCBDYW5kaWRhdGVTY2hlbWEgPSBpbXBvcnRfY29yZS56Lm9iamVjdCh7XG4gIGluZGV4OiBpbXBvcnRfY29yZS56Lm51bWJlcigpLFxuICBtZXNzYWdlOiBNZXNzYWdlU2NoZW1hLFxuICB1c2FnZTogR2VuZXJhdGlvblVzYWdlU2NoZW1hLm9wdGlvbmFsKCksXG4gIGZpbmlzaFJlYXNvbjogRmluaXNoUmVhc29uU2NoZW1hLFxuICBmaW5pc2hNZXNzYWdlOiBpbXBvcnRfY29yZS56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIGN1c3RvbTogaW1wb3J0X2NvcmUuei51bmtub3duKClcbn0pO1xuY29uc3QgQ2FuZGlkYXRlRXJyb3JTY2hlbWEgPSBpbXBvcnRfY29yZS56Lm9iamVjdCh7XG4gIGluZGV4OiBpbXBvcnRfY29yZS56Lm51bWJlcigpLFxuICBjb2RlOiBpbXBvcnRfY29yZS56LmVudW0oW1wiYmxvY2tlZFwiLCBcIm90aGVyXCIsIFwidW5rbm93blwiXSksXG4gIG1lc3NhZ2U6IGltcG9ydF9jb3JlLnouc3RyaW5nKCkub3B0aW9uYWwoKVxufSk7XG5jb25zdCBNb2RlbFJlc3BvbnNlU2NoZW1hID0gaW1wb3J0X2NvcmUuei5vYmplY3Qoe1xuICBtZXNzYWdlOiBNZXNzYWdlU2NoZW1hLm9wdGlvbmFsKCksXG4gIGZpbmlzaFJlYXNvbjogRmluaXNoUmVhc29uU2NoZW1hLFxuICBmaW5pc2hNZXNzYWdlOiBpbXBvcnRfY29yZS56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIGxhdGVuY3lNczogaW1wb3J0X2NvcmUuei5udW1iZXIoKS5vcHRpb25hbCgpLFxuICB1c2FnZTogR2VuZXJhdGlvblVzYWdlU2NoZW1hLm9wdGlvbmFsKCksXG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgYHJhd2AgaW5zdGVhZCAqL1xuICBjdXN0b206IGltcG9ydF9jb3JlLnoudW5rbm93bigpLFxuICByYXc6IGltcG9ydF9jb3JlLnoudW5rbm93bigpLFxuICByZXF1ZXN0OiBHZW5lcmF0ZVJlcXVlc3RTY2hlbWEub3B0aW9uYWwoKSxcbiAgb3BlcmF0aW9uOiBpbXBvcnRfY29yZS5PcGVyYXRpb25TY2hlbWEub3B0aW9uYWwoKVxufSk7XG5jb25zdCBHZW5lcmF0ZVJlc3BvbnNlU2NoZW1hID0gTW9kZWxSZXNwb25zZVNjaGVtYS5leHRlbmQoe1xuICAvKiogQGRlcHJlY2F0ZWQgQWxsIHJlc3BvbnNlcyBub3cgcmV0dXJuIGEgc2luZ2xlIGNhbmRpZGF0ZS4gT25seSB0aGUgZmlyc3QgY2FuZGlkYXRlIHdpbGwgYmUgdXNlZCBpZiBzdXBwbGllZC4gUmV0dXJuIGBtZXNzYWdlYCwgYGZpbmlzaFJlYXNvbmAsIGFuZCBgZmluaXNoTWVzc2FnZWAgaW5zdGVhZC4gKi9cbiAgY2FuZGlkYXRlczogaW1wb3J0X2NvcmUuei5hcnJheShDYW5kaWRhdGVTY2hlbWEpLm9wdGlvbmFsKCksXG4gIGZpbmlzaFJlYXNvbjogRmluaXNoUmVhc29uU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xuY29uc3QgTW9kZWxSZXNwb25zZUNodW5rU2NoZW1hID0gaW1wb3J0X2NvcmUuei5vYmplY3Qoe1xuICByb2xlOiBSb2xlU2NoZW1hLm9wdGlvbmFsKCksXG4gIC8qKiBpbmRleCBvZiB0aGUgbWVzc2FnZSB0aGlzIGNodW5rIGJlbG9uZ3MgdG8uICovXG4gIGluZGV4OiBpbXBvcnRfY29yZS56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gIC8qKiBUaGUgY2h1bmsgb2YgY29udGVudCB0byBzdHJlYW0gcmlnaHQgbm93LiAqL1xuICBjb250ZW50OiBpbXBvcnRfY29yZS56LmFycmF5KFBhcnRTY2hlbWEpLFxuICAvKiogTW9kZWwtc3BlY2lmaWMgZXh0cmEgaW5mb3JtYXRpb24gYXR0YWNoZWQgdG8gdGhpcyBjaHVuay4gKi9cbiAgY3VzdG9tOiBpbXBvcnRfY29yZS56LnVua25vd24oKS5vcHRpb25hbCgpLFxuICAvKiogSWYgdHJ1ZSwgdGhlIGNodW5rIGluY2x1ZGVzIGFsbCBkYXRhIGZyb20gcHJldmlvdXMgY2h1bmtzLiBPdGhlcndpc2UsIGNvbnNpZGVyZWQgdG8gYmUgaW5jcmVtZW50YWwuICovXG4gIGFnZ3JlZ2F0ZWQ6IGltcG9ydF9jb3JlLnouYm9vbGVhbigpLm9wdGlvbmFsKClcbn0pO1xuY29uc3QgR2VuZXJhdGVSZXNwb25zZUNodW5rU2NoZW1hID0gTW9kZWxSZXNwb25zZUNodW5rU2NoZW1hO1xuY29uc3QgR2VuZXJhdGVBY3Rpb25PdXRwdXRDb25maWcgPSBpbXBvcnRfY29yZS56Lm9iamVjdCh7XG4gIGZvcm1hdDogaW1wb3J0X2NvcmUuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBjb250ZW50VHlwZTogaW1wb3J0X2NvcmUuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBpbnN0cnVjdGlvbnM6IGltcG9ydF9jb3JlLnoudW5pb24oW2ltcG9ydF9jb3JlLnouYm9vbGVhbigpLCBpbXBvcnRfY29yZS56LnN0cmluZygpXSkub3B0aW9uYWwoKSxcbiAganNvblNjaGVtYTogaW1wb3J0X2NvcmUuei5hbnkoKS5vcHRpb25hbCgpLFxuICBjb25zdHJhaW5lZDogaW1wb3J0X2NvcmUuei5ib29sZWFuKCkub3B0aW9uYWwoKVxufSk7XG5jb25zdCBHZW5lcmF0ZUFjdGlvbk9wdGlvbnNTY2hlbWEgPSBpbXBvcnRfY29yZS56Lm9iamVjdCh7XG4gIC8qKiBBIG1vZGVsIG5hbWUgKGUuZy4gYHZlcnRleGFpL2dlbWluaS0xLjAtcHJvYCkuICovXG4gIG1vZGVsOiBpbXBvcnRfY29yZS56LnN0cmluZygpLFxuICAvKiogUmV0cmlldmVkIGRvY3VtZW50cyB0byBiZSB1c2VkIGFzIGNvbnRleHQgZm9yIHRoaXMgZ2VuZXJhdGlvbi4gKi9cbiAgZG9jczogaW1wb3J0X2NvcmUuei5hcnJheShpbXBvcnRfZG9jdW1lbnQuRG9jdW1lbnREYXRhU2NoZW1hKS5vcHRpb25hbCgpLFxuICAvKiogQ29udmVyc2F0aW9uIGhpc3RvcnkgZm9yIG11bHRpLXR1cm4gcHJvbXB0aW5nIHdoZW4gc3VwcG9ydGVkIGJ5IHRoZSB1bmRlcmx5aW5nIG1vZGVsLiAqL1xuICBtZXNzYWdlczogaW1wb3J0X2NvcmUuei5hcnJheShNZXNzYWdlU2NoZW1hKSxcbiAgLyoqIExpc3Qgb2YgcmVnaXN0ZXJlZCB0b29sIG5hbWVzIGZvciB0aGlzIGdlbmVyYXRpb24gaWYgc3VwcG9ydGVkIGJ5IHRoZSB1bmRlcmx5aW5nIG1vZGVsLiAqL1xuICB0b29sczogaW1wb3J0X2NvcmUuei5hcnJheShpbXBvcnRfY29yZS56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAvKiogVG9vbCBjYWxsaW5nIG1vZGUuIGBhdXRvYCBsZXRzIHRoZSBtb2RlbCBkZWNpZGUgd2hldGhlciB0byB1c2UgdG9vbHMsIGByZXF1aXJlZGAgZm9yY2VzIHRoZSBtb2RlbCB0byBjaG9vc2UgYSB0b29sLCBhbmQgYG5vbmVgIGZvcmNlcyB0aGUgbW9kZWwgbm90IHRvIHVzZSBhbnkgdG9vbHMuIERlZmF1bHRzIHRvIGBhdXRvYC4gICovXG4gIHRvb2xDaG9pY2U6IGltcG9ydF9jb3JlLnouZW51bShbXCJhdXRvXCIsIFwicmVxdWlyZWRcIiwgXCJub25lXCJdKS5vcHRpb25hbCgpLFxuICAvKiogQ29uZmlndXJhdGlvbiBmb3IgdGhlIGdlbmVyYXRpb24gcmVxdWVzdC4gKi9cbiAgY29uZmlnOiBpbXBvcnRfY29yZS56LmFueSgpLm9wdGlvbmFsKCksXG4gIC8qKiBDb25maWd1cmF0aW9uIGZvciB0aGUgZGVzaXJlZCBvdXRwdXQgb2YgdGhlIHJlcXVlc3QuIERlZmF1bHRzIHRvIHRoZSBtb2RlbCdzIGRlZmF1bHQgb3V0cHV0IGlmIHVuc3BlY2lmaWVkLiAqL1xuICBvdXRwdXQ6IEdlbmVyYXRlQWN0aW9uT3V0cHV0Q29uZmlnLm9wdGlvbmFsKCksXG4gIC8qKiBPcHRpb25zIGZvciByZXN1bWluZyBhbiBpbnRlcnJ1cHRlZCBnZW5lcmF0aW9uLiAqL1xuICByZXN1bWU6IGltcG9ydF9jb3JlLnoub2JqZWN0KHtcbiAgICByZXNwb25kOiBpbXBvcnRfY29yZS56LmFycmF5KGltcG9ydF9kb2N1bWVudC5Ub29sUmVzcG9uc2VQYXJ0U2NoZW1hKS5vcHRpb25hbCgpLFxuICAgIHJlc3RhcnQ6IGltcG9ydF9jb3JlLnouYXJyYXkoaW1wb3J0X2RvY3VtZW50LlRvb2xSZXF1ZXN0UGFydFNjaGVtYSkub3B0aW9uYWwoKSxcbiAgICBtZXRhZGF0YTogaW1wb3J0X2NvcmUuei5yZWNvcmQoaW1wb3J0X2NvcmUuei5hbnkoKSkub3B0aW9uYWwoKVxuICB9KS5vcHRpb25hbCgpLFxuICAvKiogV2hlbiB0cnVlLCByZXR1cm4gdG9vbCBjYWxscyBmb3IgbWFudWFsIHByb2Nlc3NpbmcgaW5zdGVhZCBvZiBhdXRvbWF0aWNhbGx5IHJlc29sdmluZyB0aGVtLiAqL1xuICByZXR1cm5Ub29sUmVxdWVzdHM6IGltcG9ydF9jb3JlLnouYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gIC8qKiBNYXhpbXVtIG51bWJlciBvZiB0b29sIGNhbGwgaXRlcmF0aW9ucyB0aGF0IGNhbiBiZSBwZXJmb3JtZWQgaW4gYSBzaW5nbGUgZ2VuZXJhdGUgY2FsbCAoZGVmYXVsdCA1KS4gKi9cbiAgbWF4VHVybnM6IGltcG9ydF9jb3JlLnoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgLyoqIEN1c3RvbSBzdGVwIG5hbWUgZm9yIHRoaXMgZ2VuZXJhdGUgY2FsbCB0byBkaXNwbGF5IGluIHRyYWNlIHZpZXdzLiBEZWZhdWx0cyB0byBcImdlbmVyYXRlXCIuICovXG4gIHN0ZXBOYW1lOiBpbXBvcnRfY29yZS56LnN0cmluZygpLm9wdGlvbmFsKClcbn0pO1xuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIENhbmRpZGF0ZUVycm9yU2NoZW1hLFxuICBDYW5kaWRhdGVTY2hlbWEsXG4gIEZpbmlzaFJlYXNvblNjaGVtYSxcbiAgR2VuZXJhdGVBY3Rpb25PcHRpb25zU2NoZW1hLFxuICBHZW5lcmF0ZUFjdGlvbk91dHB1dENvbmZpZyxcbiAgR2VuZXJhdGVSZXF1ZXN0U2NoZW1hLFxuICBHZW5lcmF0ZVJlc3BvbnNlQ2h1bmtTY2hlbWEsXG4gIEdlbmVyYXRlUmVzcG9uc2VTY2hlbWEsXG4gIEdlbmVyYXRpb25Db21tb25Db25maWdEZXNjcmlwdGlvbnMsXG4gIEdlbmVyYXRpb25Db21tb25Db25maWdTY2hlbWEsXG4gIEdlbmVyYXRpb25Vc2FnZVNjaGVtYSxcbiAgTWVzc2FnZVNjaGVtYSxcbiAgTW9kZWxJbmZvU2NoZW1hLFxuICBNb2RlbFJlcXVlc3RTY2hlbWEsXG4gIE1vZGVsUmVzcG9uc2VDaHVua1NjaGVtYSxcbiAgTW9kZWxSZXNwb25zZVNjaGVtYSxcbiAgT3V0cHV0Q29uZmlnU2NoZW1hLFxuICBQYXJ0U2NoZW1hLFxuICBSb2xlU2NoZW1hLFxuICBUb29sRGVmaW5pdGlvblNjaGVtYVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlbC10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/model-types.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/model.js":
/*!*************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/model.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar model_exports = {};\n__export(model_exports, {\n  CustomPartSchema: () => import_document.CustomPartSchema,\n  DataPartSchema: () => import_document.DataPartSchema,\n  MediaPartSchema: () => import_document.MediaPartSchema,\n  TextPartSchema: () => import_document.TextPartSchema,\n  ToolRequestPartSchema: () => import_document.ToolRequestPartSchema,\n  ToolResponsePartSchema: () => import_document.ToolResponsePartSchema,\n  backgroundModel: () => backgroundModel,\n  defineBackgroundModel: () => defineBackgroundModel,\n  defineGenerateAction: () => import_action.defineGenerateAction,\n  defineModel: () => defineModel,\n  getBasicUsageStats: () => getBasicUsageStats,\n  model: () => model,\n  modelActionMetadata: () => modelActionMetadata,\n  modelRef: () => modelRef,\n  resolveModel: () => resolveModel,\n  simulateConstrainedGeneration: () => import_middleware.simulateConstrainedGeneration\n});\nmodule.exports = __toCommonJS(model_exports);\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nvar import_logging = __webpack_require__(/*! @genkit-ai/core/logging */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/logging.js\");\nvar import_schema = __webpack_require__(/*! @genkit-ai/core/schema */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/schema.js\");\nvar import_node_perf_hooks = __webpack_require__(/*! node:perf_hooks */ \"node:perf_hooks\");\nvar import_document = __webpack_require__(/*! ./document.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/document.js\");\nvar import_model_types = __webpack_require__(/*! ./model-types.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/model-types.js\");\nvar import_middleware = __webpack_require__(/*! ./model/middleware.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/model/middleware.js\");\nvar import_action = __webpack_require__(/*! ./generate/action.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/generate/action.js\");\n__reExport(model_exports, __webpack_require__(/*! ./model-types.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/model-types.js\"), module.exports);\nfunction model(options, runner) {\n  const act = (0, import_core.action)(modelActionOptions(options), (input, ctx) => {\n    const startTimeMs = import_node_perf_hooks.performance.now();\n    return runner(input, ctx).then((response) => {\n      const timedResponse = {\n        ...response,\n        latencyMs: import_node_perf_hooks.performance.now() - startTimeMs\n      };\n      return timedResponse;\n    });\n  });\n  Object.assign(act, {\n    __configSchema: options.configSchema || import_core.z.unknown()\n  });\n  return act;\n}\nfunction modelActionOptions(options) {\n  const label = options.label || options.name;\n  const middleware = getModelMiddleware(options);\n  return {\n    actionType: \"model\",\n    name: options.name,\n    description: label,\n    inputSchema: import_model_types.GenerateRequestSchema,\n    outputSchema: import_model_types.GenerateResponseSchema,\n    metadata: {\n      model: {\n        label,\n        customOptions: options.configSchema ? (0, import_schema.toJsonSchema)({ schema: options.configSchema }) : void 0,\n        versions: options.versions,\n        supports: options.supports\n      }\n    },\n    use: middleware\n  };\n}\nfunction defineModel(registry, options, runner) {\n  const act = (0, import_core.defineAction)(\n    registry,\n    modelActionOptions(options),\n    (input, ctx) => {\n      const startTimeMs = import_node_perf_hooks.performance.now();\n      const secondParam = options.apiVersion === \"v2\" ? ctx : ctx.streamingRequested ? ctx.sendChunk : void 0;\n      return runner(input, secondParam).then((response) => {\n        const timedResponse = {\n          ...response,\n          latencyMs: import_node_perf_hooks.performance.now() - startTimeMs\n        };\n        return timedResponse;\n      });\n    }\n  );\n  Object.assign(act, {\n    __configSchema: options.configSchema || import_core.z.unknown()\n  });\n  return act;\n}\nfunction defineBackgroundModel(registry, options) {\n  const act = backgroundModel(options);\n  (0, import_core.registerBackgroundAction)(registry, act);\n  return act;\n}\nfunction backgroundModel(options) {\n  const label = options.label || options.name;\n  const middleware = getModelMiddleware(options);\n  const act = (0, import_core.backgroundAction)({\n    actionType: \"background-model\",\n    name: options.name,\n    description: label,\n    inputSchema: import_model_types.GenerateRequestSchema,\n    outputSchema: import_model_types.GenerateResponseSchema,\n    metadata: {\n      model: {\n        label,\n        customOptions: options.configSchema ? (0, import_schema.toJsonSchema)({ schema: options.configSchema }) : void 0,\n        versions: options.versions,\n        supports: options.supports\n      }\n    },\n    use: middleware,\n    async start(request) {\n      const startTimeMs = import_node_perf_hooks.performance.now();\n      const response = await options.start(request);\n      Object.assign(response, {\n        latencyMs: import_node_perf_hooks.performance.now() - startTimeMs\n      });\n      return response;\n    },\n    async check(op) {\n      return options.check(op);\n    },\n    cancel: options.cancel ? async (op) => {\n      if (!options.cancel) {\n        throw new import_core.GenkitError({\n          status: \"UNIMPLEMENTED\",\n          message: \"cancel not implemented\"\n        });\n      }\n      return options.cancel(op);\n    } : void 0\n  });\n  Object.assign(act, {\n    __configSchema: options.configSchema || import_core.z.unknown()\n  });\n  return act;\n}\nfunction getModelMiddleware(options) {\n  const middleware = options.use || [];\n  if (!options?.supports?.context) middleware.push((0, import_middleware.augmentWithContext)());\n  const constratedSimulator = (0, import_middleware.simulateConstrainedGeneration)();\n  middleware.push((req, next) => {\n    if (!options?.supports?.constrained || options?.supports?.constrained === \"none\" || options?.supports?.constrained === \"no-tools\" && (req.tools?.length ?? 0) > 0) {\n      return constratedSimulator(req, next);\n    }\n    return next(req);\n  });\n  return middleware;\n}\nfunction modelActionMetadata({\n  name,\n  info,\n  configSchema,\n  background\n}) {\n  return {\n    actionType: background ? \"background-model\" : \"model\",\n    name,\n    inputJsonSchema: (0, import_schema.toJsonSchema)({ schema: import_model_types.GenerateRequestSchema }),\n    outputJsonSchema: background ? (0, import_schema.toJsonSchema)({ schema: import_core.OperationSchema }) : (0, import_schema.toJsonSchema)({ schema: import_model_types.GenerateResponseSchema }),\n    metadata: {\n      model: {\n        ...info,\n        customOptions: configSchema ? (0, import_schema.toJsonSchema)({ schema: configSchema }) : void 0\n      }\n    }\n  };\n}\nfunction modelRef(options) {\n  let name = options.name;\n  if (options.namespace && !name.startsWith(options.namespace + \"/\")) {\n    name = `${options.namespace}/${name}`;\n  }\n  const ref = {\n    ...options,\n    name\n  };\n  ref.withConfig = (cfg) => {\n    return modelRef({\n      ...options,\n      name,\n      config: cfg\n    });\n  };\n  ref.withVersion = (version) => {\n    return modelRef({\n      ...options,\n      name,\n      version\n    });\n  };\n  return ref;\n}\nfunction getBasicUsageStats(input, response) {\n  const inputCounts = getPartCounts(input.flatMap((md) => md.content));\n  const outputCounts = getPartCounts(\n    Array.isArray(response) ? response.flatMap((c) => c.message.content) : response.content\n  );\n  return {\n    inputCharacters: inputCounts.characters,\n    inputImages: inputCounts.images,\n    inputVideos: inputCounts.videos,\n    inputAudioFiles: inputCounts.audio,\n    outputCharacters: outputCounts.characters,\n    outputImages: outputCounts.images,\n    outputVideos: outputCounts.videos,\n    outputAudioFiles: outputCounts.audio\n  };\n}\nfunction getPartCounts(parts) {\n  return parts.reduce(\n    (counts, part) => {\n      const isImage = part.media?.contentType?.startsWith(\"image\") || part.media?.url?.startsWith(\"data:image\");\n      const isVideo = part.media?.contentType?.startsWith(\"video\") || part.media?.url?.startsWith(\"data:video\");\n      const isAudio = part.media?.contentType?.startsWith(\"audio\") || part.media?.url?.startsWith(\"data:audio\");\n      return {\n        characters: counts.characters + (part.text?.length || 0),\n        images: counts.images + (isImage ? 1 : 0),\n        videos: counts.videos + (isVideo ? 1 : 0),\n        audio: counts.audio + (isAudio ? 1 : 0)\n      };\n    },\n    { characters: 0, images: 0, videos: 0, audio: 0 }\n  );\n}\nasync function resolveModel(registry, model2, options) {\n  let out;\n  let modelId;\n  if (!model2) {\n    model2 = await registry.lookupValue(\"defaultModel\", \"defaultModel\");\n  }\n  if (!model2) {\n    throw new import_core.GenkitError({\n      status: \"INVALID_ARGUMENT\",\n      message: \"Must supply a `model` to `generate()` calls.\"\n    });\n  }\n  if (typeof model2 === \"string\") {\n    modelId = model2;\n    out = { modelAction: await lookupModel(registry, model2) };\n  } else if (model2.hasOwnProperty(\"__action\")) {\n    modelId = model2.__action.name;\n    out = { modelAction: model2 };\n  } else {\n    const ref = model2;\n    modelId = ref.name;\n    out = {\n      modelAction: await lookupModel(registry, ref.name),\n      config: {\n        ...ref.config\n      },\n      version: ref.version\n    };\n  }\n  if (!out.modelAction) {\n    throw new import_core.GenkitError({\n      status: \"NOT_FOUND\",\n      message: `Model '${modelId}' not found`\n    });\n  }\n  if (options?.warnDeprecated && out.modelAction.__action.metadata?.model?.stage === \"deprecated\") {\n    import_logging.logger.warn(\n      `Model '${out.modelAction.__action.name}' is deprecated and may be removed in a future release.`\n    );\n  }\n  return out;\n}\nasync function lookupModel(registry, model2) {\n  return await registry.lookupAction(`/model/${model2}`) || await registry.lookupAction(`/background-model/${model2}`);\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=model.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9tb2RlbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMscUZBQWlCO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLCtGQUF5QjtBQUN0RCxvQkFBb0IsbUJBQU8sQ0FBQyw2RkFBd0I7QUFDcEQsNkJBQTZCLG1CQUFPLENBQUMsd0NBQWlCO0FBQ3RELHNCQUFzQixtQkFBTyxDQUFDLG9GQUFlO0FBQzdDLHlCQUF5QixtQkFBTyxDQUFDLDBGQUFrQjtBQUNuRCx3QkFBd0IsbUJBQU8sQ0FBQyxvR0FBdUI7QUFDdkQsb0JBQW9CLG1CQUFPLENBQUMsa0dBQXNCO0FBQ2xELDBCQUEwQixtQkFBTyxDQUFDLDBGQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRiw4QkFBOEI7QUFDOUc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLDhCQUE4QjtBQUM5RztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGtEQUFrRDtBQUN6RyxxRUFBcUUscUNBQXFDLHNDQUFzQyxtREFBbUQ7QUFDbk07QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLHNCQUFzQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0JBQWtCLEdBQUcsS0FBSztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osSUFBSTtBQUNKO0FBQ0EsWUFBWTtBQUNaLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxPQUFPLHVEQUF1RCxPQUFPO0FBQ3BIO0FBQ0E7QUFDQSxNQUFNLENBa0JMO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcS1JhbWFjaGFcXERvY3VtZW50c1xcU3VzdEFJbmV4IEdJdCBDb2RlXFxub2RlX21vZHVsZXNcXEBnZW5raXQtYWlcXGFpXFxsaWJcXG1vZGVsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZCwgc2Vjb25kVGFyZ2V0KSA9PiAoX19jb3B5UHJvcHModGFyZ2V0LCBtb2QsIFwiZGVmYXVsdFwiKSwgc2Vjb25kVGFyZ2V0ICYmIF9fY29weVByb3BzKHNlY29uZFRhcmdldCwgbW9kLCBcImRlZmF1bHRcIikpO1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgbW9kZWxfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobW9kZWxfZXhwb3J0cywge1xuICBDdXN0b21QYXJ0U2NoZW1hOiAoKSA9PiBpbXBvcnRfZG9jdW1lbnQuQ3VzdG9tUGFydFNjaGVtYSxcbiAgRGF0YVBhcnRTY2hlbWE6ICgpID0+IGltcG9ydF9kb2N1bWVudC5EYXRhUGFydFNjaGVtYSxcbiAgTWVkaWFQYXJ0U2NoZW1hOiAoKSA9PiBpbXBvcnRfZG9jdW1lbnQuTWVkaWFQYXJ0U2NoZW1hLFxuICBUZXh0UGFydFNjaGVtYTogKCkgPT4gaW1wb3J0X2RvY3VtZW50LlRleHRQYXJ0U2NoZW1hLFxuICBUb29sUmVxdWVzdFBhcnRTY2hlbWE6ICgpID0+IGltcG9ydF9kb2N1bWVudC5Ub29sUmVxdWVzdFBhcnRTY2hlbWEsXG4gIFRvb2xSZXNwb25zZVBhcnRTY2hlbWE6ICgpID0+IGltcG9ydF9kb2N1bWVudC5Ub29sUmVzcG9uc2VQYXJ0U2NoZW1hLFxuICBiYWNrZ3JvdW5kTW9kZWw6ICgpID0+IGJhY2tncm91bmRNb2RlbCxcbiAgZGVmaW5lQmFja2dyb3VuZE1vZGVsOiAoKSA9PiBkZWZpbmVCYWNrZ3JvdW5kTW9kZWwsXG4gIGRlZmluZUdlbmVyYXRlQWN0aW9uOiAoKSA9PiBpbXBvcnRfYWN0aW9uLmRlZmluZUdlbmVyYXRlQWN0aW9uLFxuICBkZWZpbmVNb2RlbDogKCkgPT4gZGVmaW5lTW9kZWwsXG4gIGdldEJhc2ljVXNhZ2VTdGF0czogKCkgPT4gZ2V0QmFzaWNVc2FnZVN0YXRzLFxuICBtb2RlbDogKCkgPT4gbW9kZWwsXG4gIG1vZGVsQWN0aW9uTWV0YWRhdGE6ICgpID0+IG1vZGVsQWN0aW9uTWV0YWRhdGEsXG4gIG1vZGVsUmVmOiAoKSA9PiBtb2RlbFJlZixcbiAgcmVzb2x2ZU1vZGVsOiAoKSA9PiByZXNvbHZlTW9kZWwsXG4gIHNpbXVsYXRlQ29uc3RyYWluZWRHZW5lcmF0aW9uOiAoKSA9PiBpbXBvcnRfbWlkZGxld2FyZS5zaW11bGF0ZUNvbnN0cmFpbmVkR2VuZXJhdGlvblxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhtb2RlbF9leHBvcnRzKTtcbnZhciBpbXBvcnRfY29yZSA9IHJlcXVpcmUoXCJAZ2Vua2l0LWFpL2NvcmVcIik7XG52YXIgaW1wb3J0X2xvZ2dpbmcgPSByZXF1aXJlKFwiQGdlbmtpdC1haS9jb3JlL2xvZ2dpbmdcIik7XG52YXIgaW1wb3J0X3NjaGVtYSA9IHJlcXVpcmUoXCJAZ2Vua2l0LWFpL2NvcmUvc2NoZW1hXCIpO1xudmFyIGltcG9ydF9ub2RlX3BlcmZfaG9va3MgPSByZXF1aXJlKFwibm9kZTpwZXJmX2hvb2tzXCIpO1xudmFyIGltcG9ydF9kb2N1bWVudCA9IHJlcXVpcmUoXCIuL2RvY3VtZW50LmpzXCIpO1xudmFyIGltcG9ydF9tb2RlbF90eXBlcyA9IHJlcXVpcmUoXCIuL21vZGVsLXR5cGVzLmpzXCIpO1xudmFyIGltcG9ydF9taWRkbGV3YXJlID0gcmVxdWlyZShcIi4vbW9kZWwvbWlkZGxld2FyZS5qc1wiKTtcbnZhciBpbXBvcnRfYWN0aW9uID0gcmVxdWlyZShcIi4vZ2VuZXJhdGUvYWN0aW9uLmpzXCIpO1xuX19yZUV4cG9ydChtb2RlbF9leHBvcnRzLCByZXF1aXJlKFwiLi9tb2RlbC10eXBlcy5qc1wiKSwgbW9kdWxlLmV4cG9ydHMpO1xuZnVuY3Rpb24gbW9kZWwob3B0aW9ucywgcnVubmVyKSB7XG4gIGNvbnN0IGFjdCA9ICgwLCBpbXBvcnRfY29yZS5hY3Rpb24pKG1vZGVsQWN0aW9uT3B0aW9ucyhvcHRpb25zKSwgKGlucHV0LCBjdHgpID0+IHtcbiAgICBjb25zdCBzdGFydFRpbWVNcyA9IGltcG9ydF9ub2RlX3BlcmZfaG9va3MucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgcmV0dXJuIHJ1bm5lcihpbnB1dCwgY3R4KS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgY29uc3QgdGltZWRSZXNwb25zZSA9IHtcbiAgICAgICAgLi4ucmVzcG9uc2UsXG4gICAgICAgIGxhdGVuY3lNczogaW1wb3J0X25vZGVfcGVyZl9ob29rcy5wZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZU1zXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRpbWVkUmVzcG9uc2U7XG4gICAgfSk7XG4gIH0pO1xuICBPYmplY3QuYXNzaWduKGFjdCwge1xuICAgIF9fY29uZmlnU2NoZW1hOiBvcHRpb25zLmNvbmZpZ1NjaGVtYSB8fCBpbXBvcnRfY29yZS56LnVua25vd24oKVxuICB9KTtcbiAgcmV0dXJuIGFjdDtcbn1cbmZ1bmN0aW9uIG1vZGVsQWN0aW9uT3B0aW9ucyhvcHRpb25zKSB7XG4gIGNvbnN0IGxhYmVsID0gb3B0aW9ucy5sYWJlbCB8fCBvcHRpb25zLm5hbWU7XG4gIGNvbnN0IG1pZGRsZXdhcmUgPSBnZXRNb2RlbE1pZGRsZXdhcmUob3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgYWN0aW9uVHlwZTogXCJtb2RlbFwiLFxuICAgIG5hbWU6IG9wdGlvbnMubmFtZSxcbiAgICBkZXNjcmlwdGlvbjogbGFiZWwsXG4gICAgaW5wdXRTY2hlbWE6IGltcG9ydF9tb2RlbF90eXBlcy5HZW5lcmF0ZVJlcXVlc3RTY2hlbWEsXG4gICAgb3V0cHV0U2NoZW1hOiBpbXBvcnRfbW9kZWxfdHlwZXMuR2VuZXJhdGVSZXNwb25zZVNjaGVtYSxcbiAgICBtZXRhZGF0YToge1xuICAgICAgbW9kZWw6IHtcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGN1c3RvbU9wdGlvbnM6IG9wdGlvbnMuY29uZmlnU2NoZW1hID8gKDAsIGltcG9ydF9zY2hlbWEudG9Kc29uU2NoZW1hKSh7IHNjaGVtYTogb3B0aW9ucy5jb25maWdTY2hlbWEgfSkgOiB2b2lkIDAsXG4gICAgICAgIHZlcnNpb25zOiBvcHRpb25zLnZlcnNpb25zLFxuICAgICAgICBzdXBwb3J0czogb3B0aW9ucy5zdXBwb3J0c1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlOiBtaWRkbGV3YXJlXG4gIH07XG59XG5mdW5jdGlvbiBkZWZpbmVNb2RlbChyZWdpc3RyeSwgb3B0aW9ucywgcnVubmVyKSB7XG4gIGNvbnN0IGFjdCA9ICgwLCBpbXBvcnRfY29yZS5kZWZpbmVBY3Rpb24pKFxuICAgIHJlZ2lzdHJ5LFxuICAgIG1vZGVsQWN0aW9uT3B0aW9ucyhvcHRpb25zKSxcbiAgICAoaW5wdXQsIGN0eCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lTXMgPSBpbXBvcnRfbm9kZV9wZXJmX2hvb2tzLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3Qgc2Vjb25kUGFyYW0gPSBvcHRpb25zLmFwaVZlcnNpb24gPT09IFwidjJcIiA/IGN0eCA6IGN0eC5zdHJlYW1pbmdSZXF1ZXN0ZWQgPyBjdHguc2VuZENodW5rIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIHJ1bm5lcihpbnB1dCwgc2Vjb25kUGFyYW0pLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRpbWVkUmVzcG9uc2UgPSB7XG4gICAgICAgICAgLi4ucmVzcG9uc2UsXG4gICAgICAgICAgbGF0ZW5jeU1zOiBpbXBvcnRfbm9kZV9wZXJmX2hvb2tzLnBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lTXNcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRpbWVkUmVzcG9uc2U7XG4gICAgICB9KTtcbiAgICB9XG4gICk7XG4gIE9iamVjdC5hc3NpZ24oYWN0LCB7XG4gICAgX19jb25maWdTY2hlbWE6IG9wdGlvbnMuY29uZmlnU2NoZW1hIHx8IGltcG9ydF9jb3JlLnoudW5rbm93bigpXG4gIH0pO1xuICByZXR1cm4gYWN0O1xufVxuZnVuY3Rpb24gZGVmaW5lQmFja2dyb3VuZE1vZGVsKHJlZ2lzdHJ5LCBvcHRpb25zKSB7XG4gIGNvbnN0IGFjdCA9IGJhY2tncm91bmRNb2RlbChvcHRpb25zKTtcbiAgKDAsIGltcG9ydF9jb3JlLnJlZ2lzdGVyQmFja2dyb3VuZEFjdGlvbikocmVnaXN0cnksIGFjdCk7XG4gIHJldHVybiBhY3Q7XG59XG5mdW5jdGlvbiBiYWNrZ3JvdW5kTW9kZWwob3B0aW9ucykge1xuICBjb25zdCBsYWJlbCA9IG9wdGlvbnMubGFiZWwgfHwgb3B0aW9ucy5uYW1lO1xuICBjb25zdCBtaWRkbGV3YXJlID0gZ2V0TW9kZWxNaWRkbGV3YXJlKG9wdGlvbnMpO1xuICBjb25zdCBhY3QgPSAoMCwgaW1wb3J0X2NvcmUuYmFja2dyb3VuZEFjdGlvbikoe1xuICAgIGFjdGlvblR5cGU6IFwiYmFja2dyb3VuZC1tb2RlbFwiLFxuICAgIG5hbWU6IG9wdGlvbnMubmFtZSxcbiAgICBkZXNjcmlwdGlvbjogbGFiZWwsXG4gICAgaW5wdXRTY2hlbWE6IGltcG9ydF9tb2RlbF90eXBlcy5HZW5lcmF0ZVJlcXVlc3RTY2hlbWEsXG4gICAgb3V0cHV0U2NoZW1hOiBpbXBvcnRfbW9kZWxfdHlwZXMuR2VuZXJhdGVSZXNwb25zZVNjaGVtYSxcbiAgICBtZXRhZGF0YToge1xuICAgICAgbW9kZWw6IHtcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGN1c3RvbU9wdGlvbnM6IG9wdGlvbnMuY29uZmlnU2NoZW1hID8gKDAsIGltcG9ydF9zY2hlbWEudG9Kc29uU2NoZW1hKSh7IHNjaGVtYTogb3B0aW9ucy5jb25maWdTY2hlbWEgfSkgOiB2b2lkIDAsXG4gICAgICAgIHZlcnNpb25zOiBvcHRpb25zLnZlcnNpb25zLFxuICAgICAgICBzdXBwb3J0czogb3B0aW9ucy5zdXBwb3J0c1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlOiBtaWRkbGV3YXJlLFxuICAgIGFzeW5jIHN0YXJ0KHJlcXVlc3QpIHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZU1zID0gaW1wb3J0X25vZGVfcGVyZl9ob29rcy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb3B0aW9ucy5zdGFydChyZXF1ZXN0KTtcbiAgICAgIE9iamVjdC5hc3NpZ24ocmVzcG9uc2UsIHtcbiAgICAgICAgbGF0ZW5jeU1zOiBpbXBvcnRfbm9kZV9wZXJmX2hvb2tzLnBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lTXNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG4gICAgYXN5bmMgY2hlY2sob3ApIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmNoZWNrKG9wKTtcbiAgICB9LFxuICAgIGNhbmNlbDogb3B0aW9ucy5jYW5jZWwgPyBhc3luYyAob3ApID0+IHtcbiAgICAgIGlmICghb3B0aW9ucy5jYW5jZWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IGltcG9ydF9jb3JlLkdlbmtpdEVycm9yKHtcbiAgICAgICAgICBzdGF0dXM6IFwiVU5JTVBMRU1FTlRFRFwiLFxuICAgICAgICAgIG1lc3NhZ2U6IFwiY2FuY2VsIG5vdCBpbXBsZW1lbnRlZFwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMuY2FuY2VsKG9wKTtcbiAgICB9IDogdm9pZCAwXG4gIH0pO1xuICBPYmplY3QuYXNzaWduKGFjdCwge1xuICAgIF9fY29uZmlnU2NoZW1hOiBvcHRpb25zLmNvbmZpZ1NjaGVtYSB8fCBpbXBvcnRfY29yZS56LnVua25vd24oKVxuICB9KTtcbiAgcmV0dXJuIGFjdDtcbn1cbmZ1bmN0aW9uIGdldE1vZGVsTWlkZGxld2FyZShvcHRpb25zKSB7XG4gIGNvbnN0IG1pZGRsZXdhcmUgPSBvcHRpb25zLnVzZSB8fCBbXTtcbiAgaWYgKCFvcHRpb25zPy5zdXBwb3J0cz8uY29udGV4dCkgbWlkZGxld2FyZS5wdXNoKCgwLCBpbXBvcnRfbWlkZGxld2FyZS5hdWdtZW50V2l0aENvbnRleHQpKCkpO1xuICBjb25zdCBjb25zdHJhdGVkU2ltdWxhdG9yID0gKDAsIGltcG9ydF9taWRkbGV3YXJlLnNpbXVsYXRlQ29uc3RyYWluZWRHZW5lcmF0aW9uKSgpO1xuICBtaWRkbGV3YXJlLnB1c2goKHJlcSwgbmV4dCkgPT4ge1xuICAgIGlmICghb3B0aW9ucz8uc3VwcG9ydHM/LmNvbnN0cmFpbmVkIHx8IG9wdGlvbnM/LnN1cHBvcnRzPy5jb25zdHJhaW5lZCA9PT0gXCJub25lXCIgfHwgb3B0aW9ucz8uc3VwcG9ydHM/LmNvbnN0cmFpbmVkID09PSBcIm5vLXRvb2xzXCIgJiYgKHJlcS50b29scz8ubGVuZ3RoID8/IDApID4gMCkge1xuICAgICAgcmV0dXJuIGNvbnN0cmF0ZWRTaW11bGF0b3IocmVxLCBuZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQocmVxKTtcbiAgfSk7XG4gIHJldHVybiBtaWRkbGV3YXJlO1xufVxuZnVuY3Rpb24gbW9kZWxBY3Rpb25NZXRhZGF0YSh7XG4gIG5hbWUsXG4gIGluZm8sXG4gIGNvbmZpZ1NjaGVtYSxcbiAgYmFja2dyb3VuZFxufSkge1xuICByZXR1cm4ge1xuICAgIGFjdGlvblR5cGU6IGJhY2tncm91bmQgPyBcImJhY2tncm91bmQtbW9kZWxcIiA6IFwibW9kZWxcIixcbiAgICBuYW1lLFxuICAgIGlucHV0SnNvblNjaGVtYTogKDAsIGltcG9ydF9zY2hlbWEudG9Kc29uU2NoZW1hKSh7IHNjaGVtYTogaW1wb3J0X21vZGVsX3R5cGVzLkdlbmVyYXRlUmVxdWVzdFNjaGVtYSB9KSxcbiAgICBvdXRwdXRKc29uU2NoZW1hOiBiYWNrZ3JvdW5kID8gKDAsIGltcG9ydF9zY2hlbWEudG9Kc29uU2NoZW1hKSh7IHNjaGVtYTogaW1wb3J0X2NvcmUuT3BlcmF0aW9uU2NoZW1hIH0pIDogKDAsIGltcG9ydF9zY2hlbWEudG9Kc29uU2NoZW1hKSh7IHNjaGVtYTogaW1wb3J0X21vZGVsX3R5cGVzLkdlbmVyYXRlUmVzcG9uc2VTY2hlbWEgfSksXG4gICAgbWV0YWRhdGE6IHtcbiAgICAgIG1vZGVsOiB7XG4gICAgICAgIC4uLmluZm8sXG4gICAgICAgIGN1c3RvbU9wdGlvbnM6IGNvbmZpZ1NjaGVtYSA/ICgwLCBpbXBvcnRfc2NoZW1hLnRvSnNvblNjaGVtYSkoeyBzY2hlbWE6IGNvbmZpZ1NjaGVtYSB9KSA6IHZvaWQgMFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1vZGVsUmVmKG9wdGlvbnMpIHtcbiAgbGV0IG5hbWUgPSBvcHRpb25zLm5hbWU7XG4gIGlmIChvcHRpb25zLm5hbWVzcGFjZSAmJiAhbmFtZS5zdGFydHNXaXRoKG9wdGlvbnMubmFtZXNwYWNlICsgXCIvXCIpKSB7XG4gICAgbmFtZSA9IGAke29wdGlvbnMubmFtZXNwYWNlfS8ke25hbWV9YDtcbiAgfVxuICBjb25zdCByZWYgPSB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBuYW1lXG4gIH07XG4gIHJlZi53aXRoQ29uZmlnID0gKGNmZykgPT4ge1xuICAgIHJldHVybiBtb2RlbFJlZih7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgbmFtZSxcbiAgICAgIGNvbmZpZzogY2ZnXG4gICAgfSk7XG4gIH07XG4gIHJlZi53aXRoVmVyc2lvbiA9ICh2ZXJzaW9uKSA9PiB7XG4gICAgcmV0dXJuIG1vZGVsUmVmKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBuYW1lLFxuICAgICAgdmVyc2lvblxuICAgIH0pO1xuICB9O1xuICByZXR1cm4gcmVmO1xufVxuZnVuY3Rpb24gZ2V0QmFzaWNVc2FnZVN0YXRzKGlucHV0LCByZXNwb25zZSkge1xuICBjb25zdCBpbnB1dENvdW50cyA9IGdldFBhcnRDb3VudHMoaW5wdXQuZmxhdE1hcCgobWQpID0+IG1kLmNvbnRlbnQpKTtcbiAgY29uc3Qgb3V0cHV0Q291bnRzID0gZ2V0UGFydENvdW50cyhcbiAgICBBcnJheS5pc0FycmF5KHJlc3BvbnNlKSA/IHJlc3BvbnNlLmZsYXRNYXAoKGMpID0+IGMubWVzc2FnZS5jb250ZW50KSA6IHJlc3BvbnNlLmNvbnRlbnRcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBpbnB1dENoYXJhY3RlcnM6IGlucHV0Q291bnRzLmNoYXJhY3RlcnMsXG4gICAgaW5wdXRJbWFnZXM6IGlucHV0Q291bnRzLmltYWdlcyxcbiAgICBpbnB1dFZpZGVvczogaW5wdXRDb3VudHMudmlkZW9zLFxuICAgIGlucHV0QXVkaW9GaWxlczogaW5wdXRDb3VudHMuYXVkaW8sXG4gICAgb3V0cHV0Q2hhcmFjdGVyczogb3V0cHV0Q291bnRzLmNoYXJhY3RlcnMsXG4gICAgb3V0cHV0SW1hZ2VzOiBvdXRwdXRDb3VudHMuaW1hZ2VzLFxuICAgIG91dHB1dFZpZGVvczogb3V0cHV0Q291bnRzLnZpZGVvcyxcbiAgICBvdXRwdXRBdWRpb0ZpbGVzOiBvdXRwdXRDb3VudHMuYXVkaW9cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhcnRDb3VudHMocGFydHMpIHtcbiAgcmV0dXJuIHBhcnRzLnJlZHVjZShcbiAgICAoY291bnRzLCBwYXJ0KSA9PiB7XG4gICAgICBjb25zdCBpc0ltYWdlID0gcGFydC5tZWRpYT8uY29udGVudFR5cGU/LnN0YXJ0c1dpdGgoXCJpbWFnZVwiKSB8fCBwYXJ0Lm1lZGlhPy51cmw/LnN0YXJ0c1dpdGgoXCJkYXRhOmltYWdlXCIpO1xuICAgICAgY29uc3QgaXNWaWRlbyA9IHBhcnQubWVkaWE/LmNvbnRlbnRUeXBlPy5zdGFydHNXaXRoKFwidmlkZW9cIikgfHwgcGFydC5tZWRpYT8udXJsPy5zdGFydHNXaXRoKFwiZGF0YTp2aWRlb1wiKTtcbiAgICAgIGNvbnN0IGlzQXVkaW8gPSBwYXJ0Lm1lZGlhPy5jb250ZW50VHlwZT8uc3RhcnRzV2l0aChcImF1ZGlvXCIpIHx8IHBhcnQubWVkaWE/LnVybD8uc3RhcnRzV2l0aChcImRhdGE6YXVkaW9cIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaGFyYWN0ZXJzOiBjb3VudHMuY2hhcmFjdGVycyArIChwYXJ0LnRleHQ/Lmxlbmd0aCB8fCAwKSxcbiAgICAgICAgaW1hZ2VzOiBjb3VudHMuaW1hZ2VzICsgKGlzSW1hZ2UgPyAxIDogMCksXG4gICAgICAgIHZpZGVvczogY291bnRzLnZpZGVvcyArIChpc1ZpZGVvID8gMSA6IDApLFxuICAgICAgICBhdWRpbzogY291bnRzLmF1ZGlvICsgKGlzQXVkaW8gPyAxIDogMClcbiAgICAgIH07XG4gICAgfSxcbiAgICB7IGNoYXJhY3RlcnM6IDAsIGltYWdlczogMCwgdmlkZW9zOiAwLCBhdWRpbzogMCB9XG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlTW9kZWwocmVnaXN0cnksIG1vZGVsMiwgb3B0aW9ucykge1xuICBsZXQgb3V0O1xuICBsZXQgbW9kZWxJZDtcbiAgaWYgKCFtb2RlbDIpIHtcbiAgICBtb2RlbDIgPSBhd2FpdCByZWdpc3RyeS5sb29rdXBWYWx1ZShcImRlZmF1bHRNb2RlbFwiLCBcImRlZmF1bHRNb2RlbFwiKTtcbiAgfVxuICBpZiAoIW1vZGVsMikge1xuICAgIHRocm93IG5ldyBpbXBvcnRfY29yZS5HZW5raXRFcnJvcih7XG4gICAgICBzdGF0dXM6IFwiSU5WQUxJRF9BUkdVTUVOVFwiLFxuICAgICAgbWVzc2FnZTogXCJNdXN0IHN1cHBseSBhIGBtb2RlbGAgdG8gYGdlbmVyYXRlKClgIGNhbGxzLlwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBtb2RlbDIgPT09IFwic3RyaW5nXCIpIHtcbiAgICBtb2RlbElkID0gbW9kZWwyO1xuICAgIG91dCA9IHsgbW9kZWxBY3Rpb246IGF3YWl0IGxvb2t1cE1vZGVsKHJlZ2lzdHJ5LCBtb2RlbDIpIH07XG4gIH0gZWxzZSBpZiAobW9kZWwyLmhhc093blByb3BlcnR5KFwiX19hY3Rpb25cIikpIHtcbiAgICBtb2RlbElkID0gbW9kZWwyLl9fYWN0aW9uLm5hbWU7XG4gICAgb3V0ID0geyBtb2RlbEFjdGlvbjogbW9kZWwyIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcmVmID0gbW9kZWwyO1xuICAgIG1vZGVsSWQgPSByZWYubmFtZTtcbiAgICBvdXQgPSB7XG4gICAgICBtb2RlbEFjdGlvbjogYXdhaXQgbG9va3VwTW9kZWwocmVnaXN0cnksIHJlZi5uYW1lKSxcbiAgICAgIGNvbmZpZzoge1xuICAgICAgICAuLi5yZWYuY29uZmlnXG4gICAgICB9LFxuICAgICAgdmVyc2lvbjogcmVmLnZlcnNpb25cbiAgICB9O1xuICB9XG4gIGlmICghb3V0Lm1vZGVsQWN0aW9uKSB7XG4gICAgdGhyb3cgbmV3IGltcG9ydF9jb3JlLkdlbmtpdEVycm9yKHtcbiAgICAgIHN0YXR1czogXCJOT1RfRk9VTkRcIixcbiAgICAgIG1lc3NhZ2U6IGBNb2RlbCAnJHttb2RlbElkfScgbm90IGZvdW5kYFxuICAgIH0pO1xuICB9XG4gIGlmIChvcHRpb25zPy53YXJuRGVwcmVjYXRlZCAmJiBvdXQubW9kZWxBY3Rpb24uX19hY3Rpb24ubWV0YWRhdGE/Lm1vZGVsPy5zdGFnZSA9PT0gXCJkZXByZWNhdGVkXCIpIHtcbiAgICBpbXBvcnRfbG9nZ2luZy5sb2dnZXIud2FybihcbiAgICAgIGBNb2RlbCAnJHtvdXQubW9kZWxBY3Rpb24uX19hY3Rpb24ubmFtZX0nIGlzIGRlcHJlY2F0ZWQgYW5kIG1heSBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvb2t1cE1vZGVsKHJlZ2lzdHJ5LCBtb2RlbDIpIHtcbiAgcmV0dXJuIGF3YWl0IHJlZ2lzdHJ5Lmxvb2t1cEFjdGlvbihgL21vZGVsLyR7bW9kZWwyfWApIHx8IGF3YWl0IHJlZ2lzdHJ5Lmxvb2t1cEFjdGlvbihgL2JhY2tncm91bmQtbW9kZWwvJHttb2RlbDJ9YCk7XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ3VzdG9tUGFydFNjaGVtYSxcbiAgRGF0YVBhcnRTY2hlbWEsXG4gIE1lZGlhUGFydFNjaGVtYSxcbiAgVGV4dFBhcnRTY2hlbWEsXG4gIFRvb2xSZXF1ZXN0UGFydFNjaGVtYSxcbiAgVG9vbFJlc3BvbnNlUGFydFNjaGVtYSxcbiAgYmFja2dyb3VuZE1vZGVsLFxuICBkZWZpbmVCYWNrZ3JvdW5kTW9kZWwsXG4gIGRlZmluZUdlbmVyYXRlQWN0aW9uLFxuICBkZWZpbmVNb2RlbCxcbiAgZ2V0QmFzaWNVc2FnZVN0YXRzLFxuICBtb2RlbCxcbiAgbW9kZWxBY3Rpb25NZXRhZGF0YSxcbiAgbW9kZWxSZWYsXG4gIHJlc29sdmVNb2RlbCxcbiAgc2ltdWxhdGVDb25zdHJhaW5lZEdlbmVyYXRpb24sXG4gIC4uLnJlcXVpcmUoXCIuL21vZGVsLXR5cGVzLmpzXCIpXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGVsLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/model.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/model/middleware.js":
/*!************************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/model/middleware.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar middleware_exports = {};\n__export(middleware_exports, {\n  CONTEXT_PREFACE: () => CONTEXT_PREFACE,\n  augmentWithContext: () => augmentWithContext,\n  downloadRequestMedia: () => downloadRequestMedia,\n  simulateConstrainedGeneration: () => simulateConstrainedGeneration,\n  simulateSystemPrompt: () => simulateSystemPrompt,\n  validateSupport: () => validateSupport\n});\nmodule.exports = __toCommonJS(middleware_exports);\nvar import_document = __webpack_require__(/*! ../document.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/document.js\");\nvar import_formats = __webpack_require__(/*! ../formats/index.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/formats/index.js\");\nfunction downloadRequestMedia(options) {\n  return async (req, next) => {\n    const { default: fetch } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/node-fetch\"), __webpack_require__.e(\"vendor-chunks/fetch-blob\"), __webpack_require__.e(\"vendor-chunks/formdata-polyfill\"), __webpack_require__.e(\"vendor-chunks/data-uri-to-buffer\"), __webpack_require__.e(\"vendor-chunks/web-streams-polyfill\"), __webpack_require__.e(\"vendor-chunks/node-domexception\")]).then(__webpack_require__.bind(__webpack_require__, /*! node-fetch */ \"(action-browser)/./node_modules/node-fetch/src/index.js\"));\n    const newReq = {\n      ...req,\n      messages: await Promise.all(\n        req.messages.map(async (message) => {\n          const content = await Promise.all(\n            message.content.map(async (part) => {\n              if (!part.media || !part.media.url.startsWith(\"http\") || options?.filter && !options?.filter(part)) {\n                return part;\n              }\n              const response = await fetch(part.media.url, {\n                size: options?.maxBytes\n              });\n              if (response.status !== 200)\n                throw new Error(\n                  `HTTP error downloading media '${part.media.url}': ${await response.text()}`\n                );\n              const contentType = part.media.contentType || response.headers.get(\"content-type\") || \"\";\n              return {\n                media: {\n                  contentType,\n                  url: `data:${contentType};base64,${Buffer.from(\n                    await response.arrayBuffer()\n                  ).toString(\"base64\")}`\n                }\n              };\n            })\n          );\n          return {\n            ...message,\n            content\n          };\n        })\n      )\n    };\n    return next(newReq);\n  };\n}\nfunction validateSupport(options) {\n  const supports = options.supports || {};\n  return async (req, next) => {\n    function invalid(message) {\n      throw new Error(\n        `Model '${options.name}' does not support ${message}. Request: ${JSON.stringify(\n          req,\n          null,\n          2\n        )}`\n      );\n    }\n    if (supports.media === false && req.messages.some((message) => message.content.some((part) => part.media)))\n      invalid(\"media, but media was provided\");\n    if (supports.tools === false && req.tools?.length)\n      invalid(\"tool use, but tools were provided\");\n    if (supports.multiturn === false && req.messages.length > 1)\n      invalid(`multiple messages, but ${req.messages.length} were provided`);\n    return next();\n  };\n}\nfunction lastUserMessage(messages) {\n  for (let i = messages.length - 1; i >= 0; i--) {\n    if (messages[i].role === \"user\") {\n      return messages[i];\n    }\n  }\n  return void 0;\n}\nfunction simulateSystemPrompt(options) {\n  const preface = options?.preface || \"SYSTEM INSTRUCTIONS:\\n\";\n  const acknowledgement = options?.acknowledgement || \"Understood.\";\n  return (req, next) => {\n    const messages = [...req.messages];\n    for (let i = 0; i < messages.length; i++) {\n      if (req.messages[i].role === \"system\") {\n        const systemPrompt = messages[i].content;\n        messages.splice(\n          i,\n          1,\n          { role: \"user\", content: [{ text: preface }, ...systemPrompt] },\n          { role: \"model\", content: [{ text: acknowledgement }] }\n        );\n        break;\n      }\n    }\n    return next({ ...req, messages });\n  };\n}\nconst CONTEXT_PREFACE = \"\\n\\nUse the following information to complete your task:\\n\\n\";\nconst CONTEXT_ITEM_TEMPLATE = (d, index, options) => {\n  let out = \"- \";\n  if (options?.citationKey) {\n    out += `[${d.metadata[options.citationKey]}]: `;\n  } else if (options?.citationKey === void 0) {\n    out += `[${d.metadata?.[\"ref\"] || d.metadata?.[\"id\"] || index}]: `;\n  }\n  out += d.text + \"\\n\";\n  return out;\n};\nfunction augmentWithContext(options) {\n  const preface = typeof options?.preface === \"undefined\" ? CONTEXT_PREFACE : options.preface;\n  const itemTemplate = options?.itemTemplate || CONTEXT_ITEM_TEMPLATE;\n  return (req, next) => {\n    if (!req.docs?.length) return next(req);\n    const userMessage = lastUserMessage(req.messages);\n    if (!userMessage) return next(req);\n    const contextPartIndex = userMessage?.content.findIndex(\n      (p) => p.metadata?.purpose === \"context\"\n    );\n    const contextPart = contextPartIndex >= 0 && userMessage.content[contextPartIndex];\n    if (contextPart && !contextPart.metadata?.pending) {\n      return next(req);\n    }\n    let out = `${preface || \"\"}`;\n    req.docs?.forEach((d, i) => {\n      out += itemTemplate(new import_document.Document(d), i, options);\n    });\n    out += \"\\n\";\n    if (contextPartIndex >= 0) {\n      userMessage.content[contextPartIndex] = {\n        ...contextPart,\n        text: out,\n        metadata: { purpose: \"context\" }\n      };\n    } else {\n      userMessage.content.push({ text: out, metadata: { purpose: \"context\" } });\n    }\n    return next(req);\n  };\n}\nconst DEFAULT_CONSTRAINED_GENERATION_INSTRUCTIONS = (schema) => `Output should be in JSON format and conform to the following schema:\n\n\\`\\`\\`\n${JSON.stringify(schema)}\n\\`\\`\\`\n`;\nfunction simulateConstrainedGeneration(options) {\n  return (req, next) => {\n    let instructions;\n    if (req.output?.constrained && req.output?.schema) {\n      instructions = (options?.instructionsRenderer ?? DEFAULT_CONSTRAINED_GENERATION_INSTRUCTIONS)(req.output?.schema);\n      req = {\n        ...req,\n        messages: (0, import_formats.injectInstructions)(req.messages, instructions),\n        output: {\n          ...req.output,\n          // we're simulating it, so to the underlying model it's unconstrained.\n          constrained: false,\n          format: void 0,\n          contentType: void 0,\n          schema: void 0\n        }\n      };\n    }\n    return next(req);\n  };\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=middleware.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9tb2RlbC9taWRkbGV3YXJlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDhCQUE4QjtBQUN2RztBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyxxRkFBZ0I7QUFDOUMscUJBQXFCLG1CQUFPLENBQUMsK0ZBQXFCO0FBQ2xEO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQixRQUFRLCtlQUFvQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxtREFBbUQsZUFBZSxLQUFLLHNCQUFzQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGFBQWEsU0FBUztBQUNyRDtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYSxxQkFBcUIsUUFBUSxhQUFhO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxxQkFBcUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEIsZUFBZSxvQkFBb0I7QUFDekUsWUFBWSwyQkFBMkIsdUJBQXVCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdDQUFnQztBQUMvQyxJQUFJO0FBQ0osZUFBZSxtREFBbUQ7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsTUFBTTtBQUNOLGlDQUFpQyx1QkFBdUIsc0JBQXNCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQU9MO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcS1JhbWFjaGFcXERvY3VtZW50c1xcU3VzdEFJbmV4IEdJdCBDb2RlXFxub2RlX21vZHVsZXNcXEBnZW5raXQtYWlcXGFpXFxsaWJcXG1vZGVsXFxtaWRkbGV3YXJlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cbiAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gIC8vIFwiZGVmYXVsdFwiIHRvIHRoZSBDb21tb25KUyBcIm1vZHVsZS5leHBvcnRzXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBtaWRkbGV3YXJlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG1pZGRsZXdhcmVfZXhwb3J0cywge1xuICBDT05URVhUX1BSRUZBQ0U6ICgpID0+IENPTlRFWFRfUFJFRkFDRSxcbiAgYXVnbWVudFdpdGhDb250ZXh0OiAoKSA9PiBhdWdtZW50V2l0aENvbnRleHQsXG4gIGRvd25sb2FkUmVxdWVzdE1lZGlhOiAoKSA9PiBkb3dubG9hZFJlcXVlc3RNZWRpYSxcbiAgc2ltdWxhdGVDb25zdHJhaW5lZEdlbmVyYXRpb246ICgpID0+IHNpbXVsYXRlQ29uc3RyYWluZWRHZW5lcmF0aW9uLFxuICBzaW11bGF0ZVN5c3RlbVByb21wdDogKCkgPT4gc2ltdWxhdGVTeXN0ZW1Qcm9tcHQsXG4gIHZhbGlkYXRlU3VwcG9ydDogKCkgPT4gdmFsaWRhdGVTdXBwb3J0XG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKG1pZGRsZXdhcmVfZXhwb3J0cyk7XG52YXIgaW1wb3J0X2RvY3VtZW50ID0gcmVxdWlyZShcIi4uL2RvY3VtZW50LmpzXCIpO1xudmFyIGltcG9ydF9mb3JtYXRzID0gcmVxdWlyZShcIi4uL2Zvcm1hdHMvaW5kZXguanNcIik7XG5mdW5jdGlvbiBkb3dubG9hZFJlcXVlc3RNZWRpYShvcHRpb25zKSB7XG4gIHJldHVybiBhc3luYyAocmVxLCBuZXh0KSA9PiB7XG4gICAgY29uc3QgeyBkZWZhdWx0OiBmZXRjaCB9ID0gYXdhaXQgaW1wb3J0KFwibm9kZS1mZXRjaFwiKTtcbiAgICBjb25zdCBuZXdSZXEgPSB7XG4gICAgICAuLi5yZXEsXG4gICAgICBtZXNzYWdlczogYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIHJlcS5tZXNzYWdlcy5tYXAoYXN5bmMgKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBtZXNzYWdlLmNvbnRlbnQubWFwKGFzeW5jIChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgIGlmICghcGFydC5tZWRpYSB8fCAhcGFydC5tZWRpYS51cmwuc3RhcnRzV2l0aChcImh0dHBcIikgfHwgb3B0aW9ucz8uZmlsdGVyICYmICFvcHRpb25zPy5maWx0ZXIocGFydCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHBhcnQubWVkaWEudXJsLCB7XG4gICAgICAgICAgICAgICAgc2l6ZTogb3B0aW9ucz8ubWF4Qnl0ZXNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBgSFRUUCBlcnJvciBkb3dubG9hZGluZyBtZWRpYSAnJHtwYXJ0Lm1lZGlhLnVybH0nOiAke2F3YWl0IHJlc3BvbnNlLnRleHQoKX1gXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSBwYXJ0Lm1lZGlhLmNvbnRlbnRUeXBlIHx8IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpIHx8IFwiXCI7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWVkaWE6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgICAgICAgdXJsOiBgZGF0YToke2NvbnRlbnRUeXBlfTtiYXNlNjQsJHtCdWZmZXIuZnJvbShcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKVxuICAgICAgICAgICAgICAgICAgKS50b1N0cmluZyhcImJhc2U2NFwiKX1gXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5tZXNzYWdlLFxuICAgICAgICAgICAgY29udGVudFxuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfTtcbiAgICByZXR1cm4gbmV4dChuZXdSZXEpO1xuICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVTdXBwb3J0KG9wdGlvbnMpIHtcbiAgY29uc3Qgc3VwcG9ydHMgPSBvcHRpb25zLnN1cHBvcnRzIHx8IHt9O1xuICByZXR1cm4gYXN5bmMgKHJlcSwgbmV4dCkgPT4ge1xuICAgIGZ1bmN0aW9uIGludmFsaWQobWVzc2FnZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgTW9kZWwgJyR7b3B0aW9ucy5uYW1lfScgZG9lcyBub3Qgc3VwcG9ydCAke21lc3NhZ2V9LiBSZXF1ZXN0OiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIHJlcSxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIDJcbiAgICAgICAgKX1gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydHMubWVkaWEgPT09IGZhbHNlICYmIHJlcS5tZXNzYWdlcy5zb21lKChtZXNzYWdlKSA9PiBtZXNzYWdlLmNvbnRlbnQuc29tZSgocGFydCkgPT4gcGFydC5tZWRpYSkpKVxuICAgICAgaW52YWxpZChcIm1lZGlhLCBidXQgbWVkaWEgd2FzIHByb3ZpZGVkXCIpO1xuICAgIGlmIChzdXBwb3J0cy50b29scyA9PT0gZmFsc2UgJiYgcmVxLnRvb2xzPy5sZW5ndGgpXG4gICAgICBpbnZhbGlkKFwidG9vbCB1c2UsIGJ1dCB0b29scyB3ZXJlIHByb3ZpZGVkXCIpO1xuICAgIGlmIChzdXBwb3J0cy5tdWx0aXR1cm4gPT09IGZhbHNlICYmIHJlcS5tZXNzYWdlcy5sZW5ndGggPiAxKVxuICAgICAgaW52YWxpZChgbXVsdGlwbGUgbWVzc2FnZXMsIGJ1dCAke3JlcS5tZXNzYWdlcy5sZW5ndGh9IHdlcmUgcHJvdmlkZWRgKTtcbiAgICByZXR1cm4gbmV4dCgpO1xuICB9O1xufVxuZnVuY3Rpb24gbGFzdFVzZXJNZXNzYWdlKG1lc3NhZ2VzKSB7XG4gIGZvciAobGV0IGkgPSBtZXNzYWdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChtZXNzYWdlc1tpXS5yb2xlID09PSBcInVzZXJcIikge1xuICAgICAgcmV0dXJuIG1lc3NhZ2VzW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuZnVuY3Rpb24gc2ltdWxhdGVTeXN0ZW1Qcm9tcHQob3B0aW9ucykge1xuICBjb25zdCBwcmVmYWNlID0gb3B0aW9ucz8ucHJlZmFjZSB8fCBcIlNZU1RFTSBJTlNUUlVDVElPTlM6XFxuXCI7XG4gIGNvbnN0IGFja25vd2xlZGdlbWVudCA9IG9wdGlvbnM/LmFja25vd2xlZGdlbWVudCB8fCBcIlVuZGVyc3Rvb2QuXCI7XG4gIHJldHVybiAocmVxLCBuZXh0KSA9PiB7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBbLi4ucmVxLm1lc3NhZ2VzXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVxLm1lc3NhZ2VzW2ldLnJvbGUgPT09IFwic3lzdGVtXCIpIHtcbiAgICAgICAgY29uc3Qgc3lzdGVtUHJvbXB0ID0gbWVzc2FnZXNbaV0uY29udGVudDtcbiAgICAgICAgbWVzc2FnZXMuc3BsaWNlKFxuICAgICAgICAgIGksXG4gICAgICAgICAgMSxcbiAgICAgICAgICB7IHJvbGU6IFwidXNlclwiLCBjb250ZW50OiBbeyB0ZXh0OiBwcmVmYWNlIH0sIC4uLnN5c3RlbVByb21wdF0gfSxcbiAgICAgICAgICB7IHJvbGU6IFwibW9kZWxcIiwgY29udGVudDogW3sgdGV4dDogYWNrbm93bGVkZ2VtZW50IH1dIH1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXh0KHsgLi4ucmVxLCBtZXNzYWdlcyB9KTtcbiAgfTtcbn1cbmNvbnN0IENPTlRFWFRfUFJFRkFDRSA9IFwiXFxuXFxuVXNlIHRoZSBmb2xsb3dpbmcgaW5mb3JtYXRpb24gdG8gY29tcGxldGUgeW91ciB0YXNrOlxcblxcblwiO1xuY29uc3QgQ09OVEVYVF9JVEVNX1RFTVBMQVRFID0gKGQsIGluZGV4LCBvcHRpb25zKSA9PiB7XG4gIGxldCBvdXQgPSBcIi0gXCI7XG4gIGlmIChvcHRpb25zPy5jaXRhdGlvbktleSkge1xuICAgIG91dCArPSBgWyR7ZC5tZXRhZGF0YVtvcHRpb25zLmNpdGF0aW9uS2V5XX1dOiBgO1xuICB9IGVsc2UgaWYgKG9wdGlvbnM/LmNpdGF0aW9uS2V5ID09PSB2b2lkIDApIHtcbiAgICBvdXQgKz0gYFske2QubWV0YWRhdGE/LltcInJlZlwiXSB8fCBkLm1ldGFkYXRhPy5bXCJpZFwiXSB8fCBpbmRleH1dOiBgO1xuICB9XG4gIG91dCArPSBkLnRleHQgKyBcIlxcblwiO1xuICByZXR1cm4gb3V0O1xufTtcbmZ1bmN0aW9uIGF1Z21lbnRXaXRoQ29udGV4dChvcHRpb25zKSB7XG4gIGNvbnN0IHByZWZhY2UgPSB0eXBlb2Ygb3B0aW9ucz8ucHJlZmFjZSA9PT0gXCJ1bmRlZmluZWRcIiA/IENPTlRFWFRfUFJFRkFDRSA6IG9wdGlvbnMucHJlZmFjZTtcbiAgY29uc3QgaXRlbVRlbXBsYXRlID0gb3B0aW9ucz8uaXRlbVRlbXBsYXRlIHx8IENPTlRFWFRfSVRFTV9URU1QTEFURTtcbiAgcmV0dXJuIChyZXEsIG5leHQpID0+IHtcbiAgICBpZiAoIXJlcS5kb2NzPy5sZW5ndGgpIHJldHVybiBuZXh0KHJlcSk7XG4gICAgY29uc3QgdXNlck1lc3NhZ2UgPSBsYXN0VXNlck1lc3NhZ2UocmVxLm1lc3NhZ2VzKTtcbiAgICBpZiAoIXVzZXJNZXNzYWdlKSByZXR1cm4gbmV4dChyZXEpO1xuICAgIGNvbnN0IGNvbnRleHRQYXJ0SW5kZXggPSB1c2VyTWVzc2FnZT8uY29udGVudC5maW5kSW5kZXgoXG4gICAgICAocCkgPT4gcC5tZXRhZGF0YT8ucHVycG9zZSA9PT0gXCJjb250ZXh0XCJcbiAgICApO1xuICAgIGNvbnN0IGNvbnRleHRQYXJ0ID0gY29udGV4dFBhcnRJbmRleCA+PSAwICYmIHVzZXJNZXNzYWdlLmNvbnRlbnRbY29udGV4dFBhcnRJbmRleF07XG4gICAgaWYgKGNvbnRleHRQYXJ0ICYmICFjb250ZXh0UGFydC5tZXRhZGF0YT8ucGVuZGluZykge1xuICAgICAgcmV0dXJuIG5leHQocmVxKTtcbiAgICB9XG4gICAgbGV0IG91dCA9IGAke3ByZWZhY2UgfHwgXCJcIn1gO1xuICAgIHJlcS5kb2NzPy5mb3JFYWNoKChkLCBpKSA9PiB7XG4gICAgICBvdXQgKz0gaXRlbVRlbXBsYXRlKG5ldyBpbXBvcnRfZG9jdW1lbnQuRG9jdW1lbnQoZCksIGksIG9wdGlvbnMpO1xuICAgIH0pO1xuICAgIG91dCArPSBcIlxcblwiO1xuICAgIGlmIChjb250ZXh0UGFydEluZGV4ID49IDApIHtcbiAgICAgIHVzZXJNZXNzYWdlLmNvbnRlbnRbY29udGV4dFBhcnRJbmRleF0gPSB7XG4gICAgICAgIC4uLmNvbnRleHRQYXJ0LFxuICAgICAgICB0ZXh0OiBvdXQsXG4gICAgICAgIG1ldGFkYXRhOiB7IHB1cnBvc2U6IFwiY29udGV4dFwiIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHVzZXJNZXNzYWdlLmNvbnRlbnQucHVzaCh7IHRleHQ6IG91dCwgbWV0YWRhdGE6IHsgcHVycG9zZTogXCJjb250ZXh0XCIgfSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQocmVxKTtcbiAgfTtcbn1cbmNvbnN0IERFRkFVTFRfQ09OU1RSQUlORURfR0VORVJBVElPTl9JTlNUUlVDVElPTlMgPSAoc2NoZW1hKSA9PiBgT3V0cHV0IHNob3VsZCBiZSBpbiBKU09OIGZvcm1hdCBhbmQgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIHNjaGVtYTpcblxuXFxgXFxgXFxgXG4ke0pTT04uc3RyaW5naWZ5KHNjaGVtYSl9XG5cXGBcXGBcXGBcbmA7XG5mdW5jdGlvbiBzaW11bGF0ZUNvbnN0cmFpbmVkR2VuZXJhdGlvbihvcHRpb25zKSB7XG4gIHJldHVybiAocmVxLCBuZXh0KSA9PiB7XG4gICAgbGV0IGluc3RydWN0aW9ucztcbiAgICBpZiAocmVxLm91dHB1dD8uY29uc3RyYWluZWQgJiYgcmVxLm91dHB1dD8uc2NoZW1hKSB7XG4gICAgICBpbnN0cnVjdGlvbnMgPSAob3B0aW9ucz8uaW5zdHJ1Y3Rpb25zUmVuZGVyZXIgPz8gREVGQVVMVF9DT05TVFJBSU5FRF9HRU5FUkFUSU9OX0lOU1RSVUNUSU9OUykocmVxLm91dHB1dD8uc2NoZW1hKTtcbiAgICAgIHJlcSA9IHtcbiAgICAgICAgLi4ucmVxLFxuICAgICAgICBtZXNzYWdlczogKDAsIGltcG9ydF9mb3JtYXRzLmluamVjdEluc3RydWN0aW9ucykocmVxLm1lc3NhZ2VzLCBpbnN0cnVjdGlvbnMpLFxuICAgICAgICBvdXRwdXQ6IHtcbiAgICAgICAgICAuLi5yZXEub3V0cHV0LFxuICAgICAgICAgIC8vIHdlJ3JlIHNpbXVsYXRpbmcgaXQsIHNvIHRvIHRoZSB1bmRlcmx5aW5nIG1vZGVsIGl0J3MgdW5jb25zdHJhaW5lZC5cbiAgICAgICAgICBjb25zdHJhaW5lZDogZmFsc2UsXG4gICAgICAgICAgZm9ybWF0OiB2b2lkIDAsXG4gICAgICAgICAgY29udGVudFR5cGU6IHZvaWQgMCxcbiAgICAgICAgICBzY2hlbWE6IHZvaWQgMFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbmV4dChyZXEpO1xuICB9O1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIENPTlRFWFRfUFJFRkFDRSxcbiAgYXVnbWVudFdpdGhDb250ZXh0LFxuICBkb3dubG9hZFJlcXVlc3RNZWRpYSxcbiAgc2ltdWxhdGVDb25zdHJhaW5lZEdlbmVyYXRpb24sXG4gIHNpbXVsYXRlU3lzdGVtUHJvbXB0LFxuICB2YWxpZGF0ZVN1cHBvcnRcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWlkZGxld2FyZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/model/middleware.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/prompt.js":
/*!**************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/prompt.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar prompt_exports = {};\n__export(prompt_exports, {\n  defineHelper: () => defineHelper,\n  definePartial: () => definePartial,\n  definePrompt: () => definePrompt,\n  isExecutablePrompt: () => isExecutablePrompt,\n  isPromptAction: () => isPromptAction,\n  loadPromptFolder: () => loadPromptFolder,\n  loadPromptFolderRecursively: () => loadPromptFolderRecursively,\n  prompt: () => prompt\n});\nmodule.exports = __toCommonJS(prompt_exports);\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nvar import_async = __webpack_require__(/*! @genkit-ai/core/async */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/async.js\");\nvar import_logging = __webpack_require__(/*! @genkit-ai/core/logging */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/logging.js\");\nvar import_schema = __webpack_require__(/*! @genkit-ai/core/schema */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/schema.js\");\nvar import_tracing = __webpack_require__(/*! @genkit-ai/core/tracing */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing.js\");\nvar import_fs = __webpack_require__(/*! fs */ \"fs\");\nvar import_path = __webpack_require__(/*! path */ \"path\");\nvar import_generate = __webpack_require__(/*! ./generate.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/generate.js\");\nvar import_message = __webpack_require__(/*! ./message.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/message.js\");\nvar import_model = __webpack_require__(/*! ./model.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/model.js\");\nvar import_session = __webpack_require__(/*! ./session.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/session.js\");\nfunction isPromptAction(action) {\n  return action.__action.metadata?.type === \"prompt\";\n}\nfunction definePrompt(registry, options) {\n  return definePromptAsync(\n    registry,\n    `${options.name}${options.variant ? `.${options.variant}` : \"\"}`,\n    Promise.resolve(options),\n    options.metadata\n  );\n}\nfunction definePromptAsync(registry, name, optionsPromise, metadata) {\n  const promptCache = {};\n  const renderOptionsFn = async (input, renderOptions) => {\n    return await (0, import_tracing.runInNewSpan)(\n      {\n        metadata: {\n          name: \"render\",\n          input\n        },\n        labels: {\n          [import_tracing.SPAN_TYPE_ATTR]: \"promptTemplate\"\n        }\n      },\n      async (metadata2) => {\n        const messages = [];\n        renderOptions = { ...renderOptions };\n        const session = (0, import_session.getCurrentSession)(registry);\n        const resolvedOptions = await optionsPromise;\n        await renderSystemPrompt(\n          registry,\n          session,\n          input,\n          messages,\n          resolvedOptions,\n          promptCache,\n          renderOptions\n        );\n        await renderMessages(\n          registry,\n          session,\n          input,\n          messages,\n          resolvedOptions,\n          renderOptions,\n          promptCache\n        );\n        await renderUserPrompt(\n          registry,\n          session,\n          input,\n          messages,\n          resolvedOptions,\n          promptCache,\n          renderOptions\n        );\n        let docs;\n        if (typeof resolvedOptions.docs === \"function\") {\n          docs = await resolvedOptions.docs(input, {\n            state: session?.state,\n            context: renderOptions?.context || (0, import_core.getContext)() || {}\n          });\n        } else {\n          docs = resolvedOptions.docs;\n        }\n        const opts = (0, import_core.stripUndefinedProps)({\n          model: resolvedOptions.model,\n          maxTurns: resolvedOptions.maxTurns,\n          messages,\n          docs,\n          tools: resolvedOptions.tools,\n          returnToolRequests: resolvedOptions.returnToolRequests,\n          toolChoice: resolvedOptions.toolChoice,\n          context: resolvedOptions.context,\n          output: resolvedOptions.output,\n          use: resolvedOptions.use,\n          ...(0, import_core.stripUndefinedProps)(renderOptions),\n          config: {\n            ...resolvedOptions?.config,\n            ...renderOptions?.config\n          },\n          metadata: resolvedOptions.metadata?.metadata ? {\n            prompt: resolvedOptions.metadata?.metadata\n          } : void 0\n        });\n        if (renderOptions?.abortSignal) {\n          opts.abortSignal = renderOptions.abortSignal;\n        }\n        if (Object.keys(opts.config).length === 0 && !renderOptions?.config) {\n          delete opts.config;\n        }\n        metadata2.output = opts;\n        return opts;\n      }\n    );\n  };\n  const rendererActionConfig = (0, import_async.lazy)(\n    () => optionsPromise.then((options) => {\n      const metadata2 = promptMetadata(options);\n      return {\n        name: `${options.name}${options.variant ? `.${options.variant}` : \"\"}`,\n        inputJsonSchema: options.input?.jsonSchema,\n        inputSchema: options.input?.schema,\n        description: options.description,\n        actionType: \"prompt\",\n        metadata: metadata2,\n        fn: async (input) => {\n          return (0, import_generate.toGenerateRequest)(\n            registry,\n            await renderOptionsFn(input, void 0)\n          );\n        }\n      };\n    })\n  );\n  const rendererAction = (0, import_core.defineActionAsync)(\n    registry,\n    \"prompt\",\n    name,\n    rendererActionConfig,\n    (action) => {\n      action.__executablePrompt = executablePrompt;\n    }\n  );\n  const executablePromptActionConfig = (0, import_async.lazy)(\n    () => optionsPromise.then((options) => {\n      const metadata2 = promptMetadata(options);\n      return {\n        name: `${options.name}${options.variant ? `.${options.variant}` : \"\"}`,\n        inputJsonSchema: options.input?.jsonSchema,\n        inputSchema: options.input?.schema,\n        outputSchema: import_model.GenerateActionOptionsSchema,\n        description: options.description,\n        actionType: \"executable-prompt\",\n        metadata: metadata2,\n        fn: async (input) => {\n          return await (0, import_generate.toGenerateActionOptions)(\n            registry,\n            await renderOptionsFn(input, void 0)\n          );\n        }\n      };\n    })\n  );\n  (0, import_core.defineActionAsync)(\n    registry,\n    \"executable-prompt\",\n    name,\n    executablePromptActionConfig,\n    (action) => {\n      action.__executablePrompt = executablePrompt;\n    }\n  );\n  const executablePrompt = wrapInExecutablePrompt({\n    registry,\n    name,\n    renderOptionsFn,\n    rendererAction,\n    metadata\n  });\n  return executablePrompt;\n}\nfunction promptMetadata(options) {\n  const metadata = {\n    ...options.metadata,\n    prompt: {\n      ...options.metadata?.prompt,\n      config: options.config,\n      input: {\n        schema: options.input ? (0, import_schema.toJsonSchema)(options.input) : void 0\n      },\n      name: options.name.includes(\".\") ? options.name.split(\".\")[0] : options.name,\n      model: modelName(options.model)\n    },\n    type: \"prompt\"\n  };\n  if (options.variant) {\n    metadata.prompt.variant = options.variant;\n  }\n  return metadata;\n}\nfunction wrapInExecutablePrompt(wrapOpts) {\n  const executablePrompt = async (input, opts) => {\n    return await (0, import_tracing.runInNewSpan)(\n      wrapOpts.registry,\n      {\n        metadata: {\n          name: (await wrapOpts.rendererAction).__action.name,\n          input\n        },\n        labels: {\n          [import_tracing.SPAN_TYPE_ATTR]: \"dotprompt\"\n        }\n      },\n      async (metadata) => {\n        const output = await (0, import_generate.generate)(wrapOpts.registry, {\n          ...await wrapOpts.renderOptionsFn(input, opts)\n        });\n        metadata.output = output;\n        return output;\n      }\n    );\n  };\n  executablePrompt.ref = { name: wrapOpts.name, metadata: wrapOpts.metadata };\n  executablePrompt.render = async (input, opts) => {\n    return {\n      ...await wrapOpts.renderOptionsFn(input, opts)\n    };\n  };\n  executablePrompt.stream = (input, opts) => {\n    return (0, import_generate.generateStream)(\n      wrapOpts.registry,\n      wrapOpts.renderOptionsFn(input, opts)\n    );\n  };\n  executablePrompt.asTool = async () => {\n    return await wrapOpts.rendererAction;\n  };\n  return executablePrompt;\n}\nasync function renderSystemPrompt(registry, session, input, messages, options, promptCache, renderOptions) {\n  if (typeof options.system === \"function\") {\n    messages.push({\n      role: \"system\",\n      content: normalizeParts(\n        await options.system(input, {\n          state: session?.state,\n          context: renderOptions?.context || (0, import_core.getContext)() || {}\n        })\n      )\n    });\n  } else if (typeof options.system === \"string\") {\n    if (!promptCache.system) {\n      promptCache.system = await registry.dotprompt.compile(options.system);\n    }\n    messages.push({\n      role: \"system\",\n      content: await renderDotpromptToParts(\n        registry,\n        promptCache.system,\n        input,\n        session,\n        options,\n        renderOptions\n      )\n    });\n  } else if (options.system) {\n    messages.push({\n      role: \"system\",\n      content: normalizeParts(options.system)\n    });\n  }\n}\nasync function renderMessages(registry, session, input, messages, options, renderOptions, promptCache) {\n  if (options.messages) {\n    if (typeof options.messages === \"function\") {\n      messages.push(\n        ...await options.messages(input, {\n          state: session?.state,\n          context: renderOptions?.context || (0, import_core.getContext)() || {},\n          history: renderOptions?.messages\n        })\n      );\n    } else if (typeof options.messages === \"string\") {\n      if (!promptCache.messages) {\n        promptCache.messages = await registry.dotprompt.compile(\n          options.messages\n        );\n      }\n      const rendered = await promptCache.messages({\n        input,\n        context: {\n          ...renderOptions?.context || (0, import_core.getContext)(),\n          state: session?.state\n        },\n        messages: renderOptions?.messages?.map(\n          (m) => import_message.Message.parseData(m)\n        )\n      });\n      messages.push(...rendered.messages);\n    } else {\n      messages.push(...options.messages);\n    }\n  } else {\n    if (renderOptions.messages) {\n      messages.push(...renderOptions.messages);\n    }\n  }\n  if (renderOptions?.messages) {\n    delete renderOptions.messages;\n  }\n}\nasync function renderUserPrompt(registry, session, input, messages, options, promptCache, renderOptions) {\n  if (typeof options.prompt === \"function\") {\n    messages.push({\n      role: \"user\",\n      content: normalizeParts(\n        await options.prompt(input, {\n          state: session?.state,\n          context: renderOptions?.context || (0, import_core.getContext)() || {}\n        })\n      )\n    });\n  } else if (typeof options.prompt === \"string\") {\n    if (!promptCache.userPrompt) {\n      promptCache.userPrompt = await registry.dotprompt.compile(options.prompt);\n    }\n    messages.push({\n      role: \"user\",\n      content: await renderDotpromptToParts(\n        registry,\n        promptCache.userPrompt,\n        input,\n        session,\n        options,\n        renderOptions\n      )\n    });\n  } else if (options.prompt) {\n    messages.push({\n      role: \"user\",\n      content: normalizeParts(options.prompt)\n    });\n  }\n}\nfunction modelName(modelArg) {\n  if (modelArg === void 0) {\n    return void 0;\n  }\n  if (typeof modelArg === \"string\") {\n    return modelArg;\n  }\n  if (modelArg.name) {\n    return modelArg.name;\n  }\n  return modelArg.__action.name;\n}\nfunction normalizeParts(parts) {\n  if (Array.isArray(parts)) return parts;\n  if (typeof parts === \"string\") {\n    return [\n      {\n        text: parts\n      }\n    ];\n  }\n  return [parts];\n}\nasync function renderDotpromptToParts(registry, promptFn, input, session, options, renderOptions) {\n  const renderred = await promptFn({\n    input,\n    context: {\n      ...renderOptions?.context || (0, import_core.getContext)(),\n      state: session?.state\n    }\n  });\n  if (renderred.messages.length !== 1) {\n    throw new Error(\"parts tempate must produce only one message\");\n  }\n  return renderred.messages[0].content;\n}\nfunction isExecutablePrompt(obj) {\n  return !!obj?.render && !!obj?.asTool && !!obj?.stream;\n}\nfunction loadPromptFolder(registry, dir = \"./prompts\", ns) {\n  const promptsPath = (0, import_path.resolve)(dir);\n  if ((0, import_fs.existsSync)(promptsPath)) {\n    loadPromptFolderRecursively(registry, dir, ns, \"\");\n  }\n}\nfunction loadPromptFolderRecursively(registry, dir, ns, subDir) {\n  const promptsPath = (0, import_path.resolve)(dir);\n  const dirEnts = (0, import_fs.readdirSync)((0, import_path.join)(promptsPath, subDir), {\n    withFileTypes: true\n  });\n  for (const dirEnt of dirEnts) {\n    const parentPath = (0, import_path.join)(promptsPath, subDir);\n    const fileName = dirEnt.name;\n    if (dirEnt.isFile() && fileName.endsWith(\".prompt\")) {\n      if (fileName.startsWith(\"_\")) {\n        const partialName = fileName.substring(1, fileName.length - 7);\n        definePartial(\n          registry,\n          partialName,\n          (0, import_fs.readFileSync)((0, import_path.join)(parentPath, fileName), {\n            encoding: \"utf8\"\n          })\n        );\n        import_logging.logger.debug(\n          `Registered Dotprompt partial \"${partialName}\" from \"${(0, import_path.join)(parentPath, fileName)}\"`\n        );\n      } else {\n        loadPrompt(\n          registry,\n          promptsPath,\n          fileName,\n          subDir ? `${subDir}/` : \"\",\n          ns\n        );\n      }\n    } else if (dirEnt.isDirectory()) {\n      loadPromptFolderRecursively(registry, dir, ns, (0, import_path.join)(subDir, fileName));\n    }\n  }\n}\nfunction definePartial(registry, name, source) {\n  registry.dotprompt.definePartial(name, source);\n}\nfunction defineHelper(registry, name, fn) {\n  registry.dotprompt.defineHelper(name, fn);\n}\nfunction loadPrompt(registry, path, filename, prefix = \"\", ns = \"dotprompt\") {\n  let name = `${prefix ?? \"\"}${(0, import_path.basename)(filename, \".prompt\")}`;\n  let variant = null;\n  if (name.includes(\".\")) {\n    const parts = name.split(\".\");\n    name = parts[0];\n    variant = parts[1];\n  }\n  const source = (0, import_fs.readFileSync)((0, import_path.join)(path, prefix ?? \"\", filename), \"utf8\");\n  const parsedPrompt = registry.dotprompt.parse(source);\n  definePromptAsync(\n    registry,\n    registryDefinitionKey(name, variant ?? void 0, ns),\n    // We use a lazy promise here because we only want prompt loaded when it's first used.\n    // This is important because otherwise the loading may happen before the user has configured\n    // all the schemas, etc., which will result in dotprompt.renderMetadata errors.\n    (0, import_async.lazy)(async () => {\n      const promptMetadata2 = await registry.dotprompt.renderMetadata(parsedPrompt);\n      if (variant) {\n        promptMetadata2.variant = variant;\n      }\n      if (promptMetadata2.output?.schema?.description === null) {\n        delete promptMetadata2.output.schema.description;\n      }\n      if (promptMetadata2.input?.schema?.description === null) {\n        delete promptMetadata2.input.schema.description;\n      }\n      const metadata = {\n        ...promptMetadata2.metadata,\n        type: \"prompt\",\n        prompt: {\n          ...promptMetadata2,\n          template: parsedPrompt.template\n        }\n      };\n      if (promptMetadata2.raw?.[\"metadata\"]) {\n        metadata[\"metadata\"] = { ...promptMetadata2.raw?.[\"metadata\"] };\n      }\n      return {\n        name: registryDefinitionKey(name, variant ?? void 0, ns),\n        model: promptMetadata2.model,\n        config: promptMetadata2.config,\n        tools: promptMetadata2.tools,\n        description: promptMetadata2.description,\n        output: {\n          jsonSchema: promptMetadata2.output?.schema,\n          format: promptMetadata2.output?.format\n        },\n        input: {\n          jsonSchema: promptMetadata2.input?.schema\n        },\n        metadata,\n        maxTurns: promptMetadata2.raw?.[\"maxTurns\"],\n        toolChoice: promptMetadata2.raw?.[\"toolChoice\"],\n        returnToolRequests: promptMetadata2.raw?.[\"returnToolRequests\"],\n        messages: parsedPrompt.template\n      };\n    })\n  );\n}\nasync function prompt(registry, name, options) {\n  return await lookupPrompt(\n    registry,\n    name,\n    options?.variant\n  );\n}\nfunction registryLookupKey(name, variant, ns) {\n  return `/prompt/${registryDefinitionKey(name, variant, ns)}`;\n}\nasync function lookupPrompt(registry, name, variant) {\n  const registryPrompt = await registry.lookupAction(\n    registryLookupKey(name, variant)\n  );\n  if (registryPrompt) {\n    return registryPrompt.__executablePrompt;\n  }\n  throw new import_core.GenkitError({\n    status: \"NOT_FOUND\",\n    message: `Prompt ${name + (variant ? ` (variant ${variant})` : \"\")} not found`\n  });\n}\nfunction registryDefinitionKey(name, variant, ns) {\n  return `${ns ? `${ns}/` : \"\"}${name}${variant ? `.${variant}` : \"\"}`;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=prompt.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9wcm9tcHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHFGQUFpQjtBQUMzQyxtQkFBbUIsbUJBQU8sQ0FBQywyRkFBdUI7QUFDbEQscUJBQXFCLG1CQUFPLENBQUMsK0ZBQXlCO0FBQ3RELG9CQUFvQixtQkFBTyxDQUFDLDZGQUF3QjtBQUNwRCxxQkFBcUIsbUJBQU8sQ0FBQywrRkFBeUI7QUFDdEQsZ0JBQWdCLG1CQUFPLENBQUMsY0FBSTtBQUM1QixrQkFBa0IsbUJBQU8sQ0FBQyxrQkFBTTtBQUNoQyxzQkFBc0IsbUJBQU8sQ0FBQyxvRkFBZTtBQUM3QyxxQkFBcUIsbUJBQU8sQ0FBQyxrRkFBYztBQUMzQyxtQkFBbUIsbUJBQU8sQ0FBQyw4RUFBWTtBQUN2QyxxQkFBcUIsbUJBQU8sQ0FBQyxrRkFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGFBQWEsRUFBRSxzQkFBc0IsZ0JBQWdCLE9BQU87QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxZQUFZO0FBQ1osU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhLEVBQUUsc0JBQXNCLGdCQUFnQixPQUFPO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWEsRUFBRSxzQkFBc0IsZ0JBQWdCLE9BQU87QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLDJDQUEyQyxZQUFZLFVBQVUsNENBQTRDO0FBQzdHO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYSxFQUFFLCtDQUErQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5Q0FBeUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0JBQStCLFFBQVEsVUFBVTtBQUN4RSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFlBQVksUUFBUSxHQUFHLFFBQVEsRUFBRSxLQUFLLEVBQUUsY0FBYyxRQUFRLE9BQU87QUFDckU7QUFDQTtBQUNBLE1BQU0sQ0FTTDtBQUNEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEtSYW1hY2hhXFxEb2N1bWVudHNcXFN1c3RBSW5leCBHSXQgQ29kZVxcbm9kZV9tb2R1bGVzXFxAZ2Vua2l0LWFpXFxhaVxcbGliXFxwcm9tcHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIHByb21wdF9leHBvcnRzID0ge307XG5fX2V4cG9ydChwcm9tcHRfZXhwb3J0cywge1xuICBkZWZpbmVIZWxwZXI6ICgpID0+IGRlZmluZUhlbHBlcixcbiAgZGVmaW5lUGFydGlhbDogKCkgPT4gZGVmaW5lUGFydGlhbCxcbiAgZGVmaW5lUHJvbXB0OiAoKSA9PiBkZWZpbmVQcm9tcHQsXG4gIGlzRXhlY3V0YWJsZVByb21wdDogKCkgPT4gaXNFeGVjdXRhYmxlUHJvbXB0LFxuICBpc1Byb21wdEFjdGlvbjogKCkgPT4gaXNQcm9tcHRBY3Rpb24sXG4gIGxvYWRQcm9tcHRGb2xkZXI6ICgpID0+IGxvYWRQcm9tcHRGb2xkZXIsXG4gIGxvYWRQcm9tcHRGb2xkZXJSZWN1cnNpdmVseTogKCkgPT4gbG9hZFByb21wdEZvbGRlclJlY3Vyc2l2ZWx5LFxuICBwcm9tcHQ6ICgpID0+IHByb21wdFxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhwcm9tcHRfZXhwb3J0cyk7XG52YXIgaW1wb3J0X2NvcmUgPSByZXF1aXJlKFwiQGdlbmtpdC1haS9jb3JlXCIpO1xudmFyIGltcG9ydF9hc3luYyA9IHJlcXVpcmUoXCJAZ2Vua2l0LWFpL2NvcmUvYXN5bmNcIik7XG52YXIgaW1wb3J0X2xvZ2dpbmcgPSByZXF1aXJlKFwiQGdlbmtpdC1haS9jb3JlL2xvZ2dpbmdcIik7XG52YXIgaW1wb3J0X3NjaGVtYSA9IHJlcXVpcmUoXCJAZ2Vua2l0LWFpL2NvcmUvc2NoZW1hXCIpO1xudmFyIGltcG9ydF90cmFjaW5nID0gcmVxdWlyZShcIkBnZW5raXQtYWkvY29yZS90cmFjaW5nXCIpO1xudmFyIGltcG9ydF9mcyA9IHJlcXVpcmUoXCJmc1wiKTtcbnZhciBpbXBvcnRfcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xudmFyIGltcG9ydF9nZW5lcmF0ZSA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlLmpzXCIpO1xudmFyIGltcG9ydF9tZXNzYWdlID0gcmVxdWlyZShcIi4vbWVzc2FnZS5qc1wiKTtcbnZhciBpbXBvcnRfbW9kZWwgPSByZXF1aXJlKFwiLi9tb2RlbC5qc1wiKTtcbnZhciBpbXBvcnRfc2Vzc2lvbiA9IHJlcXVpcmUoXCIuL3Nlc3Npb24uanNcIik7XG5mdW5jdGlvbiBpc1Byb21wdEFjdGlvbihhY3Rpb24pIHtcbiAgcmV0dXJuIGFjdGlvbi5fX2FjdGlvbi5tZXRhZGF0YT8udHlwZSA9PT0gXCJwcm9tcHRcIjtcbn1cbmZ1bmN0aW9uIGRlZmluZVByb21wdChyZWdpc3RyeSwgb3B0aW9ucykge1xuICByZXR1cm4gZGVmaW5lUHJvbXB0QXN5bmMoXG4gICAgcmVnaXN0cnksXG4gICAgYCR7b3B0aW9ucy5uYW1lfSR7b3B0aW9ucy52YXJpYW50ID8gYC4ke29wdGlvbnMudmFyaWFudH1gIDogXCJcIn1gLFxuICAgIFByb21pc2UucmVzb2x2ZShvcHRpb25zKSxcbiAgICBvcHRpb25zLm1ldGFkYXRhXG4gICk7XG59XG5mdW5jdGlvbiBkZWZpbmVQcm9tcHRBc3luYyhyZWdpc3RyeSwgbmFtZSwgb3B0aW9uc1Byb21pc2UsIG1ldGFkYXRhKSB7XG4gIGNvbnN0IHByb21wdENhY2hlID0ge307XG4gIGNvbnN0IHJlbmRlck9wdGlvbnNGbiA9IGFzeW5jIChpbnB1dCwgcmVuZGVyT3B0aW9ucykgPT4ge1xuICAgIHJldHVybiBhd2FpdCAoMCwgaW1wb3J0X3RyYWNpbmcucnVuSW5OZXdTcGFuKShcbiAgICAgIHtcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBuYW1lOiBcInJlbmRlclwiLFxuICAgICAgICAgIGlucHV0XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsczoge1xuICAgICAgICAgIFtpbXBvcnRfdHJhY2luZy5TUEFOX1RZUEVfQVRUUl06IFwicHJvbXB0VGVtcGxhdGVcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYXN5bmMgKG1ldGFkYXRhMikgPT4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgICAgICByZW5kZXJPcHRpb25zID0geyAuLi5yZW5kZXJPcHRpb25zIH07XG4gICAgICAgIGNvbnN0IHNlc3Npb24gPSAoMCwgaW1wb3J0X3Nlc3Npb24uZ2V0Q3VycmVudFNlc3Npb24pKHJlZ2lzdHJ5KTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRPcHRpb25zID0gYXdhaXQgb3B0aW9uc1Byb21pc2U7XG4gICAgICAgIGF3YWl0IHJlbmRlclN5c3RlbVByb21wdChcbiAgICAgICAgICByZWdpc3RyeSxcbiAgICAgICAgICBzZXNzaW9uLFxuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICAgIHJlc29sdmVkT3B0aW9ucyxcbiAgICAgICAgICBwcm9tcHRDYWNoZSxcbiAgICAgICAgICByZW5kZXJPcHRpb25zXG4gICAgICAgICk7XG4gICAgICAgIGF3YWl0IHJlbmRlck1lc3NhZ2VzKFxuICAgICAgICAgIHJlZ2lzdHJ5LFxuICAgICAgICAgIHNlc3Npb24sXG4gICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgbWVzc2FnZXMsXG4gICAgICAgICAgcmVzb2x2ZWRPcHRpb25zLFxuICAgICAgICAgIHJlbmRlck9wdGlvbnMsXG4gICAgICAgICAgcHJvbXB0Q2FjaGVcbiAgICAgICAgKTtcbiAgICAgICAgYXdhaXQgcmVuZGVyVXNlclByb21wdChcbiAgICAgICAgICByZWdpc3RyeSxcbiAgICAgICAgICBzZXNzaW9uLFxuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICAgIHJlc29sdmVkT3B0aW9ucyxcbiAgICAgICAgICBwcm9tcHRDYWNoZSxcbiAgICAgICAgICByZW5kZXJPcHRpb25zXG4gICAgICAgICk7XG4gICAgICAgIGxldCBkb2NzO1xuICAgICAgICBpZiAodHlwZW9mIHJlc29sdmVkT3B0aW9ucy5kb2NzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBkb2NzID0gYXdhaXQgcmVzb2x2ZWRPcHRpb25zLmRvY3MoaW5wdXQsIHtcbiAgICAgICAgICAgIHN0YXRlOiBzZXNzaW9uPy5zdGF0ZSxcbiAgICAgICAgICAgIGNvbnRleHQ6IHJlbmRlck9wdGlvbnM/LmNvbnRleHQgfHwgKDAsIGltcG9ydF9jb3JlLmdldENvbnRleHQpKCkgfHwge31cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb2NzID0gcmVzb2x2ZWRPcHRpb25zLmRvY3M7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0cyA9ICgwLCBpbXBvcnRfY29yZS5zdHJpcFVuZGVmaW5lZFByb3BzKSh7XG4gICAgICAgICAgbW9kZWw6IHJlc29sdmVkT3B0aW9ucy5tb2RlbCxcbiAgICAgICAgICBtYXhUdXJuczogcmVzb2x2ZWRPcHRpb25zLm1heFR1cm5zLFxuICAgICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICAgIGRvY3MsXG4gICAgICAgICAgdG9vbHM6IHJlc29sdmVkT3B0aW9ucy50b29scyxcbiAgICAgICAgICByZXR1cm5Ub29sUmVxdWVzdHM6IHJlc29sdmVkT3B0aW9ucy5yZXR1cm5Ub29sUmVxdWVzdHMsXG4gICAgICAgICAgdG9vbENob2ljZTogcmVzb2x2ZWRPcHRpb25zLnRvb2xDaG9pY2UsXG4gICAgICAgICAgY29udGV4dDogcmVzb2x2ZWRPcHRpb25zLmNvbnRleHQsXG4gICAgICAgICAgb3V0cHV0OiByZXNvbHZlZE9wdGlvbnMub3V0cHV0LFxuICAgICAgICAgIHVzZTogcmVzb2x2ZWRPcHRpb25zLnVzZSxcbiAgICAgICAgICAuLi4oMCwgaW1wb3J0X2NvcmUuc3RyaXBVbmRlZmluZWRQcm9wcykocmVuZGVyT3B0aW9ucyksXG4gICAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgICAuLi5yZXNvbHZlZE9wdGlvbnM/LmNvbmZpZyxcbiAgICAgICAgICAgIC4uLnJlbmRlck9wdGlvbnM/LmNvbmZpZ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbWV0YWRhdGE6IHJlc29sdmVkT3B0aW9ucy5tZXRhZGF0YT8ubWV0YWRhdGEgPyB7XG4gICAgICAgICAgICBwcm9tcHQ6IHJlc29sdmVkT3B0aW9ucy5tZXRhZGF0YT8ubWV0YWRhdGFcbiAgICAgICAgICB9IDogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVuZGVyT3B0aW9ucz8uYWJvcnRTaWduYWwpIHtcbiAgICAgICAgICBvcHRzLmFib3J0U2lnbmFsID0gcmVuZGVyT3B0aW9ucy5hYm9ydFNpZ25hbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMob3B0cy5jb25maWcpLmxlbmd0aCA9PT0gMCAmJiAhcmVuZGVyT3B0aW9ucz8uY29uZmlnKSB7XG4gICAgICAgICAgZGVsZXRlIG9wdHMuY29uZmlnO1xuICAgICAgICB9XG4gICAgICAgIG1ldGFkYXRhMi5vdXRwdXQgPSBvcHRzO1xuICAgICAgICByZXR1cm4gb3B0cztcbiAgICAgIH1cbiAgICApO1xuICB9O1xuICBjb25zdCByZW5kZXJlckFjdGlvbkNvbmZpZyA9ICgwLCBpbXBvcnRfYXN5bmMubGF6eSkoXG4gICAgKCkgPT4gb3B0aW9uc1Byb21pc2UudGhlbigob3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgbWV0YWRhdGEyID0gcHJvbXB0TWV0YWRhdGEob3B0aW9ucyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBgJHtvcHRpb25zLm5hbWV9JHtvcHRpb25zLnZhcmlhbnQgPyBgLiR7b3B0aW9ucy52YXJpYW50fWAgOiBcIlwifWAsXG4gICAgICAgIGlucHV0SnNvblNjaGVtYTogb3B0aW9ucy5pbnB1dD8uanNvblNjaGVtYSxcbiAgICAgICAgaW5wdXRTY2hlbWE6IG9wdGlvbnMuaW5wdXQ/LnNjaGVtYSxcbiAgICAgICAgZGVzY3JpcHRpb246IG9wdGlvbnMuZGVzY3JpcHRpb24sXG4gICAgICAgIGFjdGlvblR5cGU6IFwicHJvbXB0XCIsXG4gICAgICAgIG1ldGFkYXRhOiBtZXRhZGF0YTIsXG4gICAgICAgIGZuOiBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICByZXR1cm4gKDAsIGltcG9ydF9nZW5lcmF0ZS50b0dlbmVyYXRlUmVxdWVzdCkoXG4gICAgICAgICAgICByZWdpc3RyeSxcbiAgICAgICAgICAgIGF3YWl0IHJlbmRlck9wdGlvbnNGbihpbnB1dCwgdm9pZCAwKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSlcbiAgKTtcbiAgY29uc3QgcmVuZGVyZXJBY3Rpb24gPSAoMCwgaW1wb3J0X2NvcmUuZGVmaW5lQWN0aW9uQXN5bmMpKFxuICAgIHJlZ2lzdHJ5LFxuICAgIFwicHJvbXB0XCIsXG4gICAgbmFtZSxcbiAgICByZW5kZXJlckFjdGlvbkNvbmZpZyxcbiAgICAoYWN0aW9uKSA9PiB7XG4gICAgICBhY3Rpb24uX19leGVjdXRhYmxlUHJvbXB0ID0gZXhlY3V0YWJsZVByb21wdDtcbiAgICB9XG4gICk7XG4gIGNvbnN0IGV4ZWN1dGFibGVQcm9tcHRBY3Rpb25Db25maWcgPSAoMCwgaW1wb3J0X2FzeW5jLmxhenkpKFxuICAgICgpID0+IG9wdGlvbnNQcm9taXNlLnRoZW4oKG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhMiA9IHByb21wdE1ldGFkYXRhKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogYCR7b3B0aW9ucy5uYW1lfSR7b3B0aW9ucy52YXJpYW50ID8gYC4ke29wdGlvbnMudmFyaWFudH1gIDogXCJcIn1gLFxuICAgICAgICBpbnB1dEpzb25TY2hlbWE6IG9wdGlvbnMuaW5wdXQ/Lmpzb25TY2hlbWEsXG4gICAgICAgIGlucHV0U2NoZW1hOiBvcHRpb25zLmlucHV0Py5zY2hlbWEsXG4gICAgICAgIG91dHB1dFNjaGVtYTogaW1wb3J0X21vZGVsLkdlbmVyYXRlQWN0aW9uT3B0aW9uc1NjaGVtYSxcbiAgICAgICAgZGVzY3JpcHRpb246IG9wdGlvbnMuZGVzY3JpcHRpb24sXG4gICAgICAgIGFjdGlvblR5cGU6IFwiZXhlY3V0YWJsZS1wcm9tcHRcIixcbiAgICAgICAgbWV0YWRhdGE6IG1ldGFkYXRhMixcbiAgICAgICAgZm46IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgIHJldHVybiBhd2FpdCAoMCwgaW1wb3J0X2dlbmVyYXRlLnRvR2VuZXJhdGVBY3Rpb25PcHRpb25zKShcbiAgICAgICAgICAgIHJlZ2lzdHJ5LFxuICAgICAgICAgICAgYXdhaXQgcmVuZGVyT3B0aW9uc0ZuKGlucHV0LCB2b2lkIDApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KVxuICApO1xuICAoMCwgaW1wb3J0X2NvcmUuZGVmaW5lQWN0aW9uQXN5bmMpKFxuICAgIHJlZ2lzdHJ5LFxuICAgIFwiZXhlY3V0YWJsZS1wcm9tcHRcIixcbiAgICBuYW1lLFxuICAgIGV4ZWN1dGFibGVQcm9tcHRBY3Rpb25Db25maWcsXG4gICAgKGFjdGlvbikgPT4ge1xuICAgICAgYWN0aW9uLl9fZXhlY3V0YWJsZVByb21wdCA9IGV4ZWN1dGFibGVQcm9tcHQ7XG4gICAgfVxuICApO1xuICBjb25zdCBleGVjdXRhYmxlUHJvbXB0ID0gd3JhcEluRXhlY3V0YWJsZVByb21wdCh7XG4gICAgcmVnaXN0cnksXG4gICAgbmFtZSxcbiAgICByZW5kZXJPcHRpb25zRm4sXG4gICAgcmVuZGVyZXJBY3Rpb24sXG4gICAgbWV0YWRhdGFcbiAgfSk7XG4gIHJldHVybiBleGVjdXRhYmxlUHJvbXB0O1xufVxuZnVuY3Rpb24gcHJvbXB0TWV0YWRhdGEob3B0aW9ucykge1xuICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICAuLi5vcHRpb25zLm1ldGFkYXRhLFxuICAgIHByb21wdDoge1xuICAgICAgLi4ub3B0aW9ucy5tZXRhZGF0YT8ucHJvbXB0LFxuICAgICAgY29uZmlnOiBvcHRpb25zLmNvbmZpZyxcbiAgICAgIGlucHV0OiB7XG4gICAgICAgIHNjaGVtYTogb3B0aW9ucy5pbnB1dCA/ICgwLCBpbXBvcnRfc2NoZW1hLnRvSnNvblNjaGVtYSkob3B0aW9ucy5pbnB1dCkgOiB2b2lkIDBcbiAgICAgIH0sXG4gICAgICBuYW1lOiBvcHRpb25zLm5hbWUuaW5jbHVkZXMoXCIuXCIpID8gb3B0aW9ucy5uYW1lLnNwbGl0KFwiLlwiKVswXSA6IG9wdGlvbnMubmFtZSxcbiAgICAgIG1vZGVsOiBtb2RlbE5hbWUob3B0aW9ucy5tb2RlbClcbiAgICB9LFxuICAgIHR5cGU6IFwicHJvbXB0XCJcbiAgfTtcbiAgaWYgKG9wdGlvbnMudmFyaWFudCkge1xuICAgIG1ldGFkYXRhLnByb21wdC52YXJpYW50ID0gb3B0aW9ucy52YXJpYW50O1xuICB9XG4gIHJldHVybiBtZXRhZGF0YTtcbn1cbmZ1bmN0aW9uIHdyYXBJbkV4ZWN1dGFibGVQcm9tcHQod3JhcE9wdHMpIHtcbiAgY29uc3QgZXhlY3V0YWJsZVByb21wdCA9IGFzeW5jIChpbnB1dCwgb3B0cykgPT4ge1xuICAgIHJldHVybiBhd2FpdCAoMCwgaW1wb3J0X3RyYWNpbmcucnVuSW5OZXdTcGFuKShcbiAgICAgIHdyYXBPcHRzLnJlZ2lzdHJ5LFxuICAgICAge1xuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIG5hbWU6IChhd2FpdCB3cmFwT3B0cy5yZW5kZXJlckFjdGlvbikuX19hY3Rpb24ubmFtZSxcbiAgICAgICAgICBpbnB1dFxuICAgICAgICB9LFxuICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICBbaW1wb3J0X3RyYWNpbmcuU1BBTl9UWVBFX0FUVFJdOiBcImRvdHByb21wdFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhc3luYyAobWV0YWRhdGEpID0+IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgKDAsIGltcG9ydF9nZW5lcmF0ZS5nZW5lcmF0ZSkod3JhcE9wdHMucmVnaXN0cnksIHtcbiAgICAgICAgICAuLi5hd2FpdCB3cmFwT3B0cy5yZW5kZXJPcHRpb25zRm4oaW5wdXQsIG9wdHMpXG4gICAgICAgIH0pO1xuICAgICAgICBtZXRhZGF0YS5vdXRwdXQgPSBvdXRwdXQ7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICB9XG4gICAgKTtcbiAgfTtcbiAgZXhlY3V0YWJsZVByb21wdC5yZWYgPSB7IG5hbWU6IHdyYXBPcHRzLm5hbWUsIG1ldGFkYXRhOiB3cmFwT3B0cy5tZXRhZGF0YSB9O1xuICBleGVjdXRhYmxlUHJvbXB0LnJlbmRlciA9IGFzeW5jIChpbnB1dCwgb3B0cykgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5hd2FpdCB3cmFwT3B0cy5yZW5kZXJPcHRpb25zRm4oaW5wdXQsIG9wdHMpXG4gICAgfTtcbiAgfTtcbiAgZXhlY3V0YWJsZVByb21wdC5zdHJlYW0gPSAoaW5wdXQsIG9wdHMpID0+IHtcbiAgICByZXR1cm4gKDAsIGltcG9ydF9nZW5lcmF0ZS5nZW5lcmF0ZVN0cmVhbSkoXG4gICAgICB3cmFwT3B0cy5yZWdpc3RyeSxcbiAgICAgIHdyYXBPcHRzLnJlbmRlck9wdGlvbnNGbihpbnB1dCwgb3B0cylcbiAgICApO1xuICB9O1xuICBleGVjdXRhYmxlUHJvbXB0LmFzVG9vbCA9IGFzeW5jICgpID0+IHtcbiAgICByZXR1cm4gYXdhaXQgd3JhcE9wdHMucmVuZGVyZXJBY3Rpb247XG4gIH07XG4gIHJldHVybiBleGVjdXRhYmxlUHJvbXB0O1xufVxuYXN5bmMgZnVuY3Rpb24gcmVuZGVyU3lzdGVtUHJvbXB0KHJlZ2lzdHJ5LCBzZXNzaW9uLCBpbnB1dCwgbWVzc2FnZXMsIG9wdGlvbnMsIHByb21wdENhY2hlLCByZW5kZXJPcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5zeXN0ZW0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgIGNvbnRlbnQ6IG5vcm1hbGl6ZVBhcnRzKFxuICAgICAgICBhd2FpdCBvcHRpb25zLnN5c3RlbShpbnB1dCwge1xuICAgICAgICAgIHN0YXRlOiBzZXNzaW9uPy5zdGF0ZSxcbiAgICAgICAgICBjb250ZXh0OiByZW5kZXJPcHRpb25zPy5jb250ZXh0IHx8ICgwLCBpbXBvcnRfY29yZS5nZXRDb250ZXh0KSgpIHx8IHt9XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuc3lzdGVtID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKCFwcm9tcHRDYWNoZS5zeXN0ZW0pIHtcbiAgICAgIHByb21wdENhY2hlLnN5c3RlbSA9IGF3YWl0IHJlZ2lzdHJ5LmRvdHByb21wdC5jb21waWxlKG9wdGlvbnMuc3lzdGVtKTtcbiAgICB9XG4gICAgbWVzc2FnZXMucHVzaCh7XG4gICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgICAgY29udGVudDogYXdhaXQgcmVuZGVyRG90cHJvbXB0VG9QYXJ0cyhcbiAgICAgICAgcmVnaXN0cnksXG4gICAgICAgIHByb21wdENhY2hlLnN5c3RlbSxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIHNlc3Npb24sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIHJlbmRlck9wdGlvbnNcbiAgICAgIClcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLnN5c3RlbSkge1xuICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgIGNvbnRlbnQ6IG5vcm1hbGl6ZVBhcnRzKG9wdGlvbnMuc3lzdGVtKVxuICAgIH0pO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiByZW5kZXJNZXNzYWdlcyhyZWdpc3RyeSwgc2Vzc2lvbiwgaW5wdXQsIG1lc3NhZ2VzLCBvcHRpb25zLCByZW5kZXJPcHRpb25zLCBwcm9tcHRDYWNoZSkge1xuICBpZiAob3B0aW9ucy5tZXNzYWdlcykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5tZXNzYWdlcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKFxuICAgICAgICAuLi5hd2FpdCBvcHRpb25zLm1lc3NhZ2VzKGlucHV0LCB7XG4gICAgICAgICAgc3RhdGU6IHNlc3Npb24/LnN0YXRlLFxuICAgICAgICAgIGNvbnRleHQ6IHJlbmRlck9wdGlvbnM/LmNvbnRleHQgfHwgKDAsIGltcG9ydF9jb3JlLmdldENvbnRleHQpKCkgfHwge30sXG4gICAgICAgICAgaGlzdG9yeTogcmVuZGVyT3B0aW9ucz8ubWVzc2FnZXNcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5tZXNzYWdlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKCFwcm9tcHRDYWNoZS5tZXNzYWdlcykge1xuICAgICAgICBwcm9tcHRDYWNoZS5tZXNzYWdlcyA9IGF3YWl0IHJlZ2lzdHJ5LmRvdHByb21wdC5jb21waWxlKFxuICAgICAgICAgIG9wdGlvbnMubWVzc2FnZXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbmRlcmVkID0gYXdhaXQgcHJvbXB0Q2FjaGUubWVzc2FnZXMoe1xuICAgICAgICBpbnB1dCxcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIC4uLnJlbmRlck9wdGlvbnM/LmNvbnRleHQgfHwgKDAsIGltcG9ydF9jb3JlLmdldENvbnRleHQpKCksXG4gICAgICAgICAgc3RhdGU6IHNlc3Npb24/LnN0YXRlXG4gICAgICAgIH0sXG4gICAgICAgIG1lc3NhZ2VzOiByZW5kZXJPcHRpb25zPy5tZXNzYWdlcz8ubWFwKFxuICAgICAgICAgIChtKSA9PiBpbXBvcnRfbWVzc2FnZS5NZXNzYWdlLnBhcnNlRGF0YShtKVxuICAgICAgICApXG4gICAgICB9KTtcbiAgICAgIG1lc3NhZ2VzLnB1c2goLi4ucmVuZGVyZWQubWVzc2FnZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKC4uLm9wdGlvbnMubWVzc2FnZXMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocmVuZGVyT3B0aW9ucy5tZXNzYWdlcykge1xuICAgICAgbWVzc2FnZXMucHVzaCguLi5yZW5kZXJPcHRpb25zLm1lc3NhZ2VzKTtcbiAgICB9XG4gIH1cbiAgaWYgKHJlbmRlck9wdGlvbnM/Lm1lc3NhZ2VzKSB7XG4gICAgZGVsZXRlIHJlbmRlck9wdGlvbnMubWVzc2FnZXM7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHJlbmRlclVzZXJQcm9tcHQocmVnaXN0cnksIHNlc3Npb24sIGlucHV0LCBtZXNzYWdlcywgb3B0aW9ucywgcHJvbXB0Q2FjaGUsIHJlbmRlck9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLnByb21wdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgbWVzc2FnZXMucHVzaCh7XG4gICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgIGNvbnRlbnQ6IG5vcm1hbGl6ZVBhcnRzKFxuICAgICAgICBhd2FpdCBvcHRpb25zLnByb21wdChpbnB1dCwge1xuICAgICAgICAgIHN0YXRlOiBzZXNzaW9uPy5zdGF0ZSxcbiAgICAgICAgICBjb250ZXh0OiByZW5kZXJPcHRpb25zPy5jb250ZXh0IHx8ICgwLCBpbXBvcnRfY29yZS5nZXRDb250ZXh0KSgpIHx8IHt9XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMucHJvbXB0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKCFwcm9tcHRDYWNoZS51c2VyUHJvbXB0KSB7XG4gICAgICBwcm9tcHRDYWNoZS51c2VyUHJvbXB0ID0gYXdhaXQgcmVnaXN0cnkuZG90cHJvbXB0LmNvbXBpbGUob3B0aW9ucy5wcm9tcHQpO1xuICAgIH1cbiAgICBtZXNzYWdlcy5wdXNoKHtcbiAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgY29udGVudDogYXdhaXQgcmVuZGVyRG90cHJvbXB0VG9QYXJ0cyhcbiAgICAgICAgcmVnaXN0cnksXG4gICAgICAgIHByb21wdENhY2hlLnVzZXJQcm9tcHQsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBzZXNzaW9uLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICByZW5kZXJPcHRpb25zXG4gICAgICApXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5wcm9tcHQpIHtcbiAgICBtZXNzYWdlcy5wdXNoKHtcbiAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgY29udGVudDogbm9ybWFsaXplUGFydHMob3B0aW9ucy5wcm9tcHQpXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1vZGVsTmFtZShtb2RlbEFyZykge1xuICBpZiAobW9kZWxBcmcgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKHR5cGVvZiBtb2RlbEFyZyA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBtb2RlbEFyZztcbiAgfVxuICBpZiAobW9kZWxBcmcubmFtZSkge1xuICAgIHJldHVybiBtb2RlbEFyZy5uYW1lO1xuICB9XG4gIHJldHVybiBtb2RlbEFyZy5fX2FjdGlvbi5uYW1lO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUGFydHMocGFydHMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGFydHMpKSByZXR1cm4gcGFydHM7XG4gIGlmICh0eXBlb2YgcGFydHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0ZXh0OiBwYXJ0c1xuICAgICAgfVxuICAgIF07XG4gIH1cbiAgcmV0dXJuIFtwYXJ0c107XG59XG5hc3luYyBmdW5jdGlvbiByZW5kZXJEb3Rwcm9tcHRUb1BhcnRzKHJlZ2lzdHJ5LCBwcm9tcHRGbiwgaW5wdXQsIHNlc3Npb24sIG9wdGlvbnMsIHJlbmRlck9wdGlvbnMpIHtcbiAgY29uc3QgcmVuZGVycmVkID0gYXdhaXQgcHJvbXB0Rm4oe1xuICAgIGlucHV0LFxuICAgIGNvbnRleHQ6IHtcbiAgICAgIC4uLnJlbmRlck9wdGlvbnM/LmNvbnRleHQgfHwgKDAsIGltcG9ydF9jb3JlLmdldENvbnRleHQpKCksXG4gICAgICBzdGF0ZTogc2Vzc2lvbj8uc3RhdGVcbiAgICB9XG4gIH0pO1xuICBpZiAocmVuZGVycmVkLm1lc3NhZ2VzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInBhcnRzIHRlbXBhdGUgbXVzdCBwcm9kdWNlIG9ubHkgb25lIG1lc3NhZ2VcIik7XG4gIH1cbiAgcmV0dXJuIHJlbmRlcnJlZC5tZXNzYWdlc1swXS5jb250ZW50O1xufVxuZnVuY3Rpb24gaXNFeGVjdXRhYmxlUHJvbXB0KG9iaikge1xuICByZXR1cm4gISFvYmo/LnJlbmRlciAmJiAhIW9iaj8uYXNUb29sICYmICEhb2JqPy5zdHJlYW07XG59XG5mdW5jdGlvbiBsb2FkUHJvbXB0Rm9sZGVyKHJlZ2lzdHJ5LCBkaXIgPSBcIi4vcHJvbXB0c1wiLCBucykge1xuICBjb25zdCBwcm9tcHRzUGF0aCA9ICgwLCBpbXBvcnRfcGF0aC5yZXNvbHZlKShkaXIpO1xuICBpZiAoKDAsIGltcG9ydF9mcy5leGlzdHNTeW5jKShwcm9tcHRzUGF0aCkpIHtcbiAgICBsb2FkUHJvbXB0Rm9sZGVyUmVjdXJzaXZlbHkocmVnaXN0cnksIGRpciwgbnMsIFwiXCIpO1xuICB9XG59XG5mdW5jdGlvbiBsb2FkUHJvbXB0Rm9sZGVyUmVjdXJzaXZlbHkocmVnaXN0cnksIGRpciwgbnMsIHN1YkRpcikge1xuICBjb25zdCBwcm9tcHRzUGF0aCA9ICgwLCBpbXBvcnRfcGF0aC5yZXNvbHZlKShkaXIpO1xuICBjb25zdCBkaXJFbnRzID0gKDAsIGltcG9ydF9mcy5yZWFkZGlyU3luYykoKDAsIGltcG9ydF9wYXRoLmpvaW4pKHByb21wdHNQYXRoLCBzdWJEaXIpLCB7XG4gICAgd2l0aEZpbGVUeXBlczogdHJ1ZVxuICB9KTtcbiAgZm9yIChjb25zdCBkaXJFbnQgb2YgZGlyRW50cykge1xuICAgIGNvbnN0IHBhcmVudFBhdGggPSAoMCwgaW1wb3J0X3BhdGguam9pbikocHJvbXB0c1BhdGgsIHN1YkRpcik7XG4gICAgY29uc3QgZmlsZU5hbWUgPSBkaXJFbnQubmFtZTtcbiAgICBpZiAoZGlyRW50LmlzRmlsZSgpICYmIGZpbGVOYW1lLmVuZHNXaXRoKFwiLnByb21wdFwiKSkge1xuICAgICAgaWYgKGZpbGVOYW1lLnN0YXJ0c1dpdGgoXCJfXCIpKSB7XG4gICAgICAgIGNvbnN0IHBhcnRpYWxOYW1lID0gZmlsZU5hbWUuc3Vic3RyaW5nKDEsIGZpbGVOYW1lLmxlbmd0aCAtIDcpO1xuICAgICAgICBkZWZpbmVQYXJ0aWFsKFxuICAgICAgICAgIHJlZ2lzdHJ5LFxuICAgICAgICAgIHBhcnRpYWxOYW1lLFxuICAgICAgICAgICgwLCBpbXBvcnRfZnMucmVhZEZpbGVTeW5jKSgoMCwgaW1wb3J0X3BhdGguam9pbikocGFyZW50UGF0aCwgZmlsZU5hbWUpLCB7XG4gICAgICAgICAgICBlbmNvZGluZzogXCJ1dGY4XCJcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBpbXBvcnRfbG9nZ2luZy5sb2dnZXIuZGVidWcoXG4gICAgICAgICAgYFJlZ2lzdGVyZWQgRG90cHJvbXB0IHBhcnRpYWwgXCIke3BhcnRpYWxOYW1lfVwiIGZyb20gXCIkeygwLCBpbXBvcnRfcGF0aC5qb2luKShwYXJlbnRQYXRoLCBmaWxlTmFtZSl9XCJgXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2FkUHJvbXB0KFxuICAgICAgICAgIHJlZ2lzdHJ5LFxuICAgICAgICAgIHByb21wdHNQYXRoLFxuICAgICAgICAgIGZpbGVOYW1lLFxuICAgICAgICAgIHN1YkRpciA/IGAke3N1YkRpcn0vYCA6IFwiXCIsXG4gICAgICAgICAgbnNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRpckVudC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICBsb2FkUHJvbXB0Rm9sZGVyUmVjdXJzaXZlbHkocmVnaXN0cnksIGRpciwgbnMsICgwLCBpbXBvcnRfcGF0aC5qb2luKShzdWJEaXIsIGZpbGVOYW1lKSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZWZpbmVQYXJ0aWFsKHJlZ2lzdHJ5LCBuYW1lLCBzb3VyY2UpIHtcbiAgcmVnaXN0cnkuZG90cHJvbXB0LmRlZmluZVBhcnRpYWwobmFtZSwgc291cmNlKTtcbn1cbmZ1bmN0aW9uIGRlZmluZUhlbHBlcihyZWdpc3RyeSwgbmFtZSwgZm4pIHtcbiAgcmVnaXN0cnkuZG90cHJvbXB0LmRlZmluZUhlbHBlcihuYW1lLCBmbik7XG59XG5mdW5jdGlvbiBsb2FkUHJvbXB0KHJlZ2lzdHJ5LCBwYXRoLCBmaWxlbmFtZSwgcHJlZml4ID0gXCJcIiwgbnMgPSBcImRvdHByb21wdFwiKSB7XG4gIGxldCBuYW1lID0gYCR7cHJlZml4ID8/IFwiXCJ9JHsoMCwgaW1wb3J0X3BhdGguYmFzZW5hbWUpKGZpbGVuYW1lLCBcIi5wcm9tcHRcIil9YDtcbiAgbGV0IHZhcmlhbnQgPSBudWxsO1xuICBpZiAobmFtZS5pbmNsdWRlcyhcIi5cIikpIHtcbiAgICBjb25zdCBwYXJ0cyA9IG5hbWUuc3BsaXQoXCIuXCIpO1xuICAgIG5hbWUgPSBwYXJ0c1swXTtcbiAgICB2YXJpYW50ID0gcGFydHNbMV07XG4gIH1cbiAgY29uc3Qgc291cmNlID0gKDAsIGltcG9ydF9mcy5yZWFkRmlsZVN5bmMpKCgwLCBpbXBvcnRfcGF0aC5qb2luKShwYXRoLCBwcmVmaXggPz8gXCJcIiwgZmlsZW5hbWUpLCBcInV0ZjhcIik7XG4gIGNvbnN0IHBhcnNlZFByb21wdCA9IHJlZ2lzdHJ5LmRvdHByb21wdC5wYXJzZShzb3VyY2UpO1xuICBkZWZpbmVQcm9tcHRBc3luYyhcbiAgICByZWdpc3RyeSxcbiAgICByZWdpc3RyeURlZmluaXRpb25LZXkobmFtZSwgdmFyaWFudCA/PyB2b2lkIDAsIG5zKSxcbiAgICAvLyBXZSB1c2UgYSBsYXp5IHByb21pc2UgaGVyZSBiZWNhdXNlIHdlIG9ubHkgd2FudCBwcm9tcHQgbG9hZGVkIHdoZW4gaXQncyBmaXJzdCB1c2VkLlxuICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2Ugb3RoZXJ3aXNlIHRoZSBsb2FkaW5nIG1heSBoYXBwZW4gYmVmb3JlIHRoZSB1c2VyIGhhcyBjb25maWd1cmVkXG4gICAgLy8gYWxsIHRoZSBzY2hlbWFzLCBldGMuLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBkb3Rwcm9tcHQucmVuZGVyTWV0YWRhdGEgZXJyb3JzLlxuICAgICgwLCBpbXBvcnRfYXN5bmMubGF6eSkoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvbXB0TWV0YWRhdGEyID0gYXdhaXQgcmVnaXN0cnkuZG90cHJvbXB0LnJlbmRlck1ldGFkYXRhKHBhcnNlZFByb21wdCk7XG4gICAgICBpZiAodmFyaWFudCkge1xuICAgICAgICBwcm9tcHRNZXRhZGF0YTIudmFyaWFudCA9IHZhcmlhbnQ7XG4gICAgICB9XG4gICAgICBpZiAocHJvbXB0TWV0YWRhdGEyLm91dHB1dD8uc2NoZW1hPy5kZXNjcmlwdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgcHJvbXB0TWV0YWRhdGEyLm91dHB1dC5zY2hlbWEuZGVzY3JpcHRpb247XG4gICAgICB9XG4gICAgICBpZiAocHJvbXB0TWV0YWRhdGEyLmlucHV0Py5zY2hlbWE/LmRlc2NyaXB0aW9uID09PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBwcm9tcHRNZXRhZGF0YTIuaW5wdXQuc2NoZW1hLmRlc2NyaXB0aW9uO1xuICAgICAgfVxuICAgICAgY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgICAgIC4uLnByb21wdE1ldGFkYXRhMi5tZXRhZGF0YSxcbiAgICAgICAgdHlwZTogXCJwcm9tcHRcIixcbiAgICAgICAgcHJvbXB0OiB7XG4gICAgICAgICAgLi4ucHJvbXB0TWV0YWRhdGEyLFxuICAgICAgICAgIHRlbXBsYXRlOiBwYXJzZWRQcm9tcHQudGVtcGxhdGVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChwcm9tcHRNZXRhZGF0YTIucmF3Py5bXCJtZXRhZGF0YVwiXSkge1xuICAgICAgICBtZXRhZGF0YVtcIm1ldGFkYXRhXCJdID0geyAuLi5wcm9tcHRNZXRhZGF0YTIucmF3Py5bXCJtZXRhZGF0YVwiXSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogcmVnaXN0cnlEZWZpbml0aW9uS2V5KG5hbWUsIHZhcmlhbnQgPz8gdm9pZCAwLCBucyksXG4gICAgICAgIG1vZGVsOiBwcm9tcHRNZXRhZGF0YTIubW9kZWwsXG4gICAgICAgIGNvbmZpZzogcHJvbXB0TWV0YWRhdGEyLmNvbmZpZyxcbiAgICAgICAgdG9vbHM6IHByb21wdE1ldGFkYXRhMi50b29scyxcbiAgICAgICAgZGVzY3JpcHRpb246IHByb21wdE1ldGFkYXRhMi5kZXNjcmlwdGlvbixcbiAgICAgICAgb3V0cHV0OiB7XG4gICAgICAgICAganNvblNjaGVtYTogcHJvbXB0TWV0YWRhdGEyLm91dHB1dD8uc2NoZW1hLFxuICAgICAgICAgIGZvcm1hdDogcHJvbXB0TWV0YWRhdGEyLm91dHB1dD8uZm9ybWF0XG4gICAgICAgIH0sXG4gICAgICAgIGlucHV0OiB7XG4gICAgICAgICAganNvblNjaGVtYTogcHJvbXB0TWV0YWRhdGEyLmlucHV0Py5zY2hlbWFcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIG1heFR1cm5zOiBwcm9tcHRNZXRhZGF0YTIucmF3Py5bXCJtYXhUdXJuc1wiXSxcbiAgICAgICAgdG9vbENob2ljZTogcHJvbXB0TWV0YWRhdGEyLnJhdz8uW1widG9vbENob2ljZVwiXSxcbiAgICAgICAgcmV0dXJuVG9vbFJlcXVlc3RzOiBwcm9tcHRNZXRhZGF0YTIucmF3Py5bXCJyZXR1cm5Ub29sUmVxdWVzdHNcIl0sXG4gICAgICAgIG1lc3NhZ2VzOiBwYXJzZWRQcm9tcHQudGVtcGxhdGVcbiAgICAgIH07XG4gICAgfSlcbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByb21wdChyZWdpc3RyeSwgbmFtZSwgb3B0aW9ucykge1xuICByZXR1cm4gYXdhaXQgbG9va3VwUHJvbXB0KFxuICAgIHJlZ2lzdHJ5LFxuICAgIG5hbWUsXG4gICAgb3B0aW9ucz8udmFyaWFudFxuICApO1xufVxuZnVuY3Rpb24gcmVnaXN0cnlMb29rdXBLZXkobmFtZSwgdmFyaWFudCwgbnMpIHtcbiAgcmV0dXJuIGAvcHJvbXB0LyR7cmVnaXN0cnlEZWZpbml0aW9uS2V5KG5hbWUsIHZhcmlhbnQsIG5zKX1gO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9va3VwUHJvbXB0KHJlZ2lzdHJ5LCBuYW1lLCB2YXJpYW50KSB7XG4gIGNvbnN0IHJlZ2lzdHJ5UHJvbXB0ID0gYXdhaXQgcmVnaXN0cnkubG9va3VwQWN0aW9uKFxuICAgIHJlZ2lzdHJ5TG9va3VwS2V5KG5hbWUsIHZhcmlhbnQpXG4gICk7XG4gIGlmIChyZWdpc3RyeVByb21wdCkge1xuICAgIHJldHVybiByZWdpc3RyeVByb21wdC5fX2V4ZWN1dGFibGVQcm9tcHQ7XG4gIH1cbiAgdGhyb3cgbmV3IGltcG9ydF9jb3JlLkdlbmtpdEVycm9yKHtcbiAgICBzdGF0dXM6IFwiTk9UX0ZPVU5EXCIsXG4gICAgbWVzc2FnZTogYFByb21wdCAke25hbWUgKyAodmFyaWFudCA/IGAgKHZhcmlhbnQgJHt2YXJpYW50fSlgIDogXCJcIil9IG5vdCBmb3VuZGBcbiAgfSk7XG59XG5mdW5jdGlvbiByZWdpc3RyeURlZmluaXRpb25LZXkobmFtZSwgdmFyaWFudCwgbnMpIHtcbiAgcmV0dXJuIGAke25zID8gYCR7bnN9L2AgOiBcIlwifSR7bmFtZX0ke3ZhcmlhbnQgPyBgLiR7dmFyaWFudH1gIDogXCJcIn1gO1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlZmluZUhlbHBlcixcbiAgZGVmaW5lUGFydGlhbCxcbiAgZGVmaW5lUHJvbXB0LFxuICBpc0V4ZWN1dGFibGVQcm9tcHQsXG4gIGlzUHJvbXB0QWN0aW9uLFxuICBsb2FkUHJvbXB0Rm9sZGVyLFxuICBsb2FkUHJvbXB0Rm9sZGVyUmVjdXJzaXZlbHksXG4gIHByb21wdFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9tcHQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/prompt.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/reranker.js":
/*!****************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/reranker.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar reranker_exports = {};\n__export(reranker_exports, {\n  CommonRerankerOptionsSchema: () => CommonRerankerOptionsSchema,\n  RankedDocument: () => RankedDocument,\n  RankedDocumentDataSchema: () => RankedDocumentDataSchema,\n  RankedDocumentMetadataSchema: () => RankedDocumentMetadataSchema,\n  RerankerInfoSchema: () => RerankerInfoSchema,\n  defineReranker: () => defineReranker,\n  rerank: () => rerank,\n  reranker: () => reranker,\n  rerankerRef: () => rerankerRef\n});\nmodule.exports = __toCommonJS(reranker_exports);\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nvar import_schema = __webpack_require__(/*! @genkit-ai/core/schema */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/schema.js\");\nvar import_document = __webpack_require__(/*! ./document.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/document.js\");\nvar import_retriever = __webpack_require__(/*! ./retriever.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/retriever.js\");\nconst RankedDocumentMetadataSchema = import_core.z.object({\n  score: import_core.z.number()\n  // Enforces that 'score' must be a number\n}).passthrough();\nconst RankedDocumentDataSchema = import_core.z.object({\n  content: import_core.z.array(import_document.PartSchema),\n  metadata: RankedDocumentMetadataSchema\n});\nclass RankedDocument extends import_retriever.Document {\n  content;\n  metadata;\n  constructor(data) {\n    super(data);\n    this.content = data.content;\n    this.metadata = data.metadata;\n  }\n  /**\n   * Returns the score of the document.\n   * @returns The score of the document.\n   */\n  score() {\n    return this.metadata.score;\n  }\n}\nconst RerankerRequestSchema = import_core.z.object({\n  query: import_retriever.DocumentDataSchema,\n  documents: import_core.z.array(import_retriever.DocumentDataSchema),\n  options: import_core.z.any().optional()\n});\nconst RerankerResponseSchema = import_core.z.object({\n  documents: import_core.z.array(RankedDocumentDataSchema)\n});\nconst RerankerInfoSchema = import_core.z.object({\n  label: import_core.z.string().optional(),\n  /** Supported model capabilities. */\n  supports: import_core.z.object({\n    /** Model can process media as part of the prompt (multimodal input). */\n    media: import_core.z.boolean().optional()\n  }).optional()\n});\nfunction rerankerWithMetadata(reranker2, configSchema) {\n  const withMeta = reranker2;\n  withMeta.__configSchema = configSchema;\n  return withMeta;\n}\nfunction defineReranker(registry, options, runner) {\n  const act = reranker(options, runner);\n  registry.registerAction(\"reranker\", act);\n  return act;\n}\nfunction reranker(options, runner) {\n  const reranker2 = (0, import_core.action)(\n    {\n      actionType: \"reranker\",\n      name: options.name,\n      inputSchema: options.configSchema ? RerankerRequestSchema.extend({\n        options: options.configSchema.optional()\n      }) : RerankerRequestSchema,\n      outputSchema: RerankerResponseSchema,\n      metadata: {\n        type: \"reranker\",\n        info: options.info,\n        reranker: {\n          customOptions: options.configSchema ? (0, import_schema.toJsonSchema)({ schema: options.configSchema }) : void 0\n        }\n      }\n    },\n    (i) => runner(\n      new import_retriever.Document(i.query),\n      i.documents.map((d) => new import_retriever.Document(d)),\n      i.options\n    )\n  );\n  const rwm = rerankerWithMetadata(\n    reranker2,\n    options.configSchema\n  );\n  return rwm;\n}\nasync function rerank(registry, params) {\n  let reranker2;\n  if (typeof params.reranker === \"string\") {\n    reranker2 = await registry.lookupAction(`/reranker/${params.reranker}`);\n  } else if (Object.hasOwnProperty.call(params.reranker, \"info\")) {\n    reranker2 = await registry.lookupAction(`/reranker/${params.reranker.name}`);\n  } else {\n    reranker2 = params.reranker;\n  }\n  if (!reranker2) {\n    throw new Error(\"Unable to resolve the reranker\");\n  }\n  const response = await reranker2({\n    query: typeof params.query === \"string\" ? import_retriever.Document.fromText(params.query) : params.query,\n    documents: params.documents,\n    options: params.options\n  });\n  return response.documents.map((d) => new RankedDocument(d));\n}\nconst CommonRerankerOptionsSchema = import_core.z.object({\n  k: import_core.z.number().describe(\"Number of documents to rerank\").optional()\n});\nfunction rerankerRef(options) {\n  return { ...options };\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=reranker.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9yZXJhbmtlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxxRkFBaUI7QUFDM0Msb0JBQW9CLG1CQUFPLENBQUMsNkZBQXdCO0FBQ3BELHNCQUFzQixtQkFBTyxDQUFDLG9GQUFlO0FBQzdDLHVCQUF1QixtQkFBTyxDQUFDLHNGQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRiw4QkFBOEI7QUFDaEg7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZ0JBQWdCO0FBQ3pFLElBQUk7QUFDSix5REFBeUQscUJBQXFCO0FBQzlFLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE1BQU0sQ0FVTDtBQUNEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEtSYW1hY2hhXFxEb2N1bWVudHNcXFN1c3RBSW5leCBHSXQgQ29kZVxcbm9kZV9tb2R1bGVzXFxAZ2Vua2l0LWFpXFxhaVxcbGliXFxyZXJhbmtlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgcmVyYW5rZXJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocmVyYW5rZXJfZXhwb3J0cywge1xuICBDb21tb25SZXJhbmtlck9wdGlvbnNTY2hlbWE6ICgpID0+IENvbW1vblJlcmFua2VyT3B0aW9uc1NjaGVtYSxcbiAgUmFua2VkRG9jdW1lbnQ6ICgpID0+IFJhbmtlZERvY3VtZW50LFxuICBSYW5rZWREb2N1bWVudERhdGFTY2hlbWE6ICgpID0+IFJhbmtlZERvY3VtZW50RGF0YVNjaGVtYSxcbiAgUmFua2VkRG9jdW1lbnRNZXRhZGF0YVNjaGVtYTogKCkgPT4gUmFua2VkRG9jdW1lbnRNZXRhZGF0YVNjaGVtYSxcbiAgUmVyYW5rZXJJbmZvU2NoZW1hOiAoKSA9PiBSZXJhbmtlckluZm9TY2hlbWEsXG4gIGRlZmluZVJlcmFua2VyOiAoKSA9PiBkZWZpbmVSZXJhbmtlcixcbiAgcmVyYW5rOiAoKSA9PiByZXJhbmssXG4gIHJlcmFua2VyOiAoKSA9PiByZXJhbmtlcixcbiAgcmVyYW5rZXJSZWY6ICgpID0+IHJlcmFua2VyUmVmXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHJlcmFua2VyX2V4cG9ydHMpO1xudmFyIGltcG9ydF9jb3JlID0gcmVxdWlyZShcIkBnZW5raXQtYWkvY29yZVwiKTtcbnZhciBpbXBvcnRfc2NoZW1hID0gcmVxdWlyZShcIkBnZW5raXQtYWkvY29yZS9zY2hlbWFcIik7XG52YXIgaW1wb3J0X2RvY3VtZW50ID0gcmVxdWlyZShcIi4vZG9jdW1lbnQuanNcIik7XG52YXIgaW1wb3J0X3JldHJpZXZlciA9IHJlcXVpcmUoXCIuL3JldHJpZXZlci5qc1wiKTtcbmNvbnN0IFJhbmtlZERvY3VtZW50TWV0YWRhdGFTY2hlbWEgPSBpbXBvcnRfY29yZS56Lm9iamVjdCh7XG4gIHNjb3JlOiBpbXBvcnRfY29yZS56Lm51bWJlcigpXG4gIC8vIEVuZm9yY2VzIHRoYXQgJ3Njb3JlJyBtdXN0IGJlIGEgbnVtYmVyXG59KS5wYXNzdGhyb3VnaCgpO1xuY29uc3QgUmFua2VkRG9jdW1lbnREYXRhU2NoZW1hID0gaW1wb3J0X2NvcmUuei5vYmplY3Qoe1xuICBjb250ZW50OiBpbXBvcnRfY29yZS56LmFycmF5KGltcG9ydF9kb2N1bWVudC5QYXJ0U2NoZW1hKSxcbiAgbWV0YWRhdGE6IFJhbmtlZERvY3VtZW50TWV0YWRhdGFTY2hlbWFcbn0pO1xuY2xhc3MgUmFua2VkRG9jdW1lbnQgZXh0ZW5kcyBpbXBvcnRfcmV0cmlldmVyLkRvY3VtZW50IHtcbiAgY29udGVudDtcbiAgbWV0YWRhdGE7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcihkYXRhKTtcbiAgICB0aGlzLmNvbnRlbnQgPSBkYXRhLmNvbnRlbnQ7XG4gICAgdGhpcy5tZXRhZGF0YSA9IGRhdGEubWV0YWRhdGE7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNjb3JlIG9mIHRoZSBkb2N1bWVudC5cbiAgICogQHJldHVybnMgVGhlIHNjb3JlIG9mIHRoZSBkb2N1bWVudC5cbiAgICovXG4gIHNjb3JlKCkge1xuICAgIHJldHVybiB0aGlzLm1ldGFkYXRhLnNjb3JlO1xuICB9XG59XG5jb25zdCBSZXJhbmtlclJlcXVlc3RTY2hlbWEgPSBpbXBvcnRfY29yZS56Lm9iamVjdCh7XG4gIHF1ZXJ5OiBpbXBvcnRfcmV0cmlldmVyLkRvY3VtZW50RGF0YVNjaGVtYSxcbiAgZG9jdW1lbnRzOiBpbXBvcnRfY29yZS56LmFycmF5KGltcG9ydF9yZXRyaWV2ZXIuRG9jdW1lbnREYXRhU2NoZW1hKSxcbiAgb3B0aW9uczogaW1wb3J0X2NvcmUuei5hbnkoKS5vcHRpb25hbCgpXG59KTtcbmNvbnN0IFJlcmFua2VyUmVzcG9uc2VTY2hlbWEgPSBpbXBvcnRfY29yZS56Lm9iamVjdCh7XG4gIGRvY3VtZW50czogaW1wb3J0X2NvcmUuei5hcnJheShSYW5rZWREb2N1bWVudERhdGFTY2hlbWEpXG59KTtcbmNvbnN0IFJlcmFua2VySW5mb1NjaGVtYSA9IGltcG9ydF9jb3JlLnoub2JqZWN0KHtcbiAgbGFiZWw6IGltcG9ydF9jb3JlLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgLyoqIFN1cHBvcnRlZCBtb2RlbCBjYXBhYmlsaXRpZXMuICovXG4gIHN1cHBvcnRzOiBpbXBvcnRfY29yZS56Lm9iamVjdCh7XG4gICAgLyoqIE1vZGVsIGNhbiBwcm9jZXNzIG1lZGlhIGFzIHBhcnQgb2YgdGhlIHByb21wdCAobXVsdGltb2RhbCBpbnB1dCkuICovXG4gICAgbWVkaWE6IGltcG9ydF9jb3JlLnouYm9vbGVhbigpLm9wdGlvbmFsKClcbiAgfSkub3B0aW9uYWwoKVxufSk7XG5mdW5jdGlvbiByZXJhbmtlcldpdGhNZXRhZGF0YShyZXJhbmtlcjIsIGNvbmZpZ1NjaGVtYSkge1xuICBjb25zdCB3aXRoTWV0YSA9IHJlcmFua2VyMjtcbiAgd2l0aE1ldGEuX19jb25maWdTY2hlbWEgPSBjb25maWdTY2hlbWE7XG4gIHJldHVybiB3aXRoTWV0YTtcbn1cbmZ1bmN0aW9uIGRlZmluZVJlcmFua2VyKHJlZ2lzdHJ5LCBvcHRpb25zLCBydW5uZXIpIHtcbiAgY29uc3QgYWN0ID0gcmVyYW5rZXIob3B0aW9ucywgcnVubmVyKTtcbiAgcmVnaXN0cnkucmVnaXN0ZXJBY3Rpb24oXCJyZXJhbmtlclwiLCBhY3QpO1xuICByZXR1cm4gYWN0O1xufVxuZnVuY3Rpb24gcmVyYW5rZXIob3B0aW9ucywgcnVubmVyKSB7XG4gIGNvbnN0IHJlcmFua2VyMiA9ICgwLCBpbXBvcnRfY29yZS5hY3Rpb24pKFxuICAgIHtcbiAgICAgIGFjdGlvblR5cGU6IFwicmVyYW5rZXJcIixcbiAgICAgIG5hbWU6IG9wdGlvbnMubmFtZSxcbiAgICAgIGlucHV0U2NoZW1hOiBvcHRpb25zLmNvbmZpZ1NjaGVtYSA/IFJlcmFua2VyUmVxdWVzdFNjaGVtYS5leHRlbmQoe1xuICAgICAgICBvcHRpb25zOiBvcHRpb25zLmNvbmZpZ1NjaGVtYS5vcHRpb25hbCgpXG4gICAgICB9KSA6IFJlcmFua2VyUmVxdWVzdFNjaGVtYSxcbiAgICAgIG91dHB1dFNjaGVtYTogUmVyYW5rZXJSZXNwb25zZVNjaGVtYSxcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIHR5cGU6IFwicmVyYW5rZXJcIixcbiAgICAgICAgaW5mbzogb3B0aW9ucy5pbmZvLFxuICAgICAgICByZXJhbmtlcjoge1xuICAgICAgICAgIGN1c3RvbU9wdGlvbnM6IG9wdGlvbnMuY29uZmlnU2NoZW1hID8gKDAsIGltcG9ydF9zY2hlbWEudG9Kc29uU2NoZW1hKSh7IHNjaGVtYTogb3B0aW9ucy5jb25maWdTY2hlbWEgfSkgOiB2b2lkIDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgKGkpID0+IHJ1bm5lcihcbiAgICAgIG5ldyBpbXBvcnRfcmV0cmlldmVyLkRvY3VtZW50KGkucXVlcnkpLFxuICAgICAgaS5kb2N1bWVudHMubWFwKChkKSA9PiBuZXcgaW1wb3J0X3JldHJpZXZlci5Eb2N1bWVudChkKSksXG4gICAgICBpLm9wdGlvbnNcbiAgICApXG4gICk7XG4gIGNvbnN0IHJ3bSA9IHJlcmFua2VyV2l0aE1ldGFkYXRhKFxuICAgIHJlcmFua2VyMixcbiAgICBvcHRpb25zLmNvbmZpZ1NjaGVtYVxuICApO1xuICByZXR1cm4gcndtO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVyYW5rKHJlZ2lzdHJ5LCBwYXJhbXMpIHtcbiAgbGV0IHJlcmFua2VyMjtcbiAgaWYgKHR5cGVvZiBwYXJhbXMucmVyYW5rZXIgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXJhbmtlcjIgPSBhd2FpdCByZWdpc3RyeS5sb29rdXBBY3Rpb24oYC9yZXJhbmtlci8ke3BhcmFtcy5yZXJhbmtlcn1gKTtcbiAgfSBlbHNlIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbXMucmVyYW5rZXIsIFwiaW5mb1wiKSkge1xuICAgIHJlcmFua2VyMiA9IGF3YWl0IHJlZ2lzdHJ5Lmxvb2t1cEFjdGlvbihgL3JlcmFua2VyLyR7cGFyYW1zLnJlcmFua2VyLm5hbWV9YCk7XG4gIH0gZWxzZSB7XG4gICAgcmVyYW5rZXIyID0gcGFyYW1zLnJlcmFua2VyO1xuICB9XG4gIGlmICghcmVyYW5rZXIyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHJlc29sdmUgdGhlIHJlcmFua2VyXCIpO1xuICB9XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVyYW5rZXIyKHtcbiAgICBxdWVyeTogdHlwZW9mIHBhcmFtcy5xdWVyeSA9PT0gXCJzdHJpbmdcIiA/IGltcG9ydF9yZXRyaWV2ZXIuRG9jdW1lbnQuZnJvbVRleHQocGFyYW1zLnF1ZXJ5KSA6IHBhcmFtcy5xdWVyeSxcbiAgICBkb2N1bWVudHM6IHBhcmFtcy5kb2N1bWVudHMsXG4gICAgb3B0aW9uczogcGFyYW1zLm9wdGlvbnNcbiAgfSk7XG4gIHJldHVybiByZXNwb25zZS5kb2N1bWVudHMubWFwKChkKSA9PiBuZXcgUmFua2VkRG9jdW1lbnQoZCkpO1xufVxuY29uc3QgQ29tbW9uUmVyYW5rZXJPcHRpb25zU2NoZW1hID0gaW1wb3J0X2NvcmUuei5vYmplY3Qoe1xuICBrOiBpbXBvcnRfY29yZS56Lm51bWJlcigpLmRlc2NyaWJlKFwiTnVtYmVyIG9mIGRvY3VtZW50cyB0byByZXJhbmtcIikub3B0aW9uYWwoKVxufSk7XG5mdW5jdGlvbiByZXJhbmtlclJlZihvcHRpb25zKSB7XG4gIHJldHVybiB7IC4uLm9wdGlvbnMgfTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBDb21tb25SZXJhbmtlck9wdGlvbnNTY2hlbWEsXG4gIFJhbmtlZERvY3VtZW50LFxuICBSYW5rZWREb2N1bWVudERhdGFTY2hlbWEsXG4gIFJhbmtlZERvY3VtZW50TWV0YWRhdGFTY2hlbWEsXG4gIFJlcmFua2VySW5mb1NjaGVtYSxcbiAgZGVmaW5lUmVyYW5rZXIsXG4gIHJlcmFuayxcbiAgcmVyYW5rZXIsXG4gIHJlcmFua2VyUmVmXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcmFua2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/reranker.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/resource.js":
/*!****************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/resource.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar resource_exports = {};\n__export(resource_exports, {\n  ResourceInputSchema: () => ResourceInputSchema,\n  ResourceOutputSchema: () => ResourceOutputSchema,\n  defineResource: () => defineResource,\n  dynamicResource: () => dynamicResource,\n  findMatchingResource: () => findMatchingResource,\n  isDynamicResourceAction: () => isDynamicResourceAction,\n  resource: () => resource\n});\nmodule.exports = __toCommonJS(resource_exports);\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nvar import_uri_templates = __toESM(__webpack_require__(/*! uri-templates */ \"(action-browser)/./node_modules/uri-templates/uri-templates.js\"));\nvar import_model_types = __webpack_require__(/*! ./model-types.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/model-types.js\");\nconst ResourceInputSchema = import_core.z.object({\n  uri: import_core.z.string()\n});\nconst ResourceOutputSchema = import_core.z.object({\n  content: import_core.z.array(import_model_types.PartSchema)\n});\nfunction defineResource(registry, opts, fn) {\n  const action2 = dynamicResource(opts, fn);\n  action2.matches = createMatcher(opts.uri, opts.template);\n  registry.registerAction(\"resource\", action2);\n  return action2;\n}\nasync function findMatchingResource(registry, input) {\n  for (const actKeys of Object.keys(await registry.listResolvableActions())) {\n    if (actKeys.startsWith(\"/resource/\")) {\n      const resource2 = await registry.lookupAction(actKeys);\n      if (resource2.matches(input)) {\n        return resource2;\n      }\n    }\n  }\n  return void 0;\n}\nfunction isDynamicResourceAction(t) {\n  return (0, import_core.isAction)(t) && !t.__registry;\n}\nfunction resource(opts, fn) {\n  return dynamicResource(opts, fn);\n}\nfunction dynamicResource(opts, fn) {\n  const uri = opts.uri ?? opts.template;\n  if (!uri) {\n    throw new import_core.GenkitError({\n      status: \"INVALID_ARGUMENT\",\n      message: `must specify either url or template options`\n    });\n  }\n  const matcher = createMatcher(opts.uri, opts.template);\n  const act = (0, import_core.action)(\n    {\n      actionType: \"resource\",\n      name: opts.name ?? uri,\n      description: opts.description,\n      inputSchema: ResourceInputSchema,\n      outputSchema: ResourceOutputSchema,\n      metadata: {\n        resource: {\n          uri: opts.uri,\n          template: opts.template\n        },\n        ...opts.metadata,\n        type: \"resource\",\n        dynamic: true\n      }\n    },\n    async (input, ctx) => {\n      const templateMatch = matcher(input);\n      if (!templateMatch) {\n        throw new import_core.GenkitError({\n          status: \"INVALID_ARGUMENT\",\n          message: `input ${input} did not match template ${uri}`\n        });\n      }\n      const parts = await fn(input, ctx);\n      parts.content.map((p) => {\n        if (!p.metadata) {\n          p.metadata = {};\n        }\n        if (p.metadata?.resource) {\n          if (!p.metadata.resource.parent) {\n            p.metadata.resource.parent = {\n              uri: input.uri\n            };\n            if (opts.template) {\n              p.metadata.resource.parent.template = opts.template;\n            }\n          }\n        } else {\n          p.metadata.resource = {\n            uri: input.uri\n          };\n          if (opts.template) {\n            p.metadata.resource.template = opts.template;\n          }\n        }\n        return p;\n      });\n      return parts;\n    }\n  );\n  act.matches = matcher;\n  act.attach = (_) => act;\n  return act;\n}\nfunction createMatcher(uriOpt, templateOpt) {\n  if (uriOpt) {\n    return (input) => input.uri === uriOpt;\n  }\n  if (templateOpt) {\n    const template = (0, import_uri_templates.default)(templateOpt);\n    return (input) => template.fromUri(input.uri) !== void 0;\n  }\n  throw new import_core.GenkitError({\n    status: \"INVALID_ARGUMENT\",\n    message: \"must specify either url or template options\"\n  });\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=resource.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9yZXNvdXJjZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSw4QkFBOEI7QUFDdkc7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxxRkFBaUI7QUFDM0MsbUNBQW1DLG1CQUFPLENBQUMscUZBQWU7QUFDMUQseUJBQXlCLG1CQUFPLENBQUMsMEZBQWtCO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTyx5QkFBeUIsSUFBSTtBQUNoRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLENBUUw7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcYWlcXGxpYlxccmVzb3VyY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgLy8gSWYgdGhlIGltcG9ydGVyIGlzIGluIG5vZGUgY29tcGF0aWJpbGl0eSBtb2RlIG9yIHRoaXMgaXMgbm90IGFuIEVTTVxuICAvLyBmaWxlIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIHRvIGEgQ29tbW9uSlMgZmlsZSB1c2luZyBhIEJhYmVsLVxuICAvLyBjb21wYXRpYmxlIHRyYW5zZm9ybSAoaS5lLiBcIl9fZXNNb2R1bGVcIiBoYXMgbm90IGJlZW4gc2V0KSwgdGhlbiBzZXRcbiAgLy8gXCJkZWZhdWx0XCIgdG8gdGhlIENvbW1vbkpTIFwibW9kdWxlLmV4cG9ydHNcIiBmb3Igbm9kZSBjb21wYXRpYmlsaXR5LlxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIHJlc291cmNlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHJlc291cmNlX2V4cG9ydHMsIHtcbiAgUmVzb3VyY2VJbnB1dFNjaGVtYTogKCkgPT4gUmVzb3VyY2VJbnB1dFNjaGVtYSxcbiAgUmVzb3VyY2VPdXRwdXRTY2hlbWE6ICgpID0+IFJlc291cmNlT3V0cHV0U2NoZW1hLFxuICBkZWZpbmVSZXNvdXJjZTogKCkgPT4gZGVmaW5lUmVzb3VyY2UsXG4gIGR5bmFtaWNSZXNvdXJjZTogKCkgPT4gZHluYW1pY1Jlc291cmNlLFxuICBmaW5kTWF0Y2hpbmdSZXNvdXJjZTogKCkgPT4gZmluZE1hdGNoaW5nUmVzb3VyY2UsXG4gIGlzRHluYW1pY1Jlc291cmNlQWN0aW9uOiAoKSA9PiBpc0R5bmFtaWNSZXNvdXJjZUFjdGlvbixcbiAgcmVzb3VyY2U6ICgpID0+IHJlc291cmNlXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHJlc291cmNlX2V4cG9ydHMpO1xudmFyIGltcG9ydF9jb3JlID0gcmVxdWlyZShcIkBnZW5raXQtYWkvY29yZVwiKTtcbnZhciBpbXBvcnRfdXJpX3RlbXBsYXRlcyA9IF9fdG9FU00ocmVxdWlyZShcInVyaS10ZW1wbGF0ZXNcIikpO1xudmFyIGltcG9ydF9tb2RlbF90eXBlcyA9IHJlcXVpcmUoXCIuL21vZGVsLXR5cGVzLmpzXCIpO1xuY29uc3QgUmVzb3VyY2VJbnB1dFNjaGVtYSA9IGltcG9ydF9jb3JlLnoub2JqZWN0KHtcbiAgdXJpOiBpbXBvcnRfY29yZS56LnN0cmluZygpXG59KTtcbmNvbnN0IFJlc291cmNlT3V0cHV0U2NoZW1hID0gaW1wb3J0X2NvcmUuei5vYmplY3Qoe1xuICBjb250ZW50OiBpbXBvcnRfY29yZS56LmFycmF5KGltcG9ydF9tb2RlbF90eXBlcy5QYXJ0U2NoZW1hKVxufSk7XG5mdW5jdGlvbiBkZWZpbmVSZXNvdXJjZShyZWdpc3RyeSwgb3B0cywgZm4pIHtcbiAgY29uc3QgYWN0aW9uMiA9IGR5bmFtaWNSZXNvdXJjZShvcHRzLCBmbik7XG4gIGFjdGlvbjIubWF0Y2hlcyA9IGNyZWF0ZU1hdGNoZXIob3B0cy51cmksIG9wdHMudGVtcGxhdGUpO1xuICByZWdpc3RyeS5yZWdpc3RlckFjdGlvbihcInJlc291cmNlXCIsIGFjdGlvbjIpO1xuICByZXR1cm4gYWN0aW9uMjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZpbmRNYXRjaGluZ1Jlc291cmNlKHJlZ2lzdHJ5LCBpbnB1dCkge1xuICBmb3IgKGNvbnN0IGFjdEtleXMgb2YgT2JqZWN0LmtleXMoYXdhaXQgcmVnaXN0cnkubGlzdFJlc29sdmFibGVBY3Rpb25zKCkpKSB7XG4gICAgaWYgKGFjdEtleXMuc3RhcnRzV2l0aChcIi9yZXNvdXJjZS9cIikpIHtcbiAgICAgIGNvbnN0IHJlc291cmNlMiA9IGF3YWl0IHJlZ2lzdHJ5Lmxvb2t1cEFjdGlvbihhY3RLZXlzKTtcbiAgICAgIGlmIChyZXNvdXJjZTIubWF0Y2hlcyhpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc291cmNlMjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGlzRHluYW1pY1Jlc291cmNlQWN0aW9uKHQpIHtcbiAgcmV0dXJuICgwLCBpbXBvcnRfY29yZS5pc0FjdGlvbikodCkgJiYgIXQuX19yZWdpc3RyeTtcbn1cbmZ1bmN0aW9uIHJlc291cmNlKG9wdHMsIGZuKSB7XG4gIHJldHVybiBkeW5hbWljUmVzb3VyY2Uob3B0cywgZm4pO1xufVxuZnVuY3Rpb24gZHluYW1pY1Jlc291cmNlKG9wdHMsIGZuKSB7XG4gIGNvbnN0IHVyaSA9IG9wdHMudXJpID8/IG9wdHMudGVtcGxhdGU7XG4gIGlmICghdXJpKSB7XG4gICAgdGhyb3cgbmV3IGltcG9ydF9jb3JlLkdlbmtpdEVycm9yKHtcbiAgICAgIHN0YXR1czogXCJJTlZBTElEX0FSR1VNRU5UXCIsXG4gICAgICBtZXNzYWdlOiBgbXVzdCBzcGVjaWZ5IGVpdGhlciB1cmwgb3IgdGVtcGxhdGUgb3B0aW9uc2BcbiAgICB9KTtcbiAgfVxuICBjb25zdCBtYXRjaGVyID0gY3JlYXRlTWF0Y2hlcihvcHRzLnVyaSwgb3B0cy50ZW1wbGF0ZSk7XG4gIGNvbnN0IGFjdCA9ICgwLCBpbXBvcnRfY29yZS5hY3Rpb24pKFxuICAgIHtcbiAgICAgIGFjdGlvblR5cGU6IFwicmVzb3VyY2VcIixcbiAgICAgIG5hbWU6IG9wdHMubmFtZSA/PyB1cmksXG4gICAgICBkZXNjcmlwdGlvbjogb3B0cy5kZXNjcmlwdGlvbixcbiAgICAgIGlucHV0U2NoZW1hOiBSZXNvdXJjZUlucHV0U2NoZW1hLFxuICAgICAgb3V0cHV0U2NoZW1hOiBSZXNvdXJjZU91dHB1dFNjaGVtYSxcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIHJlc291cmNlOiB7XG4gICAgICAgICAgdXJpOiBvcHRzLnVyaSxcbiAgICAgICAgICB0ZW1wbGF0ZTogb3B0cy50ZW1wbGF0ZVxuICAgICAgICB9LFxuICAgICAgICAuLi5vcHRzLm1ldGFkYXRhLFxuICAgICAgICB0eXBlOiBcInJlc291cmNlXCIsXG4gICAgICAgIGR5bmFtaWM6IHRydWVcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIChpbnB1dCwgY3R4KSA9PiB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZU1hdGNoID0gbWF0Y2hlcihpbnB1dCk7XG4gICAgICBpZiAoIXRlbXBsYXRlTWF0Y2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IGltcG9ydF9jb3JlLkdlbmtpdEVycm9yKHtcbiAgICAgICAgICBzdGF0dXM6IFwiSU5WQUxJRF9BUkdVTUVOVFwiLFxuICAgICAgICAgIG1lc3NhZ2U6IGBpbnB1dCAke2lucHV0fSBkaWQgbm90IG1hdGNoIHRlbXBsYXRlICR7dXJpfWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJ0cyA9IGF3YWl0IGZuKGlucHV0LCBjdHgpO1xuICAgICAgcGFydHMuY29udGVudC5tYXAoKHApID0+IHtcbiAgICAgICAgaWYgKCFwLm1ldGFkYXRhKSB7XG4gICAgICAgICAgcC5tZXRhZGF0YSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwLm1ldGFkYXRhPy5yZXNvdXJjZSkge1xuICAgICAgICAgIGlmICghcC5tZXRhZGF0YS5yZXNvdXJjZS5wYXJlbnQpIHtcbiAgICAgICAgICAgIHAubWV0YWRhdGEucmVzb3VyY2UucGFyZW50ID0ge1xuICAgICAgICAgICAgICB1cmk6IGlucHV0LnVyaVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChvcHRzLnRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgIHAubWV0YWRhdGEucmVzb3VyY2UucGFyZW50LnRlbXBsYXRlID0gb3B0cy50ZW1wbGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcC5tZXRhZGF0YS5yZXNvdXJjZSA9IHtcbiAgICAgICAgICAgIHVyaTogaW5wdXQudXJpXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAob3B0cy50ZW1wbGF0ZSkge1xuICAgICAgICAgICAgcC5tZXRhZGF0YS5yZXNvdXJjZS50ZW1wbGF0ZSA9IG9wdHMudGVtcGxhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGFydHM7XG4gICAgfVxuICApO1xuICBhY3QubWF0Y2hlcyA9IG1hdGNoZXI7XG4gIGFjdC5hdHRhY2ggPSAoXykgPT4gYWN0O1xuICByZXR1cm4gYWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlTWF0Y2hlcih1cmlPcHQsIHRlbXBsYXRlT3B0KSB7XG4gIGlmICh1cmlPcHQpIHtcbiAgICByZXR1cm4gKGlucHV0KSA9PiBpbnB1dC51cmkgPT09IHVyaU9wdDtcbiAgfVxuICBpZiAodGVtcGxhdGVPcHQpIHtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9ICgwLCBpbXBvcnRfdXJpX3RlbXBsYXRlcy5kZWZhdWx0KSh0ZW1wbGF0ZU9wdCk7XG4gICAgcmV0dXJuIChpbnB1dCkgPT4gdGVtcGxhdGUuZnJvbVVyaShpbnB1dC51cmkpICE9PSB2b2lkIDA7XG4gIH1cbiAgdGhyb3cgbmV3IGltcG9ydF9jb3JlLkdlbmtpdEVycm9yKHtcbiAgICBzdGF0dXM6IFwiSU5WQUxJRF9BUkdVTUVOVFwiLFxuICAgIG1lc3NhZ2U6IFwibXVzdCBzcGVjaWZ5IGVpdGhlciB1cmwgb3IgdGVtcGxhdGUgb3B0aW9uc1wiXG4gIH0pO1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIFJlc291cmNlSW5wdXRTY2hlbWEsXG4gIFJlc291cmNlT3V0cHV0U2NoZW1hLFxuICBkZWZpbmVSZXNvdXJjZSxcbiAgZHluYW1pY1Jlc291cmNlLFxuICBmaW5kTWF0Y2hpbmdSZXNvdXJjZSxcbiAgaXNEeW5hbWljUmVzb3VyY2VBY3Rpb24sXG4gIHJlc291cmNlXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc291cmNlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/resource.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/retriever.js":
/*!*****************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/retriever.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar retriever_exports = {};\n__export(retriever_exports, {\n  CommonRetrieverOptionsSchema: () => CommonRetrieverOptionsSchema,\n  Document: () => import_document2.Document,\n  DocumentDataSchema: () => import_document2.DocumentDataSchema,\n  IndexerInfoSchema: () => IndexerInfoSchema,\n  RetrieverInfoSchema: () => RetrieverInfoSchema,\n  defineIndexer: () => defineIndexer,\n  defineRetriever: () => defineRetriever,\n  defineSimpleRetriever: () => defineSimpleRetriever,\n  index: () => index,\n  indexer: () => indexer,\n  indexerRef: () => indexerRef,\n  retrieve: () => retrieve,\n  retriever: () => retriever,\n  retrieverRef: () => retrieverRef\n});\nmodule.exports = __toCommonJS(retriever_exports);\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nvar import_schema = __webpack_require__(/*! @genkit-ai/core/schema */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/schema.js\");\nvar import_document = __webpack_require__(/*! ./document.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/document.js\");\nvar import_document2 = __webpack_require__(/*! ./document.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/document.js\");\nconst RetrieverRequestSchema = import_core.z.object({\n  query: import_document.DocumentDataSchema,\n  options: import_core.z.any().optional()\n});\nconst RetrieverResponseSchema = import_core.z.object({\n  documents: import_core.z.array(import_document.DocumentDataSchema)\n  // TODO: stats, etc.\n});\nconst IndexerRequestSchema = import_core.z.object({\n  documents: import_core.z.array(import_document.DocumentDataSchema),\n  options: import_core.z.any().optional()\n});\nconst RetrieverInfoSchema = import_core.z.object({\n  label: import_core.z.string().optional(),\n  /** Supported model capabilities. */\n  supports: import_core.z.object({\n    /** Model can process media as part of the prompt (multimodal input). */\n    media: import_core.z.boolean().optional()\n  }).optional()\n});\nfunction retrieverWithMetadata(retriever2, configSchema) {\n  const withMeta = retriever2;\n  withMeta.__configSchema = configSchema;\n  return withMeta;\n}\nfunction indexerWithMetadata(indexer2, configSchema) {\n  const withMeta = indexer2;\n  withMeta.__configSchema = configSchema;\n  return withMeta;\n}\nfunction defineRetriever(registry, options, runner) {\n  const r = retriever(options, runner);\n  registry.registerAction(\"retriever\", r);\n  return r;\n}\nfunction retriever(options, runner) {\n  const retriever2 = (0, import_core.action)(\n    {\n      actionType: \"retriever\",\n      name: options.name,\n      inputSchema: options.configSchema ? RetrieverRequestSchema.extend({\n        options: options.configSchema.optional()\n      }) : RetrieverRequestSchema,\n      outputSchema: RetrieverResponseSchema,\n      metadata: {\n        type: \"retriever\",\n        info: options.info,\n        retriever: {\n          customOptions: options.configSchema ? (0, import_schema.toJsonSchema)({ schema: options.configSchema }) : void 0\n        }\n      }\n    },\n    (i) => runner(new import_document.Document(i.query), i.options)\n  );\n  const rwm = retrieverWithMetadata(\n    retriever2,\n    options.configSchema\n  );\n  return rwm;\n}\nfunction defineIndexer(registry, options, runner) {\n  const r = indexer(options, runner);\n  registry.registerAction(\"indexer\", r);\n  return r;\n}\nfunction indexer(options, runner) {\n  const indexer2 = (0, import_core.action)(\n    {\n      actionType: \"indexer\",\n      name: options.name,\n      inputSchema: options.configSchema ? IndexerRequestSchema.extend({\n        options: options.configSchema.optional()\n      }) : IndexerRequestSchema,\n      outputSchema: import_core.z.void(),\n      metadata: {\n        type: \"indexer\",\n        embedderInfo: options.embedderInfo,\n        indexer: {\n          customOptions: options.configSchema ? (0, import_schema.toJsonSchema)({ schema: options.configSchema }) : void 0\n        }\n      }\n    },\n    (i) => runner(\n      i.documents.map((dd) => new import_document.Document(dd)),\n      i.options\n    )\n  );\n  const iwm = indexerWithMetadata(\n    indexer2,\n    options.configSchema\n  );\n  return iwm;\n}\nasync function retrieve(registry, params) {\n  let retriever2;\n  if (typeof params.retriever === \"string\") {\n    retriever2 = await registry.lookupAction(`/retriever/${params.retriever}`);\n  } else if (Object.hasOwnProperty.call(params.retriever, \"info\")) {\n    retriever2 = await registry.lookupAction(\n      `/retriever/${params.retriever.name}`\n    );\n  } else {\n    retriever2 = params.retriever;\n  }\n  if (!retriever2) {\n    throw new Error(\"Unable to resolve the retriever\");\n  }\n  const response = await retriever2({\n    query: typeof params.query === \"string\" ? import_document.Document.fromText(params.query) : params.query,\n    options: params.options\n  });\n  return response.documents.map((d) => new import_document.Document(d));\n}\nasync function index(registry, params) {\n  let indexer2;\n  if (typeof params.indexer === \"string\") {\n    indexer2 = await registry.lookupAction(`/indexer/${params.indexer}`);\n  } else if (Object.hasOwnProperty.call(params.indexer, \"info\")) {\n    indexer2 = await registry.lookupAction(`/indexer/${params.indexer.name}`);\n  } else {\n    indexer2 = params.indexer;\n  }\n  if (!indexer2) {\n    throw new Error(\"Unable to utilize the provided indexer\");\n  }\n  return await indexer2({\n    documents: params.documents,\n    options: params.options\n  });\n}\nconst CommonRetrieverOptionsSchema = import_core.z.object({\n  k: import_core.z.number().describe(\"Number of documents to retrieve\").optional()\n});\nfunction retrieverRef(options) {\n  return { ...options };\n}\nconst IndexerInfoSchema = RetrieverInfoSchema;\nfunction indexerRef(options) {\n  return { ...options };\n}\nfunction itemToDocument(item, options) {\n  if (!item)\n    throw new import_core.GenkitError({\n      status: \"INVALID_ARGUMENT\",\n      message: `Items returned from simple retriever must be non-null.`\n    });\n  if (typeof item === \"string\") return import_document.Document.fromText(item);\n  if (typeof options.content === \"function\") {\n    const transformed = options.content(item);\n    return typeof transformed === \"string\" ? import_document.Document.fromText(transformed) : new import_document.Document({ content: transformed });\n  }\n  if (typeof options.content === \"string\" && typeof item === \"object\")\n    return import_document.Document.fromText(item[options.content]);\n  throw new import_core.GenkitError({\n    status: \"INVALID_ARGUMENT\",\n    message: `Cannot convert item to document without content option. Item: ${JSON.stringify(item)}`\n  });\n}\nfunction itemToMetadata(item, options) {\n  if (typeof item === \"string\") return void 0;\n  if (Array.isArray(options.metadata) && typeof item === \"object\") {\n    const out = {};\n    options.metadata.forEach((key) => out[key] = item[key]);\n    return out;\n  }\n  if (typeof options.metadata === \"function\") return options.metadata(item);\n  if (!options.metadata && typeof item === \"object\") {\n    const out = { ...item };\n    if (typeof options.content === \"string\") delete out[options.content];\n    return out;\n  }\n  throw new import_core.GenkitError({\n    status: \"INVALID_ARGUMENT\",\n    message: `Unable to extract metadata from item with supplied options. Item: ${JSON.stringify(item)}`\n  });\n}\nfunction defineSimpleRetriever(registry, options, handler) {\n  return defineRetriever(\n    registry,\n    {\n      name: options.name,\n      configSchema: options.configSchema\n    },\n    async (query, config) => {\n      const result = await handler(query, config);\n      return {\n        documents: result.map((item) => {\n          const doc = itemToDocument(item, options);\n          if (typeof item !== \"string\")\n            doc.metadata = itemToMetadata(item, options);\n          return doc;\n        })\n      };\n    }\n  );\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=retriever.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9yZXRyaWV2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHFGQUFpQjtBQUMzQyxvQkFBb0IsbUJBQU8sQ0FBQyw2RkFBd0I7QUFDcEQsc0JBQXNCLG1CQUFPLENBQUMsb0ZBQWU7QUFDN0MsdUJBQXVCLG1CQUFPLENBQUMsb0ZBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLDhCQUE4QjtBQUNoSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRiw4QkFBOEI7QUFDaEg7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGlCQUFpQjtBQUM1RSxJQUFJO0FBQ0o7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxlQUFlO0FBQ3RFLElBQUk7QUFDSix1REFBdUQsb0JBQW9CO0FBQzNFLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDZIQUE2SCxzQkFBc0I7QUFDbko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxxQkFBcUI7QUFDbkcsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YscUJBQXFCO0FBQ3ZHLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBZUw7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcYWlcXGxpYlxccmV0cmlldmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciByZXRyaWV2ZXJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocmV0cmlldmVyX2V4cG9ydHMsIHtcbiAgQ29tbW9uUmV0cmlldmVyT3B0aW9uc1NjaGVtYTogKCkgPT4gQ29tbW9uUmV0cmlldmVyT3B0aW9uc1NjaGVtYSxcbiAgRG9jdW1lbnQ6ICgpID0+IGltcG9ydF9kb2N1bWVudDIuRG9jdW1lbnQsXG4gIERvY3VtZW50RGF0YVNjaGVtYTogKCkgPT4gaW1wb3J0X2RvY3VtZW50Mi5Eb2N1bWVudERhdGFTY2hlbWEsXG4gIEluZGV4ZXJJbmZvU2NoZW1hOiAoKSA9PiBJbmRleGVySW5mb1NjaGVtYSxcbiAgUmV0cmlldmVySW5mb1NjaGVtYTogKCkgPT4gUmV0cmlldmVySW5mb1NjaGVtYSxcbiAgZGVmaW5lSW5kZXhlcjogKCkgPT4gZGVmaW5lSW5kZXhlcixcbiAgZGVmaW5lUmV0cmlldmVyOiAoKSA9PiBkZWZpbmVSZXRyaWV2ZXIsXG4gIGRlZmluZVNpbXBsZVJldHJpZXZlcjogKCkgPT4gZGVmaW5lU2ltcGxlUmV0cmlldmVyLFxuICBpbmRleDogKCkgPT4gaW5kZXgsXG4gIGluZGV4ZXI6ICgpID0+IGluZGV4ZXIsXG4gIGluZGV4ZXJSZWY6ICgpID0+IGluZGV4ZXJSZWYsXG4gIHJldHJpZXZlOiAoKSA9PiByZXRyaWV2ZSxcbiAgcmV0cmlldmVyOiAoKSA9PiByZXRyaWV2ZXIsXG4gIHJldHJpZXZlclJlZjogKCkgPT4gcmV0cmlldmVyUmVmXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHJldHJpZXZlcl9leHBvcnRzKTtcbnZhciBpbXBvcnRfY29yZSA9IHJlcXVpcmUoXCJAZ2Vua2l0LWFpL2NvcmVcIik7XG52YXIgaW1wb3J0X3NjaGVtYSA9IHJlcXVpcmUoXCJAZ2Vua2l0LWFpL2NvcmUvc2NoZW1hXCIpO1xudmFyIGltcG9ydF9kb2N1bWVudCA9IHJlcXVpcmUoXCIuL2RvY3VtZW50LmpzXCIpO1xudmFyIGltcG9ydF9kb2N1bWVudDIgPSByZXF1aXJlKFwiLi9kb2N1bWVudC5qc1wiKTtcbmNvbnN0IFJldHJpZXZlclJlcXVlc3RTY2hlbWEgPSBpbXBvcnRfY29yZS56Lm9iamVjdCh7XG4gIHF1ZXJ5OiBpbXBvcnRfZG9jdW1lbnQuRG9jdW1lbnREYXRhU2NoZW1hLFxuICBvcHRpb25zOiBpbXBvcnRfY29yZS56LmFueSgpLm9wdGlvbmFsKClcbn0pO1xuY29uc3QgUmV0cmlldmVyUmVzcG9uc2VTY2hlbWEgPSBpbXBvcnRfY29yZS56Lm9iamVjdCh7XG4gIGRvY3VtZW50czogaW1wb3J0X2NvcmUuei5hcnJheShpbXBvcnRfZG9jdW1lbnQuRG9jdW1lbnREYXRhU2NoZW1hKVxuICAvLyBUT0RPOiBzdGF0cywgZXRjLlxufSk7XG5jb25zdCBJbmRleGVyUmVxdWVzdFNjaGVtYSA9IGltcG9ydF9jb3JlLnoub2JqZWN0KHtcbiAgZG9jdW1lbnRzOiBpbXBvcnRfY29yZS56LmFycmF5KGltcG9ydF9kb2N1bWVudC5Eb2N1bWVudERhdGFTY2hlbWEpLFxuICBvcHRpb25zOiBpbXBvcnRfY29yZS56LmFueSgpLm9wdGlvbmFsKClcbn0pO1xuY29uc3QgUmV0cmlldmVySW5mb1NjaGVtYSA9IGltcG9ydF9jb3JlLnoub2JqZWN0KHtcbiAgbGFiZWw6IGltcG9ydF9jb3JlLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgLyoqIFN1cHBvcnRlZCBtb2RlbCBjYXBhYmlsaXRpZXMuICovXG4gIHN1cHBvcnRzOiBpbXBvcnRfY29yZS56Lm9iamVjdCh7XG4gICAgLyoqIE1vZGVsIGNhbiBwcm9jZXNzIG1lZGlhIGFzIHBhcnQgb2YgdGhlIHByb21wdCAobXVsdGltb2RhbCBpbnB1dCkuICovXG4gICAgbWVkaWE6IGltcG9ydF9jb3JlLnouYm9vbGVhbigpLm9wdGlvbmFsKClcbiAgfSkub3B0aW9uYWwoKVxufSk7XG5mdW5jdGlvbiByZXRyaWV2ZXJXaXRoTWV0YWRhdGEocmV0cmlldmVyMiwgY29uZmlnU2NoZW1hKSB7XG4gIGNvbnN0IHdpdGhNZXRhID0gcmV0cmlldmVyMjtcbiAgd2l0aE1ldGEuX19jb25maWdTY2hlbWEgPSBjb25maWdTY2hlbWE7XG4gIHJldHVybiB3aXRoTWV0YTtcbn1cbmZ1bmN0aW9uIGluZGV4ZXJXaXRoTWV0YWRhdGEoaW5kZXhlcjIsIGNvbmZpZ1NjaGVtYSkge1xuICBjb25zdCB3aXRoTWV0YSA9IGluZGV4ZXIyO1xuICB3aXRoTWV0YS5fX2NvbmZpZ1NjaGVtYSA9IGNvbmZpZ1NjaGVtYTtcbiAgcmV0dXJuIHdpdGhNZXRhO1xufVxuZnVuY3Rpb24gZGVmaW5lUmV0cmlldmVyKHJlZ2lzdHJ5LCBvcHRpb25zLCBydW5uZXIpIHtcbiAgY29uc3QgciA9IHJldHJpZXZlcihvcHRpb25zLCBydW5uZXIpO1xuICByZWdpc3RyeS5yZWdpc3RlckFjdGlvbihcInJldHJpZXZlclwiLCByKTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiByZXRyaWV2ZXIob3B0aW9ucywgcnVubmVyKSB7XG4gIGNvbnN0IHJldHJpZXZlcjIgPSAoMCwgaW1wb3J0X2NvcmUuYWN0aW9uKShcbiAgICB7XG4gICAgICBhY3Rpb25UeXBlOiBcInJldHJpZXZlclwiLFxuICAgICAgbmFtZTogb3B0aW9ucy5uYW1lLFxuICAgICAgaW5wdXRTY2hlbWE6IG9wdGlvbnMuY29uZmlnU2NoZW1hID8gUmV0cmlldmVyUmVxdWVzdFNjaGVtYS5leHRlbmQoe1xuICAgICAgICBvcHRpb25zOiBvcHRpb25zLmNvbmZpZ1NjaGVtYS5vcHRpb25hbCgpXG4gICAgICB9KSA6IFJldHJpZXZlclJlcXVlc3RTY2hlbWEsXG4gICAgICBvdXRwdXRTY2hlbWE6IFJldHJpZXZlclJlc3BvbnNlU2NoZW1hLFxuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgdHlwZTogXCJyZXRyaWV2ZXJcIixcbiAgICAgICAgaW5mbzogb3B0aW9ucy5pbmZvLFxuICAgICAgICByZXRyaWV2ZXI6IHtcbiAgICAgICAgICBjdXN0b21PcHRpb25zOiBvcHRpb25zLmNvbmZpZ1NjaGVtYSA/ICgwLCBpbXBvcnRfc2NoZW1hLnRvSnNvblNjaGVtYSkoeyBzY2hlbWE6IG9wdGlvbnMuY29uZmlnU2NoZW1hIH0pIDogdm9pZCAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIChpKSA9PiBydW5uZXIobmV3IGltcG9ydF9kb2N1bWVudC5Eb2N1bWVudChpLnF1ZXJ5KSwgaS5vcHRpb25zKVxuICApO1xuICBjb25zdCByd20gPSByZXRyaWV2ZXJXaXRoTWV0YWRhdGEoXG4gICAgcmV0cmlldmVyMixcbiAgICBvcHRpb25zLmNvbmZpZ1NjaGVtYVxuICApO1xuICByZXR1cm4gcndtO1xufVxuZnVuY3Rpb24gZGVmaW5lSW5kZXhlcihyZWdpc3RyeSwgb3B0aW9ucywgcnVubmVyKSB7XG4gIGNvbnN0IHIgPSBpbmRleGVyKG9wdGlvbnMsIHJ1bm5lcik7XG4gIHJlZ2lzdHJ5LnJlZ2lzdGVyQWN0aW9uKFwiaW5kZXhlclwiLCByKTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBpbmRleGVyKG9wdGlvbnMsIHJ1bm5lcikge1xuICBjb25zdCBpbmRleGVyMiA9ICgwLCBpbXBvcnRfY29yZS5hY3Rpb24pKFxuICAgIHtcbiAgICAgIGFjdGlvblR5cGU6IFwiaW5kZXhlclwiLFxuICAgICAgbmFtZTogb3B0aW9ucy5uYW1lLFxuICAgICAgaW5wdXRTY2hlbWE6IG9wdGlvbnMuY29uZmlnU2NoZW1hID8gSW5kZXhlclJlcXVlc3RTY2hlbWEuZXh0ZW5kKHtcbiAgICAgICAgb3B0aW9uczogb3B0aW9ucy5jb25maWdTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgfSkgOiBJbmRleGVyUmVxdWVzdFNjaGVtYSxcbiAgICAgIG91dHB1dFNjaGVtYTogaW1wb3J0X2NvcmUuei52b2lkKCksXG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICB0eXBlOiBcImluZGV4ZXJcIixcbiAgICAgICAgZW1iZWRkZXJJbmZvOiBvcHRpb25zLmVtYmVkZGVySW5mbyxcbiAgICAgICAgaW5kZXhlcjoge1xuICAgICAgICAgIGN1c3RvbU9wdGlvbnM6IG9wdGlvbnMuY29uZmlnU2NoZW1hID8gKDAsIGltcG9ydF9zY2hlbWEudG9Kc29uU2NoZW1hKSh7IHNjaGVtYTogb3B0aW9ucy5jb25maWdTY2hlbWEgfSkgOiB2b2lkIDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgKGkpID0+IHJ1bm5lcihcbiAgICAgIGkuZG9jdW1lbnRzLm1hcCgoZGQpID0+IG5ldyBpbXBvcnRfZG9jdW1lbnQuRG9jdW1lbnQoZGQpKSxcbiAgICAgIGkub3B0aW9uc1xuICAgIClcbiAgKTtcbiAgY29uc3QgaXdtID0gaW5kZXhlcldpdGhNZXRhZGF0YShcbiAgICBpbmRleGVyMixcbiAgICBvcHRpb25zLmNvbmZpZ1NjaGVtYVxuICApO1xuICByZXR1cm4gaXdtO1xufVxuYXN5bmMgZnVuY3Rpb24gcmV0cmlldmUocmVnaXN0cnksIHBhcmFtcykge1xuICBsZXQgcmV0cmlldmVyMjtcbiAgaWYgKHR5cGVvZiBwYXJhbXMucmV0cmlldmVyID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0cmlldmVyMiA9IGF3YWl0IHJlZ2lzdHJ5Lmxvb2t1cEFjdGlvbihgL3JldHJpZXZlci8ke3BhcmFtcy5yZXRyaWV2ZXJ9YCk7XG4gIH0gZWxzZSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocGFyYW1zLnJldHJpZXZlciwgXCJpbmZvXCIpKSB7XG4gICAgcmV0cmlldmVyMiA9IGF3YWl0IHJlZ2lzdHJ5Lmxvb2t1cEFjdGlvbihcbiAgICAgIGAvcmV0cmlldmVyLyR7cGFyYW1zLnJldHJpZXZlci5uYW1lfWBcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHJpZXZlcjIgPSBwYXJhbXMucmV0cmlldmVyO1xuICB9XG4gIGlmICghcmV0cmlldmVyMikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byByZXNvbHZlIHRoZSByZXRyaWV2ZXJcIik7XG4gIH1cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXRyaWV2ZXIyKHtcbiAgICBxdWVyeTogdHlwZW9mIHBhcmFtcy5xdWVyeSA9PT0gXCJzdHJpbmdcIiA/IGltcG9ydF9kb2N1bWVudC5Eb2N1bWVudC5mcm9tVGV4dChwYXJhbXMucXVlcnkpIDogcGFyYW1zLnF1ZXJ5LFxuICAgIG9wdGlvbnM6IHBhcmFtcy5vcHRpb25zXG4gIH0pO1xuICByZXR1cm4gcmVzcG9uc2UuZG9jdW1lbnRzLm1hcCgoZCkgPT4gbmV3IGltcG9ydF9kb2N1bWVudC5Eb2N1bWVudChkKSk7XG59XG5hc3luYyBmdW5jdGlvbiBpbmRleChyZWdpc3RyeSwgcGFyYW1zKSB7XG4gIGxldCBpbmRleGVyMjtcbiAgaWYgKHR5cGVvZiBwYXJhbXMuaW5kZXhlciA9PT0gXCJzdHJpbmdcIikge1xuICAgIGluZGV4ZXIyID0gYXdhaXQgcmVnaXN0cnkubG9va3VwQWN0aW9uKGAvaW5kZXhlci8ke3BhcmFtcy5pbmRleGVyfWApO1xuICB9IGVsc2UgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtcy5pbmRleGVyLCBcImluZm9cIikpIHtcbiAgICBpbmRleGVyMiA9IGF3YWl0IHJlZ2lzdHJ5Lmxvb2t1cEFjdGlvbihgL2luZGV4ZXIvJHtwYXJhbXMuaW5kZXhlci5uYW1lfWApO1xuICB9IGVsc2Uge1xuICAgIGluZGV4ZXIyID0gcGFyYW1zLmluZGV4ZXI7XG4gIH1cbiAgaWYgKCFpbmRleGVyMikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byB1dGlsaXplIHRoZSBwcm92aWRlZCBpbmRleGVyXCIpO1xuICB9XG4gIHJldHVybiBhd2FpdCBpbmRleGVyMih7XG4gICAgZG9jdW1lbnRzOiBwYXJhbXMuZG9jdW1lbnRzLFxuICAgIG9wdGlvbnM6IHBhcmFtcy5vcHRpb25zXG4gIH0pO1xufVxuY29uc3QgQ29tbW9uUmV0cmlldmVyT3B0aW9uc1NjaGVtYSA9IGltcG9ydF9jb3JlLnoub2JqZWN0KHtcbiAgazogaW1wb3J0X2NvcmUuei5udW1iZXIoKS5kZXNjcmliZShcIk51bWJlciBvZiBkb2N1bWVudHMgdG8gcmV0cmlldmVcIikub3B0aW9uYWwoKVxufSk7XG5mdW5jdGlvbiByZXRyaWV2ZXJSZWYob3B0aW9ucykge1xuICByZXR1cm4geyAuLi5vcHRpb25zIH07XG59XG5jb25zdCBJbmRleGVySW5mb1NjaGVtYSA9IFJldHJpZXZlckluZm9TY2hlbWE7XG5mdW5jdGlvbiBpbmRleGVyUmVmKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHsgLi4ub3B0aW9ucyB9O1xufVxuZnVuY3Rpb24gaXRlbVRvRG9jdW1lbnQoaXRlbSwgb3B0aW9ucykge1xuICBpZiAoIWl0ZW0pXG4gICAgdGhyb3cgbmV3IGltcG9ydF9jb3JlLkdlbmtpdEVycm9yKHtcbiAgICAgIHN0YXR1czogXCJJTlZBTElEX0FSR1VNRU5UXCIsXG4gICAgICBtZXNzYWdlOiBgSXRlbXMgcmV0dXJuZWQgZnJvbSBzaW1wbGUgcmV0cmlldmVyIG11c3QgYmUgbm9uLW51bGwuYFxuICAgIH0pO1xuICBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpIHJldHVybiBpbXBvcnRfZG9jdW1lbnQuRG9jdW1lbnQuZnJvbVRleHQoaXRlbSk7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5jb250ZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IG9wdGlvbnMuY29udGVudChpdGVtKTtcbiAgICByZXR1cm4gdHlwZW9mIHRyYW5zZm9ybWVkID09PSBcInN0cmluZ1wiID8gaW1wb3J0X2RvY3VtZW50LkRvY3VtZW50LmZyb21UZXh0KHRyYW5zZm9ybWVkKSA6IG5ldyBpbXBvcnRfZG9jdW1lbnQuRG9jdW1lbnQoeyBjb250ZW50OiB0cmFuc2Zvcm1lZCB9KTtcbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMuY29udGVudCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgaXRlbSA9PT0gXCJvYmplY3RcIilcbiAgICByZXR1cm4gaW1wb3J0X2RvY3VtZW50LkRvY3VtZW50LmZyb21UZXh0KGl0ZW1bb3B0aW9ucy5jb250ZW50XSk7XG4gIHRocm93IG5ldyBpbXBvcnRfY29yZS5HZW5raXRFcnJvcih7XG4gICAgc3RhdHVzOiBcIklOVkFMSURfQVJHVU1FTlRcIixcbiAgICBtZXNzYWdlOiBgQ2Fubm90IGNvbnZlcnQgaXRlbSB0byBkb2N1bWVudCB3aXRob3V0IGNvbnRlbnQgb3B0aW9uLiBJdGVtOiAke0pTT04uc3RyaW5naWZ5KGl0ZW0pfWBcbiAgfSk7XG59XG5mdW5jdGlvbiBpdGVtVG9NZXRhZGF0YShpdGVtLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHZvaWQgMDtcbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5tZXRhZGF0YSkgJiYgdHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zdCBvdXQgPSB7fTtcbiAgICBvcHRpb25zLm1ldGFkYXRhLmZvckVhY2goKGtleSkgPT4gb3V0W2tleV0gPSBpdGVtW2tleV0pO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zLm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBvcHRpb25zLm1ldGFkYXRhKGl0ZW0pO1xuICBpZiAoIW9wdGlvbnMubWV0YWRhdGEgJiYgdHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zdCBvdXQgPSB7IC4uLml0ZW0gfTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29udGVudCA9PT0gXCJzdHJpbmdcIikgZGVsZXRlIG91dFtvcHRpb25zLmNvbnRlbnRdO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgdGhyb3cgbmV3IGltcG9ydF9jb3JlLkdlbmtpdEVycm9yKHtcbiAgICBzdGF0dXM6IFwiSU5WQUxJRF9BUkdVTUVOVFwiLFxuICAgIG1lc3NhZ2U6IGBVbmFibGUgdG8gZXh0cmFjdCBtZXRhZGF0YSBmcm9tIGl0ZW0gd2l0aCBzdXBwbGllZCBvcHRpb25zLiBJdGVtOiAke0pTT04uc3RyaW5naWZ5KGl0ZW0pfWBcbiAgfSk7XG59XG5mdW5jdGlvbiBkZWZpbmVTaW1wbGVSZXRyaWV2ZXIocmVnaXN0cnksIG9wdGlvbnMsIGhhbmRsZXIpIHtcbiAgcmV0dXJuIGRlZmluZVJldHJpZXZlcihcbiAgICByZWdpc3RyeSxcbiAgICB7XG4gICAgICBuYW1lOiBvcHRpb25zLm5hbWUsXG4gICAgICBjb25maWdTY2hlbWE6IG9wdGlvbnMuY29uZmlnU2NoZW1hXG4gICAgfSxcbiAgICBhc3luYyAocXVlcnksIGNvbmZpZykgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaGFuZGxlcihxdWVyeSwgY29uZmlnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvY3VtZW50czogcmVzdWx0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRvYyA9IGl0ZW1Ub0RvY3VtZW50KGl0ZW0sIG9wdGlvbnMpO1xuICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGRvYy5tZXRhZGF0YSA9IGl0ZW1Ub01ldGFkYXRhKGl0ZW0sIG9wdGlvbnMpO1xuICAgICAgICAgIHJldHVybiBkb2M7XG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgKTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBDb21tb25SZXRyaWV2ZXJPcHRpb25zU2NoZW1hLFxuICBEb2N1bWVudCxcbiAgRG9jdW1lbnREYXRhU2NoZW1hLFxuICBJbmRleGVySW5mb1NjaGVtYSxcbiAgUmV0cmlldmVySW5mb1NjaGVtYSxcbiAgZGVmaW5lSW5kZXhlcixcbiAgZGVmaW5lUmV0cmlldmVyLFxuICBkZWZpbmVTaW1wbGVSZXRyaWV2ZXIsXG4gIGluZGV4LFxuICBpbmRleGVyLFxuICBpbmRleGVyUmVmLFxuICByZXRyaWV2ZSxcbiAgcmV0cmlldmVyLFxuICByZXRyaWV2ZXJSZWZcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV0cmlldmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/retriever.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/session.js":
/*!***************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/session.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar session_exports = {};\n__export(session_exports, {\n  Session: () => Session,\n  SessionError: () => SessionError,\n  getCurrentSession: () => getCurrentSession,\n  inMemorySessionStore: () => inMemorySessionStore,\n  runWithSession: () => runWithSession\n});\nmodule.exports = __toCommonJS(session_exports);\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nvar import_uuid = __webpack_require__(/*! uuid */ \"(action-browser)/./node_modules/uuid/dist/esm-node/index.js\");\nvar import_chat = __webpack_require__(/*! ./chat.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/chat.js\");\nvar import_index = __webpack_require__(/*! ./index.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/index.js\");\nclass Session {\n  constructor(registry, options) {\n    this.registry = registry;\n    this.id = options?.id ?? (0, import_uuid.v4)();\n    this.sessionData = options?.sessionData ?? {\n      id: this.id\n    };\n    if (!this.sessionData) {\n      this.sessionData = { id: this.id };\n    }\n    if (!this.sessionData.threads) {\n      this.sessionData.threads = {};\n    }\n    this.store = options?.store ?? new InMemorySessionStore();\n  }\n  id;\n  sessionData;\n  store;\n  get state() {\n    return this.sessionData.state;\n  }\n  /**\n   * Update session state data.\n   */\n  async updateState(data) {\n    let sessionData = this.sessionData;\n    if (!sessionData) {\n      sessionData = {};\n    }\n    sessionData.state = data;\n    this.sessionData = sessionData;\n    await this.store.save(this.id, sessionData);\n  }\n  /**\n   * Update messages for a given thread.\n   */\n  async updateMessages(thread, messages) {\n    let sessionData = this.sessionData;\n    if (!sessionData) {\n      sessionData = {};\n    }\n    if (!sessionData.threads) {\n      sessionData.threads = {};\n    }\n    sessionData.threads[thread] = messages.map(\n      (m) => m.toJSON ? m.toJSON() : m\n    );\n    this.sessionData = sessionData;\n    await this.store.save(this.id, sessionData);\n  }\n  chat(optionsOrPreambleOrThreadName, maybeOptionsOrPreamble, maybeOptions) {\n    return runWithSession(this.registry, this, () => {\n      let options;\n      let threadName = import_chat.MAIN_THREAD;\n      let preamble;\n      if (optionsOrPreambleOrThreadName) {\n        if (typeof optionsOrPreambleOrThreadName === \"string\") {\n          threadName = optionsOrPreambleOrThreadName;\n        } else if ((0, import_index.isExecutablePrompt)(optionsOrPreambleOrThreadName)) {\n          preamble = optionsOrPreambleOrThreadName;\n        } else {\n          options = optionsOrPreambleOrThreadName;\n        }\n      }\n      if (maybeOptionsOrPreamble) {\n        if ((0, import_index.isExecutablePrompt)(maybeOptionsOrPreamble)) {\n          preamble = maybeOptionsOrPreamble;\n        } else {\n          options = maybeOptionsOrPreamble;\n        }\n      }\n      if (maybeOptions) {\n        options = maybeOptions;\n      }\n      let requestBase;\n      if (preamble) {\n        const renderOptions = options;\n        requestBase = preamble.render(renderOptions?.input, renderOptions).then((rb) => {\n          return {\n            ...rb,\n            messages: (0, import_index.tagAsPreamble)(rb?.messages)\n          };\n        });\n      } else {\n        const baseOptions = { ...options };\n        const messages = [];\n        if (baseOptions.system) {\n          messages.push({\n            role: \"system\",\n            content: import_index.Message.parseContent(baseOptions.system)\n          });\n        }\n        delete baseOptions.system;\n        if (baseOptions.messages) {\n          messages.push(...baseOptions.messages);\n        }\n        baseOptions.messages = (0, import_index.tagAsPreamble)(messages);\n        requestBase = Promise.resolve(baseOptions);\n      }\n      return new import_chat.Chat(this, requestBase, {\n        thread: threadName,\n        id: this.id,\n        messages: (this.sessionData?.threads && this.sessionData?.threads[threadName]) ?? []\n      });\n    });\n  }\n  /**\n   * Executes provided function within this session context allowing calling\n   * `ai.currentSession().state`\n   */\n  run(fn) {\n    return runWithSession(this.registry, this, fn);\n  }\n  toJSON() {\n    return this.sessionData;\n  }\n}\nconst sessionAlsKey = \"ai.session\";\nfunction runWithSession(registry, session, fn) {\n  return (0, import_core.getAsyncContext)().run(sessionAlsKey, session, fn);\n}\nfunction getCurrentSession(registry) {\n  return (0, import_core.getAsyncContext)().getStore(sessionAlsKey);\n}\nclass SessionError extends Error {\n  constructor(msg) {\n    super(msg);\n  }\n}\nfunction inMemorySessionStore() {\n  return new InMemorySessionStore();\n}\nclass InMemorySessionStore {\n  data = {};\n  async get(sessionId) {\n    return this.data[sessionId];\n  }\n  async save(sessionId, sessionData) {\n    this.data[sessionId] = sessionData;\n  }\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=session.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9zZXNzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxxRkFBaUI7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMseUVBQU07QUFDaEMsa0JBQWtCLG1CQUFPLENBQUMsNEVBQVc7QUFDckMsbUJBQW1CLG1CQUFPLENBQUMsOEVBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1IsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FNTDtBQUNEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEtSYW1hY2hhXFxEb2N1bWVudHNcXFN1c3RBSW5leCBHSXQgQ29kZVxcbm9kZV9tb2R1bGVzXFxAZ2Vua2l0LWFpXFxhaVxcbGliXFxzZXNzaW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBzZXNzaW9uX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNlc3Npb25fZXhwb3J0cywge1xuICBTZXNzaW9uOiAoKSA9PiBTZXNzaW9uLFxuICBTZXNzaW9uRXJyb3I6ICgpID0+IFNlc3Npb25FcnJvcixcbiAgZ2V0Q3VycmVudFNlc3Npb246ICgpID0+IGdldEN1cnJlbnRTZXNzaW9uLFxuICBpbk1lbW9yeVNlc3Npb25TdG9yZTogKCkgPT4gaW5NZW1vcnlTZXNzaW9uU3RvcmUsXG4gIHJ1bldpdGhTZXNzaW9uOiAoKSA9PiBydW5XaXRoU2Vzc2lvblxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhzZXNzaW9uX2V4cG9ydHMpO1xudmFyIGltcG9ydF9jb3JlID0gcmVxdWlyZShcIkBnZW5raXQtYWkvY29yZVwiKTtcbnZhciBpbXBvcnRfdXVpZCA9IHJlcXVpcmUoXCJ1dWlkXCIpO1xudmFyIGltcG9ydF9jaGF0ID0gcmVxdWlyZShcIi4vY2hhdC5qc1wiKTtcbnZhciBpbXBvcnRfaW5kZXggPSByZXF1aXJlKFwiLi9pbmRleC5qc1wiKTtcbmNsYXNzIFNlc3Npb24ge1xuICBjb25zdHJ1Y3RvcihyZWdpc3RyeSwgb3B0aW9ucykge1xuICAgIHRoaXMucmVnaXN0cnkgPSByZWdpc3RyeTtcbiAgICB0aGlzLmlkID0gb3B0aW9ucz8uaWQgPz8gKDAsIGltcG9ydF91dWlkLnY0KSgpO1xuICAgIHRoaXMuc2Vzc2lvbkRhdGEgPSBvcHRpb25zPy5zZXNzaW9uRGF0YSA/PyB7XG4gICAgICBpZDogdGhpcy5pZFxuICAgIH07XG4gICAgaWYgKCF0aGlzLnNlc3Npb25EYXRhKSB7XG4gICAgICB0aGlzLnNlc3Npb25EYXRhID0geyBpZDogdGhpcy5pZCB9O1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc2Vzc2lvbkRhdGEudGhyZWFkcykge1xuICAgICAgdGhpcy5zZXNzaW9uRGF0YS50aHJlYWRzID0ge307XG4gICAgfVxuICAgIHRoaXMuc3RvcmUgPSBvcHRpb25zPy5zdG9yZSA/PyBuZXcgSW5NZW1vcnlTZXNzaW9uU3RvcmUoKTtcbiAgfVxuICBpZDtcbiAgc2Vzc2lvbkRhdGE7XG4gIHN0b3JlO1xuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2Vzc2lvbkRhdGEuc3RhdGU7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSBzZXNzaW9uIHN0YXRlIGRhdGEuXG4gICAqL1xuICBhc3luYyB1cGRhdGVTdGF0ZShkYXRhKSB7XG4gICAgbGV0IHNlc3Npb25EYXRhID0gdGhpcy5zZXNzaW9uRGF0YTtcbiAgICBpZiAoIXNlc3Npb25EYXRhKSB7XG4gICAgICBzZXNzaW9uRGF0YSA9IHt9O1xuICAgIH1cbiAgICBzZXNzaW9uRGF0YS5zdGF0ZSA9IGRhdGE7XG4gICAgdGhpcy5zZXNzaW9uRGF0YSA9IHNlc3Npb25EYXRhO1xuICAgIGF3YWl0IHRoaXMuc3RvcmUuc2F2ZSh0aGlzLmlkLCBzZXNzaW9uRGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSBtZXNzYWdlcyBmb3IgYSBnaXZlbiB0aHJlYWQuXG4gICAqL1xuICBhc3luYyB1cGRhdGVNZXNzYWdlcyh0aHJlYWQsIG1lc3NhZ2VzKSB7XG4gICAgbGV0IHNlc3Npb25EYXRhID0gdGhpcy5zZXNzaW9uRGF0YTtcbiAgICBpZiAoIXNlc3Npb25EYXRhKSB7XG4gICAgICBzZXNzaW9uRGF0YSA9IHt9O1xuICAgIH1cbiAgICBpZiAoIXNlc3Npb25EYXRhLnRocmVhZHMpIHtcbiAgICAgIHNlc3Npb25EYXRhLnRocmVhZHMgPSB7fTtcbiAgICB9XG4gICAgc2Vzc2lvbkRhdGEudGhyZWFkc1t0aHJlYWRdID0gbWVzc2FnZXMubWFwKFxuICAgICAgKG0pID0+IG0udG9KU09OID8gbS50b0pTT04oKSA6IG1cbiAgICApO1xuICAgIHRoaXMuc2Vzc2lvbkRhdGEgPSBzZXNzaW9uRGF0YTtcbiAgICBhd2FpdCB0aGlzLnN0b3JlLnNhdmUodGhpcy5pZCwgc2Vzc2lvbkRhdGEpO1xuICB9XG4gIGNoYXQob3B0aW9uc09yUHJlYW1ibGVPclRocmVhZE5hbWUsIG1heWJlT3B0aW9uc09yUHJlYW1ibGUsIG1heWJlT3B0aW9ucykge1xuICAgIHJldHVybiBydW5XaXRoU2Vzc2lvbih0aGlzLnJlZ2lzdHJ5LCB0aGlzLCAoKSA9PiB7XG4gICAgICBsZXQgb3B0aW9ucztcbiAgICAgIGxldCB0aHJlYWROYW1lID0gaW1wb3J0X2NoYXQuTUFJTl9USFJFQUQ7XG4gICAgICBsZXQgcHJlYW1ibGU7XG4gICAgICBpZiAob3B0aW9uc09yUHJlYW1ibGVPclRocmVhZE5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zT3JQcmVhbWJsZU9yVGhyZWFkTmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHRocmVhZE5hbWUgPSBvcHRpb25zT3JQcmVhbWJsZU9yVGhyZWFkTmFtZTtcbiAgICAgICAgfSBlbHNlIGlmICgoMCwgaW1wb3J0X2luZGV4LmlzRXhlY3V0YWJsZVByb21wdCkob3B0aW9uc09yUHJlYW1ibGVPclRocmVhZE5hbWUpKSB7XG4gICAgICAgICAgcHJlYW1ibGUgPSBvcHRpb25zT3JQcmVhbWJsZU9yVGhyZWFkTmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yUHJlYW1ibGVPclRocmVhZE5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtYXliZU9wdGlvbnNPclByZWFtYmxlKSB7XG4gICAgICAgIGlmICgoMCwgaW1wb3J0X2luZGV4LmlzRXhlY3V0YWJsZVByb21wdCkobWF5YmVPcHRpb25zT3JQcmVhbWJsZSkpIHtcbiAgICAgICAgICBwcmVhbWJsZSA9IG1heWJlT3B0aW9uc09yUHJlYW1ibGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucyA9IG1heWJlT3B0aW9uc09yUHJlYW1ibGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtYXliZU9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG1heWJlT3B0aW9ucztcbiAgICAgIH1cbiAgICAgIGxldCByZXF1ZXN0QmFzZTtcbiAgICAgIGlmIChwcmVhbWJsZSkge1xuICAgICAgICBjb25zdCByZW5kZXJPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgcmVxdWVzdEJhc2UgPSBwcmVhbWJsZS5yZW5kZXIocmVuZGVyT3B0aW9ucz8uaW5wdXQsIHJlbmRlck9wdGlvbnMpLnRoZW4oKHJiKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnJiLFxuICAgICAgICAgICAgbWVzc2FnZXM6ICgwLCBpbXBvcnRfaW5kZXgudGFnQXNQcmVhbWJsZSkocmI/Lm1lc3NhZ2VzKVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYmFzZU9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgICAgICAgaWYgKGJhc2VPcHRpb25zLnN5c3RlbSkge1xuICAgICAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IGltcG9ydF9pbmRleC5NZXNzYWdlLnBhcnNlQ29udGVudChiYXNlT3B0aW9ucy5zeXN0ZW0pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGJhc2VPcHRpb25zLnN5c3RlbTtcbiAgICAgICAgaWYgKGJhc2VPcHRpb25zLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgbWVzc2FnZXMucHVzaCguLi5iYXNlT3B0aW9ucy5tZXNzYWdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgYmFzZU9wdGlvbnMubWVzc2FnZXMgPSAoMCwgaW1wb3J0X2luZGV4LnRhZ0FzUHJlYW1ibGUpKG1lc3NhZ2VzKTtcbiAgICAgICAgcmVxdWVzdEJhc2UgPSBQcm9taXNlLnJlc29sdmUoYmFzZU9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBpbXBvcnRfY2hhdC5DaGF0KHRoaXMsIHJlcXVlc3RCYXNlLCB7XG4gICAgICAgIHRocmVhZDogdGhyZWFkTmFtZSxcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIG1lc3NhZ2VzOiAodGhpcy5zZXNzaW9uRGF0YT8udGhyZWFkcyAmJiB0aGlzLnNlc3Npb25EYXRhPy50aHJlYWRzW3RocmVhZE5hbWVdKSA/PyBbXVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHByb3ZpZGVkIGZ1bmN0aW9uIHdpdGhpbiB0aGlzIHNlc3Npb24gY29udGV4dCBhbGxvd2luZyBjYWxsaW5nXG4gICAqIGBhaS5jdXJyZW50U2Vzc2lvbigpLnN0YXRlYFxuICAgKi9cbiAgcnVuKGZuKSB7XG4gICAgcmV0dXJuIHJ1bldpdGhTZXNzaW9uKHRoaXMucmVnaXN0cnksIHRoaXMsIGZuKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2Vzc2lvbkRhdGE7XG4gIH1cbn1cbmNvbnN0IHNlc3Npb25BbHNLZXkgPSBcImFpLnNlc3Npb25cIjtcbmZ1bmN0aW9uIHJ1bldpdGhTZXNzaW9uKHJlZ2lzdHJ5LCBzZXNzaW9uLCBmbikge1xuICByZXR1cm4gKDAsIGltcG9ydF9jb3JlLmdldEFzeW5jQ29udGV4dCkoKS5ydW4oc2Vzc2lvbkFsc0tleSwgc2Vzc2lvbiwgZm4pO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFNlc3Npb24ocmVnaXN0cnkpIHtcbiAgcmV0dXJuICgwLCBpbXBvcnRfY29yZS5nZXRBc3luY0NvbnRleHQpKCkuZ2V0U3RvcmUoc2Vzc2lvbkFsc0tleSk7XG59XG5jbGFzcyBTZXNzaW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1zZykge1xuICAgIHN1cGVyKG1zZyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGluTWVtb3J5U2Vzc2lvblN0b3JlKCkge1xuICByZXR1cm4gbmV3IEluTWVtb3J5U2Vzc2lvblN0b3JlKCk7XG59XG5jbGFzcyBJbk1lbW9yeVNlc3Npb25TdG9yZSB7XG4gIGRhdGEgPSB7fTtcbiAgYXN5bmMgZ2V0KHNlc3Npb25JZCkge1xuICAgIHJldHVybiB0aGlzLmRhdGFbc2Vzc2lvbklkXTtcbiAgfVxuICBhc3luYyBzYXZlKHNlc3Npb25JZCwgc2Vzc2lvbkRhdGEpIHtcbiAgICB0aGlzLmRhdGFbc2Vzc2lvbklkXSA9IHNlc3Npb25EYXRhO1xuICB9XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgU2Vzc2lvbixcbiAgU2Vzc2lvbkVycm9yLFxuICBnZXRDdXJyZW50U2Vzc2lvbixcbiAgaW5NZW1vcnlTZXNzaW9uU3RvcmUsXG4gIHJ1bldpdGhTZXNzaW9uXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlc3Npb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/session.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/tool.js":
/*!************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/tool.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar tool_exports = {};\n__export(tool_exports, {\n  ToolInterruptError: () => ToolInterruptError,\n  asTool: () => asTool,\n  defineInterrupt: () => defineInterrupt,\n  defineTool: () => defineTool,\n  dynamicTool: () => dynamicTool,\n  interrupt: () => interrupt,\n  isDynamicTool: () => isDynamicTool,\n  isToolRequest: () => isToolRequest,\n  isToolResponse: () => isToolResponse,\n  lookupToolByName: () => lookupToolByName,\n  resolveTools: () => resolveTools,\n  toToolDefinition: () => toToolDefinition,\n  tool: () => tool\n});\nmodule.exports = __toCommonJS(tool_exports);\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nvar import_schema = __webpack_require__(/*! @genkit-ai/core/schema */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/schema.js\");\nvar import_tracing = __webpack_require__(/*! @genkit-ai/core/tracing */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing.js\");\nvar import_prompt = __webpack_require__(/*! ./prompt.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/prompt.js\");\nfunction asTool(registry, action2) {\n  if (action2.__action?.metadata?.type === \"tool\") {\n    return action2;\n  }\n  const fn = (input) => {\n    (0, import_tracing.setCustomMetadataAttributes)({ subtype: \"tool\" });\n    return action2(input);\n  };\n  fn.__action = {\n    ...action2.__action,\n    metadata: { ...action2.__action.metadata, type: \"tool\" }\n  };\n  return fn;\n}\nasync function resolveTools(registry, tools) {\n  if (!tools || tools.length === 0) {\n    return [];\n  }\n  return await Promise.all(\n    tools.map(async (ref) => {\n      if (typeof ref === \"string\") {\n        return await lookupToolByName(registry, ref);\n      } else if ((0, import_core.isAction)(ref)) {\n        return asTool(registry, ref);\n      } else if ((0, import_prompt.isExecutablePrompt)(ref)) {\n        return await ref.asTool();\n      } else if (ref.name) {\n        return await lookupToolByName(\n          registry,\n          ref.metadata?.originalName || ref.name\n        );\n      }\n      throw new Error(\"Tools must be strings, tool definitions, or actions.\");\n    })\n  );\n}\nasync function lookupToolByName(registry, name) {\n  const tool2 = await registry.lookupAction(name) || await registry.lookupAction(`/tool/${name}`) || await registry.lookupAction(`/prompt/${name}`);\n  if (!tool2) {\n    throw new Error(`Tool ${name} not found`);\n  }\n  return tool2;\n}\nfunction toToolDefinition(tool2) {\n  const originalName = tool2.__action.name;\n  let name = originalName;\n  if (originalName.includes(\"/\")) {\n    name = originalName.substring(originalName.lastIndexOf(\"/\") + 1);\n  }\n  const out = {\n    name,\n    description: tool2.__action.description || \"\",\n    outputSchema: (0, import_schema.toJsonSchema)({\n      schema: tool2.__action.outputSchema ?? import_core.z.void(),\n      jsonSchema: tool2.__action.outputJsonSchema\n    }),\n    inputSchema: (0, import_schema.toJsonSchema)({\n      schema: tool2.__action.inputSchema ?? import_core.z.void(),\n      jsonSchema: tool2.__action.inputJsonSchema\n    })\n  };\n  if (originalName !== name) {\n    out.metadata = { originalName };\n  }\n  return out;\n}\nfunction defineTool(registry, config, fn) {\n  const a = (0, import_core.defineAction)(\n    registry,\n    {\n      ...config,\n      actionType: \"tool\",\n      metadata: { ...config.metadata || {}, type: \"tool\" }\n    },\n    (i, runOptions) => {\n      return fn(i, {\n        ...runOptions,\n        context: { ...runOptions.context },\n        interrupt: interruptTool(registry)\n      });\n    }\n  );\n  implementTool(a, config, registry);\n  return a;\n}\nfunction implementTool(a, config, registry) {\n  a.respond = (interrupt2, responseData, options) => {\n    if (registry) {\n      (0, import_core.assertUnstable)(\n        registry,\n        \"beta\",\n        \"The 'tool.reply' method is part of the 'interrupts' beta feature.\"\n      );\n    }\n    (0, import_schema.parseSchema)(responseData, {\n      jsonSchema: config.outputJsonSchema,\n      schema: config.outputSchema\n    });\n    return {\n      toolResponse: (0, import_core.stripUndefinedProps)({\n        name: interrupt2.toolRequest.name,\n        ref: interrupt2.toolRequest.ref,\n        output: responseData\n      }),\n      metadata: {\n        interruptResponse: options?.metadata || true\n      }\n    };\n  };\n  a.restart = (interrupt2, resumedMetadata, options) => {\n    if (registry) {\n      (0, import_core.assertUnstable)(\n        registry,\n        \"beta\",\n        \"The 'tool.restart' method is part of the 'interrupts' beta feature.\"\n      );\n    }\n    let replaceInput = options?.replaceInput;\n    if (replaceInput) {\n      replaceInput = (0, import_schema.parseSchema)(replaceInput, {\n        schema: config.inputSchema,\n        jsonSchema: config.inputJsonSchema\n      });\n    }\n    return {\n      toolRequest: (0, import_core.stripUndefinedProps)({\n        name: interrupt2.toolRequest.name,\n        ref: interrupt2.toolRequest.ref,\n        input: replaceInput || interrupt2.toolRequest.input\n      }),\n      metadata: (0, import_core.stripUndefinedProps)({\n        ...interrupt2.metadata,\n        resumed: resumedMetadata || true,\n        // annotate the original input if replacing it\n        replacedInput: replaceInput ? interrupt2.toolRequest.input : void 0\n      })\n    };\n  };\n}\nfunction isToolRequest(part) {\n  return !!part.toolRequest;\n}\nfunction isToolResponse(part) {\n  return !!part.toolResponse;\n}\nfunction isDynamicTool(t) {\n  return (0, import_core.isAction)(t) && !t.__registry;\n}\nfunction interrupt(config) {\n  const { requestMetadata, ...toolConfig } = config;\n  return tool(toolConfig, async (input, { interrupt: interrupt2 }) => {\n    if (!config.requestMetadata) interrupt2();\n    else if (typeof config.requestMetadata === \"object\")\n      interrupt2(config.requestMetadata);\n    else interrupt2(await Promise.resolve(config.requestMetadata(input)));\n  });\n}\nfunction defineInterrupt(registry, config) {\n  const i = interrupt(config);\n  registry.registerAction(\"tool\", i);\n  return i;\n}\nclass ToolInterruptError extends Error {\n  constructor(metadata) {\n    super();\n    this.metadata = metadata;\n    this.name = \"ToolInterruptError\";\n  }\n}\nfunction interruptTool(registry) {\n  return (metadata) => {\n    if (registry) {\n      (0, import_core.assertUnstable)(registry, \"beta\", \"Tool interrupts are a beta feature.\");\n    }\n    throw new ToolInterruptError(metadata);\n  };\n}\nfunction tool(config, fn) {\n  return dynamicTool(config, fn);\n}\nfunction dynamicTool(config, fn) {\n  const a = (0, import_core.action)(\n    {\n      ...config,\n      actionType: \"tool\",\n      metadata: { ...config.metadata || {}, type: \"tool\", dynamic: true }\n    },\n    (i, runOptions) => {\n      const interrupt2 = interruptTool(runOptions.registry);\n      if (fn) {\n        return fn(i, {\n          ...runOptions,\n          context: { ...runOptions.context },\n          interrupt: interrupt2\n        });\n      }\n      return interrupt2();\n    }\n  );\n  implementTool(a, config);\n  a.attach = (_) => a;\n  return a;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=tool.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi90b29sLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMscUZBQWlCO0FBQzNDLG9CQUFvQixtQkFBTyxDQUFDLDZGQUF3QjtBQUNwRCxxQkFBcUIsbUJBQU8sQ0FBQywrRkFBeUI7QUFDdEQsb0JBQW9CLG1CQUFPLENBQUMsZ0ZBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxpQkFBaUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLEtBQUssNkNBQTZDLEtBQUs7QUFDako7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQ0FBaUM7QUFDM0MsMENBQTBDLHVCQUF1QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQWNMO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcS1JhbWFjaGFcXERvY3VtZW50c1xcU3VzdEFJbmV4IEdJdCBDb2RlXFxub2RlX21vZHVsZXNcXEBnZW5raXQtYWlcXGFpXFxsaWJcXHRvb2wuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIHRvb2xfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodG9vbF9leHBvcnRzLCB7XG4gIFRvb2xJbnRlcnJ1cHRFcnJvcjogKCkgPT4gVG9vbEludGVycnVwdEVycm9yLFxuICBhc1Rvb2w6ICgpID0+IGFzVG9vbCxcbiAgZGVmaW5lSW50ZXJydXB0OiAoKSA9PiBkZWZpbmVJbnRlcnJ1cHQsXG4gIGRlZmluZVRvb2w6ICgpID0+IGRlZmluZVRvb2wsXG4gIGR5bmFtaWNUb29sOiAoKSA9PiBkeW5hbWljVG9vbCxcbiAgaW50ZXJydXB0OiAoKSA9PiBpbnRlcnJ1cHQsXG4gIGlzRHluYW1pY1Rvb2w6ICgpID0+IGlzRHluYW1pY1Rvb2wsXG4gIGlzVG9vbFJlcXVlc3Q6ICgpID0+IGlzVG9vbFJlcXVlc3QsXG4gIGlzVG9vbFJlc3BvbnNlOiAoKSA9PiBpc1Rvb2xSZXNwb25zZSxcbiAgbG9va3VwVG9vbEJ5TmFtZTogKCkgPT4gbG9va3VwVG9vbEJ5TmFtZSxcbiAgcmVzb2x2ZVRvb2xzOiAoKSA9PiByZXNvbHZlVG9vbHMsXG4gIHRvVG9vbERlZmluaXRpb246ICgpID0+IHRvVG9vbERlZmluaXRpb24sXG4gIHRvb2w6ICgpID0+IHRvb2xcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlModG9vbF9leHBvcnRzKTtcbnZhciBpbXBvcnRfY29yZSA9IHJlcXVpcmUoXCJAZ2Vua2l0LWFpL2NvcmVcIik7XG52YXIgaW1wb3J0X3NjaGVtYSA9IHJlcXVpcmUoXCJAZ2Vua2l0LWFpL2NvcmUvc2NoZW1hXCIpO1xudmFyIGltcG9ydF90cmFjaW5nID0gcmVxdWlyZShcIkBnZW5raXQtYWkvY29yZS90cmFjaW5nXCIpO1xudmFyIGltcG9ydF9wcm9tcHQgPSByZXF1aXJlKFwiLi9wcm9tcHQuanNcIik7XG5mdW5jdGlvbiBhc1Rvb2wocmVnaXN0cnksIGFjdGlvbjIpIHtcbiAgaWYgKGFjdGlvbjIuX19hY3Rpb24/Lm1ldGFkYXRhPy50eXBlID09PSBcInRvb2xcIikge1xuICAgIHJldHVybiBhY3Rpb24yO1xuICB9XG4gIGNvbnN0IGZuID0gKGlucHV0KSA9PiB7XG4gICAgKDAsIGltcG9ydF90cmFjaW5nLnNldEN1c3RvbU1ldGFkYXRhQXR0cmlidXRlcykoeyBzdWJ0eXBlOiBcInRvb2xcIiB9KTtcbiAgICByZXR1cm4gYWN0aW9uMihpbnB1dCk7XG4gIH07XG4gIGZuLl9fYWN0aW9uID0ge1xuICAgIC4uLmFjdGlvbjIuX19hY3Rpb24sXG4gICAgbWV0YWRhdGE6IHsgLi4uYWN0aW9uMi5fX2FjdGlvbi5tZXRhZGF0YSwgdHlwZTogXCJ0b29sXCIgfVxuICB9O1xuICByZXR1cm4gZm47XG59XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlVG9vbHMocmVnaXN0cnksIHRvb2xzKSB7XG4gIGlmICghdG9vbHMgfHwgdG9vbHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChcbiAgICB0b29scy5tYXAoYXN5bmMgKHJlZikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiByZWYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGxvb2t1cFRvb2xCeU5hbWUocmVnaXN0cnksIHJlZik7XG4gICAgICB9IGVsc2UgaWYgKCgwLCBpbXBvcnRfY29yZS5pc0FjdGlvbikocmVmKSkge1xuICAgICAgICByZXR1cm4gYXNUb29sKHJlZ2lzdHJ5LCByZWYpO1xuICAgICAgfSBlbHNlIGlmICgoMCwgaW1wb3J0X3Byb21wdC5pc0V4ZWN1dGFibGVQcm9tcHQpKHJlZikpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlZi5hc1Rvb2woKTtcbiAgICAgIH0gZWxzZSBpZiAocmVmLm5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGxvb2t1cFRvb2xCeU5hbWUoXG4gICAgICAgICAgcmVnaXN0cnksXG4gICAgICAgICAgcmVmLm1ldGFkYXRhPy5vcmlnaW5hbE5hbWUgfHwgcmVmLm5hbWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvb2xzIG11c3QgYmUgc3RyaW5ncywgdG9vbCBkZWZpbml0aW9ucywgb3IgYWN0aW9ucy5cIik7XG4gICAgfSlcbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvb2t1cFRvb2xCeU5hbWUocmVnaXN0cnksIG5hbWUpIHtcbiAgY29uc3QgdG9vbDIgPSBhd2FpdCByZWdpc3RyeS5sb29rdXBBY3Rpb24obmFtZSkgfHwgYXdhaXQgcmVnaXN0cnkubG9va3VwQWN0aW9uKGAvdG9vbC8ke25hbWV9YCkgfHwgYXdhaXQgcmVnaXN0cnkubG9va3VwQWN0aW9uKGAvcHJvbXB0LyR7bmFtZX1gKTtcbiAgaWYgKCF0b29sMikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVG9vbCAke25hbWV9IG5vdCBmb3VuZGApO1xuICB9XG4gIHJldHVybiB0b29sMjtcbn1cbmZ1bmN0aW9uIHRvVG9vbERlZmluaXRpb24odG9vbDIpIHtcbiAgY29uc3Qgb3JpZ2luYWxOYW1lID0gdG9vbDIuX19hY3Rpb24ubmFtZTtcbiAgbGV0IG5hbWUgPSBvcmlnaW5hbE5hbWU7XG4gIGlmIChvcmlnaW5hbE5hbWUuaW5jbHVkZXMoXCIvXCIpKSB7XG4gICAgbmFtZSA9IG9yaWdpbmFsTmFtZS5zdWJzdHJpbmcob3JpZ2luYWxOYW1lLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpO1xuICB9XG4gIGNvbnN0IG91dCA9IHtcbiAgICBuYW1lLFxuICAgIGRlc2NyaXB0aW9uOiB0b29sMi5fX2FjdGlvbi5kZXNjcmlwdGlvbiB8fCBcIlwiLFxuICAgIG91dHB1dFNjaGVtYTogKDAsIGltcG9ydF9zY2hlbWEudG9Kc29uU2NoZW1hKSh7XG4gICAgICBzY2hlbWE6IHRvb2wyLl9fYWN0aW9uLm91dHB1dFNjaGVtYSA/PyBpbXBvcnRfY29yZS56LnZvaWQoKSxcbiAgICAgIGpzb25TY2hlbWE6IHRvb2wyLl9fYWN0aW9uLm91dHB1dEpzb25TY2hlbWFcbiAgICB9KSxcbiAgICBpbnB1dFNjaGVtYTogKDAsIGltcG9ydF9zY2hlbWEudG9Kc29uU2NoZW1hKSh7XG4gICAgICBzY2hlbWE6IHRvb2wyLl9fYWN0aW9uLmlucHV0U2NoZW1hID8/IGltcG9ydF9jb3JlLnoudm9pZCgpLFxuICAgICAganNvblNjaGVtYTogdG9vbDIuX19hY3Rpb24uaW5wdXRKc29uU2NoZW1hXG4gICAgfSlcbiAgfTtcbiAgaWYgKG9yaWdpbmFsTmFtZSAhPT0gbmFtZSkge1xuICAgIG91dC5tZXRhZGF0YSA9IHsgb3JpZ2luYWxOYW1lIH07XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIGRlZmluZVRvb2wocmVnaXN0cnksIGNvbmZpZywgZm4pIHtcbiAgY29uc3QgYSA9ICgwLCBpbXBvcnRfY29yZS5kZWZpbmVBY3Rpb24pKFxuICAgIHJlZ2lzdHJ5LFxuICAgIHtcbiAgICAgIC4uLmNvbmZpZyxcbiAgICAgIGFjdGlvblR5cGU6IFwidG9vbFwiLFxuICAgICAgbWV0YWRhdGE6IHsgLi4uY29uZmlnLm1ldGFkYXRhIHx8IHt9LCB0eXBlOiBcInRvb2xcIiB9XG4gICAgfSxcbiAgICAoaSwgcnVuT3B0aW9ucykgPT4ge1xuICAgICAgcmV0dXJuIGZuKGksIHtcbiAgICAgICAgLi4ucnVuT3B0aW9ucyxcbiAgICAgICAgY29udGV4dDogeyAuLi5ydW5PcHRpb25zLmNvbnRleHQgfSxcbiAgICAgICAgaW50ZXJydXB0OiBpbnRlcnJ1cHRUb29sKHJlZ2lzdHJ5KVxuICAgICAgfSk7XG4gICAgfVxuICApO1xuICBpbXBsZW1lbnRUb29sKGEsIGNvbmZpZywgcmVnaXN0cnkpO1xuICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uIGltcGxlbWVudFRvb2woYSwgY29uZmlnLCByZWdpc3RyeSkge1xuICBhLnJlc3BvbmQgPSAoaW50ZXJydXB0MiwgcmVzcG9uc2VEYXRhLCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKHJlZ2lzdHJ5KSB7XG4gICAgICAoMCwgaW1wb3J0X2NvcmUuYXNzZXJ0VW5zdGFibGUpKFxuICAgICAgICByZWdpc3RyeSxcbiAgICAgICAgXCJiZXRhXCIsXG4gICAgICAgIFwiVGhlICd0b29sLnJlcGx5JyBtZXRob2QgaXMgcGFydCBvZiB0aGUgJ2ludGVycnVwdHMnIGJldGEgZmVhdHVyZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgKDAsIGltcG9ydF9zY2hlbWEucGFyc2VTY2hlbWEpKHJlc3BvbnNlRGF0YSwge1xuICAgICAganNvblNjaGVtYTogY29uZmlnLm91dHB1dEpzb25TY2hlbWEsXG4gICAgICBzY2hlbWE6IGNvbmZpZy5vdXRwdXRTY2hlbWFcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdG9vbFJlc3BvbnNlOiAoMCwgaW1wb3J0X2NvcmUuc3RyaXBVbmRlZmluZWRQcm9wcykoe1xuICAgICAgICBuYW1lOiBpbnRlcnJ1cHQyLnRvb2xSZXF1ZXN0Lm5hbWUsXG4gICAgICAgIHJlZjogaW50ZXJydXB0Mi50b29sUmVxdWVzdC5yZWYsXG4gICAgICAgIG91dHB1dDogcmVzcG9uc2VEYXRhXG4gICAgICB9KSxcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIGludGVycnVwdFJlc3BvbnNlOiBvcHRpb25zPy5tZXRhZGF0YSB8fCB0cnVlXG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgYS5yZXN0YXJ0ID0gKGludGVycnVwdDIsIHJlc3VtZWRNZXRhZGF0YSwgb3B0aW9ucykgPT4ge1xuICAgIGlmIChyZWdpc3RyeSkge1xuICAgICAgKDAsIGltcG9ydF9jb3JlLmFzc2VydFVuc3RhYmxlKShcbiAgICAgICAgcmVnaXN0cnksXG4gICAgICAgIFwiYmV0YVwiLFxuICAgICAgICBcIlRoZSAndG9vbC5yZXN0YXJ0JyBtZXRob2QgaXMgcGFydCBvZiB0aGUgJ2ludGVycnVwdHMnIGJldGEgZmVhdHVyZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IHJlcGxhY2VJbnB1dCA9IG9wdGlvbnM/LnJlcGxhY2VJbnB1dDtcbiAgICBpZiAocmVwbGFjZUlucHV0KSB7XG4gICAgICByZXBsYWNlSW5wdXQgPSAoMCwgaW1wb3J0X3NjaGVtYS5wYXJzZVNjaGVtYSkocmVwbGFjZUlucHV0LCB7XG4gICAgICAgIHNjaGVtYTogY29uZmlnLmlucHV0U2NoZW1hLFxuICAgICAgICBqc29uU2NoZW1hOiBjb25maWcuaW5wdXRKc29uU2NoZW1hXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvb2xSZXF1ZXN0OiAoMCwgaW1wb3J0X2NvcmUuc3RyaXBVbmRlZmluZWRQcm9wcykoe1xuICAgICAgICBuYW1lOiBpbnRlcnJ1cHQyLnRvb2xSZXF1ZXN0Lm5hbWUsXG4gICAgICAgIHJlZjogaW50ZXJydXB0Mi50b29sUmVxdWVzdC5yZWYsXG4gICAgICAgIGlucHV0OiByZXBsYWNlSW5wdXQgfHwgaW50ZXJydXB0Mi50b29sUmVxdWVzdC5pbnB1dFxuICAgICAgfSksXG4gICAgICBtZXRhZGF0YTogKDAsIGltcG9ydF9jb3JlLnN0cmlwVW5kZWZpbmVkUHJvcHMpKHtcbiAgICAgICAgLi4uaW50ZXJydXB0Mi5tZXRhZGF0YSxcbiAgICAgICAgcmVzdW1lZDogcmVzdW1lZE1ldGFkYXRhIHx8IHRydWUsXG4gICAgICAgIC8vIGFubm90YXRlIHRoZSBvcmlnaW5hbCBpbnB1dCBpZiByZXBsYWNpbmcgaXRcbiAgICAgICAgcmVwbGFjZWRJbnB1dDogcmVwbGFjZUlucHV0ID8gaW50ZXJydXB0Mi50b29sUmVxdWVzdC5pbnB1dCA6IHZvaWQgMFxuICAgICAgfSlcbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gaXNUb29sUmVxdWVzdChwYXJ0KSB7XG4gIHJldHVybiAhIXBhcnQudG9vbFJlcXVlc3Q7XG59XG5mdW5jdGlvbiBpc1Rvb2xSZXNwb25zZShwYXJ0KSB7XG4gIHJldHVybiAhIXBhcnQudG9vbFJlc3BvbnNlO1xufVxuZnVuY3Rpb24gaXNEeW5hbWljVG9vbCh0KSB7XG4gIHJldHVybiAoMCwgaW1wb3J0X2NvcmUuaXNBY3Rpb24pKHQpICYmICF0Ll9fcmVnaXN0cnk7XG59XG5mdW5jdGlvbiBpbnRlcnJ1cHQoY29uZmlnKSB7XG4gIGNvbnN0IHsgcmVxdWVzdE1ldGFkYXRhLCAuLi50b29sQ29uZmlnIH0gPSBjb25maWc7XG4gIHJldHVybiB0b29sKHRvb2xDb25maWcsIGFzeW5jIChpbnB1dCwgeyBpbnRlcnJ1cHQ6IGludGVycnVwdDIgfSkgPT4ge1xuICAgIGlmICghY29uZmlnLnJlcXVlc3RNZXRhZGF0YSkgaW50ZXJydXB0MigpO1xuICAgIGVsc2UgaWYgKHR5cGVvZiBjb25maWcucmVxdWVzdE1ldGFkYXRhID09PSBcIm9iamVjdFwiKVxuICAgICAgaW50ZXJydXB0Mihjb25maWcucmVxdWVzdE1ldGFkYXRhKTtcbiAgICBlbHNlIGludGVycnVwdDIoYXdhaXQgUHJvbWlzZS5yZXNvbHZlKGNvbmZpZy5yZXF1ZXN0TWV0YWRhdGEoaW5wdXQpKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZGVmaW5lSW50ZXJydXB0KHJlZ2lzdHJ5LCBjb25maWcpIHtcbiAgY29uc3QgaSA9IGludGVycnVwdChjb25maWcpO1xuICByZWdpc3RyeS5yZWdpc3RlckFjdGlvbihcInRvb2xcIiwgaSk7XG4gIHJldHVybiBpO1xufVxuY2xhc3MgVG9vbEludGVycnVwdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXRhZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgIHRoaXMubmFtZSA9IFwiVG9vbEludGVycnVwdEVycm9yXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVycnVwdFRvb2wocmVnaXN0cnkpIHtcbiAgcmV0dXJuIChtZXRhZGF0YSkgPT4ge1xuICAgIGlmIChyZWdpc3RyeSkge1xuICAgICAgKDAsIGltcG9ydF9jb3JlLmFzc2VydFVuc3RhYmxlKShyZWdpc3RyeSwgXCJiZXRhXCIsIFwiVG9vbCBpbnRlcnJ1cHRzIGFyZSBhIGJldGEgZmVhdHVyZS5cIik7XG4gICAgfVxuICAgIHRocm93IG5ldyBUb29sSW50ZXJydXB0RXJyb3IobWV0YWRhdGEpO1xuICB9O1xufVxuZnVuY3Rpb24gdG9vbChjb25maWcsIGZuKSB7XG4gIHJldHVybiBkeW5hbWljVG9vbChjb25maWcsIGZuKTtcbn1cbmZ1bmN0aW9uIGR5bmFtaWNUb29sKGNvbmZpZywgZm4pIHtcbiAgY29uc3QgYSA9ICgwLCBpbXBvcnRfY29yZS5hY3Rpb24pKFxuICAgIHtcbiAgICAgIC4uLmNvbmZpZyxcbiAgICAgIGFjdGlvblR5cGU6IFwidG9vbFwiLFxuICAgICAgbWV0YWRhdGE6IHsgLi4uY29uZmlnLm1ldGFkYXRhIHx8IHt9LCB0eXBlOiBcInRvb2xcIiwgZHluYW1pYzogdHJ1ZSB9XG4gICAgfSxcbiAgICAoaSwgcnVuT3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgaW50ZXJydXB0MiA9IGludGVycnVwdFRvb2wocnVuT3B0aW9ucy5yZWdpc3RyeSk7XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKGksIHtcbiAgICAgICAgICAuLi5ydW5PcHRpb25zLFxuICAgICAgICAgIGNvbnRleHQ6IHsgLi4ucnVuT3B0aW9ucy5jb250ZXh0IH0sXG4gICAgICAgICAgaW50ZXJydXB0OiBpbnRlcnJ1cHQyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGludGVycnVwdDIoKTtcbiAgICB9XG4gICk7XG4gIGltcGxlbWVudFRvb2woYSwgY29uZmlnKTtcbiAgYS5hdHRhY2ggPSAoXykgPT4gYTtcbiAgcmV0dXJuIGE7XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgVG9vbEludGVycnVwdEVycm9yLFxuICBhc1Rvb2wsXG4gIGRlZmluZUludGVycnVwdCxcbiAgZGVmaW5lVG9vbCxcbiAgZHluYW1pY1Rvb2wsXG4gIGludGVycnVwdCxcbiAgaXNEeW5hbWljVG9vbCxcbiAgaXNUb29sUmVxdWVzdCxcbiAgaXNUb29sUmVzcG9uc2UsXG4gIGxvb2t1cFRvb2xCeU5hbWUsXG4gIHJlc29sdmVUb29scyxcbiAgdG9Ub29sRGVmaW5pdGlvbixcbiAgdG9vbFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b29sLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/tool.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/types.js":
/*!*************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/types.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar types_exports = {};\n__export(types_exports, {\n  LlmResponseSchema: () => LlmResponseSchema,\n  LlmStatsSchema: () => LlmStatsSchema,\n  ToolCallSchema: () => ToolCallSchema,\n  ToolSchema: () => ToolSchema,\n  toToolWireFormat: () => toToolWireFormat\n});\nmodule.exports = __toCommonJS(types_exports);\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nvar import_schema = __webpack_require__(/*! @genkit-ai/core/schema */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/schema.js\");\nconst LlmStatsSchema = import_core.z.object({\n  latencyMs: import_core.z.number().optional(),\n  inputTokenCount: import_core.z.number().optional(),\n  outputTokenCount: import_core.z.number().optional()\n});\nconst ToolSchema = import_core.z.object({\n  name: import_core.z.string(),\n  description: import_core.z.string().optional(),\n  schema: import_core.z.any()\n});\nconst ToolCallSchema = import_core.z.object({\n  toolName: import_core.z.string(),\n  arguments: import_core.z.any()\n});\nconst LlmResponseSchema = import_core.z.object({\n  completion: import_core.z.string(),\n  toolCalls: import_core.z.array(ToolCallSchema).optional(),\n  stats: LlmStatsSchema\n});\nfunction toToolWireFormat(actions) {\n  if (!actions) return void 0;\n  return actions.map((a) => {\n    return {\n      name: a.__action.name,\n      description: a.__action.description,\n      schema: {\n        input: (0, import_schema.toJsonSchema)({\n          schema: a.__action.inputSchema,\n          jsonSchema: a.__action.inputJsonSchema\n        }),\n        output: (0, import_schema.toJsonSchema)({\n          schema: a.__action.outputSchema,\n          jsonSchema: a.__action.outputJsonSchema\n        })\n      }\n    };\n  });\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMscUZBQWlCO0FBQzNDLG9CQUFvQixtQkFBTyxDQUFDLDZGQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU0sQ0FNTDtBQUNEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEtSYW1hY2hhXFxEb2N1bWVudHNcXFN1c3RBSW5leCBHSXQgQ29kZVxcbm9kZV9tb2R1bGVzXFxAZ2Vua2l0LWFpXFxhaVxcbGliXFx0eXBlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgdHlwZXNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodHlwZXNfZXhwb3J0cywge1xuICBMbG1SZXNwb25zZVNjaGVtYTogKCkgPT4gTGxtUmVzcG9uc2VTY2hlbWEsXG4gIExsbVN0YXRzU2NoZW1hOiAoKSA9PiBMbG1TdGF0c1NjaGVtYSxcbiAgVG9vbENhbGxTY2hlbWE6ICgpID0+IFRvb2xDYWxsU2NoZW1hLFxuICBUb29sU2NoZW1hOiAoKSA9PiBUb29sU2NoZW1hLFxuICB0b1Rvb2xXaXJlRm9ybWF0OiAoKSA9PiB0b1Rvb2xXaXJlRm9ybWF0XG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHR5cGVzX2V4cG9ydHMpO1xudmFyIGltcG9ydF9jb3JlID0gcmVxdWlyZShcIkBnZW5raXQtYWkvY29yZVwiKTtcbnZhciBpbXBvcnRfc2NoZW1hID0gcmVxdWlyZShcIkBnZW5raXQtYWkvY29yZS9zY2hlbWFcIik7XG5jb25zdCBMbG1TdGF0c1NjaGVtYSA9IGltcG9ydF9jb3JlLnoub2JqZWN0KHtcbiAgbGF0ZW5jeU1zOiBpbXBvcnRfY29yZS56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gIGlucHV0VG9rZW5Db3VudDogaW1wb3J0X2NvcmUuei5udW1iZXIoKS5vcHRpb25hbCgpLFxuICBvdXRwdXRUb2tlbkNvdW50OiBpbXBvcnRfY29yZS56Lm51bWJlcigpLm9wdGlvbmFsKClcbn0pO1xuY29uc3QgVG9vbFNjaGVtYSA9IGltcG9ydF9jb3JlLnoub2JqZWN0KHtcbiAgbmFtZTogaW1wb3J0X2NvcmUuei5zdHJpbmcoKSxcbiAgZGVzY3JpcHRpb246IGltcG9ydF9jb3JlLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgc2NoZW1hOiBpbXBvcnRfY29yZS56LmFueSgpXG59KTtcbmNvbnN0IFRvb2xDYWxsU2NoZW1hID0gaW1wb3J0X2NvcmUuei5vYmplY3Qoe1xuICB0b29sTmFtZTogaW1wb3J0X2NvcmUuei5zdHJpbmcoKSxcbiAgYXJndW1lbnRzOiBpbXBvcnRfY29yZS56LmFueSgpXG59KTtcbmNvbnN0IExsbVJlc3BvbnNlU2NoZW1hID0gaW1wb3J0X2NvcmUuei5vYmplY3Qoe1xuICBjb21wbGV0aW9uOiBpbXBvcnRfY29yZS56LnN0cmluZygpLFxuICB0b29sQ2FsbHM6IGltcG9ydF9jb3JlLnouYXJyYXkoVG9vbENhbGxTY2hlbWEpLm9wdGlvbmFsKCksXG4gIHN0YXRzOiBMbG1TdGF0c1NjaGVtYVxufSk7XG5mdW5jdGlvbiB0b1Rvb2xXaXJlRm9ybWF0KGFjdGlvbnMpIHtcbiAgaWYgKCFhY3Rpb25zKSByZXR1cm4gdm9pZCAwO1xuICByZXR1cm4gYWN0aW9ucy5tYXAoKGEpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogYS5fX2FjdGlvbi5uYW1lLFxuICAgICAgZGVzY3JpcHRpb246IGEuX19hY3Rpb24uZGVzY3JpcHRpb24sXG4gICAgICBzY2hlbWE6IHtcbiAgICAgICAgaW5wdXQ6ICgwLCBpbXBvcnRfc2NoZW1hLnRvSnNvblNjaGVtYSkoe1xuICAgICAgICAgIHNjaGVtYTogYS5fX2FjdGlvbi5pbnB1dFNjaGVtYSxcbiAgICAgICAgICBqc29uU2NoZW1hOiBhLl9fYWN0aW9uLmlucHV0SnNvblNjaGVtYVxuICAgICAgICB9KSxcbiAgICAgICAgb3V0cHV0OiAoMCwgaW1wb3J0X3NjaGVtYS50b0pzb25TY2hlbWEpKHtcbiAgICAgICAgICBzY2hlbWE6IGEuX19hY3Rpb24ub3V0cHV0U2NoZW1hLFxuICAgICAgICAgIGpzb25TY2hlbWE6IGEuX19hY3Rpb24ub3V0cHV0SnNvblNjaGVtYVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIExsbVJlc3BvbnNlU2NoZW1hLFxuICBMbG1TdGF0c1NjaGVtYSxcbiAgVG9vbENhbGxTY2hlbWEsXG4gIFRvb2xTY2hlbWEsXG4gIHRvVG9vbFdpcmVGb3JtYXRcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/types.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/__codegen/version.js":
/*!***************************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/__codegen/version.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar version_exports = {};\n__export(version_exports, {\n  version: () => version\n});\nmodule.exports = __toCommonJS(version_exports);\nconst version = \"1.20.0\";\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL19fY29kZWdlbi92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FFTDtBQUNEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEtSYW1hY2hhXFxEb2N1bWVudHNcXFN1c3RBSW5leCBHSXQgQ29kZVxcbm9kZV9tb2R1bGVzXFxAZ2Vua2l0LWFpXFxjb3JlXFxsaWJcXF9fY29kZWdlblxcdmVyc2lvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgdmVyc2lvbl9leHBvcnRzID0ge307XG5fX2V4cG9ydCh2ZXJzaW9uX2V4cG9ydHMsIHtcbiAgdmVyc2lvbjogKCkgPT4gdmVyc2lvblxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyh2ZXJzaW9uX2V4cG9ydHMpO1xuY29uc3QgdmVyc2lvbiA9IFwiMS4yMC4wXCI7XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgdmVyc2lvblxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/__codegen/version.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/action.js":
/*!****************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/action.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar action_exports = {};\n__export(action_exports, {\n  StatusCodes: () => import_statusTypes.StatusCodes,\n  StatusSchema: () => import_statusTypes.StatusSchema,\n  action: () => action,\n  actionWithMiddleware: () => actionWithMiddleware,\n  defineAction: () => defineAction,\n  defineActionAsync: () => defineActionAsync,\n  getStreamingCallback: () => getStreamingCallback,\n  isAction: () => isAction,\n  isInRuntimeContext: () => isInRuntimeContext,\n  runInActionRuntimeContext: () => runInActionRuntimeContext,\n  runOutsideActionRuntimeContext: () => runOutsideActionRuntimeContext,\n  runWithStreamingCallback: () => runWithStreamingCallback,\n  sentinelNoopStreamingCallback: () => sentinelNoopStreamingCallback\n});\nmodule.exports = __toCommonJS(action_exports);\nvar import_async_context = __webpack_require__(/*! ./async-context.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/async-context.js\");\nvar import_async = __webpack_require__(/*! ./async.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/async.js\");\nvar import_context = __webpack_require__(/*! ./context.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/context.js\");\nvar import_schema = __webpack_require__(/*! ./schema.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/schema.js\");\nvar import_tracing = __webpack_require__(/*! ./tracing.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing.js\");\nvar import_statusTypes = __webpack_require__(/*! ./statusTypes.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/statusTypes.js\");\nconst makeNoopAbortSignal = () => new AbortController().signal;\nfunction actionWithMiddleware(action2, middleware) {\n  const wrapped = async (req, options) => {\n    return (await wrapped.run(req, options)).result;\n  };\n  wrapped.__action = action2.__action;\n  wrapped.run = async (req, options) => {\n    let telemetry;\n    const dispatch = async (index, req2, opts) => {\n      if (index === middleware.length) {\n        const result = await action2.run(req2, opts);\n        telemetry = result.telemetry;\n        return result.result;\n      }\n      const currentMiddleware = middleware[index];\n      if (currentMiddleware.length === 3) {\n        return currentMiddleware(\n          req2,\n          opts,\n          async (modifiedReq, modifiedOptions) => dispatch(index + 1, modifiedReq || req2, modifiedOptions || opts)\n        );\n      } else if (currentMiddleware.length === 2) {\n        return currentMiddleware(\n          req2,\n          async (modifiedReq) => dispatch(index + 1, modifiedReq || req2, opts)\n        );\n      } else {\n        throw new Error(\"unspported middleware function shape\");\n      }\n    };\n    wrapped.stream = action2.stream;\n    return { result: await dispatch(0, req, options), telemetry };\n  };\n  return wrapped;\n}\nfunction action(config, fn) {\n  const actionName = typeof config.name === \"string\" ? config.name : `${config.name.pluginId}/${config.name.actionId}`;\n  const actionMetadata = {\n    name: actionName,\n    description: config.description,\n    inputSchema: config.inputSchema,\n    inputJsonSchema: config.inputJsonSchema,\n    outputSchema: config.outputSchema,\n    outputJsonSchema: config.outputJsonSchema,\n    streamSchema: config.streamSchema,\n    metadata: config.metadata,\n    actionType: config.actionType\n  };\n  const actionFn = async (input, options) => {\n    return (await actionFn.run(input, options)).result;\n  };\n  actionFn.__action = { ...actionMetadata };\n  actionFn.run = async (input, options) => {\n    input = (0, import_schema.parseSchema)(input, {\n      schema: config.inputSchema,\n      jsonSchema: config.inputJsonSchema\n    });\n    let traceId;\n    let spanId;\n    let output = await (0, import_tracing.runInNewSpan)(\n      {\n        metadata: {\n          name: actionName\n        },\n        labels: {\n          [import_tracing.SPAN_TYPE_ATTR]: \"action\",\n          \"genkit:metadata:subtype\": config.actionType,\n          ...options?.telemetryLabels\n        }\n      },\n      async (metadata, span) => {\n        (0, import_tracing.setCustomMetadataAttributes)({\n          subtype: config.actionType\n        });\n        if (options?.context) {\n          (0, import_tracing.setCustomMetadataAttributes)({\n            context: JSON.stringify(options.context)\n          });\n        }\n        traceId = span.spanContext().traceId;\n        spanId = span.spanContext().spanId;\n        metadata.name = actionName;\n        metadata.input = input;\n        try {\n          const actFn = () => fn(input, {\n            ...options,\n            // Context can either be explicitly set, or inherited from the parent action.\n            context: {\n              ...actionFn.__registry?.context,\n              ...options?.context ?? (0, import_context.getContext)()\n            },\n            streamingRequested: !!options?.onChunk && options.onChunk !== sentinelNoopStreamingCallback,\n            sendChunk: options?.onChunk ?? sentinelNoopStreamingCallback,\n            trace: {\n              traceId,\n              spanId\n            },\n            registry: actionFn.__registry,\n            abortSignal: options?.abortSignal ?? makeNoopAbortSignal()\n          });\n          const output2 = await (0, import_context.runWithContext)(options?.context, actFn);\n          metadata.output = JSON.stringify(output2);\n          return output2;\n        } catch (err) {\n          if (typeof err === \"object\") {\n            err.traceId = traceId;\n          }\n          throw err;\n        }\n      }\n    );\n    output = (0, import_schema.parseSchema)(output, {\n      schema: config.outputSchema,\n      jsonSchema: config.outputJsonSchema\n    });\n    return {\n      result: output,\n      telemetry: {\n        traceId,\n        spanId\n      }\n    };\n  };\n  actionFn.stream = (input, opts) => {\n    let chunkStreamController;\n    const chunkStream = new ReadableStream({\n      start(controller) {\n        chunkStreamController = controller;\n      },\n      pull() {\n      },\n      cancel() {\n      }\n    });\n    const invocationPromise = actionFn.run(config.inputSchema ? config.inputSchema.parse(input) : input, {\n      onChunk: (chunk) => {\n        chunkStreamController.enqueue(chunk);\n      },\n      context: {\n        ...actionFn.__registry?.context,\n        ...opts?.context ?? (0, import_context.getContext)()\n      },\n      abortSignal: opts?.abortSignal,\n      telemetryLabels: opts?.telemetryLabels\n    }).then((s) => s.result).finally(() => {\n      chunkStreamController.close();\n    });\n    return {\n      output: invocationPromise,\n      stream: async function* () {\n        const reader = chunkStream.getReader();\n        while (true) {\n          const chunk = await reader.read();\n          if (chunk.value) {\n            yield chunk.value;\n          }\n          if (chunk.done) {\n            break;\n          }\n        }\n        return await invocationPromise;\n      }()\n    };\n  };\n  if (config.use) {\n    return actionWithMiddleware(actionFn, config.use);\n  }\n  return actionFn;\n}\nfunction isAction(a) {\n  return typeof a === \"function\" && \"__action\" in a;\n}\nfunction defineAction(registry, config, fn) {\n  if (isInRuntimeContext()) {\n    throw new Error(\n      \"Cannot define new actions at runtime.\\nSee: https://github.com/firebase/genkit/blob/main/docs/errors/no_new_actions_at_runtime.md\"\n    );\n  }\n  const act = action(config, async (i, options) => {\n    await registry.initializeAllPlugins();\n    return await runInActionRuntimeContext(() => fn(i, options));\n  });\n  act.__action.actionType = config.actionType;\n  registry.registerAction(config.actionType, act);\n  return act;\n}\nfunction defineActionAsync(registry, actionType, name, config, onInit) {\n  const actionName = typeof name === \"string\" ? name : `${name.pluginId}/${name.actionId}`;\n  const actionPromise = (0, import_async.lazy)(\n    () => config.then((resolvedConfig) => {\n      const act = action(\n        resolvedConfig,\n        async (i, options) => {\n          await registry.initializeAllPlugins();\n          return await runInActionRuntimeContext(\n            () => resolvedConfig.fn(i, options)\n          );\n        }\n      );\n      act.__action.actionType = actionType;\n      onInit?.(act);\n      return act;\n    })\n  );\n  registry.registerActionAsync(actionType, actionName, actionPromise);\n  return actionPromise;\n}\nconst streamingAlsKey = \"core.action.streamingCallback\";\nconst sentinelNoopStreamingCallback = () => null;\nfunction runWithStreamingCallback(streamingCallback, fn) {\n  return (0, import_async_context.getAsyncContext)().run(\n    streamingAlsKey,\n    streamingCallback || sentinelNoopStreamingCallback,\n    fn\n  );\n}\nfunction getStreamingCallback() {\n  const cb = (0, import_async_context.getAsyncContext)().getStore(streamingAlsKey);\n  if (cb === sentinelNoopStreamingCallback) {\n    return void 0;\n  }\n  return cb;\n}\nconst runtimeContextAslKey = \"core.action.runtimeContext\";\nfunction isInRuntimeContext() {\n  return (0, import_async_context.getAsyncContext)().getStore(runtimeContextAslKey) === \"runtime\";\n}\nfunction runInActionRuntimeContext(fn) {\n  return (0, import_async_context.getAsyncContext)().run(runtimeContextAslKey, \"runtime\", fn);\n}\nfunction runOutsideActionRuntimeContext(fn) {\n  return (0, import_async_context.getAsyncContext)().run(runtimeContextAslKey, \"outside\", fn);\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=action.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL2FjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDJCQUEyQixtQkFBTyxDQUFDLGdHQUFvQjtBQUN2RCxtQkFBbUIsbUJBQU8sQ0FBQyxnRkFBWTtBQUN2QyxxQkFBcUIsbUJBQU8sQ0FBQyxvRkFBYztBQUMzQyxvQkFBb0IsbUJBQU8sQ0FBQyxrRkFBYTtBQUN6QyxxQkFBcUIsbUJBQU8sQ0FBQyxvRkFBYztBQUMzQyx5QkFBeUIsbUJBQU8sQ0FBQyw0RkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLHFCQUFxQixHQUFHLHFCQUFxQjtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGNBQWMsR0FBRyxjQUFjO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBY0w7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcY29yZVxcbGliXFxhY3Rpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIGFjdGlvbl9leHBvcnRzID0ge307XG5fX2V4cG9ydChhY3Rpb25fZXhwb3J0cywge1xuICBTdGF0dXNDb2RlczogKCkgPT4gaW1wb3J0X3N0YXR1c1R5cGVzLlN0YXR1c0NvZGVzLFxuICBTdGF0dXNTY2hlbWE6ICgpID0+IGltcG9ydF9zdGF0dXNUeXBlcy5TdGF0dXNTY2hlbWEsXG4gIGFjdGlvbjogKCkgPT4gYWN0aW9uLFxuICBhY3Rpb25XaXRoTWlkZGxld2FyZTogKCkgPT4gYWN0aW9uV2l0aE1pZGRsZXdhcmUsXG4gIGRlZmluZUFjdGlvbjogKCkgPT4gZGVmaW5lQWN0aW9uLFxuICBkZWZpbmVBY3Rpb25Bc3luYzogKCkgPT4gZGVmaW5lQWN0aW9uQXN5bmMsXG4gIGdldFN0cmVhbWluZ0NhbGxiYWNrOiAoKSA9PiBnZXRTdHJlYW1pbmdDYWxsYmFjayxcbiAgaXNBY3Rpb246ICgpID0+IGlzQWN0aW9uLFxuICBpc0luUnVudGltZUNvbnRleHQ6ICgpID0+IGlzSW5SdW50aW1lQ29udGV4dCxcbiAgcnVuSW5BY3Rpb25SdW50aW1lQ29udGV4dDogKCkgPT4gcnVuSW5BY3Rpb25SdW50aW1lQ29udGV4dCxcbiAgcnVuT3V0c2lkZUFjdGlvblJ1bnRpbWVDb250ZXh0OiAoKSA9PiBydW5PdXRzaWRlQWN0aW9uUnVudGltZUNvbnRleHQsXG4gIHJ1bldpdGhTdHJlYW1pbmdDYWxsYmFjazogKCkgPT4gcnVuV2l0aFN0cmVhbWluZ0NhbGxiYWNrLFxuICBzZW50aW5lbE5vb3BTdHJlYW1pbmdDYWxsYmFjazogKCkgPT4gc2VudGluZWxOb29wU3RyZWFtaW5nQ2FsbGJhY2tcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoYWN0aW9uX2V4cG9ydHMpO1xudmFyIGltcG9ydF9hc3luY19jb250ZXh0ID0gcmVxdWlyZShcIi4vYXN5bmMtY29udGV4dC5qc1wiKTtcbnZhciBpbXBvcnRfYXN5bmMgPSByZXF1aXJlKFwiLi9hc3luYy5qc1wiKTtcbnZhciBpbXBvcnRfY29udGV4dCA9IHJlcXVpcmUoXCIuL2NvbnRleHQuanNcIik7XG52YXIgaW1wb3J0X3NjaGVtYSA9IHJlcXVpcmUoXCIuL3NjaGVtYS5qc1wiKTtcbnZhciBpbXBvcnRfdHJhY2luZyA9IHJlcXVpcmUoXCIuL3RyYWNpbmcuanNcIik7XG52YXIgaW1wb3J0X3N0YXR1c1R5cGVzID0gcmVxdWlyZShcIi4vc3RhdHVzVHlwZXMuanNcIik7XG5jb25zdCBtYWtlTm9vcEFib3J0U2lnbmFsID0gKCkgPT4gbmV3IEFib3J0Q29udHJvbGxlcigpLnNpZ25hbDtcbmZ1bmN0aW9uIGFjdGlvbldpdGhNaWRkbGV3YXJlKGFjdGlvbjIsIG1pZGRsZXdhcmUpIHtcbiAgY29uc3Qgd3JhcHBlZCA9IGFzeW5jIChyZXEsIG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gKGF3YWl0IHdyYXBwZWQucnVuKHJlcSwgb3B0aW9ucykpLnJlc3VsdDtcbiAgfTtcbiAgd3JhcHBlZC5fX2FjdGlvbiA9IGFjdGlvbjIuX19hY3Rpb247XG4gIHdyYXBwZWQucnVuID0gYXN5bmMgKHJlcSwgb3B0aW9ucykgPT4ge1xuICAgIGxldCB0ZWxlbWV0cnk7XG4gICAgY29uc3QgZGlzcGF0Y2ggPSBhc3luYyAoaW5kZXgsIHJlcTIsIG9wdHMpID0+IHtcbiAgICAgIGlmIChpbmRleCA9PT0gbWlkZGxld2FyZS5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWN0aW9uMi5ydW4ocmVxMiwgb3B0cyk7XG4gICAgICAgIHRlbGVtZXRyeSA9IHJlc3VsdC50ZWxlbWV0cnk7XG4gICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudE1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlW2luZGV4XTtcbiAgICAgIGlmIChjdXJyZW50TWlkZGxld2FyZS5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRNaWRkbGV3YXJlKFxuICAgICAgICAgIHJlcTIsXG4gICAgICAgICAgb3B0cyxcbiAgICAgICAgICBhc3luYyAobW9kaWZpZWRSZXEsIG1vZGlmaWVkT3B0aW9ucykgPT4gZGlzcGF0Y2goaW5kZXggKyAxLCBtb2RpZmllZFJlcSB8fCByZXEyLCBtb2RpZmllZE9wdGlvbnMgfHwgb3B0cylcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudE1pZGRsZXdhcmUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50TWlkZGxld2FyZShcbiAgICAgICAgICByZXEyLFxuICAgICAgICAgIGFzeW5jIChtb2RpZmllZFJlcSkgPT4gZGlzcGF0Y2goaW5kZXggKyAxLCBtb2RpZmllZFJlcSB8fCByZXEyLCBvcHRzKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zcHBvcnRlZCBtaWRkbGV3YXJlIGZ1bmN0aW9uIHNoYXBlXCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgd3JhcHBlZC5zdHJlYW0gPSBhY3Rpb24yLnN0cmVhbTtcbiAgICByZXR1cm4geyByZXN1bHQ6IGF3YWl0IGRpc3BhdGNoKDAsIHJlcSwgb3B0aW9ucyksIHRlbGVtZXRyeSB9O1xuICB9O1xuICByZXR1cm4gd3JhcHBlZDtcbn1cbmZ1bmN0aW9uIGFjdGlvbihjb25maWcsIGZuKSB7XG4gIGNvbnN0IGFjdGlvbk5hbWUgPSB0eXBlb2YgY29uZmlnLm5hbWUgPT09IFwic3RyaW5nXCIgPyBjb25maWcubmFtZSA6IGAke2NvbmZpZy5uYW1lLnBsdWdpbklkfS8ke2NvbmZpZy5uYW1lLmFjdGlvbklkfWA7XG4gIGNvbnN0IGFjdGlvbk1ldGFkYXRhID0ge1xuICAgIG5hbWU6IGFjdGlvbk5hbWUsXG4gICAgZGVzY3JpcHRpb246IGNvbmZpZy5kZXNjcmlwdGlvbixcbiAgICBpbnB1dFNjaGVtYTogY29uZmlnLmlucHV0U2NoZW1hLFxuICAgIGlucHV0SnNvblNjaGVtYTogY29uZmlnLmlucHV0SnNvblNjaGVtYSxcbiAgICBvdXRwdXRTY2hlbWE6IGNvbmZpZy5vdXRwdXRTY2hlbWEsXG4gICAgb3V0cHV0SnNvblNjaGVtYTogY29uZmlnLm91dHB1dEpzb25TY2hlbWEsXG4gICAgc3RyZWFtU2NoZW1hOiBjb25maWcuc3RyZWFtU2NoZW1hLFxuICAgIG1ldGFkYXRhOiBjb25maWcubWV0YWRhdGEsXG4gICAgYWN0aW9uVHlwZTogY29uZmlnLmFjdGlvblR5cGVcbiAgfTtcbiAgY29uc3QgYWN0aW9uRm4gPSBhc3luYyAoaW5wdXQsIG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gKGF3YWl0IGFjdGlvbkZuLnJ1bihpbnB1dCwgb3B0aW9ucykpLnJlc3VsdDtcbiAgfTtcbiAgYWN0aW9uRm4uX19hY3Rpb24gPSB7IC4uLmFjdGlvbk1ldGFkYXRhIH07XG4gIGFjdGlvbkZuLnJ1biA9IGFzeW5jIChpbnB1dCwgb3B0aW9ucykgPT4ge1xuICAgIGlucHV0ID0gKDAsIGltcG9ydF9zY2hlbWEucGFyc2VTY2hlbWEpKGlucHV0LCB7XG4gICAgICBzY2hlbWE6IGNvbmZpZy5pbnB1dFNjaGVtYSxcbiAgICAgIGpzb25TY2hlbWE6IGNvbmZpZy5pbnB1dEpzb25TY2hlbWFcbiAgICB9KTtcbiAgICBsZXQgdHJhY2VJZDtcbiAgICBsZXQgc3BhbklkO1xuICAgIGxldCBvdXRwdXQgPSBhd2FpdCAoMCwgaW1wb3J0X3RyYWNpbmcucnVuSW5OZXdTcGFuKShcbiAgICAgIHtcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBuYW1lOiBhY3Rpb25OYW1lXG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsczoge1xuICAgICAgICAgIFtpbXBvcnRfdHJhY2luZy5TUEFOX1RZUEVfQVRUUl06IFwiYWN0aW9uXCIsXG4gICAgICAgICAgXCJnZW5raXQ6bWV0YWRhdGE6c3VidHlwZVwiOiBjb25maWcuYWN0aW9uVHlwZSxcbiAgICAgICAgICAuLi5vcHRpb25zPy50ZWxlbWV0cnlMYWJlbHNcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFzeW5jIChtZXRhZGF0YSwgc3BhbikgPT4ge1xuICAgICAgICAoMCwgaW1wb3J0X3RyYWNpbmcuc2V0Q3VzdG9tTWV0YWRhdGFBdHRyaWJ1dGVzKSh7XG4gICAgICAgICAgc3VidHlwZTogY29uZmlnLmFjdGlvblR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcHRpb25zPy5jb250ZXh0KSB7XG4gICAgICAgICAgKDAsIGltcG9ydF90cmFjaW5nLnNldEN1c3RvbU1ldGFkYXRhQXR0cmlidXRlcykoe1xuICAgICAgICAgICAgY29udGV4dDogSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5jb250ZXh0KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNlSWQgPSBzcGFuLnNwYW5Db250ZXh0KCkudHJhY2VJZDtcbiAgICAgICAgc3BhbklkID0gc3Bhbi5zcGFuQ29udGV4dCgpLnNwYW5JZDtcbiAgICAgICAgbWV0YWRhdGEubmFtZSA9IGFjdGlvbk5hbWU7XG4gICAgICAgIG1ldGFkYXRhLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgYWN0Rm4gPSAoKSA9PiBmbihpbnB1dCwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIC8vIENvbnRleHQgY2FuIGVpdGhlciBiZSBleHBsaWNpdGx5IHNldCwgb3IgaW5oZXJpdGVkIGZyb20gdGhlIHBhcmVudCBhY3Rpb24uXG4gICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgIC4uLmFjdGlvbkZuLl9fcmVnaXN0cnk/LmNvbnRleHQsXG4gICAgICAgICAgICAgIC4uLm9wdGlvbnM/LmNvbnRleHQgPz8gKDAsIGltcG9ydF9jb250ZXh0LmdldENvbnRleHQpKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHJlYW1pbmdSZXF1ZXN0ZWQ6ICEhb3B0aW9ucz8ub25DaHVuayAmJiBvcHRpb25zLm9uQ2h1bmsgIT09IHNlbnRpbmVsTm9vcFN0cmVhbWluZ0NhbGxiYWNrLFxuICAgICAgICAgICAgc2VuZENodW5rOiBvcHRpb25zPy5vbkNodW5rID8/IHNlbnRpbmVsTm9vcFN0cmVhbWluZ0NhbGxiYWNrLFxuICAgICAgICAgICAgdHJhY2U6IHtcbiAgICAgICAgICAgICAgdHJhY2VJZCxcbiAgICAgICAgICAgICAgc3BhbklkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVnaXN0cnk6IGFjdGlvbkZuLl9fcmVnaXN0cnksXG4gICAgICAgICAgICBhYm9ydFNpZ25hbDogb3B0aW9ucz8uYWJvcnRTaWduYWwgPz8gbWFrZU5vb3BBYm9ydFNpZ25hbCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3Qgb3V0cHV0MiA9IGF3YWl0ICgwLCBpbXBvcnRfY29udGV4dC5ydW5XaXRoQ29udGV4dCkob3B0aW9ucz8uY29udGV4dCwgYWN0Rm4pO1xuICAgICAgICAgIG1ldGFkYXRhLm91dHB1dCA9IEpTT04uc3RyaW5naWZ5KG91dHB1dDIpO1xuICAgICAgICAgIHJldHVybiBvdXRwdXQyO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGVyciA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgZXJyLnRyYWNlSWQgPSB0cmFjZUlkO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIG91dHB1dCA9ICgwLCBpbXBvcnRfc2NoZW1hLnBhcnNlU2NoZW1hKShvdXRwdXQsIHtcbiAgICAgIHNjaGVtYTogY29uZmlnLm91dHB1dFNjaGVtYSxcbiAgICAgIGpzb25TY2hlbWE6IGNvbmZpZy5vdXRwdXRKc29uU2NoZW1hXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogb3V0cHV0LFxuICAgICAgdGVsZW1ldHJ5OiB7XG4gICAgICAgIHRyYWNlSWQsXG4gICAgICAgIHNwYW5JZFxuICAgICAgfVxuICAgIH07XG4gIH07XG4gIGFjdGlvbkZuLnN0cmVhbSA9IChpbnB1dCwgb3B0cykgPT4ge1xuICAgIGxldCBjaHVua1N0cmVhbUNvbnRyb2xsZXI7XG4gICAgY29uc3QgY2h1bmtTdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICBjaHVua1N0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgfSxcbiAgICAgIHB1bGwoKSB7XG4gICAgICB9LFxuICAgICAgY2FuY2VsKCkge1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGludm9jYXRpb25Qcm9taXNlID0gYWN0aW9uRm4ucnVuKGNvbmZpZy5pbnB1dFNjaGVtYSA/IGNvbmZpZy5pbnB1dFNjaGVtYS5wYXJzZShpbnB1dCkgOiBpbnB1dCwge1xuICAgICAgb25DaHVuazogKGNodW5rKSA9PiB7XG4gICAgICAgIGNodW5rU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgIH0sXG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIC4uLmFjdGlvbkZuLl9fcmVnaXN0cnk/LmNvbnRleHQsXG4gICAgICAgIC4uLm9wdHM/LmNvbnRleHQgPz8gKDAsIGltcG9ydF9jb250ZXh0LmdldENvbnRleHQpKClcbiAgICAgIH0sXG4gICAgICBhYm9ydFNpZ25hbDogb3B0cz8uYWJvcnRTaWduYWwsXG4gICAgICB0ZWxlbWV0cnlMYWJlbHM6IG9wdHM/LnRlbGVtZXRyeUxhYmVsc1xuICAgIH0pLnRoZW4oKHMpID0+IHMucmVzdWx0KS5maW5hbGx5KCgpID0+IHtcbiAgICAgIGNodW5rU3RyZWFtQ29udHJvbGxlci5jbG9zZSgpO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBvdXRwdXQ6IGludm9jYXRpb25Qcm9taXNlLFxuICAgICAgc3RyZWFtOiBhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBjaHVua1N0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCBjaHVuayA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKGNodW5rLnZhbHVlKSB7XG4gICAgICAgICAgICB5aWVsZCBjaHVuay52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNodW5rLmRvbmUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgaW52b2NhdGlvblByb21pc2U7XG4gICAgICB9KClcbiAgICB9O1xuICB9O1xuICBpZiAoY29uZmlnLnVzZSkge1xuICAgIHJldHVybiBhY3Rpb25XaXRoTWlkZGxld2FyZShhY3Rpb25GbiwgY29uZmlnLnVzZSk7XG4gIH1cbiAgcmV0dXJuIGFjdGlvbkZuO1xufVxuZnVuY3Rpb24gaXNBY3Rpb24oYSkge1xuICByZXR1cm4gdHlwZW9mIGEgPT09IFwiZnVuY3Rpb25cIiAmJiBcIl9fYWN0aW9uXCIgaW4gYTtcbn1cbmZ1bmN0aW9uIGRlZmluZUFjdGlvbihyZWdpc3RyeSwgY29uZmlnLCBmbikge1xuICBpZiAoaXNJblJ1bnRpbWVDb250ZXh0KCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkNhbm5vdCBkZWZpbmUgbmV3IGFjdGlvbnMgYXQgcnVudGltZS5cXG5TZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9maXJlYmFzZS9nZW5raXQvYmxvYi9tYWluL2RvY3MvZXJyb3JzL25vX25ld19hY3Rpb25zX2F0X3J1bnRpbWUubWRcIlxuICAgICk7XG4gIH1cbiAgY29uc3QgYWN0ID0gYWN0aW9uKGNvbmZpZywgYXN5bmMgKGksIG9wdGlvbnMpID0+IHtcbiAgICBhd2FpdCByZWdpc3RyeS5pbml0aWFsaXplQWxsUGx1Z2lucygpO1xuICAgIHJldHVybiBhd2FpdCBydW5JbkFjdGlvblJ1bnRpbWVDb250ZXh0KCgpID0+IGZuKGksIG9wdGlvbnMpKTtcbiAgfSk7XG4gIGFjdC5fX2FjdGlvbi5hY3Rpb25UeXBlID0gY29uZmlnLmFjdGlvblR5cGU7XG4gIHJlZ2lzdHJ5LnJlZ2lzdGVyQWN0aW9uKGNvbmZpZy5hY3Rpb25UeXBlLCBhY3QpO1xuICByZXR1cm4gYWN0O1xufVxuZnVuY3Rpb24gZGVmaW5lQWN0aW9uQXN5bmMocmVnaXN0cnksIGFjdGlvblR5cGUsIG5hbWUsIGNvbmZpZywgb25Jbml0KSB7XG4gIGNvbnN0IGFjdGlvbk5hbWUgPSB0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiA/IG5hbWUgOiBgJHtuYW1lLnBsdWdpbklkfS8ke25hbWUuYWN0aW9uSWR9YDtcbiAgY29uc3QgYWN0aW9uUHJvbWlzZSA9ICgwLCBpbXBvcnRfYXN5bmMubGF6eSkoXG4gICAgKCkgPT4gY29uZmlnLnRoZW4oKHJlc29sdmVkQ29uZmlnKSA9PiB7XG4gICAgICBjb25zdCBhY3QgPSBhY3Rpb24oXG4gICAgICAgIHJlc29sdmVkQ29uZmlnLFxuICAgICAgICBhc3luYyAoaSwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgIGF3YWl0IHJlZ2lzdHJ5LmluaXRpYWxpemVBbGxQbHVnaW5zKCk7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHJ1bkluQWN0aW9uUnVudGltZUNvbnRleHQoXG4gICAgICAgICAgICAoKSA9PiByZXNvbHZlZENvbmZpZy5mbihpLCBvcHRpb25zKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBhY3QuX19hY3Rpb24uYWN0aW9uVHlwZSA9IGFjdGlvblR5cGU7XG4gICAgICBvbkluaXQ/LihhY3QpO1xuICAgICAgcmV0dXJuIGFjdDtcbiAgICB9KVxuICApO1xuICByZWdpc3RyeS5yZWdpc3RlckFjdGlvbkFzeW5jKGFjdGlvblR5cGUsIGFjdGlvbk5hbWUsIGFjdGlvblByb21pc2UpO1xuICByZXR1cm4gYWN0aW9uUHJvbWlzZTtcbn1cbmNvbnN0IHN0cmVhbWluZ0Fsc0tleSA9IFwiY29yZS5hY3Rpb24uc3RyZWFtaW5nQ2FsbGJhY2tcIjtcbmNvbnN0IHNlbnRpbmVsTm9vcFN0cmVhbWluZ0NhbGxiYWNrID0gKCkgPT4gbnVsbDtcbmZ1bmN0aW9uIHJ1bldpdGhTdHJlYW1pbmdDYWxsYmFjayhzdHJlYW1pbmdDYWxsYmFjaywgZm4pIHtcbiAgcmV0dXJuICgwLCBpbXBvcnRfYXN5bmNfY29udGV4dC5nZXRBc3luY0NvbnRleHQpKCkucnVuKFxuICAgIHN0cmVhbWluZ0Fsc0tleSxcbiAgICBzdHJlYW1pbmdDYWxsYmFjayB8fCBzZW50aW5lbE5vb3BTdHJlYW1pbmdDYWxsYmFjayxcbiAgICBmblxuICApO1xufVxuZnVuY3Rpb24gZ2V0U3RyZWFtaW5nQ2FsbGJhY2soKSB7XG4gIGNvbnN0IGNiID0gKDAsIGltcG9ydF9hc3luY19jb250ZXh0LmdldEFzeW5jQ29udGV4dCkoKS5nZXRTdG9yZShzdHJlYW1pbmdBbHNLZXkpO1xuICBpZiAoY2IgPT09IHNlbnRpbmVsTm9vcFN0cmVhbWluZ0NhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gY2I7XG59XG5jb25zdCBydW50aW1lQ29udGV4dEFzbEtleSA9IFwiY29yZS5hY3Rpb24ucnVudGltZUNvbnRleHRcIjtcbmZ1bmN0aW9uIGlzSW5SdW50aW1lQ29udGV4dCgpIHtcbiAgcmV0dXJuICgwLCBpbXBvcnRfYXN5bmNfY29udGV4dC5nZXRBc3luY0NvbnRleHQpKCkuZ2V0U3RvcmUocnVudGltZUNvbnRleHRBc2xLZXkpID09PSBcInJ1bnRpbWVcIjtcbn1cbmZ1bmN0aW9uIHJ1bkluQWN0aW9uUnVudGltZUNvbnRleHQoZm4pIHtcbiAgcmV0dXJuICgwLCBpbXBvcnRfYXN5bmNfY29udGV4dC5nZXRBc3luY0NvbnRleHQpKCkucnVuKHJ1bnRpbWVDb250ZXh0QXNsS2V5LCBcInJ1bnRpbWVcIiwgZm4pO1xufVxuZnVuY3Rpb24gcnVuT3V0c2lkZUFjdGlvblJ1bnRpbWVDb250ZXh0KGZuKSB7XG4gIHJldHVybiAoMCwgaW1wb3J0X2FzeW5jX2NvbnRleHQuZ2V0QXN5bmNDb250ZXh0KSgpLnJ1bihydW50aW1lQ29udGV4dEFzbEtleSwgXCJvdXRzaWRlXCIsIGZuKTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBTdGF0dXNDb2RlcyxcbiAgU3RhdHVzU2NoZW1hLFxuICBhY3Rpb24sXG4gIGFjdGlvbldpdGhNaWRkbGV3YXJlLFxuICBkZWZpbmVBY3Rpb24sXG4gIGRlZmluZUFjdGlvbkFzeW5jLFxuICBnZXRTdHJlYW1pbmdDYWxsYmFjayxcbiAgaXNBY3Rpb24sXG4gIGlzSW5SdW50aW1lQ29udGV4dCxcbiAgcnVuSW5BY3Rpb25SdW50aW1lQ29udGV4dCxcbiAgcnVuT3V0c2lkZUFjdGlvblJ1bnRpbWVDb250ZXh0LFxuICBydW5XaXRoU3RyZWFtaW5nQ2FsbGJhY2ssXG4gIHNlbnRpbmVsTm9vcFN0cmVhbWluZ0NhbGxiYWNrXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/action.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/async-context.js":
/*!***********************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/async-context.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar async_context_exports = {};\n__export(async_context_exports, {\n  getAsyncContext: () => getAsyncContext,\n  setAsyncContext: () => setAsyncContext\n});\nmodule.exports = __toCommonJS(async_context_exports);\nvar import_error = __webpack_require__(/*! ./error.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/error.js\");\nconst asyncContextKey = \"__genkit_AsyncContext\";\nfunction getAsyncContext() {\n  if (!global[asyncContextKey]) {\n    throw new import_error.GenkitError({\n      status: \"FAILED_PRECONDITION\",\n      message: \"Async context is not initialized.\"\n    });\n  }\n  return global[asyncContextKey];\n}\nfunction setAsyncContext(context) {\n  if (global[asyncContextKey]) return;\n  global[asyncContextKey] = context;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=async-context.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL2FzeW5jLWNvbnRleHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLGdGQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUdMO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcS1JhbWFjaGFcXERvY3VtZW50c1xcU3VzdEFJbmV4IEdJdCBDb2RlXFxub2RlX21vZHVsZXNcXEBnZW5raXQtYWlcXGNvcmVcXGxpYlxcYXN5bmMtY29udGV4dC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgYXN5bmNfY29udGV4dF9leHBvcnRzID0ge307XG5fX2V4cG9ydChhc3luY19jb250ZXh0X2V4cG9ydHMsIHtcbiAgZ2V0QXN5bmNDb250ZXh0OiAoKSA9PiBnZXRBc3luY0NvbnRleHQsXG4gIHNldEFzeW5jQ29udGV4dDogKCkgPT4gc2V0QXN5bmNDb250ZXh0XG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKGFzeW5jX2NvbnRleHRfZXhwb3J0cyk7XG52YXIgaW1wb3J0X2Vycm9yID0gcmVxdWlyZShcIi4vZXJyb3IuanNcIik7XG5jb25zdCBhc3luY0NvbnRleHRLZXkgPSBcIl9fZ2Vua2l0X0FzeW5jQ29udGV4dFwiO1xuZnVuY3Rpb24gZ2V0QXN5bmNDb250ZXh0KCkge1xuICBpZiAoIWdsb2JhbFthc3luY0NvbnRleHRLZXldKSB7XG4gICAgdGhyb3cgbmV3IGltcG9ydF9lcnJvci5HZW5raXRFcnJvcih7XG4gICAgICBzdGF0dXM6IFwiRkFJTEVEX1BSRUNPTkRJVElPTlwiLFxuICAgICAgbWVzc2FnZTogXCJBc3luYyBjb250ZXh0IGlzIG5vdCBpbml0aWFsaXplZC5cIlxuICAgIH0pO1xuICB9XG4gIHJldHVybiBnbG9iYWxbYXN5bmNDb250ZXh0S2V5XTtcbn1cbmZ1bmN0aW9uIHNldEFzeW5jQ29udGV4dChjb250ZXh0KSB7XG4gIGlmIChnbG9iYWxbYXN5bmNDb250ZXh0S2V5XSkgcmV0dXJuO1xuICBnbG9iYWxbYXN5bmNDb250ZXh0S2V5XSA9IGNvbnRleHQ7XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0QXN5bmNDb250ZXh0LFxuICBzZXRBc3luY0NvbnRleHRcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXN5bmMtY29udGV4dC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/async-context.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/async.js":
/*!***************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/async.js ***!
  \***************************************************/
/***/ ((module) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar async_exports = {};\n__export(async_exports, {\n  Channel: () => Channel,\n  LazyPromise: () => LazyPromise,\n  lazy: () => lazy\n});\nmodule.exports = __toCommonJS(async_exports);\nfunction createTask() {\n  let resolve, reject;\n  const promise = new Promise(\n    (res, rej) => [resolve, reject] = [res, rej]\n  );\n  return {\n    resolve,\n    reject,\n    promise\n  };\n}\nclass Channel {\n  ready = createTask();\n  buffer = [];\n  err = null;\n  send(value) {\n    this.buffer.push(value);\n    this.ready.resolve();\n  }\n  close() {\n    this.buffer.push(null);\n    this.ready.resolve();\n  }\n  error(err) {\n    this.err = err;\n    this.ready.reject(err);\n  }\n  [Symbol.asyncIterator]() {\n    return {\n      next: async () => {\n        if (this.err) {\n          throw this.err;\n        }\n        if (!this.buffer.length) {\n          await this.ready.promise;\n        }\n        const value = this.buffer.shift();\n        if (!this.buffer.length) {\n          this.ready = createTask();\n        }\n        return {\n          value,\n          done: !value\n        };\n      }\n    };\n  }\n}\nclass LazyPromise {\n  executor;\n  promise;\n  constructor(executor) {\n    this.executor = executor;\n  }\n  then(onfulfilled, onrejected) {\n    this.promise ??= new Promise(this.executor);\n    return this.promise.then(onfulfilled, onrejected);\n  }\n}\nfunction lazy(fn) {\n  return new LazyPromise((resolve, reject) => {\n    try {\n      resolve(fn());\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=async.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL2FzeW5jLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLENBSUw7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcY29yZVxcbGliXFxhc3luYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgYXN5bmNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoYXN5bmNfZXhwb3J0cywge1xuICBDaGFubmVsOiAoKSA9PiBDaGFubmVsLFxuICBMYXp5UHJvbWlzZTogKCkgPT4gTGF6eVByb21pc2UsXG4gIGxhenk6ICgpID0+IGxhenlcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoYXN5bmNfZXhwb3J0cyk7XG5mdW5jdGlvbiBjcmVhdGVUYXNrKCkge1xuICBsZXQgcmVzb2x2ZSwgcmVqZWN0O1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoXG4gICAgKHJlcywgcmVqKSA9PiBbcmVzb2x2ZSwgcmVqZWN0XSA9IFtyZXMsIHJlal1cbiAgKTtcbiAgcmV0dXJuIHtcbiAgICByZXNvbHZlLFxuICAgIHJlamVjdCxcbiAgICBwcm9taXNlXG4gIH07XG59XG5jbGFzcyBDaGFubmVsIHtcbiAgcmVhZHkgPSBjcmVhdGVUYXNrKCk7XG4gIGJ1ZmZlciA9IFtdO1xuICBlcnIgPSBudWxsO1xuICBzZW5kKHZhbHVlKSB7XG4gICAgdGhpcy5idWZmZXIucHVzaCh2YWx1ZSk7XG4gICAgdGhpcy5yZWFkeS5yZXNvbHZlKCk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5idWZmZXIucHVzaChudWxsKTtcbiAgICB0aGlzLnJlYWR5LnJlc29sdmUoKTtcbiAgfVxuICBlcnJvcihlcnIpIHtcbiAgICB0aGlzLmVyciA9IGVycjtcbiAgICB0aGlzLnJlYWR5LnJlamVjdChlcnIpO1xuICB9XG4gIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuZXJyKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5lcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnJlYWR5LnByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmJ1ZmZlci5zaGlmdCgpO1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMucmVhZHkgPSBjcmVhdGVUYXNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBkb25lOiAhdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5jbGFzcyBMYXp5UHJvbWlzZSB7XG4gIGV4ZWN1dG9yO1xuICBwcm9taXNlO1xuICBjb25zdHJ1Y3RvcihleGVjdXRvcikge1xuICAgIHRoaXMuZXhlY3V0b3IgPSBleGVjdXRvcjtcbiAgfVxuICB0aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKSB7XG4gICAgdGhpcy5wcm9taXNlID8/PSBuZXcgUHJvbWlzZSh0aGlzLmV4ZWN1dG9yKTtcbiAgICByZXR1cm4gdGhpcy5wcm9taXNlLnRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpO1xuICB9XG59XG5mdW5jdGlvbiBsYXp5KGZuKSB7XG4gIHJldHVybiBuZXcgTGF6eVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXNvbHZlKGZuKCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlamVjdChlKTtcbiAgICB9XG4gIH0pO1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIENoYW5uZWwsXG4gIExhenlQcm9taXNlLFxuICBsYXp5XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzeW5jLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/async.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/background-action.js":
/*!***************************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/background-action.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar background_action_exports = {};\n__export(background_action_exports, {\n  OperationSchema: () => OperationSchema,\n  backgroundAction: () => backgroundAction,\n  defineBackgroundAction: () => defineBackgroundAction,\n  isBackgroundAction: () => isBackgroundAction,\n  lookupBackgroundAction: () => lookupBackgroundAction,\n  registerBackgroundAction: () => registerBackgroundAction\n});\nmodule.exports = __toCommonJS(background_action_exports);\nvar z = __toESM(__webpack_require__(/*! zod */ \"(action-browser)/./node_modules/zod/lib/index.js\"));\nvar import_action = __webpack_require__(/*! ./action.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/action.js\");\nvar import_error = __webpack_require__(/*! ./error.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/error.js\");\nvar import_schema = __webpack_require__(/*! ./schema.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/schema.js\");\nconst OperationSchema = z.object({\n  action: z.string().optional(),\n  id: z.string(),\n  done: z.boolean().optional(),\n  output: z.any().optional(),\n  error: z.object({ message: z.string() }).passthrough().optional(),\n  metadata: z.record(z.string(), z.any()).optional()\n});\nasync function lookupBackgroundAction(registry, key) {\n  const root = await registry.lookupAction(key);\n  if (!root) return void 0;\n  const actionName = key.substring(key.indexOf(\"/\", 1) + 1);\n  return new BackgroundActionImpl(\n    root,\n    await registry.lookupAction(`/check-operation/${actionName}/check`),\n    await registry.lookupAction(`/cancel-operation/${actionName}/cancel`)\n  );\n}\nclass BackgroundActionImpl {\n  __action;\n  startAction;\n  checkAction;\n  cancelAction;\n  constructor(startAction, checkAction, cancelAction) {\n    this.__action = {\n      name: startAction.__action.name,\n      description: startAction.__action.description,\n      inputSchema: startAction.__action.inputSchema,\n      inputJsonSchema: startAction.__action.inputJsonSchema,\n      metadata: startAction.__action.metadata,\n      actionType: startAction.__action.actionType\n    };\n    this.startAction = startAction;\n    this.checkAction = checkAction;\n    this.cancelAction = cancelAction;\n  }\n  async start(input, options) {\n    return await this.startAction(input, options);\n  }\n  async check(operation) {\n    return await this.checkAction(operation);\n  }\n  get supportsCancel() {\n    return !!this.cancelAction;\n  }\n  async cancel(operation) {\n    if (!this.cancelAction) {\n      return operation;\n    }\n    return await this.cancelAction(operation);\n  }\n}\nfunction defineBackgroundAction(registry, config) {\n  const act = backgroundAction(config);\n  registerBackgroundAction(registry, act);\n  return act;\n}\nfunction registerBackgroundAction(registry, act, opts) {\n  registry.registerAction(\n    act.startAction.__action.actionType,\n    act.startAction,\n    opts\n  );\n  registry.registerAction(\n    act.checkAction.__action.actionType,\n    act.checkAction,\n    opts\n  );\n  if (act.cancelAction) {\n    registry.registerAction(\n      act.cancelAction.__action.actionType,\n      act.cancelAction,\n      opts\n    );\n  }\n}\nfunction backgroundAction(config) {\n  const startAction = (0, import_action.action)(\n    {\n      actionType: config.actionType,\n      name: config.name,\n      description: config.description,\n      inputSchema: config.inputSchema,\n      inputJsonSchema: config.inputJsonSchema,\n      outputSchema: OperationSchema,\n      metadata: {\n        ...config.metadata,\n        outputSchema: (0, import_schema.toJsonSchema)({\n          schema: config.outputSchema,\n          jsonSchema: config.outputJsonSchema\n        })\n      },\n      use: config.use\n    },\n    async (input, options) => {\n      const operation = await config.start(input, options);\n      operation.action = `/${config.actionType}/${config.name}`;\n      return operation;\n    }\n  );\n  const checkAction = (0, import_action.action)(\n    {\n      actionType: \"check-operation\",\n      name: `${config.name}/check`,\n      description: config.description,\n      inputSchema: OperationSchema,\n      inputJsonSchema: config.inputJsonSchema,\n      outputSchema: OperationSchema,\n      metadata: {\n        ...config.metadata,\n        outputSchema: (0, import_schema.toJsonSchema)({\n          schema: config.outputSchema,\n          jsonSchema: config.outputJsonSchema\n        })\n      }\n    },\n    async (input) => {\n      const operation = await config.check(input);\n      operation.action = `/${config.actionType}/${config.name}`;\n      return operation;\n    }\n  );\n  let cancelAction = void 0;\n  if (config.cancel) {\n    cancelAction = (0, import_action.action)(\n      {\n        actionType: \"cancel-operation\",\n        name: `${config.name}/cancel`,\n        description: config.description,\n        inputSchema: OperationSchema,\n        inputJsonSchema: config.inputJsonSchema,\n        outputSchema: OperationSchema,\n        metadata: {\n          ...config.metadata,\n          outputSchema: (0, import_schema.toJsonSchema)({\n            schema: config.outputSchema,\n            jsonSchema: config.outputJsonSchema\n          })\n        }\n      },\n      async (input) => {\n        if (!config.cancel) {\n          throw new import_error.GenkitError({\n            status: \"UNAVAILABLE\",\n            message: `${config.name} does not support cancellation.`\n          });\n        }\n        const operation = await config.cancel(input);\n        operation.action = `/${config.actionType}/${config.name}`;\n        return operation;\n      }\n    );\n  }\n  return new BackgroundActionImpl(startAction, checkAction, cancelAction);\n}\nfunction isBackgroundAction(a) {\n  return a instanceof BackgroundActionImpl;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=background-action.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL2JhY2tncm91bmQtYWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDhCQUE4QjtBQUN2RztBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyw2REFBSztBQUM3QixvQkFBb0IsbUJBQU8sQ0FBQyxrRkFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyxnRkFBWTtBQUN2QyxvQkFBb0IsbUJBQU8sQ0FBQyxrRkFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsV0FBVztBQUMvRCxxREFBcUQsV0FBVztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkJBQTZCLGtCQUFrQixHQUFHLFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkJBQTZCLGtCQUFrQixHQUFHLFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDLFdBQVc7QUFDWDtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQixHQUFHLFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBT0w7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcY29yZVxcbGliXFxiYWNrZ3JvdW5kLWFjdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgYmFja2dyb3VuZF9hY3Rpb25fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoYmFja2dyb3VuZF9hY3Rpb25fZXhwb3J0cywge1xuICBPcGVyYXRpb25TY2hlbWE6ICgpID0+IE9wZXJhdGlvblNjaGVtYSxcbiAgYmFja2dyb3VuZEFjdGlvbjogKCkgPT4gYmFja2dyb3VuZEFjdGlvbixcbiAgZGVmaW5lQmFja2dyb3VuZEFjdGlvbjogKCkgPT4gZGVmaW5lQmFja2dyb3VuZEFjdGlvbixcbiAgaXNCYWNrZ3JvdW5kQWN0aW9uOiAoKSA9PiBpc0JhY2tncm91bmRBY3Rpb24sXG4gIGxvb2t1cEJhY2tncm91bmRBY3Rpb246ICgpID0+IGxvb2t1cEJhY2tncm91bmRBY3Rpb24sXG4gIHJlZ2lzdGVyQmFja2dyb3VuZEFjdGlvbjogKCkgPT4gcmVnaXN0ZXJCYWNrZ3JvdW5kQWN0aW9uXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKGJhY2tncm91bmRfYWN0aW9uX2V4cG9ydHMpO1xudmFyIHogPSBfX3RvRVNNKHJlcXVpcmUoXCJ6b2RcIikpO1xudmFyIGltcG9ydF9hY3Rpb24gPSByZXF1aXJlKFwiLi9hY3Rpb24uanNcIik7XG52YXIgaW1wb3J0X2Vycm9yID0gcmVxdWlyZShcIi4vZXJyb3IuanNcIik7XG52YXIgaW1wb3J0X3NjaGVtYSA9IHJlcXVpcmUoXCIuL3NjaGVtYS5qc1wiKTtcbmNvbnN0IE9wZXJhdGlvblNjaGVtYSA9IHoub2JqZWN0KHtcbiAgYWN0aW9uOiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIGlkOiB6LnN0cmluZygpLFxuICBkb25lOiB6LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICBvdXRwdXQ6IHouYW55KCkub3B0aW9uYWwoKSxcbiAgZXJyb3I6IHoub2JqZWN0KHsgbWVzc2FnZTogei5zdHJpbmcoKSB9KS5wYXNzdGhyb3VnaCgpLm9wdGlvbmFsKCksXG4gIG1ldGFkYXRhOiB6LnJlY29yZCh6LnN0cmluZygpLCB6LmFueSgpKS5vcHRpb25hbCgpXG59KTtcbmFzeW5jIGZ1bmN0aW9uIGxvb2t1cEJhY2tncm91bmRBY3Rpb24ocmVnaXN0cnksIGtleSkge1xuICBjb25zdCByb290ID0gYXdhaXQgcmVnaXN0cnkubG9va3VwQWN0aW9uKGtleSk7XG4gIGlmICghcm9vdCkgcmV0dXJuIHZvaWQgMDtcbiAgY29uc3QgYWN0aW9uTmFtZSA9IGtleS5zdWJzdHJpbmcoa2V5LmluZGV4T2YoXCIvXCIsIDEpICsgMSk7XG4gIHJldHVybiBuZXcgQmFja2dyb3VuZEFjdGlvbkltcGwoXG4gICAgcm9vdCxcbiAgICBhd2FpdCByZWdpc3RyeS5sb29rdXBBY3Rpb24oYC9jaGVjay1vcGVyYXRpb24vJHthY3Rpb25OYW1lfS9jaGVja2ApLFxuICAgIGF3YWl0IHJlZ2lzdHJ5Lmxvb2t1cEFjdGlvbihgL2NhbmNlbC1vcGVyYXRpb24vJHthY3Rpb25OYW1lfS9jYW5jZWxgKVxuICApO1xufVxuY2xhc3MgQmFja2dyb3VuZEFjdGlvbkltcGwge1xuICBfX2FjdGlvbjtcbiAgc3RhcnRBY3Rpb247XG4gIGNoZWNrQWN0aW9uO1xuICBjYW5jZWxBY3Rpb247XG4gIGNvbnN0cnVjdG9yKHN0YXJ0QWN0aW9uLCBjaGVja0FjdGlvbiwgY2FuY2VsQWN0aW9uKSB7XG4gICAgdGhpcy5fX2FjdGlvbiA9IHtcbiAgICAgIG5hbWU6IHN0YXJ0QWN0aW9uLl9fYWN0aW9uLm5hbWUsXG4gICAgICBkZXNjcmlwdGlvbjogc3RhcnRBY3Rpb24uX19hY3Rpb24uZGVzY3JpcHRpb24sXG4gICAgICBpbnB1dFNjaGVtYTogc3RhcnRBY3Rpb24uX19hY3Rpb24uaW5wdXRTY2hlbWEsXG4gICAgICBpbnB1dEpzb25TY2hlbWE6IHN0YXJ0QWN0aW9uLl9fYWN0aW9uLmlucHV0SnNvblNjaGVtYSxcbiAgICAgIG1ldGFkYXRhOiBzdGFydEFjdGlvbi5fX2FjdGlvbi5tZXRhZGF0YSxcbiAgICAgIGFjdGlvblR5cGU6IHN0YXJ0QWN0aW9uLl9fYWN0aW9uLmFjdGlvblR5cGVcbiAgICB9O1xuICAgIHRoaXMuc3RhcnRBY3Rpb24gPSBzdGFydEFjdGlvbjtcbiAgICB0aGlzLmNoZWNrQWN0aW9uID0gY2hlY2tBY3Rpb247XG4gICAgdGhpcy5jYW5jZWxBY3Rpb24gPSBjYW5jZWxBY3Rpb247XG4gIH1cbiAgYXN5bmMgc3RhcnQoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zdGFydEFjdGlvbihpbnB1dCwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgY2hlY2sob3BlcmF0aW9uKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY2hlY2tBY3Rpb24ob3BlcmF0aW9uKTtcbiAgfVxuICBnZXQgc3VwcG9ydHNDYW5jZWwoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5jYW5jZWxBY3Rpb247XG4gIH1cbiAgYXN5bmMgY2FuY2VsKG9wZXJhdGlvbikge1xuICAgIGlmICghdGhpcy5jYW5jZWxBY3Rpb24pIHtcbiAgICAgIHJldHVybiBvcGVyYXRpb247XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLmNhbmNlbEFjdGlvbihvcGVyYXRpb24pO1xuICB9XG59XG5mdW5jdGlvbiBkZWZpbmVCYWNrZ3JvdW5kQWN0aW9uKHJlZ2lzdHJ5LCBjb25maWcpIHtcbiAgY29uc3QgYWN0ID0gYmFja2dyb3VuZEFjdGlvbihjb25maWcpO1xuICByZWdpc3RlckJhY2tncm91bmRBY3Rpb24ocmVnaXN0cnksIGFjdCk7XG4gIHJldHVybiBhY3Q7XG59XG5mdW5jdGlvbiByZWdpc3RlckJhY2tncm91bmRBY3Rpb24ocmVnaXN0cnksIGFjdCwgb3B0cykge1xuICByZWdpc3RyeS5yZWdpc3RlckFjdGlvbihcbiAgICBhY3Quc3RhcnRBY3Rpb24uX19hY3Rpb24uYWN0aW9uVHlwZSxcbiAgICBhY3Quc3RhcnRBY3Rpb24sXG4gICAgb3B0c1xuICApO1xuICByZWdpc3RyeS5yZWdpc3RlckFjdGlvbihcbiAgICBhY3QuY2hlY2tBY3Rpb24uX19hY3Rpb24uYWN0aW9uVHlwZSxcbiAgICBhY3QuY2hlY2tBY3Rpb24sXG4gICAgb3B0c1xuICApO1xuICBpZiAoYWN0LmNhbmNlbEFjdGlvbikge1xuICAgIHJlZ2lzdHJ5LnJlZ2lzdGVyQWN0aW9uKFxuICAgICAgYWN0LmNhbmNlbEFjdGlvbi5fX2FjdGlvbi5hY3Rpb25UeXBlLFxuICAgICAgYWN0LmNhbmNlbEFjdGlvbixcbiAgICAgIG9wdHNcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBiYWNrZ3JvdW5kQWN0aW9uKGNvbmZpZykge1xuICBjb25zdCBzdGFydEFjdGlvbiA9ICgwLCBpbXBvcnRfYWN0aW9uLmFjdGlvbikoXG4gICAge1xuICAgICAgYWN0aW9uVHlwZTogY29uZmlnLmFjdGlvblR5cGUsXG4gICAgICBuYW1lOiBjb25maWcubmFtZSxcbiAgICAgIGRlc2NyaXB0aW9uOiBjb25maWcuZGVzY3JpcHRpb24sXG4gICAgICBpbnB1dFNjaGVtYTogY29uZmlnLmlucHV0U2NoZW1hLFxuICAgICAgaW5wdXRKc29uU2NoZW1hOiBjb25maWcuaW5wdXRKc29uU2NoZW1hLFxuICAgICAgb3V0cHV0U2NoZW1hOiBPcGVyYXRpb25TY2hlbWEsXG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICAuLi5jb25maWcubWV0YWRhdGEsXG4gICAgICAgIG91dHB1dFNjaGVtYTogKDAsIGltcG9ydF9zY2hlbWEudG9Kc29uU2NoZW1hKSh7XG4gICAgICAgICAgc2NoZW1hOiBjb25maWcub3V0cHV0U2NoZW1hLFxuICAgICAgICAgIGpzb25TY2hlbWE6IGNvbmZpZy5vdXRwdXRKc29uU2NoZW1hXG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgdXNlOiBjb25maWcudXNlXG4gICAgfSxcbiAgICBhc3luYyAoaW5wdXQsIG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IGF3YWl0IGNvbmZpZy5zdGFydChpbnB1dCwgb3B0aW9ucyk7XG4gICAgICBvcGVyYXRpb24uYWN0aW9uID0gYC8ke2NvbmZpZy5hY3Rpb25UeXBlfS8ke2NvbmZpZy5uYW1lfWA7XG4gICAgICByZXR1cm4gb3BlcmF0aW9uO1xuICAgIH1cbiAgKTtcbiAgY29uc3QgY2hlY2tBY3Rpb24gPSAoMCwgaW1wb3J0X2FjdGlvbi5hY3Rpb24pKFxuICAgIHtcbiAgICAgIGFjdGlvblR5cGU6IFwiY2hlY2stb3BlcmF0aW9uXCIsXG4gICAgICBuYW1lOiBgJHtjb25maWcubmFtZX0vY2hlY2tgLFxuICAgICAgZGVzY3JpcHRpb246IGNvbmZpZy5kZXNjcmlwdGlvbixcbiAgICAgIGlucHV0U2NoZW1hOiBPcGVyYXRpb25TY2hlbWEsXG4gICAgICBpbnB1dEpzb25TY2hlbWE6IGNvbmZpZy5pbnB1dEpzb25TY2hlbWEsXG4gICAgICBvdXRwdXRTY2hlbWE6IE9wZXJhdGlvblNjaGVtYSxcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIC4uLmNvbmZpZy5tZXRhZGF0YSxcbiAgICAgICAgb3V0cHV0U2NoZW1hOiAoMCwgaW1wb3J0X3NjaGVtYS50b0pzb25TY2hlbWEpKHtcbiAgICAgICAgICBzY2hlbWE6IGNvbmZpZy5vdXRwdXRTY2hlbWEsXG4gICAgICAgICAganNvblNjaGVtYTogY29uZmlnLm91dHB1dEpzb25TY2hlbWFcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgY29uc3Qgb3BlcmF0aW9uID0gYXdhaXQgY29uZmlnLmNoZWNrKGlucHV0KTtcbiAgICAgIG9wZXJhdGlvbi5hY3Rpb24gPSBgLyR7Y29uZmlnLmFjdGlvblR5cGV9LyR7Y29uZmlnLm5hbWV9YDtcbiAgICAgIHJldHVybiBvcGVyYXRpb247XG4gICAgfVxuICApO1xuICBsZXQgY2FuY2VsQWN0aW9uID0gdm9pZCAwO1xuICBpZiAoY29uZmlnLmNhbmNlbCkge1xuICAgIGNhbmNlbEFjdGlvbiA9ICgwLCBpbXBvcnRfYWN0aW9uLmFjdGlvbikoXG4gICAgICB7XG4gICAgICAgIGFjdGlvblR5cGU6IFwiY2FuY2VsLW9wZXJhdGlvblwiLFxuICAgICAgICBuYW1lOiBgJHtjb25maWcubmFtZX0vY2FuY2VsYCxcbiAgICAgICAgZGVzY3JpcHRpb246IGNvbmZpZy5kZXNjcmlwdGlvbixcbiAgICAgICAgaW5wdXRTY2hlbWE6IE9wZXJhdGlvblNjaGVtYSxcbiAgICAgICAgaW5wdXRKc29uU2NoZW1hOiBjb25maWcuaW5wdXRKc29uU2NoZW1hLFxuICAgICAgICBvdXRwdXRTY2hlbWE6IE9wZXJhdGlvblNjaGVtYSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAuLi5jb25maWcubWV0YWRhdGEsXG4gICAgICAgICAgb3V0cHV0U2NoZW1hOiAoMCwgaW1wb3J0X3NjaGVtYS50b0pzb25TY2hlbWEpKHtcbiAgICAgICAgICAgIHNjaGVtYTogY29uZmlnLm91dHB1dFNjaGVtYSxcbiAgICAgICAgICAgIGpzb25TY2hlbWE6IGNvbmZpZy5vdXRwdXRKc29uU2NoZW1hXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICBpZiAoIWNvbmZpZy5jYW5jZWwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgaW1wb3J0X2Vycm9yLkdlbmtpdEVycm9yKHtcbiAgICAgICAgICAgIHN0YXR1czogXCJVTkFWQUlMQUJMRVwiLFxuICAgICAgICAgICAgbWVzc2FnZTogYCR7Y29uZmlnLm5hbWV9IGRvZXMgbm90IHN1cHBvcnQgY2FuY2VsbGF0aW9uLmBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcGVyYXRpb24gPSBhd2FpdCBjb25maWcuY2FuY2VsKGlucHV0KTtcbiAgICAgICAgb3BlcmF0aW9uLmFjdGlvbiA9IGAvJHtjb25maWcuYWN0aW9uVHlwZX0vJHtjb25maWcubmFtZX1gO1xuICAgICAgICByZXR1cm4gb3BlcmF0aW9uO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG5ldyBCYWNrZ3JvdW5kQWN0aW9uSW1wbChzdGFydEFjdGlvbiwgY2hlY2tBY3Rpb24sIGNhbmNlbEFjdGlvbik7XG59XG5mdW5jdGlvbiBpc0JhY2tncm91bmRBY3Rpb24oYSkge1xuICByZXR1cm4gYSBpbnN0YW5jZW9mIEJhY2tncm91bmRBY3Rpb25JbXBsO1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIE9wZXJhdGlvblNjaGVtYSxcbiAgYmFja2dyb3VuZEFjdGlvbixcbiAgZGVmaW5lQmFja2dyb3VuZEFjdGlvbixcbiAgaXNCYWNrZ3JvdW5kQWN0aW9uLFxuICBsb29rdXBCYWNrZ3JvdW5kQWN0aW9uLFxuICByZWdpc3RlckJhY2tncm91bmRBY3Rpb25cbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFja2dyb3VuZC1hY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/background-action.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/context.js":
/*!*****************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/context.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar context_exports = {};\n__export(context_exports, {\n  apiKey: () => apiKey,\n  getContext: () => getContext,\n  runWithContext: () => runWithContext\n});\nmodule.exports = __toCommonJS(context_exports);\nvar import_action = __webpack_require__(/*! ./action.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/action.js\");\nvar import_async_context = __webpack_require__(/*! ./async-context.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/async-context.js\");\nvar import_error = __webpack_require__(/*! ./error.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/error.js\");\nconst contextAlsKey = \"core.auth.context\";\nfunction runWithContext(context, fn) {\n  if (context === void 0) {\n    return fn();\n  }\n  return (0, import_async_context.getAsyncContext)().run(\n    contextAlsKey,\n    context,\n    () => (0, import_action.runInActionRuntimeContext)(fn)\n  );\n}\nfunction getContext() {\n  return (0, import_async_context.getAsyncContext)().getStore(contextAlsKey);\n}\nfunction apiKey(valueOrPolicy) {\n  return async (request) => {\n    const context = {\n      auth: { apiKey: request.headers[\"authorization\"] }\n    };\n    if (typeof valueOrPolicy === \"string\") {\n      if (!context.auth?.apiKey) {\n        console.error(\"THROWING UNAUTHENTICATED\");\n        throw new import_error.UserFacingError(\"UNAUTHENTICATED\", \"Unauthenticated\");\n      }\n      if (context.auth?.apiKey != valueOrPolicy) {\n        console.error(\"Throwing PERMISSION_DENIED\");\n        throw new import_error.UserFacingError(\"PERMISSION_DENIED\", \"Permission Denied\");\n      }\n    } else if (typeof valueOrPolicy === \"function\") {\n      await valueOrPolicy(context);\n    } else if (typeof valueOrPolicy !== \"undefined\") {\n      throw new Error(\n        `Invalid type ${typeof valueOrPolicy} passed to apiKey()`\n      );\n    }\n    return context;\n  };\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=context.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL2NvbnRleHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsa0ZBQWE7QUFDekMsMkJBQTJCLG1CQUFPLENBQUMsZ0dBQW9CO0FBQ3ZELG1CQUFtQixtQkFBTyxDQUFDLGdGQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FJTDtBQUNEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEtSYW1hY2hhXFxEb2N1bWVudHNcXFN1c3RBSW5leCBHSXQgQ29kZVxcbm9kZV9tb2R1bGVzXFxAZ2Vua2l0LWFpXFxjb3JlXFxsaWJcXGNvbnRleHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIGNvbnRleHRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoY29udGV4dF9leHBvcnRzLCB7XG4gIGFwaUtleTogKCkgPT4gYXBpS2V5LFxuICBnZXRDb250ZXh0OiAoKSA9PiBnZXRDb250ZXh0LFxuICBydW5XaXRoQ29udGV4dDogKCkgPT4gcnVuV2l0aENvbnRleHRcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoY29udGV4dF9leHBvcnRzKTtcbnZhciBpbXBvcnRfYWN0aW9uID0gcmVxdWlyZShcIi4vYWN0aW9uLmpzXCIpO1xudmFyIGltcG9ydF9hc3luY19jb250ZXh0ID0gcmVxdWlyZShcIi4vYXN5bmMtY29udGV4dC5qc1wiKTtcbnZhciBpbXBvcnRfZXJyb3IgPSByZXF1aXJlKFwiLi9lcnJvci5qc1wiKTtcbmNvbnN0IGNvbnRleHRBbHNLZXkgPSBcImNvcmUuYXV0aC5jb250ZXh0XCI7XG5mdW5jdGlvbiBydW5XaXRoQ29udGV4dChjb250ZXh0LCBmbikge1xuICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGZuKCk7XG4gIH1cbiAgcmV0dXJuICgwLCBpbXBvcnRfYXN5bmNfY29udGV4dC5nZXRBc3luY0NvbnRleHQpKCkucnVuKFxuICAgIGNvbnRleHRBbHNLZXksXG4gICAgY29udGV4dCxcbiAgICAoKSA9PiAoMCwgaW1wb3J0X2FjdGlvbi5ydW5JbkFjdGlvblJ1bnRpbWVDb250ZXh0KShmbilcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gIHJldHVybiAoMCwgaW1wb3J0X2FzeW5jX2NvbnRleHQuZ2V0QXN5bmNDb250ZXh0KSgpLmdldFN0b3JlKGNvbnRleHRBbHNLZXkpO1xufVxuZnVuY3Rpb24gYXBpS2V5KHZhbHVlT3JQb2xpY3kpIHtcbiAgcmV0dXJuIGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIGF1dGg6IHsgYXBpS2V5OiByZXF1ZXN0LmhlYWRlcnNbXCJhdXRob3JpemF0aW9uXCJdIH1cbiAgICB9O1xuICAgIGlmICh0eXBlb2YgdmFsdWVPclBvbGljeSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKCFjb250ZXh0LmF1dGg/LmFwaUtleSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiVEhST1dJTkcgVU5BVVRIRU5USUNBVEVEXCIpO1xuICAgICAgICB0aHJvdyBuZXcgaW1wb3J0X2Vycm9yLlVzZXJGYWNpbmdFcnJvcihcIlVOQVVUSEVOVElDQVRFRFwiLCBcIlVuYXV0aGVudGljYXRlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0LmF1dGg/LmFwaUtleSAhPSB2YWx1ZU9yUG9saWN5KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUaHJvd2luZyBQRVJNSVNTSU9OX0RFTklFRFwiKTtcbiAgICAgICAgdGhyb3cgbmV3IGltcG9ydF9lcnJvci5Vc2VyRmFjaW5nRXJyb3IoXCJQRVJNSVNTSU9OX0RFTklFRFwiLCBcIlBlcm1pc3Npb24gRGVuaWVkXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlT3JQb2xpY3kgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgYXdhaXQgdmFsdWVPclBvbGljeShjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZU9yUG9saWN5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIHR5cGUgJHt0eXBlb2YgdmFsdWVPclBvbGljeX0gcGFzc2VkIHRvIGFwaUtleSgpYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH07XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXBpS2V5LFxuICBnZXRDb250ZXh0LFxuICBydW5XaXRoQ29udGV4dFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250ZXh0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/context.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/error.js":
/*!***************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/error.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar error_exports = {};\n__export(error_exports, {\n  GenkitError: () => GenkitError,\n  UnstableApiError: () => UnstableApiError,\n  UserFacingError: () => UserFacingError,\n  assertUnstable: () => assertUnstable,\n  getCallableJSON: () => getCallableJSON,\n  getErrorMessage: () => getErrorMessage,\n  getErrorStack: () => getErrorStack,\n  getHttpStatus: () => getHttpStatus\n});\nmodule.exports = __toCommonJS(error_exports);\nvar import_statusTypes = __webpack_require__(/*! ./statusTypes.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/statusTypes.js\");\nclass GenkitError extends Error {\n  source;\n  status;\n  detail;\n  code;\n  // For easy printing, we wrap the error with information like the source\n  // and status, but that's redundant with JSON.\n  originalMessage;\n  constructor({\n    status,\n    message,\n    detail,\n    source\n  }) {\n    super(`${source ? `${source}: ` : \"\"}${status}: ${message}`);\n    this.originalMessage = message;\n    this.code = (0, import_statusTypes.httpStatusCode)(status);\n    this.status = status;\n    this.detail = detail;\n    this.name = \"GenkitError\";\n  }\n  /**\n   * Returns a JSON-serializable representation of this object.\n   */\n  toJSON() {\n    return {\n      // This error type is used by 3P authors with the field \"detail\",\n      // but the actual Callable protocol value is \"details\"\n      ...this.detail === void 0 ? {} : { details: this.detail },\n      status: this.status,\n      message: this.originalMessage\n    };\n  }\n}\nclass UnstableApiError extends GenkitError {\n  constructor(level, message) {\n    super({\n      status: \"FAILED_PRECONDITION\",\n      message: `${message ? message + \" \" : \"\"}This API requires '${level}' stability level.\n\nTo use this feature, initialize Genkit using \\`import {genkit} from \"genkit/${level}\"\\`.`\n    });\n    this.name = \"UnstableApiError\";\n  }\n}\nfunction assertUnstable(registry, level, message) {\n  if (level === \"beta\" && registry.apiStability === \"stable\") {\n    throw new UnstableApiError(level, message);\n  }\n}\nclass UserFacingError extends GenkitError {\n  constructor(status, message, details) {\n    super({ status, detail: details, message });\n    super.name = \"UserFacingError\";\n  }\n}\nfunction getHttpStatus(e) {\n  if (e instanceof GenkitError) {\n    return e.code;\n  }\n  return 500;\n}\nfunction getCallableJSON(e) {\n  if (e instanceof GenkitError) {\n    return e.toJSON();\n  }\n  return {\n    message: \"Internal Error\",\n    status: \"INTERNAL\"\n  };\n}\nfunction getErrorMessage(e) {\n  if (e instanceof Error) {\n    return e.message;\n  }\n  return `${e}`;\n}\nfunction getErrorStack(e) {\n  if (e instanceof Error) {\n    return e.stack;\n  }\n  return void 0;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL2Vycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyw0RkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsYUFBYSxZQUFZLE9BQU8sU0FBUyxFQUFFLE9BQU8sSUFBSSxRQUFRO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLElBQUksc0JBQXNCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2QkFBNkIscUJBQXFCLE1BQU07O0FBRTFFLHVEQUF1RCxRQUFRLGVBQWUsTUFBTTtBQUNwRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtDQUFrQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksRUFBRTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBU0w7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcY29yZVxcbGliXFxlcnJvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgZXJyb3JfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZXJyb3JfZXhwb3J0cywge1xuICBHZW5raXRFcnJvcjogKCkgPT4gR2Vua2l0RXJyb3IsXG4gIFVuc3RhYmxlQXBpRXJyb3I6ICgpID0+IFVuc3RhYmxlQXBpRXJyb3IsXG4gIFVzZXJGYWNpbmdFcnJvcjogKCkgPT4gVXNlckZhY2luZ0Vycm9yLFxuICBhc3NlcnRVbnN0YWJsZTogKCkgPT4gYXNzZXJ0VW5zdGFibGUsXG4gIGdldENhbGxhYmxlSlNPTjogKCkgPT4gZ2V0Q2FsbGFibGVKU09OLFxuICBnZXRFcnJvck1lc3NhZ2U6ICgpID0+IGdldEVycm9yTWVzc2FnZSxcbiAgZ2V0RXJyb3JTdGFjazogKCkgPT4gZ2V0RXJyb3JTdGFjayxcbiAgZ2V0SHR0cFN0YXR1czogKCkgPT4gZ2V0SHR0cFN0YXR1c1xufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhlcnJvcl9leHBvcnRzKTtcbnZhciBpbXBvcnRfc3RhdHVzVHlwZXMgPSByZXF1aXJlKFwiLi9zdGF0dXNUeXBlcy5qc1wiKTtcbmNsYXNzIEdlbmtpdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBzb3VyY2U7XG4gIHN0YXR1cztcbiAgZGV0YWlsO1xuICBjb2RlO1xuICAvLyBGb3IgZWFzeSBwcmludGluZywgd2Ugd3JhcCB0aGUgZXJyb3Igd2l0aCBpbmZvcm1hdGlvbiBsaWtlIHRoZSBzb3VyY2VcbiAgLy8gYW5kIHN0YXR1cywgYnV0IHRoYXQncyByZWR1bmRhbnQgd2l0aCBKU09OLlxuICBvcmlnaW5hbE1lc3NhZ2U7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBzdGF0dXMsXG4gICAgbWVzc2FnZSxcbiAgICBkZXRhaWwsXG4gICAgc291cmNlXG4gIH0pIHtcbiAgICBzdXBlcihgJHtzb3VyY2UgPyBgJHtzb3VyY2V9OiBgIDogXCJcIn0ke3N0YXR1c306ICR7bWVzc2FnZX1gKTtcbiAgICB0aGlzLm9yaWdpbmFsTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5jb2RlID0gKDAsIGltcG9ydF9zdGF0dXNUeXBlcy5odHRwU3RhdHVzQ29kZSkoc3RhdHVzKTtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLmRldGFpbCA9IGRldGFpbDtcbiAgICB0aGlzLm5hbWUgPSBcIkdlbmtpdEVycm9yXCI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gVGhpcyBlcnJvciB0eXBlIGlzIHVzZWQgYnkgM1AgYXV0aG9ycyB3aXRoIHRoZSBmaWVsZCBcImRldGFpbFwiLFxuICAgICAgLy8gYnV0IHRoZSBhY3R1YWwgQ2FsbGFibGUgcHJvdG9jb2wgdmFsdWUgaXMgXCJkZXRhaWxzXCJcbiAgICAgIC4uLnRoaXMuZGV0YWlsID09PSB2b2lkIDAgPyB7fSA6IHsgZGV0YWlsczogdGhpcy5kZXRhaWwgfSxcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICBtZXNzYWdlOiB0aGlzLm9yaWdpbmFsTWVzc2FnZVxuICAgIH07XG4gIH1cbn1cbmNsYXNzIFVuc3RhYmxlQXBpRXJyb3IgZXh0ZW5kcyBHZW5raXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGxldmVsLCBtZXNzYWdlKSB7XG4gICAgc3VwZXIoe1xuICAgICAgc3RhdHVzOiBcIkZBSUxFRF9QUkVDT05ESVRJT05cIixcbiAgICAgIG1lc3NhZ2U6IGAke21lc3NhZ2UgPyBtZXNzYWdlICsgXCIgXCIgOiBcIlwifVRoaXMgQVBJIHJlcXVpcmVzICcke2xldmVsfScgc3RhYmlsaXR5IGxldmVsLlxuXG5UbyB1c2UgdGhpcyBmZWF0dXJlLCBpbml0aWFsaXplIEdlbmtpdCB1c2luZyBcXGBpbXBvcnQge2dlbmtpdH0gZnJvbSBcImdlbmtpdC8ke2xldmVsfVwiXFxgLmBcbiAgICB9KTtcbiAgICB0aGlzLm5hbWUgPSBcIlVuc3RhYmxlQXBpRXJyb3JcIjtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0VW5zdGFibGUocmVnaXN0cnksIGxldmVsLCBtZXNzYWdlKSB7XG4gIGlmIChsZXZlbCA9PT0gXCJiZXRhXCIgJiYgcmVnaXN0cnkuYXBpU3RhYmlsaXR5ID09PSBcInN0YWJsZVwiKSB7XG4gICAgdGhyb3cgbmV3IFVuc3RhYmxlQXBpRXJyb3IobGV2ZWwsIG1lc3NhZ2UpO1xuICB9XG59XG5jbGFzcyBVc2VyRmFjaW5nRXJyb3IgZXh0ZW5kcyBHZW5raXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHN0YXR1cywgbWVzc2FnZSwgZGV0YWlscykge1xuICAgIHN1cGVyKHsgc3RhdHVzLCBkZXRhaWw6IGRldGFpbHMsIG1lc3NhZ2UgfSk7XG4gICAgc3VwZXIubmFtZSA9IFwiVXNlckZhY2luZ0Vycm9yXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEh0dHBTdGF0dXMoZSkge1xuICBpZiAoZSBpbnN0YW5jZW9mIEdlbmtpdEVycm9yKSB7XG4gICAgcmV0dXJuIGUuY29kZTtcbiAgfVxuICByZXR1cm4gNTAwO1xufVxuZnVuY3Rpb24gZ2V0Q2FsbGFibGVKU09OKGUpIHtcbiAgaWYgKGUgaW5zdGFuY2VvZiBHZW5raXRFcnJvcikge1xuICAgIHJldHVybiBlLnRvSlNPTigpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZTogXCJJbnRlcm5hbCBFcnJvclwiLFxuICAgIHN0YXR1czogXCJJTlRFUk5BTFwiXG4gIH07XG59XG5mdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UoZSkge1xuICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIGUubWVzc2FnZTtcbiAgfVxuICByZXR1cm4gYCR7ZX1gO1xufVxuZnVuY3Rpb24gZ2V0RXJyb3JTdGFjayhlKSB7XG4gIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gZS5zdGFjaztcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdlbmtpdEVycm9yLFxuICBVbnN0YWJsZUFwaUVycm9yLFxuICBVc2VyRmFjaW5nRXJyb3IsXG4gIGFzc2VydFVuc3RhYmxlLFxuICBnZXRDYWxsYWJsZUpTT04sXG4gIGdldEVycm9yTWVzc2FnZSxcbiAgZ2V0RXJyb3JTdGFjayxcbiAgZ2V0SHR0cFN0YXR1c1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/error.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/flow.js":
/*!**************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/flow.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar flow_exports = {};\n__export(flow_exports, {\n  defineFlow: () => defineFlow,\n  flow: () => flow,\n  run: () => run\n});\nmodule.exports = __toCommonJS(flow_exports);\nvar import_action = __webpack_require__(/*! ./action.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/action.js\");\nvar import_tracing = __webpack_require__(/*! ./tracing.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing.js\");\nfunction flow(config, fn) {\n  const resolvedConfig = typeof config === \"string\" ? { name: config } : config;\n  return flowAction(resolvedConfig, fn);\n}\nfunction defineFlow(registry, config, fn) {\n  const f = flow(config, fn);\n  registry.registerAction(\"flow\", f);\n  return f;\n}\nfunction flowAction(config, fn) {\n  return (0, import_action.action)(\n    {\n      actionType: \"flow\",\n      name: config.name,\n      inputSchema: config.inputSchema,\n      outputSchema: config.outputSchema,\n      streamSchema: config.streamSchema,\n      metadata: config.metadata\n    },\n    async (input, { sendChunk, context, trace, abortSignal, streamingRequested }) => {\n      const ctx = sendChunk;\n      ctx.sendChunk = sendChunk;\n      ctx.context = context;\n      ctx.trace = trace;\n      ctx.abortSignal = abortSignal;\n      ctx.streamingRequested = streamingRequested;\n      return fn(input, ctx);\n    }\n  );\n}\nfunction run(name, funcOrInput, fnOrRegistry, _) {\n  let func;\n  let input;\n  let hasInput = false;\n  if (typeof funcOrInput === \"function\") {\n    func = funcOrInput;\n  } else {\n    input = funcOrInput;\n    hasInput = true;\n  }\n  if (typeof fnOrRegistry === \"function\") {\n    func = fnOrRegistry;\n  }\n  if (!func) {\n    throw new Error(\"unable to resolve run function\");\n  }\n  return (0, import_tracing.runInNewSpan)(\n    {\n      metadata: { name },\n      labels: {\n        [import_tracing.SPAN_TYPE_ATTR]: \"flowStep\"\n      }\n    },\n    async (meta) => {\n      meta.input = input;\n      const output = hasInput ? await func(input) : await func();\n      meta.output = JSON.stringify(output);\n      return output;\n    }\n  );\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=flow.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL2Zsb3cuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsa0ZBQWE7QUFDekMscUJBQXFCLG1CQUFPLENBQUMsb0ZBQWM7QUFDM0M7QUFDQSx3REFBd0QsZUFBZTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0IsNERBQTREO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUlMO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcS1JhbWFjaGFcXERvY3VtZW50c1xcU3VzdEFJbmV4IEdJdCBDb2RlXFxub2RlX21vZHVsZXNcXEBnZW5raXQtYWlcXGNvcmVcXGxpYlxcZmxvdy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgZmxvd19leHBvcnRzID0ge307XG5fX2V4cG9ydChmbG93X2V4cG9ydHMsIHtcbiAgZGVmaW5lRmxvdzogKCkgPT4gZGVmaW5lRmxvdyxcbiAgZmxvdzogKCkgPT4gZmxvdyxcbiAgcnVuOiAoKSA9PiBydW5cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoZmxvd19leHBvcnRzKTtcbnZhciBpbXBvcnRfYWN0aW9uID0gcmVxdWlyZShcIi4vYWN0aW9uLmpzXCIpO1xudmFyIGltcG9ydF90cmFjaW5nID0gcmVxdWlyZShcIi4vdHJhY2luZy5qc1wiKTtcbmZ1bmN0aW9uIGZsb3coY29uZmlnLCBmbikge1xuICBjb25zdCByZXNvbHZlZENvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09IFwic3RyaW5nXCIgPyB7IG5hbWU6IGNvbmZpZyB9IDogY29uZmlnO1xuICByZXR1cm4gZmxvd0FjdGlvbihyZXNvbHZlZENvbmZpZywgZm4pO1xufVxuZnVuY3Rpb24gZGVmaW5lRmxvdyhyZWdpc3RyeSwgY29uZmlnLCBmbikge1xuICBjb25zdCBmID0gZmxvdyhjb25maWcsIGZuKTtcbiAgcmVnaXN0cnkucmVnaXN0ZXJBY3Rpb24oXCJmbG93XCIsIGYpO1xuICByZXR1cm4gZjtcbn1cbmZ1bmN0aW9uIGZsb3dBY3Rpb24oY29uZmlnLCBmbikge1xuICByZXR1cm4gKDAsIGltcG9ydF9hY3Rpb24uYWN0aW9uKShcbiAgICB7XG4gICAgICBhY3Rpb25UeXBlOiBcImZsb3dcIixcbiAgICAgIG5hbWU6IGNvbmZpZy5uYW1lLFxuICAgICAgaW5wdXRTY2hlbWE6IGNvbmZpZy5pbnB1dFNjaGVtYSxcbiAgICAgIG91dHB1dFNjaGVtYTogY29uZmlnLm91dHB1dFNjaGVtYSxcbiAgICAgIHN0cmVhbVNjaGVtYTogY29uZmlnLnN0cmVhbVNjaGVtYSxcbiAgICAgIG1ldGFkYXRhOiBjb25maWcubWV0YWRhdGFcbiAgICB9LFxuICAgIGFzeW5jIChpbnB1dCwgeyBzZW5kQ2h1bmssIGNvbnRleHQsIHRyYWNlLCBhYm9ydFNpZ25hbCwgc3RyZWFtaW5nUmVxdWVzdGVkIH0pID0+IHtcbiAgICAgIGNvbnN0IGN0eCA9IHNlbmRDaHVuaztcbiAgICAgIGN0eC5zZW5kQ2h1bmsgPSBzZW5kQ2h1bms7XG4gICAgICBjdHguY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICBjdHgudHJhY2UgPSB0cmFjZTtcbiAgICAgIGN0eC5hYm9ydFNpZ25hbCA9IGFib3J0U2lnbmFsO1xuICAgICAgY3R4LnN0cmVhbWluZ1JlcXVlc3RlZCA9IHN0cmVhbWluZ1JlcXVlc3RlZDtcbiAgICAgIHJldHVybiBmbihpbnB1dCwgY3R4KTtcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBydW4obmFtZSwgZnVuY09ySW5wdXQsIGZuT3JSZWdpc3RyeSwgXykge1xuICBsZXQgZnVuYztcbiAgbGV0IGlucHV0O1xuICBsZXQgaGFzSW5wdXQgPSBmYWxzZTtcbiAgaWYgKHR5cGVvZiBmdW5jT3JJbnB1dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZnVuYyA9IGZ1bmNPcklucHV0O1xuICB9IGVsc2Uge1xuICAgIGlucHV0ID0gZnVuY09ySW5wdXQ7XG4gICAgaGFzSW5wdXQgPSB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgZm5PclJlZ2lzdHJ5ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmdW5jID0gZm5PclJlZ2lzdHJ5O1xuICB9XG4gIGlmICghZnVuYykge1xuICAgIHRocm93IG5ldyBFcnJvcihcInVuYWJsZSB0byByZXNvbHZlIHJ1biBmdW5jdGlvblwiKTtcbiAgfVxuICByZXR1cm4gKDAsIGltcG9ydF90cmFjaW5nLnJ1bkluTmV3U3BhbikoXG4gICAge1xuICAgICAgbWV0YWRhdGE6IHsgbmFtZSB9LFxuICAgICAgbGFiZWxzOiB7XG4gICAgICAgIFtpbXBvcnRfdHJhY2luZy5TUEFOX1RZUEVfQVRUUl06IFwiZmxvd1N0ZXBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgKG1ldGEpID0+IHtcbiAgICAgIG1ldGEuaW5wdXQgPSBpbnB1dDtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGhhc0lucHV0ID8gYXdhaXQgZnVuYyhpbnB1dCkgOiBhd2FpdCBmdW5jKCk7XG4gICAgICBtZXRhLm91dHB1dCA9IEpTT04uc3RyaW5naWZ5KG91dHB1dCk7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgKTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBkZWZpbmVGbG93LFxuICBmbG93LFxuICBydW5cbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zmxvdy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/flow.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar index_exports = {};\n__export(index_exports, {\n  GENKIT_CLIENT_HEADER: () => GENKIT_CLIENT_HEADER,\n  GENKIT_REFLECTION_API_SPEC_VERSION: () => GENKIT_REFLECTION_API_SPEC_VERSION,\n  GENKIT_VERSION: () => GENKIT_VERSION,\n  GenkitError: () => import_error.GenkitError,\n  OperationSchema: () => import_background_action.OperationSchema,\n  UnstableApiError: () => import_error.UnstableApiError,\n  UserFacingError: () => import_error.UserFacingError,\n  apiKey: () => import_context.apiKey,\n  assertUnstable: () => import_error.assertUnstable,\n  backgroundAction: () => import_background_action.backgroundAction,\n  defineBackgroundAction: () => import_background_action.defineBackgroundAction,\n  defineFlow: () => import_flow.defineFlow,\n  defineJsonSchema: () => import_schema.defineJsonSchema,\n  defineSchema: () => import_schema.defineSchema,\n  flow: () => import_flow.flow,\n  getAsyncContext: () => import_async_context.getAsyncContext,\n  getCallableJSON: () => import_error.getCallableJSON,\n  getClientHeader: () => getClientHeader,\n  getContext: () => import_context.getContext,\n  getHttpStatus: () => import_error.getHttpStatus,\n  isBackgroundAction: () => import_background_action.isBackgroundAction,\n  registerBackgroundAction: () => import_background_action.registerBackgroundAction,\n  run: () => import_flow.run,\n  runWithContext: () => import_context.runWithContext,\n  setClientHeader: () => setClientHeader,\n  z: () => import_zod.z\n});\nmodule.exports = __toCommonJS(index_exports);\nvar import_version = __webpack_require__(/*! ./__codegen/version.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/__codegen/version.js\");\nvar import_zod = __webpack_require__(/*! zod */ \"(action-browser)/./node_modules/zod/lib/index.js\");\n__reExport(index_exports, __webpack_require__(/*! ./action.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/action.js\"), module.exports);\nvar import_async_context = __webpack_require__(/*! ./async-context.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/async-context.js\");\nvar import_background_action = __webpack_require__(/*! ./background-action.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/background-action.js\");\nvar import_context = __webpack_require__(/*! ./context.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/context.js\");\nvar import_error = __webpack_require__(/*! ./error.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/error.js\");\nvar import_flow = __webpack_require__(/*! ./flow.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/flow.js\");\n__reExport(index_exports, __webpack_require__(/*! ./plugin.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/plugin.js\"), module.exports);\n__reExport(index_exports, __webpack_require__(/*! ./reflection.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/reflection.js\"), module.exports);\nvar import_schema = __webpack_require__(/*! ./schema.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/schema.js\");\n__reExport(index_exports, __webpack_require__(/*! ./telemetryTypes.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/telemetryTypes.js\"), module.exports);\n__reExport(index_exports, __webpack_require__(/*! ./utils.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/utils.js\"), module.exports);\nconst GENKIT_VERSION = import_version.version;\nconst GENKIT_CLIENT_HEADER = `genkit-node/${GENKIT_VERSION} gl-node/${process.versions.node}`;\nconst GENKIT_REFLECTION_API_SPEC_VERSION = 1;\nconst clientHeaderGlobalKey = \"__genkit_ClientHeader\";\nfunction getClientHeader() {\n  if (global[clientHeaderGlobalKey]) {\n    return GENKIT_CLIENT_HEADER + \" \" + global[clientHeaderGlobalKey];\n  }\n  return GENKIT_CLIENT_HEADER;\n}\nfunction setClientHeader(header) {\n  global[clientHeaderGlobalKey] = header;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLHdHQUF3QjtBQUNyRCxpQkFBaUIsbUJBQU8sQ0FBQyw2REFBSztBQUM5QiwwQkFBMEIsbUJBQU8sQ0FBQyxrRkFBYTtBQUMvQywyQkFBMkIsbUJBQU8sQ0FBQyxnR0FBb0I7QUFDdkQsK0JBQStCLG1CQUFPLENBQUMsd0dBQXdCO0FBQy9ELHFCQUFxQixtQkFBTyxDQUFDLG9GQUFjO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLGdGQUFZO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLDhFQUFXO0FBQ3JDLDBCQUEwQixtQkFBTyxDQUFDLGtGQUFhO0FBQy9DLDBCQUEwQixtQkFBTyxDQUFDLDBGQUFpQjtBQUNuRCxvQkFBb0IsbUJBQU8sQ0FBQyxrRkFBYTtBQUN6QywwQkFBMEIsbUJBQU8sQ0FBQyxrR0FBcUI7QUFDdkQsMEJBQTBCLG1CQUFPLENBQUMsZ0ZBQVk7QUFDOUM7QUFDQSw0Q0FBNEMsZ0JBQWdCLFVBQVUsc0JBQXNCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FnQ0w7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcY29yZVxcbGliXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2QsIHNlY29uZFRhcmdldCkgPT4gKF9fY29weVByb3BzKHRhcmdldCwgbW9kLCBcImRlZmF1bHRcIiksIHNlY29uZFRhcmdldCAmJiBfX2NvcHlQcm9wcyhzZWNvbmRUYXJnZXQsIG1vZCwgXCJkZWZhdWx0XCIpKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIGluZGV4X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGluZGV4X2V4cG9ydHMsIHtcbiAgR0VOS0lUX0NMSUVOVF9IRUFERVI6ICgpID0+IEdFTktJVF9DTElFTlRfSEVBREVSLFxuICBHRU5LSVRfUkVGTEVDVElPTl9BUElfU1BFQ19WRVJTSU9OOiAoKSA9PiBHRU5LSVRfUkVGTEVDVElPTl9BUElfU1BFQ19WRVJTSU9OLFxuICBHRU5LSVRfVkVSU0lPTjogKCkgPT4gR0VOS0lUX1ZFUlNJT04sXG4gIEdlbmtpdEVycm9yOiAoKSA9PiBpbXBvcnRfZXJyb3IuR2Vua2l0RXJyb3IsXG4gIE9wZXJhdGlvblNjaGVtYTogKCkgPT4gaW1wb3J0X2JhY2tncm91bmRfYWN0aW9uLk9wZXJhdGlvblNjaGVtYSxcbiAgVW5zdGFibGVBcGlFcnJvcjogKCkgPT4gaW1wb3J0X2Vycm9yLlVuc3RhYmxlQXBpRXJyb3IsXG4gIFVzZXJGYWNpbmdFcnJvcjogKCkgPT4gaW1wb3J0X2Vycm9yLlVzZXJGYWNpbmdFcnJvcixcbiAgYXBpS2V5OiAoKSA9PiBpbXBvcnRfY29udGV4dC5hcGlLZXksXG4gIGFzc2VydFVuc3RhYmxlOiAoKSA9PiBpbXBvcnRfZXJyb3IuYXNzZXJ0VW5zdGFibGUsXG4gIGJhY2tncm91bmRBY3Rpb246ICgpID0+IGltcG9ydF9iYWNrZ3JvdW5kX2FjdGlvbi5iYWNrZ3JvdW5kQWN0aW9uLFxuICBkZWZpbmVCYWNrZ3JvdW5kQWN0aW9uOiAoKSA9PiBpbXBvcnRfYmFja2dyb3VuZF9hY3Rpb24uZGVmaW5lQmFja2dyb3VuZEFjdGlvbixcbiAgZGVmaW5lRmxvdzogKCkgPT4gaW1wb3J0X2Zsb3cuZGVmaW5lRmxvdyxcbiAgZGVmaW5lSnNvblNjaGVtYTogKCkgPT4gaW1wb3J0X3NjaGVtYS5kZWZpbmVKc29uU2NoZW1hLFxuICBkZWZpbmVTY2hlbWE6ICgpID0+IGltcG9ydF9zY2hlbWEuZGVmaW5lU2NoZW1hLFxuICBmbG93OiAoKSA9PiBpbXBvcnRfZmxvdy5mbG93LFxuICBnZXRBc3luY0NvbnRleHQ6ICgpID0+IGltcG9ydF9hc3luY19jb250ZXh0LmdldEFzeW5jQ29udGV4dCxcbiAgZ2V0Q2FsbGFibGVKU09OOiAoKSA9PiBpbXBvcnRfZXJyb3IuZ2V0Q2FsbGFibGVKU09OLFxuICBnZXRDbGllbnRIZWFkZXI6ICgpID0+IGdldENsaWVudEhlYWRlcixcbiAgZ2V0Q29udGV4dDogKCkgPT4gaW1wb3J0X2NvbnRleHQuZ2V0Q29udGV4dCxcbiAgZ2V0SHR0cFN0YXR1czogKCkgPT4gaW1wb3J0X2Vycm9yLmdldEh0dHBTdGF0dXMsXG4gIGlzQmFja2dyb3VuZEFjdGlvbjogKCkgPT4gaW1wb3J0X2JhY2tncm91bmRfYWN0aW9uLmlzQmFja2dyb3VuZEFjdGlvbixcbiAgcmVnaXN0ZXJCYWNrZ3JvdW5kQWN0aW9uOiAoKSA9PiBpbXBvcnRfYmFja2dyb3VuZF9hY3Rpb24ucmVnaXN0ZXJCYWNrZ3JvdW5kQWN0aW9uLFxuICBydW46ICgpID0+IGltcG9ydF9mbG93LnJ1bixcbiAgcnVuV2l0aENvbnRleHQ6ICgpID0+IGltcG9ydF9jb250ZXh0LnJ1bldpdGhDb250ZXh0LFxuICBzZXRDbGllbnRIZWFkZXI6ICgpID0+IHNldENsaWVudEhlYWRlcixcbiAgejogKCkgPT4gaW1wb3J0X3pvZC56XG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKGluZGV4X2V4cG9ydHMpO1xudmFyIGltcG9ydF92ZXJzaW9uID0gcmVxdWlyZShcIi4vX19jb2RlZ2VuL3ZlcnNpb24uanNcIik7XG52YXIgaW1wb3J0X3pvZCA9IHJlcXVpcmUoXCJ6b2RcIik7XG5fX3JlRXhwb3J0KGluZGV4X2V4cG9ydHMsIHJlcXVpcmUoXCIuL2FjdGlvbi5qc1wiKSwgbW9kdWxlLmV4cG9ydHMpO1xudmFyIGltcG9ydF9hc3luY19jb250ZXh0ID0gcmVxdWlyZShcIi4vYXN5bmMtY29udGV4dC5qc1wiKTtcbnZhciBpbXBvcnRfYmFja2dyb3VuZF9hY3Rpb24gPSByZXF1aXJlKFwiLi9iYWNrZ3JvdW5kLWFjdGlvbi5qc1wiKTtcbnZhciBpbXBvcnRfY29udGV4dCA9IHJlcXVpcmUoXCIuL2NvbnRleHQuanNcIik7XG52YXIgaW1wb3J0X2Vycm9yID0gcmVxdWlyZShcIi4vZXJyb3IuanNcIik7XG52YXIgaW1wb3J0X2Zsb3cgPSByZXF1aXJlKFwiLi9mbG93LmpzXCIpO1xuX19yZUV4cG9ydChpbmRleF9leHBvcnRzLCByZXF1aXJlKFwiLi9wbHVnaW4uanNcIiksIG1vZHVsZS5leHBvcnRzKTtcbl9fcmVFeHBvcnQoaW5kZXhfZXhwb3J0cywgcmVxdWlyZShcIi4vcmVmbGVjdGlvbi5qc1wiKSwgbW9kdWxlLmV4cG9ydHMpO1xudmFyIGltcG9ydF9zY2hlbWEgPSByZXF1aXJlKFwiLi9zY2hlbWEuanNcIik7XG5fX3JlRXhwb3J0KGluZGV4X2V4cG9ydHMsIHJlcXVpcmUoXCIuL3RlbGVtZXRyeVR5cGVzLmpzXCIpLCBtb2R1bGUuZXhwb3J0cyk7XG5fX3JlRXhwb3J0KGluZGV4X2V4cG9ydHMsIHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpLCBtb2R1bGUuZXhwb3J0cyk7XG5jb25zdCBHRU5LSVRfVkVSU0lPTiA9IGltcG9ydF92ZXJzaW9uLnZlcnNpb247XG5jb25zdCBHRU5LSVRfQ0xJRU5UX0hFQURFUiA9IGBnZW5raXQtbm9kZS8ke0dFTktJVF9WRVJTSU9OfSBnbC1ub2RlLyR7cHJvY2Vzcy52ZXJzaW9ucy5ub2RlfWA7XG5jb25zdCBHRU5LSVRfUkVGTEVDVElPTl9BUElfU1BFQ19WRVJTSU9OID0gMTtcbmNvbnN0IGNsaWVudEhlYWRlckdsb2JhbEtleSA9IFwiX19nZW5raXRfQ2xpZW50SGVhZGVyXCI7XG5mdW5jdGlvbiBnZXRDbGllbnRIZWFkZXIoKSB7XG4gIGlmIChnbG9iYWxbY2xpZW50SGVhZGVyR2xvYmFsS2V5XSkge1xuICAgIHJldHVybiBHRU5LSVRfQ0xJRU5UX0hFQURFUiArIFwiIFwiICsgZ2xvYmFsW2NsaWVudEhlYWRlckdsb2JhbEtleV07XG4gIH1cbiAgcmV0dXJuIEdFTktJVF9DTElFTlRfSEVBREVSO1xufVxuZnVuY3Rpb24gc2V0Q2xpZW50SGVhZGVyKGhlYWRlcikge1xuICBnbG9iYWxbY2xpZW50SGVhZGVyR2xvYmFsS2V5XSA9IGhlYWRlcjtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBHRU5LSVRfQ0xJRU5UX0hFQURFUixcbiAgR0VOS0lUX1JFRkxFQ1RJT05fQVBJX1NQRUNfVkVSU0lPTixcbiAgR0VOS0lUX1ZFUlNJT04sXG4gIEdlbmtpdEVycm9yLFxuICBPcGVyYXRpb25TY2hlbWEsXG4gIFVuc3RhYmxlQXBpRXJyb3IsXG4gIFVzZXJGYWNpbmdFcnJvcixcbiAgYXBpS2V5LFxuICBhc3NlcnRVbnN0YWJsZSxcbiAgYmFja2dyb3VuZEFjdGlvbixcbiAgZGVmaW5lQmFja2dyb3VuZEFjdGlvbixcbiAgZGVmaW5lRmxvdyxcbiAgZGVmaW5lSnNvblNjaGVtYSxcbiAgZGVmaW5lU2NoZW1hLFxuICBmbG93LFxuICBnZXRBc3luY0NvbnRleHQsXG4gIGdldENhbGxhYmxlSlNPTixcbiAgZ2V0Q2xpZW50SGVhZGVyLFxuICBnZXRDb250ZXh0LFxuICBnZXRIdHRwU3RhdHVzLFxuICBpc0JhY2tncm91bmRBY3Rpb24sXG4gIHJlZ2lzdGVyQmFja2dyb3VuZEFjdGlvbixcbiAgcnVuLFxuICBydW5XaXRoQ29udGV4dCxcbiAgc2V0Q2xpZW50SGVhZGVyLFxuICB6LFxuICAuLi5yZXF1aXJlKFwiLi9hY3Rpb24uanNcIiksXG4gIC4uLnJlcXVpcmUoXCIuL3BsdWdpbi5qc1wiKSxcbiAgLi4ucmVxdWlyZShcIi4vcmVmbGVjdGlvbi5qc1wiKSxcbiAgLi4ucmVxdWlyZShcIi4vdGVsZW1ldHJ5VHlwZXMuanNcIiksXG4gIC4uLnJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/logging.js":
/*!*****************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/logging.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar logging_exports = {};\n__export(logging_exports, {\n  logger: () => logger\n});\nmodule.exports = __toCommonJS(logging_exports);\nconst LOG_LEVELS = [\"debug\", \"info\", \"warn\", \"error\"];\nconst loggerKey = \"__genkit_logger\";\nconst _defaultLogger = {\n  shouldLog(targetLevel) {\n    return LOG_LEVELS.indexOf(this.level) <= LOG_LEVELS.indexOf(targetLevel);\n  },\n  debug(...args) {\n    this.shouldLog(\"debug\") && console.debug(...args);\n  },\n  info(...args) {\n    this.shouldLog(\"info\") && console.info(...args);\n  },\n  warn(...args) {\n    this.shouldLog(\"warn\") && console.warn(...args);\n  },\n  error(...args) {\n    this.shouldLog(\"error\") && console.error(...args);\n  },\n  level: \"info\"\n};\nfunction getLogger() {\n  if (!global[loggerKey]) {\n    global[loggerKey] = _defaultLogger;\n  }\n  return global[loggerKey];\n}\nclass Logger {\n  defaultLogger = _defaultLogger;\n  init(fn) {\n    global[loggerKey] = fn;\n  }\n  info(...args) {\n    getLogger().info.apply(getLogger(), args);\n  }\n  debug(...args) {\n    getLogger().debug.apply(getLogger(), args);\n  }\n  error(...args) {\n    getLogger().error.apply(getLogger(), args);\n  }\n  warn(...args) {\n    getLogger().warn.apply(getLogger(), args);\n  }\n  setLogLevel(level) {\n    getLogger().level = level;\n  }\n  logStructured(msg, metadata) {\n    getLogger().info(msg, metadata);\n  }\n  logStructuredError(msg, metadata) {\n    getLogger().error(msg, metadata);\n  }\n}\nconst logger = new Logger();\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=logging.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL2xvZ2dpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBRUw7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcY29yZVxcbGliXFxsb2dnaW5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBsb2dnaW5nX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGxvZ2dpbmdfZXhwb3J0cywge1xuICBsb2dnZXI6ICgpID0+IGxvZ2dlclxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhsb2dnaW5nX2V4cG9ydHMpO1xuY29uc3QgTE9HX0xFVkVMUyA9IFtcImRlYnVnXCIsIFwiaW5mb1wiLCBcIndhcm5cIiwgXCJlcnJvclwiXTtcbmNvbnN0IGxvZ2dlcktleSA9IFwiX19nZW5raXRfbG9nZ2VyXCI7XG5jb25zdCBfZGVmYXVsdExvZ2dlciA9IHtcbiAgc2hvdWxkTG9nKHRhcmdldExldmVsKSB7XG4gICAgcmV0dXJuIExPR19MRVZFTFMuaW5kZXhPZih0aGlzLmxldmVsKSA8PSBMT0dfTEVWRUxTLmluZGV4T2YodGFyZ2V0TGV2ZWwpO1xuICB9LFxuICBkZWJ1ZyguLi5hcmdzKSB7XG4gICAgdGhpcy5zaG91bGRMb2coXCJkZWJ1Z1wiKSAmJiBjb25zb2xlLmRlYnVnKC4uLmFyZ3MpO1xuICB9LFxuICBpbmZvKC4uLmFyZ3MpIHtcbiAgICB0aGlzLnNob3VsZExvZyhcImluZm9cIikgJiYgY29uc29sZS5pbmZvKC4uLmFyZ3MpO1xuICB9LFxuICB3YXJuKC4uLmFyZ3MpIHtcbiAgICB0aGlzLnNob3VsZExvZyhcIndhcm5cIikgJiYgY29uc29sZS53YXJuKC4uLmFyZ3MpO1xuICB9LFxuICBlcnJvciguLi5hcmdzKSB7XG4gICAgdGhpcy5zaG91bGRMb2coXCJlcnJvclwiKSAmJiBjb25zb2xlLmVycm9yKC4uLmFyZ3MpO1xuICB9LFxuICBsZXZlbDogXCJpbmZvXCJcbn07XG5mdW5jdGlvbiBnZXRMb2dnZXIoKSB7XG4gIGlmICghZ2xvYmFsW2xvZ2dlcktleV0pIHtcbiAgICBnbG9iYWxbbG9nZ2VyS2V5XSA9IF9kZWZhdWx0TG9nZ2VyO1xuICB9XG4gIHJldHVybiBnbG9iYWxbbG9nZ2VyS2V5XTtcbn1cbmNsYXNzIExvZ2dlciB7XG4gIGRlZmF1bHRMb2dnZXIgPSBfZGVmYXVsdExvZ2dlcjtcbiAgaW5pdChmbikge1xuICAgIGdsb2JhbFtsb2dnZXJLZXldID0gZm47XG4gIH1cbiAgaW5mbyguLi5hcmdzKSB7XG4gICAgZ2V0TG9nZ2VyKCkuaW5mby5hcHBseShnZXRMb2dnZXIoKSwgYXJncyk7XG4gIH1cbiAgZGVidWcoLi4uYXJncykge1xuICAgIGdldExvZ2dlcigpLmRlYnVnLmFwcGx5KGdldExvZ2dlcigpLCBhcmdzKTtcbiAgfVxuICBlcnJvciguLi5hcmdzKSB7XG4gICAgZ2V0TG9nZ2VyKCkuZXJyb3IuYXBwbHkoZ2V0TG9nZ2VyKCksIGFyZ3MpO1xuICB9XG4gIHdhcm4oLi4uYXJncykge1xuICAgIGdldExvZ2dlcigpLndhcm4uYXBwbHkoZ2V0TG9nZ2VyKCksIGFyZ3MpO1xuICB9XG4gIHNldExvZ0xldmVsKGxldmVsKSB7XG4gICAgZ2V0TG9nZ2VyKCkubGV2ZWwgPSBsZXZlbDtcbiAgfVxuICBsb2dTdHJ1Y3R1cmVkKG1zZywgbWV0YWRhdGEpIHtcbiAgICBnZXRMb2dnZXIoKS5pbmZvKG1zZywgbWV0YWRhdGEpO1xuICB9XG4gIGxvZ1N0cnVjdHVyZWRFcnJvcihtc2csIG1ldGFkYXRhKSB7XG4gICAgZ2V0TG9nZ2VyKCkuZXJyb3IobXNnLCBtZXRhZGF0YSk7XG4gIH1cbn1cbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoKTtcbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBsb2dnZXJcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2luZy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/logging.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/node-async-context.js":
/*!****************************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/node-async-context.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar node_async_context_exports = {};\n__export(node_async_context_exports, {\n  NodeAsyncContext: () => NodeAsyncContext,\n  initNodeAsyncContext: () => initNodeAsyncContext\n});\nmodule.exports = __toCommonJS(node_async_context_exports);\nvar import_node_async_hooks = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\");\nvar import_async_context = __webpack_require__(/*! ./async-context.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/async-context.js\");\nclass NodeAsyncContext {\n  asls = {};\n  getStore(key) {\n    return this.asls[key]?.getStore();\n  }\n  run(key, store, callback) {\n    if (!this.asls[key]) {\n      this.asls[key] = new import_node_async_hooks.AsyncLocalStorage();\n    }\n    return this.asls[key].run(store, callback);\n  }\n}\nfunction initNodeAsyncContext() {\n  (0, import_async_context.setAsyncContext)(new NodeAsyncContext());\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=node-async-context.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL25vZGUtYXN5bmMtY29udGV4dC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsOEJBQThCLG1CQUFPLENBQUMsMENBQWtCO0FBQ3hELDJCQUEyQixtQkFBTyxDQUFDLGdHQUFvQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FHTDtBQUNEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEtSYW1hY2hhXFxEb2N1bWVudHNcXFN1c3RBSW5leCBHSXQgQ29kZVxcbm9kZV9tb2R1bGVzXFxAZ2Vua2l0LWFpXFxjb3JlXFxsaWJcXG5vZGUtYXN5bmMtY29udGV4dC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgbm9kZV9hc3luY19jb250ZXh0X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5vZGVfYXN5bmNfY29udGV4dF9leHBvcnRzLCB7XG4gIE5vZGVBc3luY0NvbnRleHQ6ICgpID0+IE5vZGVBc3luY0NvbnRleHQsXG4gIGluaXROb2RlQXN5bmNDb250ZXh0OiAoKSA9PiBpbml0Tm9kZUFzeW5jQ29udGV4dFxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhub2RlX2FzeW5jX2NvbnRleHRfZXhwb3J0cyk7XG52YXIgaW1wb3J0X25vZGVfYXN5bmNfaG9va3MgPSByZXF1aXJlKFwibm9kZTphc3luY19ob29rc1wiKTtcbnZhciBpbXBvcnRfYXN5bmNfY29udGV4dCA9IHJlcXVpcmUoXCIuL2FzeW5jLWNvbnRleHQuanNcIik7XG5jbGFzcyBOb2RlQXN5bmNDb250ZXh0IHtcbiAgYXNscyA9IHt9O1xuICBnZXRTdG9yZShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5hc2xzW2tleV0/LmdldFN0b3JlKCk7XG4gIH1cbiAgcnVuKGtleSwgc3RvcmUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLmFzbHNba2V5XSkge1xuICAgICAgdGhpcy5hc2xzW2tleV0gPSBuZXcgaW1wb3J0X25vZGVfYXN5bmNfaG9va3MuQXN5bmNMb2NhbFN0b3JhZ2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYXNsc1trZXldLnJ1bihzdG9yZSwgY2FsbGJhY2spO1xuICB9XG59XG5mdW5jdGlvbiBpbml0Tm9kZUFzeW5jQ29udGV4dCgpIHtcbiAgKDAsIGltcG9ydF9hc3luY19jb250ZXh0LnNldEFzeW5jQ29udGV4dCkobmV3IE5vZGVBc3luY0NvbnRleHQoKSk7XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgTm9kZUFzeW5jQ29udGV4dCxcbiAgaW5pdE5vZGVBc3luY0NvbnRleHRcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9kZS1hc3luYy1jb250ZXh0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/node-async-context.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/node.js":
/*!**************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/node.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar node_exports = {};\n__export(node_exports, {\n  initNodeFeatures: () => initNodeFeatures\n});\nmodule.exports = __toCommonJS(node_exports);\nvar import_node_async_context = __webpack_require__(/*! ./node-async-context.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/node-async-context.js\");\nvar import_node_telemetry_provider = __webpack_require__(/*! ./tracing/node-telemetry-provider.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/node-telemetry-provider.js\");\nfunction initNodeFeatures() {\n  (0, import_node_async_context.initNodeAsyncContext)();\n  (0, import_node_telemetry_provider.initNodeTelemetryProvider)();\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=node.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL25vZGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxnQ0FBZ0MsbUJBQU8sQ0FBQywwR0FBeUI7QUFDakUscUNBQXFDLG1CQUFPLENBQUMsb0lBQXNDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBRUw7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcY29yZVxcbGliXFxub2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBub2RlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5vZGVfZXhwb3J0cywge1xuICBpbml0Tm9kZUZlYXR1cmVzOiAoKSA9PiBpbml0Tm9kZUZlYXR1cmVzXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKG5vZGVfZXhwb3J0cyk7XG52YXIgaW1wb3J0X25vZGVfYXN5bmNfY29udGV4dCA9IHJlcXVpcmUoXCIuL25vZGUtYXN5bmMtY29udGV4dC5qc1wiKTtcbnZhciBpbXBvcnRfbm9kZV90ZWxlbWV0cnlfcHJvdmlkZXIgPSByZXF1aXJlKFwiLi90cmFjaW5nL25vZGUtdGVsZW1ldHJ5LXByb3ZpZGVyLmpzXCIpO1xuZnVuY3Rpb24gaW5pdE5vZGVGZWF0dXJlcygpIHtcbiAgKDAsIGltcG9ydF9ub2RlX2FzeW5jX2NvbnRleHQuaW5pdE5vZGVBc3luY0NvbnRleHQpKCk7XG4gICgwLCBpbXBvcnRfbm9kZV90ZWxlbWV0cnlfcHJvdmlkZXIuaW5pdE5vZGVUZWxlbWV0cnlQcm92aWRlcikoKTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBpbml0Tm9kZUZlYXR1cmVzXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vZGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/node.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/plugin.js":
/*!****************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/plugin.js ***!
  \****************************************************/
/***/ ((module) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar plugin_exports = {};\nmodule.exports = __toCommonJS(plugin_exports);\n//# sourceMappingURL=plugin.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3BsdWdpbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcS1JhbWFjaGFcXERvY3VtZW50c1xcU3VzdEFJbmV4IEdJdCBDb2RlXFxub2RlX21vZHVsZXNcXEBnZW5raXQtYWlcXGNvcmVcXGxpYlxccGx1Z2luLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBwbHVnaW5fZXhwb3J0cyA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMocGx1Z2luX2V4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1Z2luLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/plugin.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/reflection.js":
/*!********************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/reflection.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar reflection_exports = {};\n__export(reflection_exports, {\n  ReflectionServer: () => ReflectionServer,\n  RunActionResponseSchema: () => RunActionResponseSchema\n});\nmodule.exports = __toCommonJS(reflection_exports);\nvar import_express = __toESM(__webpack_require__(/*! express */ \"express\"));\nvar import_promises = __toESM(__webpack_require__(/*! fs/promises */ \"fs/promises\"));\nvar import_get_port = __toESM(__webpack_require__(/*! get-port */ \"(action-browser)/./node_modules/get-port/index.js\"));\nvar import_path = __toESM(__webpack_require__(/*! path */ \"path\"));\nvar z = __toESM(__webpack_require__(/*! zod */ \"(action-browser)/./node_modules/zod/lib/index.js\"));\nvar import_action = __webpack_require__(/*! ./action.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/action.js\");\nvar import_index = __webpack_require__(/*! ./index.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nvar import_logging = __webpack_require__(/*! ./logging.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/logging.js\");\nvar import_schema = __webpack_require__(/*! ./schema.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/schema.js\");\nvar import_tracing = __webpack_require__(/*! ./tracing.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing.js\");\nconst RunActionResponseSchema = z.object({\n  result: z.unknown().optional(),\n  error: z.unknown().optional(),\n  telemetry: z.object({\n    traceId: z.string().optional()\n  }).optional()\n});\nclass ReflectionServer {\n  /** List of all running servers needed to be cleaned up on process exit. */\n  static RUNNING_SERVERS = [];\n  /** Registry instance to be used for API calls. */\n  registry;\n  /** Options for the reflection server. */\n  options;\n  /** Port the server is actually running on. This may differ from `options.port` if the original was occupied. Null if server is not running. */\n  port = null;\n  /** Express server instance. Null if server is not running. */\n  server = null;\n  /** Path to the runtime file. Null if server is not running. */\n  runtimeFilePath = null;\n  constructor(registry, options) {\n    this.registry = registry;\n    this.options = {\n      port: 3100,\n      bodyLimit: \"30mb\",\n      configuredEnvs: [\"dev\"],\n      ...options\n    };\n  }\n  /**\n   * Finds a free port to run the server on based on the original chosen port and environment.\n   */\n  async findPort() {\n    const chosenPort = this.options.port;\n    const freePort = await (0, import_get_port.default)({\n      port: (0, import_get_port.makeRange)(chosenPort, chosenPort + 100)\n    });\n    if (freePort !== chosenPort) {\n      import_logging.logger.warn(\n        `Port ${chosenPort} is already in use, using next available port ${freePort} instead.`\n      );\n    }\n    return freePort;\n  }\n  /**\n   * Starts the server.\n   *\n   * The server will be registered to be shut down on process exit.\n   */\n  async start() {\n    const server = (0, import_express.default)();\n    server.use(import_express.default.json({ limit: this.options.bodyLimit }));\n    server.use((req, res, next) => {\n      res.header(\"x-genkit-version\", import_index.GENKIT_VERSION);\n      next();\n    });\n    server.get(\"/api/__health\", async (_, response) => {\n      await this.registry.listActions();\n      response.status(200).send(\"OK\");\n    });\n    server.get(\"/api/__quitquitquit\", async (_, response) => {\n      import_logging.logger.debug(\"Received quitquitquit\");\n      response.status(200).send(\"OK\");\n      await this.stop();\n    });\n    server.get(\"/api/actions\", async (_, response, next) => {\n      import_logging.logger.debug(\"Fetching actions.\");\n      try {\n        const actions = await this.registry.listResolvableActions();\n        const convertedActions = {};\n        Object.keys(actions).forEach((key) => {\n          const action = actions[key];\n          convertedActions[key] = {\n            key,\n            name: action.name,\n            description: action.description,\n            metadata: action.metadata\n          };\n          if (action.inputSchema || action.inputJsonSchema) {\n            convertedActions[key].inputSchema = (0, import_schema.toJsonSchema)({\n              schema: action.inputSchema,\n              jsonSchema: action.inputJsonSchema\n            });\n          }\n          if (action.outputSchema || action.outputJsonSchema) {\n            convertedActions[key].outputSchema = (0, import_schema.toJsonSchema)({\n              schema: action.outputSchema,\n              jsonSchema: action.outputJsonSchema\n            });\n          }\n        });\n        response.send(convertedActions);\n      } catch (err) {\n        const { message, stack } = err;\n        next({ message, stack });\n      }\n    });\n    server.post(\"/api/runAction\", async (request, response, next) => {\n      const { key, input, context, telemetryLabels } = request.body;\n      const { stream } = request.query;\n      import_logging.logger.debug(`Running action \\`${key}\\` with stream=${stream}...`);\n      try {\n        const action = await this.registry.lookupAction(key);\n        if (!action) {\n          response.status(404).send(`action ${key} not found`);\n          return;\n        }\n        if (stream === \"true\") {\n          try {\n            const callback = (chunk) => {\n              response.write(JSON.stringify(chunk) + \"\\n\");\n            };\n            const result = await action.run(input, {\n              context,\n              onChunk: callback,\n              telemetryLabels\n            });\n            await (0, import_tracing.flushTracing)();\n            response.write(\n              JSON.stringify({\n                result: result.result,\n                telemetry: {\n                  traceId: result.telemetry.traceId\n                }\n              })\n            );\n            response.end();\n          } catch (err) {\n            const { message, stack } = err;\n            const errorResponse = {\n              code: import_action.StatusCodes.INTERNAL,\n              message,\n              details: {\n                stack\n              }\n            };\n            if (err.traceId) {\n              errorResponse.details.traceId = err.traceId;\n            }\n            response.write(\n              JSON.stringify({\n                error: errorResponse\n              })\n            );\n            response.end();\n          }\n        } else {\n          const result = await action.run(input, { context, telemetryLabels });\n          await (0, import_tracing.flushTracing)();\n          response.send({\n            result: result.result,\n            telemetry: {\n              traceId: result.telemetry.traceId\n            }\n          });\n        }\n      } catch (err) {\n        const { message, stack, traceId } = err;\n        next({ message, stack, traceId });\n      }\n    });\n    server.get(\"/api/envs\", async (_, response) => {\n      response.json(this.options.configuredEnvs);\n    });\n    server.post(\"/api/notify\", async (request, response) => {\n      const { telemetryServerUrl, reflectionApiSpecVersion } = request.body;\n      if (!process.env.GENKIT_TELEMETRY_SERVER) {\n        if (typeof telemetryServerUrl === \"string\") {\n          (0, import_tracing.setTelemetryServerUrl)(telemetryServerUrl);\n          import_logging.logger.debug(\n            `Connected to telemetry server on ${telemetryServerUrl}`\n          );\n        }\n      }\n      if (reflectionApiSpecVersion !== import_index.GENKIT_REFLECTION_API_SPEC_VERSION) {\n        if (!reflectionApiSpecVersion || reflectionApiSpecVersion < import_index.GENKIT_REFLECTION_API_SPEC_VERSION) {\n          import_logging.logger.warn(\n            \"WARNING: Genkit CLI version may be outdated. Please update `genkit-cli` to the latest version.\"\n          );\n        } else {\n          import_logging.logger.warn(\n            `Genkit CLI is newer than runtime library. Some feature may not be supported. Consider upgrading your runtime library version (debug info: expected ${import_index.GENKIT_REFLECTION_API_SPEC_VERSION}, got ${reflectionApiSpecVersion}).`\n          );\n        }\n      }\n      response.status(200).send(\"OK\");\n    });\n    server.use((err, req, res, next) => {\n      import_logging.logger.error(err.stack);\n      const error = err;\n      const { message, stack } = error;\n      const errorResponse = {\n        code: import_action.StatusCodes.INTERNAL,\n        message,\n        details: {\n          stack\n        }\n      };\n      if (err.traceId) {\n        errorResponse.details.traceId = err.traceId;\n      }\n      res.status(500).json(errorResponse);\n    });\n    this.port = await this.findPort();\n    this.server = server.listen(this.port, async () => {\n      import_logging.logger.debug(\n        `Reflection server (${process.pid}) running on http://localhost:${this.port}`\n      );\n      ReflectionServer.RUNNING_SERVERS.push(this);\n      await this.writeRuntimeFile();\n    });\n  }\n  /**\n   * Stops the server and removes it from the list of running servers to clean up on exit.\n   */\n  async stop() {\n    if (!this.server) {\n      return;\n    }\n    return new Promise(async (resolve, reject) => {\n      await this.cleanupRuntimeFile();\n      this.server.close(async (err) => {\n        if (err) {\n          import_logging.logger.error(\n            `Error shutting down reflection server on port ${this.port}: ${err}`\n          );\n          reject(err);\n        }\n        const index = ReflectionServer.RUNNING_SERVERS.indexOf(this);\n        if (index > -1) {\n          ReflectionServer.RUNNING_SERVERS.splice(index, 1);\n        }\n        import_logging.logger.debug(\n          `Reflection server on port ${this.port} has successfully shut down.`\n        );\n        this.port = null;\n        this.server = null;\n        resolve();\n      });\n    });\n  }\n  /**\n   * Writes the runtime file to the project root.\n   */\n  async writeRuntimeFile() {\n    try {\n      const rootDir = await findProjectRoot();\n      const runtimesDir = import_path.default.join(rootDir, \".genkit\", \"runtimes\");\n      const date = /* @__PURE__ */ new Date();\n      const time = date.getTime();\n      const timestamp = date.toISOString();\n      const runtimeId = `${process.pid}${this.port !== null ? `-${this.port}` : \"\"}`;\n      this.runtimeFilePath = import_path.default.join(\n        runtimesDir,\n        `${runtimeId}-${time}.json`\n      );\n      const fileContent = JSON.stringify(\n        {\n          id: process.env.GENKIT_RUNTIME_ID || runtimeId,\n          pid: process.pid,\n          name: this.options.name,\n          reflectionServerUrl: `http://localhost:${this.port}`,\n          timestamp,\n          genkitVersion: `nodejs/${import_index.GENKIT_VERSION}`,\n          reflectionApiSpecVersion: import_index.GENKIT_REFLECTION_API_SPEC_VERSION\n        },\n        null,\n        2\n      );\n      await import_promises.default.mkdir(runtimesDir, { recursive: true });\n      await import_promises.default.writeFile(this.runtimeFilePath, fileContent, \"utf8\");\n      import_logging.logger.debug(`Runtime file written: ${this.runtimeFilePath}`);\n    } catch (error) {\n      import_logging.logger.error(`Error writing runtime file: ${error}`);\n    }\n  }\n  /**\n   * Cleans up the port file.\n   */\n  async cleanupRuntimeFile() {\n    if (!this.runtimeFilePath) {\n      return;\n    }\n    try {\n      const fileContent = await import_promises.default.readFile(this.runtimeFilePath, \"utf8\");\n      const data = JSON.parse(fileContent);\n      if (data.pid === process.pid) {\n        await import_promises.default.unlink(this.runtimeFilePath);\n        import_logging.logger.debug(`Runtime file cleaned up: ${this.runtimeFilePath}`);\n      }\n    } catch (error) {\n      import_logging.logger.error(`Error cleaning up runtime file: ${error}`);\n    }\n  }\n  /**\n   * Stops all running reflection servers.\n   */\n  static async stopAll() {\n    return Promise.all(\n      ReflectionServer.RUNNING_SERVERS.map((server) => server.stop())\n    );\n  }\n}\nasync function findProjectRoot() {\n  let currentDir = process.cwd();\n  while (currentDir !== import_path.default.parse(currentDir).root) {\n    const packageJsonPath = import_path.default.join(currentDir, \"package.json\");\n    try {\n      await import_promises.default.access(packageJsonPath);\n      return currentDir;\n    } catch {\n      currentDir = import_path.default.dirname(currentDir);\n    }\n  }\n  throw new Error(\"Could not find project root (package.json not found)\");\n}\nif ( true && \"hot\" in module) {\n  module.hot.accept();\n  module.hot.dispose(async () => {\n    import_logging.logger.debug(\"Cleaning up reflection server(s) before module reload...\");\n    await ReflectionServer.stopAll();\n  });\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=reflection.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3JlZmxlY3Rpb24uanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDhCQUE4QjtBQUN2RztBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNkJBQTZCLG1CQUFPLENBQUMsd0JBQVM7QUFDOUMsOEJBQThCLG1CQUFPLENBQUMsZ0NBQWE7QUFDbkQsOEJBQThCLG1CQUFPLENBQUMsbUVBQVU7QUFDaEQsMEJBQTBCLG1CQUFPLENBQUMsa0JBQU07QUFDeEMsZ0JBQWdCLG1CQUFPLENBQUMsNkRBQUs7QUFDN0Isb0JBQW9CLG1CQUFPLENBQUMsa0ZBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQVk7QUFDdkMscUJBQXFCLG1CQUFPLENBQUMsb0ZBQWM7QUFDM0Msb0JBQW9CLG1CQUFPLENBQUMsa0ZBQWE7QUFDekMscUJBQXFCLG1CQUFPLENBQUMsb0ZBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVksK0NBQStDLFVBQVU7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywrQkFBK0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1IsZ0JBQWdCLGlCQUFpQjtBQUNqQyxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsdUNBQXVDO0FBQ3JELGNBQWMsU0FBUztBQUN2QixzREFBc0QsSUFBSSxpQkFBaUIsT0FBTztBQUNsRjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsS0FBSztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxZQUFZO0FBQ1osb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsbURBQW1ELDBCQUEwQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1IsZ0JBQWdCLDBCQUEwQjtBQUMxQyxlQUFlLHlCQUF5QjtBQUN4QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsY0FBYywrQ0FBK0M7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsbUJBQW1CO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxrS0FBa0ssZ0RBQWdELFFBQVEseUJBQXlCO0FBQ25QO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFlBQVksZ0NBQWdDLFVBQVU7QUFDcEY7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFVBQVUsSUFBSSxJQUFJO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZLEVBQUUseUJBQXlCLFVBQVUsT0FBTztBQUNuRjtBQUNBO0FBQ0EsV0FBVyxVQUFVLEdBQUcsS0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsVUFBVTtBQUM3RDtBQUNBLG1DQUFtQyw0QkFBNEI7QUFDL0Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EseURBQXlELGlCQUFpQjtBQUMxRTtBQUNBLDJEQUEyRCxxQkFBcUI7QUFDaEYsTUFBTTtBQUNOLGlFQUFpRSxNQUFNO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UscUJBQXFCO0FBQ3JGO0FBQ0EsTUFBTTtBQUNOLHFFQUFxRSxNQUFNO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUE2QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTSxDQUdMO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcS1JhbWFjaGFcXERvY3VtZW50c1xcU3VzdEFJbmV4IEdJdCBDb2RlXFxub2RlX21vZHVsZXNcXEBnZW5raXQtYWlcXGNvcmVcXGxpYlxccmVmbGVjdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgcmVmbGVjdGlvbl9leHBvcnRzID0ge307XG5fX2V4cG9ydChyZWZsZWN0aW9uX2V4cG9ydHMsIHtcbiAgUmVmbGVjdGlvblNlcnZlcjogKCkgPT4gUmVmbGVjdGlvblNlcnZlcixcbiAgUnVuQWN0aW9uUmVzcG9uc2VTY2hlbWE6ICgpID0+IFJ1bkFjdGlvblJlc3BvbnNlU2NoZW1hXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHJlZmxlY3Rpb25fZXhwb3J0cyk7XG52YXIgaW1wb3J0X2V4cHJlc3MgPSBfX3RvRVNNKHJlcXVpcmUoXCJleHByZXNzXCIpKTtcbnZhciBpbXBvcnRfcHJvbWlzZXMgPSBfX3RvRVNNKHJlcXVpcmUoXCJmcy9wcm9taXNlc1wiKSk7XG52YXIgaW1wb3J0X2dldF9wb3J0ID0gX190b0VTTShyZXF1aXJlKFwiZ2V0LXBvcnRcIikpO1xudmFyIGltcG9ydF9wYXRoID0gX190b0VTTShyZXF1aXJlKFwicGF0aFwiKSk7XG52YXIgeiA9IF9fdG9FU00ocmVxdWlyZShcInpvZFwiKSk7XG52YXIgaW1wb3J0X2FjdGlvbiA9IHJlcXVpcmUoXCIuL2FjdGlvbi5qc1wiKTtcbnZhciBpbXBvcnRfaW5kZXggPSByZXF1aXJlKFwiLi9pbmRleC5qc1wiKTtcbnZhciBpbXBvcnRfbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmcuanNcIik7XG52YXIgaW1wb3J0X3NjaGVtYSA9IHJlcXVpcmUoXCIuL3NjaGVtYS5qc1wiKTtcbnZhciBpbXBvcnRfdHJhY2luZyA9IHJlcXVpcmUoXCIuL3RyYWNpbmcuanNcIik7XG5jb25zdCBSdW5BY3Rpb25SZXNwb25zZVNjaGVtYSA9IHoub2JqZWN0KHtcbiAgcmVzdWx0OiB6LnVua25vd24oKS5vcHRpb25hbCgpLFxuICBlcnJvcjogei51bmtub3duKCkub3B0aW9uYWwoKSxcbiAgdGVsZW1ldHJ5OiB6Lm9iamVjdCh7XG4gICAgdHJhY2VJZDogei5zdHJpbmcoKS5vcHRpb25hbCgpXG4gIH0pLm9wdGlvbmFsKClcbn0pO1xuY2xhc3MgUmVmbGVjdGlvblNlcnZlciB7XG4gIC8qKiBMaXN0IG9mIGFsbCBydW5uaW5nIHNlcnZlcnMgbmVlZGVkIHRvIGJlIGNsZWFuZWQgdXAgb24gcHJvY2VzcyBleGl0LiAqL1xuICBzdGF0aWMgUlVOTklOR19TRVJWRVJTID0gW107XG4gIC8qKiBSZWdpc3RyeSBpbnN0YW5jZSB0byBiZSB1c2VkIGZvciBBUEkgY2FsbHMuICovXG4gIHJlZ2lzdHJ5O1xuICAvKiogT3B0aW9ucyBmb3IgdGhlIHJlZmxlY3Rpb24gc2VydmVyLiAqL1xuICBvcHRpb25zO1xuICAvKiogUG9ydCB0aGUgc2VydmVyIGlzIGFjdHVhbGx5IHJ1bm5pbmcgb24uIFRoaXMgbWF5IGRpZmZlciBmcm9tIGBvcHRpb25zLnBvcnRgIGlmIHRoZSBvcmlnaW5hbCB3YXMgb2NjdXBpZWQuIE51bGwgaWYgc2VydmVyIGlzIG5vdCBydW5uaW5nLiAqL1xuICBwb3J0ID0gbnVsbDtcbiAgLyoqIEV4cHJlc3Mgc2VydmVyIGluc3RhbmNlLiBOdWxsIGlmIHNlcnZlciBpcyBub3QgcnVubmluZy4gKi9cbiAgc2VydmVyID0gbnVsbDtcbiAgLyoqIFBhdGggdG8gdGhlIHJ1bnRpbWUgZmlsZS4gTnVsbCBpZiBzZXJ2ZXIgaXMgbm90IHJ1bm5pbmcuICovXG4gIHJ1bnRpbWVGaWxlUGF0aCA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHJlZ2lzdHJ5LCBvcHRpb25zKSB7XG4gICAgdGhpcy5yZWdpc3RyeSA9IHJlZ2lzdHJ5O1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIHBvcnQ6IDMxMDAsXG4gICAgICBib2R5TGltaXQ6IFwiMzBtYlwiLFxuICAgICAgY29uZmlndXJlZEVudnM6IFtcImRldlwiXSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBGaW5kcyBhIGZyZWUgcG9ydCB0byBydW4gdGhlIHNlcnZlciBvbiBiYXNlZCBvbiB0aGUgb3JpZ2luYWwgY2hvc2VuIHBvcnQgYW5kIGVudmlyb25tZW50LlxuICAgKi9cbiAgYXN5bmMgZmluZFBvcnQoKSB7XG4gICAgY29uc3QgY2hvc2VuUG9ydCA9IHRoaXMub3B0aW9ucy5wb3J0O1xuICAgIGNvbnN0IGZyZWVQb3J0ID0gYXdhaXQgKDAsIGltcG9ydF9nZXRfcG9ydC5kZWZhdWx0KSh7XG4gICAgICBwb3J0OiAoMCwgaW1wb3J0X2dldF9wb3J0Lm1ha2VSYW5nZSkoY2hvc2VuUG9ydCwgY2hvc2VuUG9ydCArIDEwMClcbiAgICB9KTtcbiAgICBpZiAoZnJlZVBvcnQgIT09IGNob3NlblBvcnQpIHtcbiAgICAgIGltcG9ydF9sb2dnaW5nLmxvZ2dlci53YXJuKFxuICAgICAgICBgUG9ydCAke2Nob3NlblBvcnR9IGlzIGFscmVhZHkgaW4gdXNlLCB1c2luZyBuZXh0IGF2YWlsYWJsZSBwb3J0ICR7ZnJlZVBvcnR9IGluc3RlYWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyZWVQb3J0O1xuICB9XG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIHNlcnZlci5cbiAgICpcbiAgICogVGhlIHNlcnZlciB3aWxsIGJlIHJlZ2lzdGVyZWQgdG8gYmUgc2h1dCBkb3duIG9uIHByb2Nlc3MgZXhpdC5cbiAgICovXG4gIGFzeW5jIHN0YXJ0KCkge1xuICAgIGNvbnN0IHNlcnZlciA9ICgwLCBpbXBvcnRfZXhwcmVzcy5kZWZhdWx0KSgpO1xuICAgIHNlcnZlci51c2UoaW1wb3J0X2V4cHJlc3MuZGVmYXVsdC5qc29uKHsgbGltaXQ6IHRoaXMub3B0aW9ucy5ib2R5TGltaXQgfSkpO1xuICAgIHNlcnZlci51c2UoKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG4gICAgICByZXMuaGVhZGVyKFwieC1nZW5raXQtdmVyc2lvblwiLCBpbXBvcnRfaW5kZXguR0VOS0lUX1ZFUlNJT04pO1xuICAgICAgbmV4dCgpO1xuICAgIH0pO1xuICAgIHNlcnZlci5nZXQoXCIvYXBpL19faGVhbHRoXCIsIGFzeW5jIChfLCByZXNwb25zZSkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5yZWdpc3RyeS5saXN0QWN0aW9ucygpO1xuICAgICAgcmVzcG9uc2Uuc3RhdHVzKDIwMCkuc2VuZChcIk9LXCIpO1xuICAgIH0pO1xuICAgIHNlcnZlci5nZXQoXCIvYXBpL19fcXVpdHF1aXRxdWl0XCIsIGFzeW5jIChfLCByZXNwb25zZSkgPT4ge1xuICAgICAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLmRlYnVnKFwiUmVjZWl2ZWQgcXVpdHF1aXRxdWl0XCIpO1xuICAgICAgcmVzcG9uc2Uuc3RhdHVzKDIwMCkuc2VuZChcIk9LXCIpO1xuICAgICAgYXdhaXQgdGhpcy5zdG9wKCk7XG4gICAgfSk7XG4gICAgc2VydmVyLmdldChcIi9hcGkvYWN0aW9uc1wiLCBhc3luYyAoXywgcmVzcG9uc2UsIG5leHQpID0+IHtcbiAgICAgIGltcG9ydF9sb2dnaW5nLmxvZ2dlci5kZWJ1ZyhcIkZldGNoaW5nIGFjdGlvbnMuXCIpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IGF3YWl0IHRoaXMucmVnaXN0cnkubGlzdFJlc29sdmFibGVBY3Rpb25zKCk7XG4gICAgICAgIGNvbnN0IGNvbnZlcnRlZEFjdGlvbnMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoYWN0aW9ucykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgY29uc3QgYWN0aW9uID0gYWN0aW9uc1trZXldO1xuICAgICAgICAgIGNvbnZlcnRlZEFjdGlvbnNba2V5XSA9IHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIG5hbWU6IGFjdGlvbi5uYW1lLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGFjdGlvbi5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIG1ldGFkYXRhOiBhY3Rpb24ubWV0YWRhdGFcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChhY3Rpb24uaW5wdXRTY2hlbWEgfHwgYWN0aW9uLmlucHV0SnNvblNjaGVtYSkge1xuICAgICAgICAgICAgY29udmVydGVkQWN0aW9uc1trZXldLmlucHV0U2NoZW1hID0gKDAsIGltcG9ydF9zY2hlbWEudG9Kc29uU2NoZW1hKSh7XG4gICAgICAgICAgICAgIHNjaGVtYTogYWN0aW9uLmlucHV0U2NoZW1hLFxuICAgICAgICAgICAgICBqc29uU2NoZW1hOiBhY3Rpb24uaW5wdXRKc29uU2NoZW1hXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFjdGlvbi5vdXRwdXRTY2hlbWEgfHwgYWN0aW9uLm91dHB1dEpzb25TY2hlbWEpIHtcbiAgICAgICAgICAgIGNvbnZlcnRlZEFjdGlvbnNba2V5XS5vdXRwdXRTY2hlbWEgPSAoMCwgaW1wb3J0X3NjaGVtYS50b0pzb25TY2hlbWEpKHtcbiAgICAgICAgICAgICAgc2NoZW1hOiBhY3Rpb24ub3V0cHV0U2NoZW1hLFxuICAgICAgICAgICAgICBqc29uU2NoZW1hOiBhY3Rpb24ub3V0cHV0SnNvblNjaGVtYVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVzcG9uc2Uuc2VuZChjb252ZXJ0ZWRBY3Rpb25zKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2UsIHN0YWNrIH0gPSBlcnI7XG4gICAgICAgIG5leHQoeyBtZXNzYWdlLCBzdGFjayB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzZXJ2ZXIucG9zdChcIi9hcGkvcnVuQWN0aW9uXCIsIGFzeW5jIChyZXF1ZXN0LCByZXNwb25zZSwgbmV4dCkgPT4ge1xuICAgICAgY29uc3QgeyBrZXksIGlucHV0LCBjb250ZXh0LCB0ZWxlbWV0cnlMYWJlbHMgfSA9IHJlcXVlc3QuYm9keTtcbiAgICAgIGNvbnN0IHsgc3RyZWFtIH0gPSByZXF1ZXN0LnF1ZXJ5O1xuICAgICAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLmRlYnVnKGBSdW5uaW5nIGFjdGlvbiBcXGAke2tleX1cXGAgd2l0aCBzdHJlYW09JHtzdHJlYW19Li4uYCk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhY3Rpb24gPSBhd2FpdCB0aGlzLnJlZ2lzdHJ5Lmxvb2t1cEFjdGlvbihrZXkpO1xuICAgICAgICBpZiAoIWFjdGlvbikge1xuICAgICAgICAgIHJlc3BvbnNlLnN0YXR1cyg0MDQpLnNlbmQoYGFjdGlvbiAke2tleX0gbm90IGZvdW5kYCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0gPT09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgIHJlc3BvbnNlLndyaXRlKEpTT04uc3RyaW5naWZ5KGNodW5rKSArIFwiXFxuXCIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFjdGlvbi5ydW4oaW5wdXQsIHtcbiAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgb25DaHVuazogY2FsbGJhY2ssXG4gICAgICAgICAgICAgIHRlbGVtZXRyeUxhYmVsc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCAoMCwgaW1wb3J0X3RyYWNpbmcuZmx1c2hUcmFjaW5nKSgpO1xuICAgICAgICAgICAgcmVzcG9uc2Uud3JpdGUoXG4gICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdC5yZXN1bHQsXG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5OiB7XG4gICAgICAgICAgICAgICAgICB0cmFjZUlkOiByZXN1bHQudGVsZW1ldHJ5LnRyYWNlSWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVzcG9uc2UuZW5kKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zdCB7IG1lc3NhZ2UsIHN0YWNrIH0gPSBlcnI7XG4gICAgICAgICAgICBjb25zdCBlcnJvclJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICBjb2RlOiBpbXBvcnRfYWN0aW9uLlN0YXR1c0NvZGVzLklOVEVSTkFMLFxuICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgICAgc3RhY2tcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChlcnIudHJhY2VJZCkge1xuICAgICAgICAgICAgICBlcnJvclJlc3BvbnNlLmRldGFpbHMudHJhY2VJZCA9IGVyci50cmFjZUlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzcG9uc2Uud3JpdGUoXG4gICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JSZXNwb25zZVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlc3BvbnNlLmVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhY3Rpb24ucnVuKGlucHV0LCB7IGNvbnRleHQsIHRlbGVtZXRyeUxhYmVscyB9KTtcbiAgICAgICAgICBhd2FpdCAoMCwgaW1wb3J0X3RyYWNpbmcuZmx1c2hUcmFjaW5nKSgpO1xuICAgICAgICAgIHJlc3BvbnNlLnNlbmQoe1xuICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQucmVzdWx0LFxuICAgICAgICAgICAgdGVsZW1ldHJ5OiB7XG4gICAgICAgICAgICAgIHRyYWNlSWQ6IHJlc3VsdC50ZWxlbWV0cnkudHJhY2VJZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlLCBzdGFjaywgdHJhY2VJZCB9ID0gZXJyO1xuICAgICAgICBuZXh0KHsgbWVzc2FnZSwgc3RhY2ssIHRyYWNlSWQgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2VydmVyLmdldChcIi9hcGkvZW52c1wiLCBhc3luYyAoXywgcmVzcG9uc2UpID0+IHtcbiAgICAgIHJlc3BvbnNlLmpzb24odGhpcy5vcHRpb25zLmNvbmZpZ3VyZWRFbnZzKTtcbiAgICB9KTtcbiAgICBzZXJ2ZXIucG9zdChcIi9hcGkvbm90aWZ5XCIsIGFzeW5jIChyZXF1ZXN0LCByZXNwb25zZSkgPT4ge1xuICAgICAgY29uc3QgeyB0ZWxlbWV0cnlTZXJ2ZXJVcmwsIHJlZmxlY3Rpb25BcGlTcGVjVmVyc2lvbiB9ID0gcmVxdWVzdC5ib2R5O1xuICAgICAgaWYgKCFwcm9jZXNzLmVudi5HRU5LSVRfVEVMRU1FVFJZX1NFUlZFUikge1xuICAgICAgICBpZiAodHlwZW9mIHRlbGVtZXRyeVNlcnZlclVybCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICgwLCBpbXBvcnRfdHJhY2luZy5zZXRUZWxlbWV0cnlTZXJ2ZXJVcmwpKHRlbGVtZXRyeVNlcnZlclVybCk7XG4gICAgICAgICAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLmRlYnVnKFxuICAgICAgICAgICAgYENvbm5lY3RlZCB0byB0ZWxlbWV0cnkgc2VydmVyIG9uICR7dGVsZW1ldHJ5U2VydmVyVXJsfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVmbGVjdGlvbkFwaVNwZWNWZXJzaW9uICE9PSBpbXBvcnRfaW5kZXguR0VOS0lUX1JFRkxFQ1RJT05fQVBJX1NQRUNfVkVSU0lPTikge1xuICAgICAgICBpZiAoIXJlZmxlY3Rpb25BcGlTcGVjVmVyc2lvbiB8fCByZWZsZWN0aW9uQXBpU3BlY1ZlcnNpb24gPCBpbXBvcnRfaW5kZXguR0VOS0lUX1JFRkxFQ1RJT05fQVBJX1NQRUNfVkVSU0lPTikge1xuICAgICAgICAgIGltcG9ydF9sb2dnaW5nLmxvZ2dlci53YXJuKFxuICAgICAgICAgICAgXCJXQVJOSU5HOiBHZW5raXQgQ0xJIHZlcnNpb24gbWF5IGJlIG91dGRhdGVkLiBQbGVhc2UgdXBkYXRlIGBnZW5raXQtY2xpYCB0byB0aGUgbGF0ZXN0IHZlcnNpb24uXCJcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGltcG9ydF9sb2dnaW5nLmxvZ2dlci53YXJuKFxuICAgICAgICAgICAgYEdlbmtpdCBDTEkgaXMgbmV3ZXIgdGhhbiBydW50aW1lIGxpYnJhcnkuIFNvbWUgZmVhdHVyZSBtYXkgbm90IGJlIHN1cHBvcnRlZC4gQ29uc2lkZXIgdXBncmFkaW5nIHlvdXIgcnVudGltZSBsaWJyYXJ5IHZlcnNpb24gKGRlYnVnIGluZm86IGV4cGVjdGVkICR7aW1wb3J0X2luZGV4LkdFTktJVF9SRUZMRUNUSU9OX0FQSV9TUEVDX1ZFUlNJT059LCBnb3QgJHtyZWZsZWN0aW9uQXBpU3BlY1ZlcnNpb259KS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzcG9uc2Uuc3RhdHVzKDIwMCkuc2VuZChcIk9LXCIpO1xuICAgIH0pO1xuICAgIHNlcnZlci51c2UoKGVyciwgcmVxLCByZXMsIG5leHQpID0+IHtcbiAgICAgIGltcG9ydF9sb2dnaW5nLmxvZ2dlci5lcnJvcihlcnIuc3RhY2spO1xuICAgICAgY29uc3QgZXJyb3IgPSBlcnI7XG4gICAgICBjb25zdCB7IG1lc3NhZ2UsIHN0YWNrIH0gPSBlcnJvcjtcbiAgICAgIGNvbnN0IGVycm9yUmVzcG9uc2UgPSB7XG4gICAgICAgIGNvZGU6IGltcG9ydF9hY3Rpb24uU3RhdHVzQ29kZXMuSU5URVJOQUwsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICBzdGFja1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGVyci50cmFjZUlkKSB7XG4gICAgICAgIGVycm9yUmVzcG9uc2UuZGV0YWlscy50cmFjZUlkID0gZXJyLnRyYWNlSWQ7XG4gICAgICB9XG4gICAgICByZXMuc3RhdHVzKDUwMCkuanNvbihlcnJvclJlc3BvbnNlKTtcbiAgICB9KTtcbiAgICB0aGlzLnBvcnQgPSBhd2FpdCB0aGlzLmZpbmRQb3J0KCk7XG4gICAgdGhpcy5zZXJ2ZXIgPSBzZXJ2ZXIubGlzdGVuKHRoaXMucG9ydCwgYXN5bmMgKCkgPT4ge1xuICAgICAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLmRlYnVnKFxuICAgICAgICBgUmVmbGVjdGlvbiBzZXJ2ZXIgKCR7cHJvY2Vzcy5waWR9KSBydW5uaW5nIG9uIGh0dHA6Ly9sb2NhbGhvc3Q6JHt0aGlzLnBvcnR9YFxuICAgICAgKTtcbiAgICAgIFJlZmxlY3Rpb25TZXJ2ZXIuUlVOTklOR19TRVJWRVJTLnB1c2godGhpcyk7XG4gICAgICBhd2FpdCB0aGlzLndyaXRlUnVudGltZUZpbGUoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3RvcHMgdGhlIHNlcnZlciBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBsaXN0IG9mIHJ1bm5pbmcgc2VydmVycyB0byBjbGVhbiB1cCBvbiBleGl0LlxuICAgKi9cbiAgYXN5bmMgc3RvcCgpIHtcbiAgICBpZiAoIXRoaXMuc2VydmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLmNsZWFudXBSdW50aW1lRmlsZSgpO1xuICAgICAgdGhpcy5zZXJ2ZXIuY2xvc2UoYXN5bmMgKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgYEVycm9yIHNodXR0aW5nIGRvd24gcmVmbGVjdGlvbiBzZXJ2ZXIgb24gcG9ydCAke3RoaXMucG9ydH06ICR7ZXJyfWBcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ID0gUmVmbGVjdGlvblNlcnZlci5SVU5OSU5HX1NFUlZFUlMuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICBSZWZsZWN0aW9uU2VydmVyLlJVTk5JTkdfU0VSVkVSUy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGltcG9ydF9sb2dnaW5nLmxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgICBgUmVmbGVjdGlvbiBzZXJ2ZXIgb24gcG9ydCAke3RoaXMucG9ydH0gaGFzIHN1Y2Nlc3NmdWxseSBzaHV0IGRvd24uYFxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBvcnQgPSBudWxsO1xuICAgICAgICB0aGlzLnNlcnZlciA9IG51bGw7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZXMgdGhlIHJ1bnRpbWUgZmlsZSB0byB0aGUgcHJvamVjdCByb290LlxuICAgKi9cbiAgYXN5bmMgd3JpdGVSdW50aW1lRmlsZSgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgcm9vdERpciA9IGF3YWl0IGZpbmRQcm9qZWN0Um9vdCgpO1xuICAgICAgY29uc3QgcnVudGltZXNEaXIgPSBpbXBvcnRfcGF0aC5kZWZhdWx0LmpvaW4ocm9vdERpciwgXCIuZ2Vua2l0XCIsIFwicnVudGltZXNcIik7XG4gICAgICBjb25zdCBkYXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCB0aW1lID0gZGF0ZS5nZXRUaW1lKCk7XG4gICAgICBjb25zdCB0aW1lc3RhbXAgPSBkYXRlLnRvSVNPU3RyaW5nKCk7XG4gICAgICBjb25zdCBydW50aW1lSWQgPSBgJHtwcm9jZXNzLnBpZH0ke3RoaXMucG9ydCAhPT0gbnVsbCA/IGAtJHt0aGlzLnBvcnR9YCA6IFwiXCJ9YDtcbiAgICAgIHRoaXMucnVudGltZUZpbGVQYXRoID0gaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKFxuICAgICAgICBydW50aW1lc0RpcixcbiAgICAgICAgYCR7cnVudGltZUlkfS0ke3RpbWV9Lmpzb25gXG4gICAgICApO1xuICAgICAgY29uc3QgZmlsZUNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShcbiAgICAgICAge1xuICAgICAgICAgIGlkOiBwcm9jZXNzLmVudi5HRU5LSVRfUlVOVElNRV9JRCB8fCBydW50aW1lSWQsXG4gICAgICAgICAgcGlkOiBwcm9jZXNzLnBpZCxcbiAgICAgICAgICBuYW1lOiB0aGlzLm9wdGlvbnMubmFtZSxcbiAgICAgICAgICByZWZsZWN0aW9uU2VydmVyVXJsOiBgaHR0cDovL2xvY2FsaG9zdDoke3RoaXMucG9ydH1gLFxuICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICBnZW5raXRWZXJzaW9uOiBgbm9kZWpzLyR7aW1wb3J0X2luZGV4LkdFTktJVF9WRVJTSU9OfWAsXG4gICAgICAgICAgcmVmbGVjdGlvbkFwaVNwZWNWZXJzaW9uOiBpbXBvcnRfaW5kZXguR0VOS0lUX1JFRkxFQ1RJT05fQVBJX1NQRUNfVkVSU0lPTlxuICAgICAgICB9LFxuICAgICAgICBudWxsLFxuICAgICAgICAyXG4gICAgICApO1xuICAgICAgYXdhaXQgaW1wb3J0X3Byb21pc2VzLmRlZmF1bHQubWtkaXIocnVudGltZXNEaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgYXdhaXQgaW1wb3J0X3Byb21pc2VzLmRlZmF1bHQud3JpdGVGaWxlKHRoaXMucnVudGltZUZpbGVQYXRoLCBmaWxlQ29udGVudCwgXCJ1dGY4XCIpO1xuICAgICAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLmRlYnVnKGBSdW50aW1lIGZpbGUgd3JpdHRlbjogJHt0aGlzLnJ1bnRpbWVGaWxlUGF0aH1gKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLmVycm9yKGBFcnJvciB3cml0aW5nIHJ1bnRpbWUgZmlsZTogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENsZWFucyB1cCB0aGUgcG9ydCBmaWxlLlxuICAgKi9cbiAgYXN5bmMgY2xlYW51cFJ1bnRpbWVGaWxlKCkge1xuICAgIGlmICghdGhpcy5ydW50aW1lRmlsZVBhdGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZpbGVDb250ZW50ID0gYXdhaXQgaW1wb3J0X3Byb21pc2VzLmRlZmF1bHQucmVhZEZpbGUodGhpcy5ydW50aW1lRmlsZVBhdGgsIFwidXRmOFwiKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGZpbGVDb250ZW50KTtcbiAgICAgIGlmIChkYXRhLnBpZCA9PT0gcHJvY2Vzcy5waWQpIHtcbiAgICAgICAgYXdhaXQgaW1wb3J0X3Byb21pc2VzLmRlZmF1bHQudW5saW5rKHRoaXMucnVudGltZUZpbGVQYXRoKTtcbiAgICAgICAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLmRlYnVnKGBSdW50aW1lIGZpbGUgY2xlYW5lZCB1cDogJHt0aGlzLnJ1bnRpbWVGaWxlUGF0aH1gKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLmVycm9yKGBFcnJvciBjbGVhbmluZyB1cCBydW50aW1lIGZpbGU6ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTdG9wcyBhbGwgcnVubmluZyByZWZsZWN0aW9uIHNlcnZlcnMuXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgc3RvcEFsbCgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICBSZWZsZWN0aW9uU2VydmVyLlJVTk5JTkdfU0VSVkVSUy5tYXAoKHNlcnZlcikgPT4gc2VydmVyLnN0b3AoKSlcbiAgICApO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBmaW5kUHJvamVjdFJvb3QoKSB7XG4gIGxldCBjdXJyZW50RGlyID0gcHJvY2Vzcy5jd2QoKTtcbiAgd2hpbGUgKGN1cnJlbnREaXIgIT09IGltcG9ydF9wYXRoLmRlZmF1bHQucGFyc2UoY3VycmVudERpcikucm9vdCkge1xuICAgIGNvbnN0IHBhY2thZ2VKc29uUGF0aCA9IGltcG9ydF9wYXRoLmRlZmF1bHQuam9pbihjdXJyZW50RGlyLCBcInBhY2thZ2UuanNvblwiKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgaW1wb3J0X3Byb21pc2VzLmRlZmF1bHQuYWNjZXNzKHBhY2thZ2VKc29uUGF0aCk7XG4gICAgICByZXR1cm4gY3VycmVudERpcjtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGN1cnJlbnREaXIgPSBpbXBvcnRfcGF0aC5kZWZhdWx0LmRpcm5hbWUoY3VycmVudERpcik7XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIHByb2plY3Qgcm9vdCAocGFja2FnZS5qc29uIG5vdCBmb3VuZClcIik7XG59XG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcImhvdFwiIGluIG1vZHVsZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpO1xuICBtb2R1bGUuaG90LmRpc3Bvc2UoYXN5bmMgKCkgPT4ge1xuICAgIGltcG9ydF9sb2dnaW5nLmxvZ2dlci5kZWJ1ZyhcIkNsZWFuaW5nIHVwIHJlZmxlY3Rpb24gc2VydmVyKHMpIGJlZm9yZSBtb2R1bGUgcmVsb2FkLi4uXCIpO1xuICAgIGF3YWl0IFJlZmxlY3Rpb25TZXJ2ZXIuc3RvcEFsbCgpO1xuICB9KTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBSZWZsZWN0aW9uU2VydmVyLFxuICBSdW5BY3Rpb25SZXNwb25zZVNjaGVtYVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWZsZWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/reflection.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/registry.js":
/*!******************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/registry.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar registry_exports = {};\n__export(registry_exports, {\n  Registry: () => Registry,\n  parseRegistryKey: () => parseRegistryKey\n});\nmodule.exports = __toCommonJS(registry_exports);\nvar import_dotprompt = __webpack_require__(/*! dotprompt */ \"(action-browser)/./node_modules/dotprompt/dist/index.js\");\nvar import_action = __webpack_require__(/*! ./action.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/action.js\");\nvar import_background_action = __webpack_require__(/*! ./background-action.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/background-action.js\");\nvar import_error = __webpack_require__(/*! ./error.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/error.js\");\nvar import_logging = __webpack_require__(/*! ./logging.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/logging.js\");\nvar import_schema = __webpack_require__(/*! ./schema.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/schema.js\");\nfunction parsePluginName(registryKey) {\n  const tokens = registryKey.split(\"/\");\n  if (tokens.length >= 4) {\n    return tokens[2];\n  }\n  return void 0;\n}\nfunction parseRegistryKey(registryKey) {\n  const tokens = registryKey.split(\"/\");\n  if (tokens.length < 3) {\n    return void 0;\n  }\n  if (tokens.length >= 4) {\n    return {\n      actionType: tokens[1],\n      pluginName: tokens[2],\n      actionName: tokens.slice(3).join(\"/\")\n    };\n  }\n  return {\n    actionType: tokens[1],\n    actionName: tokens[2]\n  };\n}\nclass Registry {\n  actionsById = {};\n  pluginsByName = {};\n  schemasByName = {};\n  valueByTypeAndName = {};\n  allPluginsInitialized = false;\n  apiStability = \"stable\";\n  dotprompt;\n  parent;\n  /** Additional runtime context data for flows and tools. */\n  context;\n  constructor(parent) {\n    if (parent) {\n      this.parent = parent;\n      this.apiStability = parent?.apiStability;\n      this.dotprompt = parent.dotprompt;\n    } else {\n      this.dotprompt = new import_dotprompt.Dotprompt({\n        schemaResolver: async (name) => {\n          const resolvedSchema = await this.lookupSchema(name);\n          if (!resolvedSchema) {\n            throw new import_error.GenkitError({\n              message: `Schema '${name}' not found`,\n              status: \"NOT_FOUND\"\n            });\n          }\n          return (0, import_schema.toJsonSchema)(resolvedSchema);\n        }\n      });\n    }\n  }\n  /**\n   * Creates a new registry overlaid onto the provided registry.\n   * @param parent The parent registry.\n   * @returns The new overlaid registry.\n   */\n  static withParent(parent) {\n    return new Registry(parent);\n  }\n  /**\n   * Looks up an action in the registry.\n   * @param key The key of the action to lookup.\n   * @returns The action.\n   */\n  async lookupAction(key) {\n    const parsedKey = parseRegistryKey(key);\n    if (parsedKey?.pluginName && this.pluginsByName[parsedKey.pluginName]) {\n      await this.initializePlugin(parsedKey.pluginName);\n      if (!this.actionsById[key]) {\n        await this.resolvePluginAction(\n          parsedKey.pluginName,\n          parsedKey.actionType,\n          parsedKey.actionName\n        );\n      }\n    }\n    return await this.actionsById[key] || this.parent?.lookupAction(key);\n  }\n  /**\n   * Looks up a background action from the registry.\n   * @param key The key of the action to lookup.\n   * @returns The action.\n   */\n  async lookupBackgroundAction(key) {\n    return (0, import_background_action.lookupBackgroundAction)(this, key);\n  }\n  /**\n   * Registers an action in the registry.\n   * @param type The type of the action to register.\n   * @param action The action to register.\n   */\n  registerAction(type, action, opts) {\n    if (type !== action.__action.actionType) {\n      throw new import_error.GenkitError({\n        status: \"INVALID_ARGUMENT\",\n        message: `action type (${type}) does not match type on action (${action.__action.actionType})`\n      });\n    }\n    if (opts?.namespace && !action.__action.name.startsWith(`${opts.namespace}/`)) {\n      action.__action.name = `${opts.namespace}/${action.__action.name}`;\n    }\n    const key = `/${type}/${action.__action.name}`;\n    import_logging.logger.debug(`registering ${key}`);\n    if (this.actionsById.hasOwnProperty(key)) {\n      import_logging.logger.warn(\n        `WARNING: ${key} already has an entry in the registry. Overwriting.`\n      );\n    }\n    this.actionsById[key] = action;\n    if (action.__registry) {\n      import_logging.logger.error(`ERROR: ${key} already registered.`);\n    }\n    action.__registry = this;\n  }\n  /**\n   * Registers an action promise in the registry.\n   */\n  registerActionAsync(type, name, action, opts) {\n    if (opts?.namespace && !name.startsWith(`${opts.namespace}/`)) {\n      name = `${opts.namespace}/${name}`;\n    }\n    const key = `/${type}/${name}`;\n    import_logging.logger.debug(`registering ${key} (async)`);\n    if (this.actionsById.hasOwnProperty(key)) {\n      import_logging.logger.warn(\n        `WARNING: ${key} already has an entry in the registry. Overwriting.`\n      );\n    }\n    this.actionsById[key] = action;\n  }\n  /**\n   * Returns all actions that have been registered in the registry.\n   * @returns All actions in the registry as a map of <key, action>.\n   */\n  async listActions() {\n    await this.initializeAllPlugins();\n    const actions = {};\n    await Promise.all(\n      Object.entries(this.actionsById).map(async ([key, action]) => {\n        actions[key] = await action;\n      })\n    );\n    return {\n      ...await this.parent?.listActions(),\n      ...actions\n    };\n  }\n  /**\n   * Returns all actions that are resolvable by plugins as well as those that are already\n   * in the registry.\n   *\n   * NOTE: this method should not be used in latency sensitive code paths.\n   * It may rely on \"admin\" API calls such as \"list models\", which may cause increased cold start latency.\n   *\n   * @returns All resolvable action metadata as a map of <key, action metadata>.\n   */\n  async listResolvableActions() {\n    const resolvableActions = {};\n    await Promise.all(\n      Object.entries(this.pluginsByName).map(async ([pluginName, plugin]) => {\n        if (plugin.listActions) {\n          try {\n            (await plugin.listActions()).forEach((meta) => {\n              if (!meta.name) {\n                throw new import_error.GenkitError({\n                  status: \"INVALID_ARGUMENT\",\n                  message: `Invalid metadata when listing actions from ${pluginName} - name required`\n                });\n              }\n              if (!meta.actionType) {\n                throw new import_error.GenkitError({\n                  status: \"INVALID_ARGUMENT\",\n                  message: `Invalid metadata when listing actions from ${pluginName} - actionType required`\n                });\n              }\n              resolvableActions[`/${meta.actionType}/${meta.name}`] = meta;\n            });\n          } catch (e) {\n            import_logging.logger.error(`Error listing actions for ${pluginName}\n`, e);\n          }\n        }\n      })\n    );\n    for (const [key, action] of Object.entries(await this.listActions())) {\n      resolvableActions[key] = action.__action;\n    }\n    return {\n      ...await this.parent?.listResolvableActions(),\n      ...resolvableActions\n    };\n  }\n  /**\n   * Initializes all plugins in the registry.\n   */\n  async initializeAllPlugins() {\n    if (this.allPluginsInitialized) {\n      return;\n    }\n    for (const pluginName of Object.keys(this.pluginsByName)) {\n      await this.initializePlugin(pluginName);\n    }\n    this.allPluginsInitialized = true;\n  }\n  /**\n   * Registers a plugin provider. This plugin must be initialized before it can be used by calling {@link initializePlugin} or {@link initializeAllPlugins}.\n   * @param name The name of the plugin to register.\n   * @param provider The plugin provider.\n   */\n  registerPluginProvider(name, provider) {\n    if (this.pluginsByName[name]) {\n      throw new Error(`Plugin ${name} already registered`);\n    }\n    this.allPluginsInitialized = false;\n    let cached;\n    let isInitialized = false;\n    this.pluginsByName[name] = {\n      name: provider.name,\n      initializer: () => {\n        if (!isInitialized) {\n          cached = provider.initializer();\n          isInitialized = true;\n        }\n        return cached;\n      },\n      resolver: async (actionType, actionName) => {\n        if (provider.resolver) {\n          await provider.resolver(actionType, actionName);\n        }\n      },\n      listActions: async () => {\n        if (provider.listActions) {\n          return await provider.listActions();\n        }\n        return [];\n      }\n    };\n  }\n  /**\n   * Looks up a plugin.\n   * @param name The name of the plugin to lookup.\n   * @returns The plugin provider.\n   */\n  lookupPlugin(name) {\n    return this.pluginsByName[name] || this.parent?.lookupPlugin(name);\n  }\n  /**\n   * Resolves a new Action dynamically by registering it.\n   * @param pluginName The name of the plugin\n   * @param actionType The type of the action\n   * @param actionName The name of the action\n   * @returns\n   */\n  async resolvePluginAction(pluginName, actionType, actionName) {\n    const plugin = this.pluginsByName[pluginName];\n    if (plugin) {\n      return await (0, import_action.runOutsideActionRuntimeContext)(async () => {\n        if (plugin.resolver) {\n          await plugin.resolver(actionType, actionName);\n        }\n      });\n    }\n  }\n  /**\n   * Initializes a plugin already registered with {@link registerPluginProvider}.\n   * @param name The name of the plugin to initialize.\n   * @returns The plugin.\n   */\n  async initializePlugin(name) {\n    if (this.pluginsByName[name]) {\n      return await (0, import_action.runOutsideActionRuntimeContext)(\n        () => this.pluginsByName[name].initializer()\n      );\n    }\n  }\n  /**\n   * Registers a schema.\n   * @param name The name of the schema to register.\n   * @param data The schema to register (either a Zod schema or a JSON schema).\n   */\n  registerSchema(name, data) {\n    if (this.schemasByName[name]) {\n      throw new Error(`Schema ${name} already registered`);\n    }\n    this.schemasByName[name] = data;\n  }\n  registerValue(type, name, value) {\n    if (!this.valueByTypeAndName[type]) {\n      this.valueByTypeAndName[type] = {};\n    }\n    this.valueByTypeAndName[type][name] = value;\n  }\n  async lookupValue(type, key) {\n    const pluginName = parsePluginName(key);\n    if (!this.valueByTypeAndName[type]?.[key] && pluginName) {\n      await this.initializePlugin(pluginName);\n    }\n    return this.valueByTypeAndName[type]?.[key] || this.parent?.lookupValue(type, key);\n  }\n  async listValues(type) {\n    await this.initializeAllPlugins();\n    return {\n      ...await this.parent?.listValues(type) || {},\n      ...this.valueByTypeAndName[type] || {}\n    };\n  }\n  /**\n   * Looks up a schema.\n   * @param name The name of the schema to lookup.\n   * @returns The schema.\n   */\n  lookupSchema(name) {\n    return this.schemasByName[name] || this.parent?.lookupSchema(name);\n  }\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=registry.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3JlZ2lzdHJ5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQywwRUFBVztBQUMxQyxvQkFBb0IsbUJBQU8sQ0FBQyxrRkFBYTtBQUN6QywrQkFBK0IsbUJBQU8sQ0FBQyx3R0FBd0I7QUFDL0QsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQVk7QUFDdkMscUJBQXFCLG1CQUFPLENBQUMsb0ZBQWM7QUFDM0Msb0JBQW9CLG1CQUFPLENBQUMsa0ZBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxLQUFLO0FBQ3ZDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxLQUFLLG1DQUFtQywyQkFBMkI7QUFDcEcsT0FBTztBQUNQO0FBQ0EsK0RBQStELGVBQWU7QUFDOUUsZ0NBQWdDLGVBQWUsR0FBRyxxQkFBcUI7QUFDdkU7QUFDQSxvQkFBb0IsS0FBSyxHQUFHLHFCQUFxQjtBQUNqRCwrQ0FBK0MsSUFBSTtBQUNuRDtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsS0FBSztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxlQUFlO0FBQzlELGdCQUFnQixlQUFlLEdBQUcsS0FBSztBQUN2QztBQUNBLG9CQUFvQixLQUFLLEdBQUcsS0FBSztBQUNqQywrQ0FBK0MsS0FBSztBQUNwRDtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxZQUFZO0FBQ3JGLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxZQUFZO0FBQ3JGLGlCQUFpQjtBQUNqQjtBQUNBLG9DQUFvQyxnQkFBZ0IsR0FBRyxVQUFVO0FBQ2pFLGFBQWE7QUFDYixZQUFZO0FBQ1oscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRyx3QkFBd0IsSUFBSSwyQkFBMkI7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDZCQUE2QjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBR0w7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcY29yZVxcbGliXFxyZWdpc3RyeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgcmVnaXN0cnlfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocmVnaXN0cnlfZXhwb3J0cywge1xuICBSZWdpc3RyeTogKCkgPT4gUmVnaXN0cnksXG4gIHBhcnNlUmVnaXN0cnlLZXk6ICgpID0+IHBhcnNlUmVnaXN0cnlLZXlcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMocmVnaXN0cnlfZXhwb3J0cyk7XG52YXIgaW1wb3J0X2RvdHByb21wdCA9IHJlcXVpcmUoXCJkb3Rwcm9tcHRcIik7XG52YXIgaW1wb3J0X2FjdGlvbiA9IHJlcXVpcmUoXCIuL2FjdGlvbi5qc1wiKTtcbnZhciBpbXBvcnRfYmFja2dyb3VuZF9hY3Rpb24gPSByZXF1aXJlKFwiLi9iYWNrZ3JvdW5kLWFjdGlvbi5qc1wiKTtcbnZhciBpbXBvcnRfZXJyb3IgPSByZXF1aXJlKFwiLi9lcnJvci5qc1wiKTtcbnZhciBpbXBvcnRfbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmcuanNcIik7XG52YXIgaW1wb3J0X3NjaGVtYSA9IHJlcXVpcmUoXCIuL3NjaGVtYS5qc1wiKTtcbmZ1bmN0aW9uIHBhcnNlUGx1Z2luTmFtZShyZWdpc3RyeUtleSkge1xuICBjb25zdCB0b2tlbnMgPSByZWdpc3RyeUtleS5zcGxpdChcIi9cIik7XG4gIGlmICh0b2tlbnMubGVuZ3RoID49IDQpIHtcbiAgICByZXR1cm4gdG9rZW5zWzJdO1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5mdW5jdGlvbiBwYXJzZVJlZ2lzdHJ5S2V5KHJlZ2lzdHJ5S2V5KSB7XG4gIGNvbnN0IHRva2VucyA9IHJlZ2lzdHJ5S2V5LnNwbGl0KFwiL1wiKTtcbiAgaWYgKHRva2Vucy5sZW5ndGggPCAzKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAodG9rZW5zLmxlbmd0aCA+PSA0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGlvblR5cGU6IHRva2Vuc1sxXSxcbiAgICAgIHBsdWdpbk5hbWU6IHRva2Vuc1syXSxcbiAgICAgIGFjdGlvbk5hbWU6IHRva2Vucy5zbGljZSgzKS5qb2luKFwiL1wiKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhY3Rpb25UeXBlOiB0b2tlbnNbMV0sXG4gICAgYWN0aW9uTmFtZTogdG9rZW5zWzJdXG4gIH07XG59XG5jbGFzcyBSZWdpc3RyeSB7XG4gIGFjdGlvbnNCeUlkID0ge307XG4gIHBsdWdpbnNCeU5hbWUgPSB7fTtcbiAgc2NoZW1hc0J5TmFtZSA9IHt9O1xuICB2YWx1ZUJ5VHlwZUFuZE5hbWUgPSB7fTtcbiAgYWxsUGx1Z2luc0luaXRpYWxpemVkID0gZmFsc2U7XG4gIGFwaVN0YWJpbGl0eSA9IFwic3RhYmxlXCI7XG4gIGRvdHByb21wdDtcbiAgcGFyZW50O1xuICAvKiogQWRkaXRpb25hbCBydW50aW1lIGNvbnRleHQgZGF0YSBmb3IgZmxvd3MgYW5kIHRvb2xzLiAqL1xuICBjb250ZXh0O1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgIHRoaXMuYXBpU3RhYmlsaXR5ID0gcGFyZW50Py5hcGlTdGFiaWxpdHk7XG4gICAgICB0aGlzLmRvdHByb21wdCA9IHBhcmVudC5kb3Rwcm9tcHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZG90cHJvbXB0ID0gbmV3IGltcG9ydF9kb3Rwcm9tcHQuRG90cHJvbXB0KHtcbiAgICAgICAgc2NoZW1hUmVzb2x2ZXI6IGFzeW5jIChuYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzb2x2ZWRTY2hlbWEgPSBhd2FpdCB0aGlzLmxvb2t1cFNjaGVtYShuYW1lKTtcbiAgICAgICAgICBpZiAoIXJlc29sdmVkU2NoZW1hKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgaW1wb3J0X2Vycm9yLkdlbmtpdEVycm9yKHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogYFNjaGVtYSAnJHtuYW1lfScgbm90IGZvdW5kYCxcbiAgICAgICAgICAgICAgc3RhdHVzOiBcIk5PVF9GT1VORFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICgwLCBpbXBvcnRfc2NoZW1hLnRvSnNvblNjaGVtYSkocmVzb2x2ZWRTY2hlbWEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgcmVnaXN0cnkgb3ZlcmxhaWQgb250byB0aGUgcHJvdmlkZWQgcmVnaXN0cnkuXG4gICAqIEBwYXJhbSBwYXJlbnQgVGhlIHBhcmVudCByZWdpc3RyeS5cbiAgICogQHJldHVybnMgVGhlIG5ldyBvdmVybGFpZCByZWdpc3RyeS5cbiAgICovXG4gIHN0YXRpYyB3aXRoUGFyZW50KHBhcmVudCkge1xuICAgIHJldHVybiBuZXcgUmVnaXN0cnkocGFyZW50KTtcbiAgfVxuICAvKipcbiAgICogTG9va3MgdXAgYW4gYWN0aW9uIGluIHRoZSByZWdpc3RyeS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBhY3Rpb24gdG8gbG9va3VwLlxuICAgKiBAcmV0dXJucyBUaGUgYWN0aW9uLlxuICAgKi9cbiAgYXN5bmMgbG9va3VwQWN0aW9uKGtleSkge1xuICAgIGNvbnN0IHBhcnNlZEtleSA9IHBhcnNlUmVnaXN0cnlLZXkoa2V5KTtcbiAgICBpZiAocGFyc2VkS2V5Py5wbHVnaW5OYW1lICYmIHRoaXMucGx1Z2luc0J5TmFtZVtwYXJzZWRLZXkucGx1Z2luTmFtZV0pIHtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVBsdWdpbihwYXJzZWRLZXkucGx1Z2luTmFtZSk7XG4gICAgICBpZiAoIXRoaXMuYWN0aW9uc0J5SWRba2V5XSkge1xuICAgICAgICBhd2FpdCB0aGlzLnJlc29sdmVQbHVnaW5BY3Rpb24oXG4gICAgICAgICAgcGFyc2VkS2V5LnBsdWdpbk5hbWUsXG4gICAgICAgICAgcGFyc2VkS2V5LmFjdGlvblR5cGUsXG4gICAgICAgICAgcGFyc2VkS2V5LmFjdGlvbk5hbWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYWN0aW9uc0J5SWRba2V5XSB8fCB0aGlzLnBhcmVudD8ubG9va3VwQWN0aW9uKGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIExvb2tzIHVwIGEgYmFja2dyb3VuZCBhY3Rpb24gZnJvbSB0aGUgcmVnaXN0cnkuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgYWN0aW9uIHRvIGxvb2t1cC5cbiAgICogQHJldHVybnMgVGhlIGFjdGlvbi5cbiAgICovXG4gIGFzeW5jIGxvb2t1cEJhY2tncm91bmRBY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuICgwLCBpbXBvcnRfYmFja2dyb3VuZF9hY3Rpb24ubG9va3VwQmFja2dyb3VuZEFjdGlvbikodGhpcywga2V5KTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGFjdGlvbiBpbiB0aGUgcmVnaXN0cnkuXG4gICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBhY3Rpb24gdG8gcmVnaXN0ZXIuXG4gICAqIEBwYXJhbSBhY3Rpb24gVGhlIGFjdGlvbiB0byByZWdpc3Rlci5cbiAgICovXG4gIHJlZ2lzdGVyQWN0aW9uKHR5cGUsIGFjdGlvbiwgb3B0cykge1xuICAgIGlmICh0eXBlICE9PSBhY3Rpb24uX19hY3Rpb24uYWN0aW9uVHlwZSkge1xuICAgICAgdGhyb3cgbmV3IGltcG9ydF9lcnJvci5HZW5raXRFcnJvcih7XG4gICAgICAgIHN0YXR1czogXCJJTlZBTElEX0FSR1VNRU5UXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBhY3Rpb24gdHlwZSAoJHt0eXBlfSkgZG9lcyBub3QgbWF0Y2ggdHlwZSBvbiBhY3Rpb24gKCR7YWN0aW9uLl9fYWN0aW9uLmFjdGlvblR5cGV9KWBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAob3B0cz8ubmFtZXNwYWNlICYmICFhY3Rpb24uX19hY3Rpb24ubmFtZS5zdGFydHNXaXRoKGAke29wdHMubmFtZXNwYWNlfS9gKSkge1xuICAgICAgYWN0aW9uLl9fYWN0aW9uLm5hbWUgPSBgJHtvcHRzLm5hbWVzcGFjZX0vJHthY3Rpb24uX19hY3Rpb24ubmFtZX1gO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBgLyR7dHlwZX0vJHthY3Rpb24uX19hY3Rpb24ubmFtZX1gO1xuICAgIGltcG9ydF9sb2dnaW5nLmxvZ2dlci5kZWJ1ZyhgcmVnaXN0ZXJpbmcgJHtrZXl9YCk7XG4gICAgaWYgKHRoaXMuYWN0aW9uc0J5SWQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLndhcm4oXG4gICAgICAgIGBXQVJOSU5HOiAke2tleX0gYWxyZWFkeSBoYXMgYW4gZW50cnkgaW4gdGhlIHJlZ2lzdHJ5LiBPdmVyd3JpdGluZy5gXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmFjdGlvbnNCeUlkW2tleV0gPSBhY3Rpb247XG4gICAgaWYgKGFjdGlvbi5fX3JlZ2lzdHJ5KSB7XG4gICAgICBpbXBvcnRfbG9nZ2luZy5sb2dnZXIuZXJyb3IoYEVSUk9SOiAke2tleX0gYWxyZWFkeSByZWdpc3RlcmVkLmApO1xuICAgIH1cbiAgICBhY3Rpb24uX19yZWdpc3RyeSA9IHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBhY3Rpb24gcHJvbWlzZSBpbiB0aGUgcmVnaXN0cnkuXG4gICAqL1xuICByZWdpc3RlckFjdGlvbkFzeW5jKHR5cGUsIG5hbWUsIGFjdGlvbiwgb3B0cykge1xuICAgIGlmIChvcHRzPy5uYW1lc3BhY2UgJiYgIW5hbWUuc3RhcnRzV2l0aChgJHtvcHRzLm5hbWVzcGFjZX0vYCkpIHtcbiAgICAgIG5hbWUgPSBgJHtvcHRzLm5hbWVzcGFjZX0vJHtuYW1lfWA7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IGAvJHt0eXBlfS8ke25hbWV9YDtcbiAgICBpbXBvcnRfbG9nZ2luZy5sb2dnZXIuZGVidWcoYHJlZ2lzdGVyaW5nICR7a2V5fSAoYXN5bmMpYCk7XG4gICAgaWYgKHRoaXMuYWN0aW9uc0J5SWQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLndhcm4oXG4gICAgICAgIGBXQVJOSU5HOiAke2tleX0gYWxyZWFkeSBoYXMgYW4gZW50cnkgaW4gdGhlIHJlZ2lzdHJ5LiBPdmVyd3JpdGluZy5gXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmFjdGlvbnNCeUlkW2tleV0gPSBhY3Rpb247XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGFjdGlvbnMgdGhhdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCBpbiB0aGUgcmVnaXN0cnkuXG4gICAqIEByZXR1cm5zIEFsbCBhY3Rpb25zIGluIHRoZSByZWdpc3RyeSBhcyBhIG1hcCBvZiA8a2V5LCBhY3Rpb24+LlxuICAgKi9cbiAgYXN5bmMgbGlzdEFjdGlvbnMoKSB7XG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXplQWxsUGx1Z2lucygpO1xuICAgIGNvbnN0IGFjdGlvbnMgPSB7fTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuYWN0aW9uc0J5SWQpLm1hcChhc3luYyAoW2tleSwgYWN0aW9uXSkgPT4ge1xuICAgICAgICBhY3Rpb25zW2tleV0gPSBhd2FpdCBhY3Rpb247XG4gICAgICB9KVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmF3YWl0IHRoaXMucGFyZW50Py5saXN0QWN0aW9ucygpLFxuICAgICAgLi4uYWN0aW9uc1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGFjdGlvbnMgdGhhdCBhcmUgcmVzb2x2YWJsZSBieSBwbHVnaW5zIGFzIHdlbGwgYXMgdGhvc2UgdGhhdCBhcmUgYWxyZWFkeVxuICAgKiBpbiB0aGUgcmVnaXN0cnkuXG4gICAqXG4gICAqIE5PVEU6IHRoaXMgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZCBpbiBsYXRlbmN5IHNlbnNpdGl2ZSBjb2RlIHBhdGhzLlxuICAgKiBJdCBtYXkgcmVseSBvbiBcImFkbWluXCIgQVBJIGNhbGxzIHN1Y2ggYXMgXCJsaXN0IG1vZGVsc1wiLCB3aGljaCBtYXkgY2F1c2UgaW5jcmVhc2VkIGNvbGQgc3RhcnQgbGF0ZW5jeS5cbiAgICpcbiAgICogQHJldHVybnMgQWxsIHJlc29sdmFibGUgYWN0aW9uIG1ldGFkYXRhIGFzIGEgbWFwIG9mIDxrZXksIGFjdGlvbiBtZXRhZGF0YT4uXG4gICAqL1xuICBhc3luYyBsaXN0UmVzb2x2YWJsZUFjdGlvbnMoKSB7XG4gICAgY29uc3QgcmVzb2x2YWJsZUFjdGlvbnMgPSB7fTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMucGx1Z2luc0J5TmFtZSkubWFwKGFzeW5jIChbcGx1Z2luTmFtZSwgcGx1Z2luXSkgPT4ge1xuICAgICAgICBpZiAocGx1Z2luLmxpc3RBY3Rpb25zKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIChhd2FpdCBwbHVnaW4ubGlzdEFjdGlvbnMoKSkuZm9yRWFjaCgobWV0YSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoIW1ldGEubmFtZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBpbXBvcnRfZXJyb3IuR2Vua2l0RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcIklOVkFMSURfQVJHVU1FTlRcIixcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkIG1ldGFkYXRhIHdoZW4gbGlzdGluZyBhY3Rpb25zIGZyb20gJHtwbHVnaW5OYW1lfSAtIG5hbWUgcmVxdWlyZWRgXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFtZXRhLmFjdGlvblR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgaW1wb3J0X2Vycm9yLkdlbmtpdEVycm9yKHtcbiAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJJTlZBTElEX0FSR1VNRU5UXCIsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCBtZXRhZGF0YSB3aGVuIGxpc3RpbmcgYWN0aW9ucyBmcm9tICR7cGx1Z2luTmFtZX0gLSBhY3Rpb25UeXBlIHJlcXVpcmVkYFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmFibGVBY3Rpb25zW2AvJHttZXRhLmFjdGlvblR5cGV9LyR7bWV0YS5uYW1lfWBdID0gbWV0YTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGltcG9ydF9sb2dnaW5nLmxvZ2dlci5lcnJvcihgRXJyb3IgbGlzdGluZyBhY3Rpb25zIGZvciAke3BsdWdpbk5hbWV9XG5gLCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIGFjdGlvbl0gb2YgT2JqZWN0LmVudHJpZXMoYXdhaXQgdGhpcy5saXN0QWN0aW9ucygpKSkge1xuICAgICAgcmVzb2x2YWJsZUFjdGlvbnNba2V5XSA9IGFjdGlvbi5fX2FjdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmF3YWl0IHRoaXMucGFyZW50Py5saXN0UmVzb2x2YWJsZUFjdGlvbnMoKSxcbiAgICAgIC4uLnJlc29sdmFibGVBY3Rpb25zXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgYWxsIHBsdWdpbnMgaW4gdGhlIHJlZ2lzdHJ5LlxuICAgKi9cbiAgYXN5bmMgaW5pdGlhbGl6ZUFsbFBsdWdpbnMoKSB7XG4gICAgaWYgKHRoaXMuYWxsUGx1Z2luc0luaXRpYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgcGx1Z2luTmFtZSBvZiBPYmplY3Qua2V5cyh0aGlzLnBsdWdpbnNCeU5hbWUpKSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQbHVnaW4ocGx1Z2luTmFtZSk7XG4gICAgfVxuICAgIHRoaXMuYWxsUGx1Z2luc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgcGx1Z2luIHByb3ZpZGVyLiBUaGlzIHBsdWdpbiBtdXN0IGJlIGluaXRpYWxpemVkIGJlZm9yZSBpdCBjYW4gYmUgdXNlZCBieSBjYWxsaW5nIHtAbGluayBpbml0aWFsaXplUGx1Z2lufSBvciB7QGxpbmsgaW5pdGlhbGl6ZUFsbFBsdWdpbnN9LlxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIHRvIHJlZ2lzdGVyLlxuICAgKiBAcGFyYW0gcHJvdmlkZXIgVGhlIHBsdWdpbiBwcm92aWRlci5cbiAgICovXG4gIHJlZ2lzdGVyUGx1Z2luUHJvdmlkZXIobmFtZSwgcHJvdmlkZXIpIHtcbiAgICBpZiAodGhpcy5wbHVnaW5zQnlOYW1lW25hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBsdWdpbiAke25hbWV9IGFscmVhZHkgcmVnaXN0ZXJlZGApO1xuICAgIH1cbiAgICB0aGlzLmFsbFBsdWdpbnNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIGxldCBjYWNoZWQ7XG4gICAgbGV0IGlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBsdWdpbnNCeU5hbWVbbmFtZV0gPSB7XG4gICAgICBuYW1lOiBwcm92aWRlci5uYW1lLFxuICAgICAgaW5pdGlhbGl6ZXI6ICgpID0+IHtcbiAgICAgICAgaWYgKCFpc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgY2FjaGVkID0gcHJvdmlkZXIuaW5pdGlhbGl6ZXIoKTtcbiAgICAgICAgICBpc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgfSxcbiAgICAgIHJlc29sdmVyOiBhc3luYyAoYWN0aW9uVHlwZSwgYWN0aW9uTmFtZSkgPT4ge1xuICAgICAgICBpZiAocHJvdmlkZXIucmVzb2x2ZXIpIHtcbiAgICAgICAgICBhd2FpdCBwcm92aWRlci5yZXNvbHZlcihhY3Rpb25UeXBlLCBhY3Rpb25OYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxpc3RBY3Rpb25zOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmIChwcm92aWRlci5saXN0QWN0aW9ucykge1xuICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5saXN0QWN0aW9ucygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBMb29rcyB1cCBhIHBsdWdpbi5cbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHBsdWdpbiB0byBsb29rdXAuXG4gICAqIEByZXR1cm5zIFRoZSBwbHVnaW4gcHJvdmlkZXIuXG4gICAqL1xuICBsb29rdXBQbHVnaW4obmFtZSkge1xuICAgIHJldHVybiB0aGlzLnBsdWdpbnNCeU5hbWVbbmFtZV0gfHwgdGhpcy5wYXJlbnQ/Lmxvb2t1cFBsdWdpbihuYW1lKTtcbiAgfVxuICAvKipcbiAgICogUmVzb2x2ZXMgYSBuZXcgQWN0aW9uIGR5bmFtaWNhbGx5IGJ5IHJlZ2lzdGVyaW5nIGl0LlxuICAgKiBAcGFyYW0gcGx1Z2luTmFtZSBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luXG4gICAqIEBwYXJhbSBhY3Rpb25UeXBlIFRoZSB0eXBlIG9mIHRoZSBhY3Rpb25cbiAgICogQHBhcmFtIGFjdGlvbk5hbWUgVGhlIG5hbWUgb2YgdGhlIGFjdGlvblxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgcmVzb2x2ZVBsdWdpbkFjdGlvbihwbHVnaW5OYW1lLCBhY3Rpb25UeXBlLCBhY3Rpb25OYW1lKSB7XG4gICAgY29uc3QgcGx1Z2luID0gdGhpcy5wbHVnaW5zQnlOYW1lW3BsdWdpbk5hbWVdO1xuICAgIGlmIChwbHVnaW4pIHtcbiAgICAgIHJldHVybiBhd2FpdCAoMCwgaW1wb3J0X2FjdGlvbi5ydW5PdXRzaWRlQWN0aW9uUnVudGltZUNvbnRleHQpKGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKHBsdWdpbi5yZXNvbHZlcikge1xuICAgICAgICAgIGF3YWl0IHBsdWdpbi5yZXNvbHZlcihhY3Rpb25UeXBlLCBhY3Rpb25OYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIHBsdWdpbiBhbHJlYWR5IHJlZ2lzdGVyZWQgd2l0aCB7QGxpbmsgcmVnaXN0ZXJQbHVnaW5Qcm92aWRlcn0uXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gdG8gaW5pdGlhbGl6ZS5cbiAgICogQHJldHVybnMgVGhlIHBsdWdpbi5cbiAgICovXG4gIGFzeW5jIGluaXRpYWxpemVQbHVnaW4obmFtZSkge1xuICAgIGlmICh0aGlzLnBsdWdpbnNCeU5hbWVbbmFtZV0pIHtcbiAgICAgIHJldHVybiBhd2FpdCAoMCwgaW1wb3J0X2FjdGlvbi5ydW5PdXRzaWRlQWN0aW9uUnVudGltZUNvbnRleHQpKFxuICAgICAgICAoKSA9PiB0aGlzLnBsdWdpbnNCeU5hbWVbbmFtZV0uaW5pdGlhbGl6ZXIoKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIHNjaGVtYS5cbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHNjaGVtYSB0byByZWdpc3Rlci5cbiAgICogQHBhcmFtIGRhdGEgVGhlIHNjaGVtYSB0byByZWdpc3RlciAoZWl0aGVyIGEgWm9kIHNjaGVtYSBvciBhIEpTT04gc2NoZW1hKS5cbiAgICovXG4gIHJlZ2lzdGVyU2NoZW1hKG5hbWUsIGRhdGEpIHtcbiAgICBpZiAodGhpcy5zY2hlbWFzQnlOYW1lW25hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFNjaGVtYSAke25hbWV9IGFscmVhZHkgcmVnaXN0ZXJlZGApO1xuICAgIH1cbiAgICB0aGlzLnNjaGVtYXNCeU5hbWVbbmFtZV0gPSBkYXRhO1xuICB9XG4gIHJlZ2lzdGVyVmFsdWUodHlwZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoIXRoaXMudmFsdWVCeVR5cGVBbmROYW1lW3R5cGVdKSB7XG4gICAgICB0aGlzLnZhbHVlQnlUeXBlQW5kTmFtZVt0eXBlXSA9IHt9O1xuICAgIH1cbiAgICB0aGlzLnZhbHVlQnlUeXBlQW5kTmFtZVt0eXBlXVtuYW1lXSA9IHZhbHVlO1xuICB9XG4gIGFzeW5jIGxvb2t1cFZhbHVlKHR5cGUsIGtleSkge1xuICAgIGNvbnN0IHBsdWdpbk5hbWUgPSBwYXJzZVBsdWdpbk5hbWUoa2V5KTtcbiAgICBpZiAoIXRoaXMudmFsdWVCeVR5cGVBbmROYW1lW3R5cGVdPy5ba2V5XSAmJiBwbHVnaW5OYW1lKSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQbHVnaW4ocGx1Z2luTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnZhbHVlQnlUeXBlQW5kTmFtZVt0eXBlXT8uW2tleV0gfHwgdGhpcy5wYXJlbnQ/Lmxvb2t1cFZhbHVlKHR5cGUsIGtleSk7XG4gIH1cbiAgYXN5bmMgbGlzdFZhbHVlcyh0eXBlKSB7XG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXplQWxsUGx1Z2lucygpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5hd2FpdCB0aGlzLnBhcmVudD8ubGlzdFZhbHVlcyh0eXBlKSB8fCB7fSxcbiAgICAgIC4uLnRoaXMudmFsdWVCeVR5cGVBbmROYW1lW3R5cGVdIHx8IHt9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogTG9va3MgdXAgYSBzY2hlbWEuXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzY2hlbWEgdG8gbG9va3VwLlxuICAgKiBAcmV0dXJucyBUaGUgc2NoZW1hLlxuICAgKi9cbiAgbG9va3VwU2NoZW1hKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5zY2hlbWFzQnlOYW1lW25hbWVdIHx8IHRoaXMucGFyZW50Py5sb29rdXBTY2hlbWEobmFtZSk7XG4gIH1cbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBSZWdpc3RyeSxcbiAgcGFyc2VSZWdpc3RyeUtleVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWdpc3RyeS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/registry.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/schema.js":
/*!****************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/schema.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar schema_exports = {};\n__export(schema_exports, {\n  ValidationError: () => ValidationError,\n  defineJsonSchema: () => defineJsonSchema,\n  defineSchema: () => defineSchema,\n  parseSchema: () => parseSchema,\n  toJsonSchema: () => toJsonSchema,\n  validateSchema: () => validateSchema,\n  z: () => import_zod.z\n});\nmodule.exports = __toCommonJS(schema_exports);\nvar import_ajv = __toESM(__webpack_require__(/*! ajv */ \"(action-browser)/./node_modules/ajv/dist/ajv.js\"));\nvar import_ajv_formats = __toESM(__webpack_require__(/*! ajv-formats */ \"(action-browser)/./node_modules/ajv-formats/dist/index.js\"));\nvar import_zod = __webpack_require__(/*! zod */ \"(action-browser)/./node_modules/zod/lib/index.js\");\nvar import_zod_to_json_schema = __toESM(__webpack_require__(/*! zod-to-json-schema */ \"(action-browser)/./node_modules/zod-to-json-schema/dist/cjs/index.js\"));\nvar import_error = __webpack_require__(/*! ./error.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/error.js\");\nconst ajv = new import_ajv.default();\n(0, import_ajv_formats.default)(ajv);\nconst jsonSchemas = /* @__PURE__ */ new WeakMap();\nconst validators = /* @__PURE__ */ new WeakMap();\nclass ValidationError extends import_error.GenkitError {\n  constructor({\n    data,\n    errors,\n    schema\n  }) {\n    super({\n      status: \"INVALID_ARGUMENT\",\n      message: `Schema validation failed. Parse Errors:\n\n${errors.map((e) => `- ${e.path}: ${e.message}`).join(\"\\n\")}\n\nProvided data:\n\n${JSON.stringify(data, null, 2)}\n\nRequired JSON schema:\n\n${JSON.stringify(schema, null, 2)}`,\n      detail: { errors, schema }\n    });\n  }\n}\nfunction toJsonSchema({\n  jsonSchema,\n  schema\n}) {\n  if (!jsonSchema && !schema) return null;\n  if (jsonSchema) return jsonSchema;\n  if (jsonSchemas.has(schema)) return jsonSchemas.get(schema);\n  const outSchema = (0, import_zod_to_json_schema.default)(schema, {\n    $refStrategy: \"none\",\n    removeAdditionalStrategy: \"strict\"\n  });\n  jsonSchemas.set(schema, outSchema);\n  return outSchema;\n}\nfunction toErrorDetail(error) {\n  return {\n    path: error.instancePath.substring(1).replace(/\\//g, \".\") || \"(root)\",\n    message: error.message\n  };\n}\nfunction validateSchema(data, options) {\n  const toValidate = toJsonSchema(options);\n  if (!toValidate) {\n    return { valid: true, schema: toValidate };\n  }\n  const validator = validators.get(toValidate) || ajv.compile(toValidate);\n  const valid = validator(data);\n  const errors = validator.errors?.map((e) => e);\n  return { valid, errors: errors?.map(toErrorDetail), schema: toValidate };\n}\nfunction parseSchema(data, options) {\n  const { valid, errors, schema } = validateSchema(data, options);\n  if (!valid) throw new ValidationError({ data, errors, schema });\n  return data;\n}\nfunction defineSchema(registry, name, schema) {\n  registry.registerSchema(name, { schema });\n  return schema;\n}\nfunction defineJsonSchema(registry, name, jsonSchema) {\n  registry.registerSchema(name, { jsonSchema });\n  return jsonSchema;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=schema.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3NjaGVtYS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSw4QkFBOEI7QUFDdkc7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyw0REFBSztBQUN0QyxpQ0FBaUMsbUJBQU8sQ0FBQyw4RUFBYTtBQUN0RCxpQkFBaUIsbUJBQU8sQ0FBQyw2REFBSztBQUM5Qix3Q0FBd0MsbUJBQU8sQ0FBQyxnR0FBb0I7QUFDcEUsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLHVCQUF1QixPQUFPLElBQUksVUFBVTs7QUFFOUM7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQSxFQUFFLGdDQUFnQztBQUNsQyxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEMsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQSxNQUFNLENBUUw7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcY29yZVxcbGliXFxzY2hlbWEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgLy8gSWYgdGhlIGltcG9ydGVyIGlzIGluIG5vZGUgY29tcGF0aWJpbGl0eSBtb2RlIG9yIHRoaXMgaXMgbm90IGFuIEVTTVxuICAvLyBmaWxlIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIHRvIGEgQ29tbW9uSlMgZmlsZSB1c2luZyBhIEJhYmVsLVxuICAvLyBjb21wYXRpYmxlIHRyYW5zZm9ybSAoaS5lLiBcIl9fZXNNb2R1bGVcIiBoYXMgbm90IGJlZW4gc2V0KSwgdGhlbiBzZXRcbiAgLy8gXCJkZWZhdWx0XCIgdG8gdGhlIENvbW1vbkpTIFwibW9kdWxlLmV4cG9ydHNcIiBmb3Igbm9kZSBjb21wYXRpYmlsaXR5LlxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIHNjaGVtYV9leHBvcnRzID0ge307XG5fX2V4cG9ydChzY2hlbWFfZXhwb3J0cywge1xuICBWYWxpZGF0aW9uRXJyb3I6ICgpID0+IFZhbGlkYXRpb25FcnJvcixcbiAgZGVmaW5lSnNvblNjaGVtYTogKCkgPT4gZGVmaW5lSnNvblNjaGVtYSxcbiAgZGVmaW5lU2NoZW1hOiAoKSA9PiBkZWZpbmVTY2hlbWEsXG4gIHBhcnNlU2NoZW1hOiAoKSA9PiBwYXJzZVNjaGVtYSxcbiAgdG9Kc29uU2NoZW1hOiAoKSA9PiB0b0pzb25TY2hlbWEsXG4gIHZhbGlkYXRlU2NoZW1hOiAoKSA9PiB2YWxpZGF0ZVNjaGVtYSxcbiAgejogKCkgPT4gaW1wb3J0X3pvZC56XG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHNjaGVtYV9leHBvcnRzKTtcbnZhciBpbXBvcnRfYWp2ID0gX190b0VTTShyZXF1aXJlKFwiYWp2XCIpKTtcbnZhciBpbXBvcnRfYWp2X2Zvcm1hdHMgPSBfX3RvRVNNKHJlcXVpcmUoXCJhanYtZm9ybWF0c1wiKSk7XG52YXIgaW1wb3J0X3pvZCA9IHJlcXVpcmUoXCJ6b2RcIik7XG52YXIgaW1wb3J0X3pvZF90b19qc29uX3NjaGVtYSA9IF9fdG9FU00ocmVxdWlyZShcInpvZC10by1qc29uLXNjaGVtYVwiKSk7XG52YXIgaW1wb3J0X2Vycm9yID0gcmVxdWlyZShcIi4vZXJyb3IuanNcIik7XG5jb25zdCBhanYgPSBuZXcgaW1wb3J0X2Fqdi5kZWZhdWx0KCk7XG4oMCwgaW1wb3J0X2Fqdl9mb3JtYXRzLmRlZmF1bHQpKGFqdik7XG5jb25zdCBqc29uU2NoZW1hcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgdmFsaWRhdG9ycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgaW1wb3J0X2Vycm9yLkdlbmtpdEVycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRhdGEsXG4gICAgZXJyb3JzLFxuICAgIHNjaGVtYVxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgc3RhdHVzOiBcIklOVkFMSURfQVJHVU1FTlRcIixcbiAgICAgIG1lc3NhZ2U6IGBTY2hlbWEgdmFsaWRhdGlvbiBmYWlsZWQuIFBhcnNlIEVycm9yczpcblxuJHtlcnJvcnMubWFwKChlKSA9PiBgLSAke2UucGF0aH06ICR7ZS5tZXNzYWdlfWApLmpvaW4oXCJcXG5cIil9XG5cblByb3ZpZGVkIGRhdGE6XG5cbiR7SlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMil9XG5cblJlcXVpcmVkIEpTT04gc2NoZW1hOlxuXG4ke0pTT04uc3RyaW5naWZ5KHNjaGVtYSwgbnVsbCwgMil9YCxcbiAgICAgIGRldGFpbDogeyBlcnJvcnMsIHNjaGVtYSB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvSnNvblNjaGVtYSh7XG4gIGpzb25TY2hlbWEsXG4gIHNjaGVtYVxufSkge1xuICBpZiAoIWpzb25TY2hlbWEgJiYgIXNjaGVtYSkgcmV0dXJuIG51bGw7XG4gIGlmIChqc29uU2NoZW1hKSByZXR1cm4ganNvblNjaGVtYTtcbiAgaWYgKGpzb25TY2hlbWFzLmhhcyhzY2hlbWEpKSByZXR1cm4ganNvblNjaGVtYXMuZ2V0KHNjaGVtYSk7XG4gIGNvbnN0IG91dFNjaGVtYSA9ICgwLCBpbXBvcnRfem9kX3RvX2pzb25fc2NoZW1hLmRlZmF1bHQpKHNjaGVtYSwge1xuICAgICRyZWZTdHJhdGVneTogXCJub25lXCIsXG4gICAgcmVtb3ZlQWRkaXRpb25hbFN0cmF0ZWd5OiBcInN0cmljdFwiXG4gIH0pO1xuICBqc29uU2NoZW1hcy5zZXQoc2NoZW1hLCBvdXRTY2hlbWEpO1xuICByZXR1cm4gb3V0U2NoZW1hO1xufVxuZnVuY3Rpb24gdG9FcnJvckRldGFpbChlcnJvcikge1xuICByZXR1cm4ge1xuICAgIHBhdGg6IGVycm9yLmluc3RhbmNlUGF0aC5zdWJzdHJpbmcoMSkucmVwbGFjZSgvXFwvL2csIFwiLlwiKSB8fCBcIihyb290KVwiLFxuICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlU2NoZW1hKGRhdGEsIG9wdGlvbnMpIHtcbiAgY29uc3QgdG9WYWxpZGF0ZSA9IHRvSnNvblNjaGVtYShvcHRpb25zKTtcbiAgaWYgKCF0b1ZhbGlkYXRlKSB7XG4gICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIHNjaGVtYTogdG9WYWxpZGF0ZSB9O1xuICB9XG4gIGNvbnN0IHZhbGlkYXRvciA9IHZhbGlkYXRvcnMuZ2V0KHRvVmFsaWRhdGUpIHx8IGFqdi5jb21waWxlKHRvVmFsaWRhdGUpO1xuICBjb25zdCB2YWxpZCA9IHZhbGlkYXRvcihkYXRhKTtcbiAgY29uc3QgZXJyb3JzID0gdmFsaWRhdG9yLmVycm9ycz8ubWFwKChlKSA9PiBlKTtcbiAgcmV0dXJuIHsgdmFsaWQsIGVycm9yczogZXJyb3JzPy5tYXAodG9FcnJvckRldGFpbCksIHNjaGVtYTogdG9WYWxpZGF0ZSB9O1xufVxuZnVuY3Rpb24gcGFyc2VTY2hlbWEoZGF0YSwgb3B0aW9ucykge1xuICBjb25zdCB7IHZhbGlkLCBlcnJvcnMsIHNjaGVtYSB9ID0gdmFsaWRhdGVTY2hlbWEoZGF0YSwgb3B0aW9ucyk7XG4gIGlmICghdmFsaWQpIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoeyBkYXRhLCBlcnJvcnMsIHNjaGVtYSB9KTtcbiAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBkZWZpbmVTY2hlbWEocmVnaXN0cnksIG5hbWUsIHNjaGVtYSkge1xuICByZWdpc3RyeS5yZWdpc3RlclNjaGVtYShuYW1lLCB7IHNjaGVtYSB9KTtcbiAgcmV0dXJuIHNjaGVtYTtcbn1cbmZ1bmN0aW9uIGRlZmluZUpzb25TY2hlbWEocmVnaXN0cnksIG5hbWUsIGpzb25TY2hlbWEpIHtcbiAgcmVnaXN0cnkucmVnaXN0ZXJTY2hlbWEobmFtZSwgeyBqc29uU2NoZW1hIH0pO1xuICByZXR1cm4ganNvblNjaGVtYTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBWYWxpZGF0aW9uRXJyb3IsXG4gIGRlZmluZUpzb25TY2hlbWEsXG4gIGRlZmluZVNjaGVtYSxcbiAgcGFyc2VTY2hlbWEsXG4gIHRvSnNvblNjaGVtYSxcbiAgdmFsaWRhdGVTY2hlbWEsXG4gIHpcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NoZW1hLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/schema.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/statusTypes.js":
/*!*********************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/statusTypes.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar statusTypes_exports = {};\n__export(statusTypes_exports, {\n  StatusCodes: () => StatusCodes,\n  StatusNameSchema: () => StatusNameSchema,\n  StatusSchema: () => StatusSchema,\n  httpStatusCode: () => httpStatusCode\n});\nmodule.exports = __toCommonJS(statusTypes_exports);\nvar z = __toESM(__webpack_require__(/*! zod */ \"(action-browser)/./node_modules/zod/lib/index.js\"));\nvar StatusCodes = /* @__PURE__ */ ((StatusCodes2) => {\n  StatusCodes2[StatusCodes2[\"OK\"] = 0] = \"OK\";\n  StatusCodes2[StatusCodes2[\"CANCELLED\"] = 1] = \"CANCELLED\";\n  StatusCodes2[StatusCodes2[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n  StatusCodes2[StatusCodes2[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\n  StatusCodes2[StatusCodes2[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\n  StatusCodes2[StatusCodes2[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\n  StatusCodes2[StatusCodes2[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\n  StatusCodes2[StatusCodes2[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\n  StatusCodes2[StatusCodes2[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\n  StatusCodes2[StatusCodes2[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\n  StatusCodes2[StatusCodes2[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\n  StatusCodes2[StatusCodes2[\"ABORTED\"] = 10] = \"ABORTED\";\n  StatusCodes2[StatusCodes2[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\n  StatusCodes2[StatusCodes2[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\n  StatusCodes2[StatusCodes2[\"INTERNAL\"] = 13] = \"INTERNAL\";\n  StatusCodes2[StatusCodes2[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\n  StatusCodes2[StatusCodes2[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\n  return StatusCodes2;\n})(StatusCodes || {});\nconst StatusNameSchema = z.enum([\n  \"OK\",\n  \"CANCELLED\",\n  \"UNKNOWN\",\n  \"INVALID_ARGUMENT\",\n  \"DEADLINE_EXCEEDED\",\n  \"NOT_FOUND\",\n  \"ALREADY_EXISTS\",\n  \"PERMISSION_DENIED\",\n  \"UNAUTHENTICATED\",\n  \"RESOURCE_EXHAUSTED\",\n  \"FAILED_PRECONDITION\",\n  \"ABORTED\",\n  \"OUT_OF_RANGE\",\n  \"UNIMPLEMENTED\",\n  \"INTERNAL\",\n  \"UNAVAILABLE\",\n  \"DATA_LOSS\"\n]);\nconst statusCodeMap = {\n  OK: 200,\n  CANCELLED: 499,\n  UNKNOWN: 500,\n  INVALID_ARGUMENT: 400,\n  DEADLINE_EXCEEDED: 504,\n  NOT_FOUND: 404,\n  ALREADY_EXISTS: 409,\n  PERMISSION_DENIED: 403,\n  UNAUTHENTICATED: 401,\n  RESOURCE_EXHAUSTED: 429,\n  FAILED_PRECONDITION: 400,\n  ABORTED: 409,\n  OUT_OF_RANGE: 400,\n  UNIMPLEMENTED: 501,\n  INTERNAL: 500,\n  UNAVAILABLE: 503,\n  DATA_LOSS: 500\n};\nfunction httpStatusCode(status) {\n  if (!(status in statusCodeMap)) {\n    throw new Error(`Invalid status code ${status}`);\n  }\n  return statusCodeMap[status];\n}\nconst StatusCodesSchema = z.nativeEnum(StatusCodes);\nconst StatusSchema = z.object({\n  code: StatusCodesSchema,\n  message: z.string(),\n  details: z.any().optional()\n});\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=statusTypes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3N0YXR1c1R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDhCQUE4QjtBQUN2RztBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLDZEQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxtQkFBbUI7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsTUFBTSxDQUtMO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcS1JhbWFjaGFcXERvY3VtZW50c1xcU3VzdEFJbmV4IEdJdCBDb2RlXFxub2RlX21vZHVsZXNcXEBnZW5raXQtYWlcXGNvcmVcXGxpYlxcc3RhdHVzVHlwZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgLy8gSWYgdGhlIGltcG9ydGVyIGlzIGluIG5vZGUgY29tcGF0aWJpbGl0eSBtb2RlIG9yIHRoaXMgaXMgbm90IGFuIEVTTVxuICAvLyBmaWxlIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIHRvIGEgQ29tbW9uSlMgZmlsZSB1c2luZyBhIEJhYmVsLVxuICAvLyBjb21wYXRpYmxlIHRyYW5zZm9ybSAoaS5lLiBcIl9fZXNNb2R1bGVcIiBoYXMgbm90IGJlZW4gc2V0KSwgdGhlbiBzZXRcbiAgLy8gXCJkZWZhdWx0XCIgdG8gdGhlIENvbW1vbkpTIFwibW9kdWxlLmV4cG9ydHNcIiBmb3Igbm9kZSBjb21wYXRpYmlsaXR5LlxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIHN0YXR1c1R5cGVzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHN0YXR1c1R5cGVzX2V4cG9ydHMsIHtcbiAgU3RhdHVzQ29kZXM6ICgpID0+IFN0YXR1c0NvZGVzLFxuICBTdGF0dXNOYW1lU2NoZW1hOiAoKSA9PiBTdGF0dXNOYW1lU2NoZW1hLFxuICBTdGF0dXNTY2hlbWE6ICgpID0+IFN0YXR1c1NjaGVtYSxcbiAgaHR0cFN0YXR1c0NvZGU6ICgpID0+IGh0dHBTdGF0dXNDb2RlXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHN0YXR1c1R5cGVzX2V4cG9ydHMpO1xudmFyIHogPSBfX3RvRVNNKHJlcXVpcmUoXCJ6b2RcIikpO1xudmFyIFN0YXR1c0NvZGVzID0gLyogQF9fUFVSRV9fICovICgoU3RhdHVzQ29kZXMyKSA9PiB7XG4gIFN0YXR1c0NvZGVzMltTdGF0dXNDb2RlczJbXCJPS1wiXSA9IDBdID0gXCJPS1wiO1xuICBTdGF0dXNDb2RlczJbU3RhdHVzQ29kZXMyW1wiQ0FOQ0VMTEVEXCJdID0gMV0gPSBcIkNBTkNFTExFRFwiO1xuICBTdGF0dXNDb2RlczJbU3RhdHVzQ29kZXMyW1wiVU5LTk9XTlwiXSA9IDJdID0gXCJVTktOT1dOXCI7XG4gIFN0YXR1c0NvZGVzMltTdGF0dXNDb2RlczJbXCJJTlZBTElEX0FSR1VNRU5UXCJdID0gM10gPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcbiAgU3RhdHVzQ29kZXMyW1N0YXR1c0NvZGVzMltcIkRFQURMSU5FX0VYQ0VFREVEXCJdID0gNF0gPSBcIkRFQURMSU5FX0VYQ0VFREVEXCI7XG4gIFN0YXR1c0NvZGVzMltTdGF0dXNDb2RlczJbXCJOT1RfRk9VTkRcIl0gPSA1XSA9IFwiTk9UX0ZPVU5EXCI7XG4gIFN0YXR1c0NvZGVzMltTdGF0dXNDb2RlczJbXCJBTFJFQURZX0VYSVNUU1wiXSA9IDZdID0gXCJBTFJFQURZX0VYSVNUU1wiO1xuICBTdGF0dXNDb2RlczJbU3RhdHVzQ29kZXMyW1wiUEVSTUlTU0lPTl9ERU5JRURcIl0gPSA3XSA9IFwiUEVSTUlTU0lPTl9ERU5JRURcIjtcbiAgU3RhdHVzQ29kZXMyW1N0YXR1c0NvZGVzMltcIlVOQVVUSEVOVElDQVRFRFwiXSA9IDE2XSA9IFwiVU5BVVRIRU5USUNBVEVEXCI7XG4gIFN0YXR1c0NvZGVzMltTdGF0dXNDb2RlczJbXCJSRVNPVVJDRV9FWEhBVVNURURcIl0gPSA4XSA9IFwiUkVTT1VSQ0VfRVhIQVVTVEVEXCI7XG4gIFN0YXR1c0NvZGVzMltTdGF0dXNDb2RlczJbXCJGQUlMRURfUFJFQ09ORElUSU9OXCJdID0gOV0gPSBcIkZBSUxFRF9QUkVDT05ESVRJT05cIjtcbiAgU3RhdHVzQ29kZXMyW1N0YXR1c0NvZGVzMltcIkFCT1JURURcIl0gPSAxMF0gPSBcIkFCT1JURURcIjtcbiAgU3RhdHVzQ29kZXMyW1N0YXR1c0NvZGVzMltcIk9VVF9PRl9SQU5HRVwiXSA9IDExXSA9IFwiT1VUX09GX1JBTkdFXCI7XG4gIFN0YXR1c0NvZGVzMltTdGF0dXNDb2RlczJbXCJVTklNUExFTUVOVEVEXCJdID0gMTJdID0gXCJVTklNUExFTUVOVEVEXCI7XG4gIFN0YXR1c0NvZGVzMltTdGF0dXNDb2RlczJbXCJJTlRFUk5BTFwiXSA9IDEzXSA9IFwiSU5URVJOQUxcIjtcbiAgU3RhdHVzQ29kZXMyW1N0YXR1c0NvZGVzMltcIlVOQVZBSUxBQkxFXCJdID0gMTRdID0gXCJVTkFWQUlMQUJMRVwiO1xuICBTdGF0dXNDb2RlczJbU3RhdHVzQ29kZXMyW1wiREFUQV9MT1NTXCJdID0gMTVdID0gXCJEQVRBX0xPU1NcIjtcbiAgcmV0dXJuIFN0YXR1c0NvZGVzMjtcbn0pKFN0YXR1c0NvZGVzIHx8IHt9KTtcbmNvbnN0IFN0YXR1c05hbWVTY2hlbWEgPSB6LmVudW0oW1xuICBcIk9LXCIsXG4gIFwiQ0FOQ0VMTEVEXCIsXG4gIFwiVU5LTk9XTlwiLFxuICBcIklOVkFMSURfQVJHVU1FTlRcIixcbiAgXCJERUFETElORV9FWENFRURFRFwiLFxuICBcIk5PVF9GT1VORFwiLFxuICBcIkFMUkVBRFlfRVhJU1RTXCIsXG4gIFwiUEVSTUlTU0lPTl9ERU5JRURcIixcbiAgXCJVTkFVVEhFTlRJQ0FURURcIixcbiAgXCJSRVNPVVJDRV9FWEhBVVNURURcIixcbiAgXCJGQUlMRURfUFJFQ09ORElUSU9OXCIsXG4gIFwiQUJPUlRFRFwiLFxuICBcIk9VVF9PRl9SQU5HRVwiLFxuICBcIlVOSU1QTEVNRU5URURcIixcbiAgXCJJTlRFUk5BTFwiLFxuICBcIlVOQVZBSUxBQkxFXCIsXG4gIFwiREFUQV9MT1NTXCJcbl0pO1xuY29uc3Qgc3RhdHVzQ29kZU1hcCA9IHtcbiAgT0s6IDIwMCxcbiAgQ0FOQ0VMTEVEOiA0OTksXG4gIFVOS05PV046IDUwMCxcbiAgSU5WQUxJRF9BUkdVTUVOVDogNDAwLFxuICBERUFETElORV9FWENFRURFRDogNTA0LFxuICBOT1RfRk9VTkQ6IDQwNCxcbiAgQUxSRUFEWV9FWElTVFM6IDQwOSxcbiAgUEVSTUlTU0lPTl9ERU5JRUQ6IDQwMyxcbiAgVU5BVVRIRU5USUNBVEVEOiA0MDEsXG4gIFJFU09VUkNFX0VYSEFVU1RFRDogNDI5LFxuICBGQUlMRURfUFJFQ09ORElUSU9OOiA0MDAsXG4gIEFCT1JURUQ6IDQwOSxcbiAgT1VUX09GX1JBTkdFOiA0MDAsXG4gIFVOSU1QTEVNRU5URUQ6IDUwMSxcbiAgSU5URVJOQUw6IDUwMCxcbiAgVU5BVkFJTEFCTEU6IDUwMyxcbiAgREFUQV9MT1NTOiA1MDBcbn07XG5mdW5jdGlvbiBodHRwU3RhdHVzQ29kZShzdGF0dXMpIHtcbiAgaWYgKCEoc3RhdHVzIGluIHN0YXR1c0NvZGVNYXApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0YXR1cyBjb2RlICR7c3RhdHVzfWApO1xuICB9XG4gIHJldHVybiBzdGF0dXNDb2RlTWFwW3N0YXR1c107XG59XG5jb25zdCBTdGF0dXNDb2Rlc1NjaGVtYSA9IHoubmF0aXZlRW51bShTdGF0dXNDb2Rlcyk7XG5jb25zdCBTdGF0dXNTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIGNvZGU6IFN0YXR1c0NvZGVzU2NoZW1hLFxuICBtZXNzYWdlOiB6LnN0cmluZygpLFxuICBkZXRhaWxzOiB6LmFueSgpLm9wdGlvbmFsKClcbn0pO1xuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIFN0YXR1c0NvZGVzLFxuICBTdGF0dXNOYW1lU2NoZW1hLFxuICBTdGF0dXNTY2hlbWEsXG4gIGh0dHBTdGF0dXNDb2RlXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXR1c1R5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/statusTypes.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/telemetryTypes.js":
/*!************************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/telemetryTypes.js ***!
  \************************************************************/
/***/ ((module) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar telemetryTypes_exports = {};\nmodule.exports = __toCommonJS(telemetryTypes_exports);\n//# sourceMappingURL=telemetryTypes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3RlbGVtZXRyeVR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcY29yZVxcbGliXFx0ZWxlbWV0cnlUeXBlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgdGVsZW1ldHJ5VHlwZXNfZXhwb3J0cyA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlModGVsZW1ldHJ5VHlwZXNfZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZWxlbWV0cnlUeXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/telemetryTypes.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/tracing.js":
/*!*****************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/tracing.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar tracing_exports = {};\n__export(tracing_exports, {\n  enableTelemetry: () => enableTelemetry,\n  ensureBasicTelemetryInstrumentation: () => ensureBasicTelemetryInstrumentation,\n  flushTracing: () => flushTracing,\n  setTelemetryProvider: () => setTelemetryProvider\n});\nmodule.exports = __toCommonJS(tracing_exports);\nvar import_error = __webpack_require__(/*! ./error.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/error.js\");\nvar import_logging = __webpack_require__(/*! ./logging.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/logging.js\");\n__reExport(tracing_exports, __webpack_require__(/*! ./tracing/exporter.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/exporter.js\"), module.exports);\n__reExport(tracing_exports, __webpack_require__(/*! ./tracing/instrumentation.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/instrumentation.js\"), module.exports);\n__reExport(tracing_exports, __webpack_require__(/*! ./tracing/types.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/types.js\"), module.exports);\nconst instrumentationKey = \"__GENKIT_TELEMETRY_INSTRUMENTED\";\nconst telemetryProviderKey = \"__GENKIT_TELEMETRY_PROVIDER\";\nasync function ensureBasicTelemetryInstrumentation() {\n  await checkFirebaseMonitoringAutoInit();\n  if (global[instrumentationKey]) {\n    return await global[instrumentationKey];\n  }\n  await enableTelemetry({});\n}\nasync function checkFirebaseMonitoringAutoInit() {\n  if (!global[instrumentationKey] && process.env.ENABLE_FIREBASE_MONITORING === \"true\") {\n    try {\n      const importModule = new Function(\n        \"moduleName\",\n        \"return import(moduleName)\"\n      );\n      const firebaseModule = await importModule(\"@genkit-ai/firebase\");\n      firebaseModule.enableFirebaseTelemetry();\n    } catch (e) {\n      import_logging.logger.warn(\n        \"It looks like you're trying to enable firebase monitoring, but haven't installed the firebase plugin. Please run `npm i --save @genkit-ai/firebase` and redeploy.\"\n      );\n    }\n  }\n}\nfunction getTelemetryProvider() {\n  if (global[telemetryProviderKey]) {\n    return global[telemetryProviderKey];\n  }\n  throw new import_error.GenkitError({\n    status: \"FAILED_PRECONDITION\",\n    message: \"TelemetryProvider is not initialized.\"\n  });\n}\nfunction setTelemetryProvider(provider) {\n  if (global[telemetryProviderKey]) return;\n  global[telemetryProviderKey] = provider;\n}\nasync function enableTelemetry(telemetryConfig) {\n  global[instrumentationKey] = telemetryConfig instanceof Promise ? telemetryConfig : Promise.resolve();\n  return getTelemetryProvider().enableTelemetry(telemetryConfig);\n}\nasync function flushTracing() {\n  return getTelemetryProvider().flushTracing();\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=tracing.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3RyYWNpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLGdGQUFZO0FBQ3ZDLHFCQUFxQixtQkFBTyxDQUFDLG9GQUFjO0FBQzNDLDRCQUE0QixtQkFBTyxDQUFDLHNHQUF1QjtBQUMzRCw0QkFBNEIsbUJBQU8sQ0FBQyxvSEFBOEI7QUFDbEUsNEJBQTRCLG1CQUFPLENBQUMsZ0dBQW9CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQVFMO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcS1JhbWFjaGFcXERvY3VtZW50c1xcU3VzdEFJbmV4IEdJdCBDb2RlXFxub2RlX21vZHVsZXNcXEBnZW5raXQtYWlcXGNvcmVcXGxpYlxcdHJhY2luZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2QsIHNlY29uZFRhcmdldCkgPT4gKF9fY29weVByb3BzKHRhcmdldCwgbW9kLCBcImRlZmF1bHRcIiksIHNlY29uZFRhcmdldCAmJiBfX2NvcHlQcm9wcyhzZWNvbmRUYXJnZXQsIG1vZCwgXCJkZWZhdWx0XCIpKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIHRyYWNpbmdfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodHJhY2luZ19leHBvcnRzLCB7XG4gIGVuYWJsZVRlbGVtZXRyeTogKCkgPT4gZW5hYmxlVGVsZW1ldHJ5LFxuICBlbnN1cmVCYXNpY1RlbGVtZXRyeUluc3RydW1lbnRhdGlvbjogKCkgPT4gZW5zdXJlQmFzaWNUZWxlbWV0cnlJbnN0cnVtZW50YXRpb24sXG4gIGZsdXNoVHJhY2luZzogKCkgPT4gZmx1c2hUcmFjaW5nLFxuICBzZXRUZWxlbWV0cnlQcm92aWRlcjogKCkgPT4gc2V0VGVsZW1ldHJ5UHJvdmlkZXJcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlModHJhY2luZ19leHBvcnRzKTtcbnZhciBpbXBvcnRfZXJyb3IgPSByZXF1aXJlKFwiLi9lcnJvci5qc1wiKTtcbnZhciBpbXBvcnRfbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmcuanNcIik7XG5fX3JlRXhwb3J0KHRyYWNpbmdfZXhwb3J0cywgcmVxdWlyZShcIi4vdHJhY2luZy9leHBvcnRlci5qc1wiKSwgbW9kdWxlLmV4cG9ydHMpO1xuX19yZUV4cG9ydCh0cmFjaW5nX2V4cG9ydHMsIHJlcXVpcmUoXCIuL3RyYWNpbmcvaW5zdHJ1bWVudGF0aW9uLmpzXCIpLCBtb2R1bGUuZXhwb3J0cyk7XG5fX3JlRXhwb3J0KHRyYWNpbmdfZXhwb3J0cywgcmVxdWlyZShcIi4vdHJhY2luZy90eXBlcy5qc1wiKSwgbW9kdWxlLmV4cG9ydHMpO1xuY29uc3QgaW5zdHJ1bWVudGF0aW9uS2V5ID0gXCJfX0dFTktJVF9URUxFTUVUUllfSU5TVFJVTUVOVEVEXCI7XG5jb25zdCB0ZWxlbWV0cnlQcm92aWRlcktleSA9IFwiX19HRU5LSVRfVEVMRU1FVFJZX1BST1ZJREVSXCI7XG5hc3luYyBmdW5jdGlvbiBlbnN1cmVCYXNpY1RlbGVtZXRyeUluc3RydW1lbnRhdGlvbigpIHtcbiAgYXdhaXQgY2hlY2tGaXJlYmFzZU1vbml0b3JpbmdBdXRvSW5pdCgpO1xuICBpZiAoZ2xvYmFsW2luc3RydW1lbnRhdGlvbktleV0pIHtcbiAgICByZXR1cm4gYXdhaXQgZ2xvYmFsW2luc3RydW1lbnRhdGlvbktleV07XG4gIH1cbiAgYXdhaXQgZW5hYmxlVGVsZW1ldHJ5KHt9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrRmlyZWJhc2VNb25pdG9yaW5nQXV0b0luaXQoKSB7XG4gIGlmICghZ2xvYmFsW2luc3RydW1lbnRhdGlvbktleV0gJiYgcHJvY2Vzcy5lbnYuRU5BQkxFX0ZJUkVCQVNFX01PTklUT1JJTkcgPT09IFwidHJ1ZVwiKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGltcG9ydE1vZHVsZSA9IG5ldyBGdW5jdGlvbihcbiAgICAgICAgXCJtb2R1bGVOYW1lXCIsXG4gICAgICAgIFwicmV0dXJuIGltcG9ydChtb2R1bGVOYW1lKVwiXG4gICAgICApO1xuICAgICAgY29uc3QgZmlyZWJhc2VNb2R1bGUgPSBhd2FpdCBpbXBvcnRNb2R1bGUoXCJAZ2Vua2l0LWFpL2ZpcmViYXNlXCIpO1xuICAgICAgZmlyZWJhc2VNb2R1bGUuZW5hYmxlRmlyZWJhc2VUZWxlbWV0cnkoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpbXBvcnRfbG9nZ2luZy5sb2dnZXIud2FybihcbiAgICAgICAgXCJJdCBsb29rcyBsaWtlIHlvdSdyZSB0cnlpbmcgdG8gZW5hYmxlIGZpcmViYXNlIG1vbml0b3JpbmcsIGJ1dCBoYXZlbid0IGluc3RhbGxlZCB0aGUgZmlyZWJhc2UgcGx1Z2luLiBQbGVhc2UgcnVuIGBucG0gaSAtLXNhdmUgQGdlbmtpdC1haS9maXJlYmFzZWAgYW5kIHJlZGVwbG95LlwiXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0VGVsZW1ldHJ5UHJvdmlkZXIoKSB7XG4gIGlmIChnbG9iYWxbdGVsZW1ldHJ5UHJvdmlkZXJLZXldKSB7XG4gICAgcmV0dXJuIGdsb2JhbFt0ZWxlbWV0cnlQcm92aWRlcktleV07XG4gIH1cbiAgdGhyb3cgbmV3IGltcG9ydF9lcnJvci5HZW5raXRFcnJvcih7XG4gICAgc3RhdHVzOiBcIkZBSUxFRF9QUkVDT05ESVRJT05cIixcbiAgICBtZXNzYWdlOiBcIlRlbGVtZXRyeVByb3ZpZGVyIGlzIG5vdCBpbml0aWFsaXplZC5cIlxuICB9KTtcbn1cbmZ1bmN0aW9uIHNldFRlbGVtZXRyeVByb3ZpZGVyKHByb3ZpZGVyKSB7XG4gIGlmIChnbG9iYWxbdGVsZW1ldHJ5UHJvdmlkZXJLZXldKSByZXR1cm47XG4gIGdsb2JhbFt0ZWxlbWV0cnlQcm92aWRlcktleV0gPSBwcm92aWRlcjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGVuYWJsZVRlbGVtZXRyeSh0ZWxlbWV0cnlDb25maWcpIHtcbiAgZ2xvYmFsW2luc3RydW1lbnRhdGlvbktleV0gPSB0ZWxlbWV0cnlDb25maWcgaW5zdGFuY2VvZiBQcm9taXNlID8gdGVsZW1ldHJ5Q29uZmlnIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gIHJldHVybiBnZXRUZWxlbWV0cnlQcm92aWRlcigpLmVuYWJsZVRlbGVtZXRyeSh0ZWxlbWV0cnlDb25maWcpO1xufVxuYXN5bmMgZnVuY3Rpb24gZmx1c2hUcmFjaW5nKCkge1xuICByZXR1cm4gZ2V0VGVsZW1ldHJ5UHJvdmlkZXIoKS5mbHVzaFRyYWNpbmcoKTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBlbmFibGVUZWxlbWV0cnksXG4gIGVuc3VyZUJhc2ljVGVsZW1ldHJ5SW5zdHJ1bWVudGF0aW9uLFxuICBmbHVzaFRyYWNpbmcsXG4gIHNldFRlbGVtZXRyeVByb3ZpZGVyLFxuICAuLi5yZXF1aXJlKFwiLi90cmFjaW5nL2V4cG9ydGVyLmpzXCIpLFxuICAuLi5yZXF1aXJlKFwiLi90cmFjaW5nL2luc3RydW1lbnRhdGlvbi5qc1wiKSxcbiAgLi4ucmVxdWlyZShcIi4vdHJhY2luZy90eXBlcy5qc1wiKVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFjaW5nLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/tracing.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/exporter.js":
/*!**************************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/tracing/exporter.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar exporter_exports = {};\n__export(exporter_exports, {\n  TraceServerExporter: () => TraceServerExporter,\n  setTelemetryServerUrl: () => setTelemetryServerUrl,\n  telemetryServerUrl: () => telemetryServerUrl\n});\nmodule.exports = __toCommonJS(exporter_exports);\nvar import_api = __webpack_require__(/*! @opentelemetry/api */ \"(action-browser)/./node_modules/@opentelemetry/api/build/esm/index.js\");\nvar import_core = __webpack_require__(/*! @opentelemetry/core */ \"(action-browser)/./node_modules/@opentelemetry/core/build/esm/index.js\");\nvar import_logging = __webpack_require__(/*! ../logging.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/logging.js\");\nvar import_utils = __webpack_require__(/*! ../utils.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/utils.js\");\nlet telemetryServerUrl;\nfunction setTelemetryServerUrl(url) {\n  telemetryServerUrl = url;\n}\nclass TraceServerExporter {\n  /**\n   * Export spans.\n   * @param spans\n   * @param resultCallback\n   */\n  export(spans, resultCallback) {\n    this._sendSpans(spans, resultCallback);\n  }\n  /**\n   * Shutdown the exporter.\n   */\n  shutdown() {\n    this._sendSpans([]);\n    return this.forceFlush();\n  }\n  /**\n   * Converts span info into trace store format.\n   * @param span\n   */\n  _exportInfo(span) {\n    const spanData = {\n      spanId: span.spanContext().spanId,\n      traceId: span.spanContext().traceId,\n      startTime: transformTime(span.startTime),\n      endTime: transformTime(span.endTime),\n      attributes: { ...span.attributes },\n      displayName: span.name,\n      links: span.links,\n      spanKind: import_api.SpanKind[span.kind],\n      parentSpanId: span.parentSpanId,\n      sameProcessAsParentSpan: { value: !span.spanContext().isRemote },\n      status: span.status,\n      timeEvents: {\n        timeEvent: span.events.map((e) => ({\n          time: transformTime(e.time),\n          annotation: {\n            attributes: e.attributes ?? {},\n            description: e.name\n          }\n        }))\n      }\n    };\n    if (span.instrumentationLibrary !== void 0) {\n      spanData.instrumentationLibrary = {\n        name: span.instrumentationLibrary.name\n      };\n      if (span.instrumentationLibrary.schemaUrl !== void 0) {\n        spanData.instrumentationLibrary.schemaUrl = span.instrumentationLibrary.schemaUrl;\n      }\n      if (span.instrumentationLibrary.version !== void 0) {\n        spanData.instrumentationLibrary.version = span.instrumentationLibrary.version;\n      }\n    }\n    (0, import_utils.deleteUndefinedProps)(spanData);\n    return spanData;\n  }\n  /**\n   * Exports any pending spans in exporter\n   */\n  forceFlush() {\n    return Promise.resolve();\n  }\n  async _sendSpans(spans, done) {\n    const traces = {};\n    for (const span of spans) {\n      if (!traces[span.spanContext().traceId]) {\n        traces[span.spanContext().traceId] = [];\n      }\n      traces[span.spanContext().traceId].push(span);\n    }\n    let error = false;\n    for (const traceId of Object.keys(traces)) {\n      try {\n        await this.save(traceId, traces[traceId]);\n      } catch (e) {\n        error = true;\n        import_logging.logger.error(`Failed to save trace ${traceId}`, e);\n      }\n      if (done) {\n        return done({\n          code: error ? import_core.ExportResultCode.FAILED : import_core.ExportResultCode.SUCCESS\n        });\n      }\n    }\n  }\n  async save(traceId, spans) {\n    if (!telemetryServerUrl) {\n      import_logging.logger.debug(\n        `Telemetry server is not configured, trace ${traceId} not saved!`\n      );\n      return;\n    }\n    const data = {\n      traceId,\n      spans: {}\n    };\n    for (const span of spans) {\n      const convertedSpan = this._exportInfo(span);\n      data.spans[convertedSpan.spanId] = convertedSpan;\n      if (!convertedSpan.parentSpanId) {\n        data.displayName = convertedSpan.displayName;\n        data.startTime = convertedSpan.startTime;\n        data.endTime = convertedSpan.endTime;\n      }\n    }\n    await fetch(`${telemetryServerUrl}/api/traces`, {\n      method: \"POST\",\n      headers: {\n        Accept: \"application/json\",\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(data)\n    });\n  }\n}\nfunction transformTime(time) {\n  return (0, import_core.hrTimeToMilliseconds)(time);\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=exporter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3RyYWNpbmcvZXhwb3J0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsaUdBQW9CO0FBQzdDLGtCQUFrQixtQkFBTyxDQUFDLG1HQUFxQjtBQUMvQyxxQkFBcUIsbUJBQU8sQ0FBQyxxRkFBZTtBQUM1QyxtQkFBbUIsbUJBQU8sQ0FBQyxpRkFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFDQUFxQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSw0REFBNEQsUUFBUTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUlMO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcS1JhbWFjaGFcXERvY3VtZW50c1xcU3VzdEFJbmV4IEdJdCBDb2RlXFxub2RlX21vZHVsZXNcXEBnZW5raXQtYWlcXGNvcmVcXGxpYlxcdHJhY2luZ1xcZXhwb3J0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIGV4cG9ydGVyX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGV4cG9ydGVyX2V4cG9ydHMsIHtcbiAgVHJhY2VTZXJ2ZXJFeHBvcnRlcjogKCkgPT4gVHJhY2VTZXJ2ZXJFeHBvcnRlcixcbiAgc2V0VGVsZW1ldHJ5U2VydmVyVXJsOiAoKSA9PiBzZXRUZWxlbWV0cnlTZXJ2ZXJVcmwsXG4gIHRlbGVtZXRyeVNlcnZlclVybDogKCkgPT4gdGVsZW1ldHJ5U2VydmVyVXJsXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKGV4cG9ydGVyX2V4cG9ydHMpO1xudmFyIGltcG9ydF9hcGkgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvYXBpXCIpO1xudmFyIGltcG9ydF9jb3JlID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2NvcmVcIik7XG52YXIgaW1wb3J0X2xvZ2dpbmcgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy5qc1wiKTtcbnZhciBpbXBvcnRfdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMuanNcIik7XG5sZXQgdGVsZW1ldHJ5U2VydmVyVXJsO1xuZnVuY3Rpb24gc2V0VGVsZW1ldHJ5U2VydmVyVXJsKHVybCkge1xuICB0ZWxlbWV0cnlTZXJ2ZXJVcmwgPSB1cmw7XG59XG5jbGFzcyBUcmFjZVNlcnZlckV4cG9ydGVyIHtcbiAgLyoqXG4gICAqIEV4cG9ydCBzcGFucy5cbiAgICogQHBhcmFtIHNwYW5zXG4gICAqIEBwYXJhbSByZXN1bHRDYWxsYmFja1xuICAgKi9cbiAgZXhwb3J0KHNwYW5zLCByZXN1bHRDYWxsYmFjaykge1xuICAgIHRoaXMuX3NlbmRTcGFucyhzcGFucywgcmVzdWx0Q2FsbGJhY2spO1xuICB9XG4gIC8qKlxuICAgKiBTaHV0ZG93biB0aGUgZXhwb3J0ZXIuXG4gICAqL1xuICBzaHV0ZG93bigpIHtcbiAgICB0aGlzLl9zZW5kU3BhbnMoW10pO1xuICAgIHJldHVybiB0aGlzLmZvcmNlRmx1c2goKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgc3BhbiBpbmZvIGludG8gdHJhY2Ugc3RvcmUgZm9ybWF0LlxuICAgKiBAcGFyYW0gc3BhblxuICAgKi9cbiAgX2V4cG9ydEluZm8oc3Bhbikge1xuICAgIGNvbnN0IHNwYW5EYXRhID0ge1xuICAgICAgc3BhbklkOiBzcGFuLnNwYW5Db250ZXh0KCkuc3BhbklkLFxuICAgICAgdHJhY2VJZDogc3Bhbi5zcGFuQ29udGV4dCgpLnRyYWNlSWQsXG4gICAgICBzdGFydFRpbWU6IHRyYW5zZm9ybVRpbWUoc3Bhbi5zdGFydFRpbWUpLFxuICAgICAgZW5kVGltZTogdHJhbnNmb3JtVGltZShzcGFuLmVuZFRpbWUpLFxuICAgICAgYXR0cmlidXRlczogeyAuLi5zcGFuLmF0dHJpYnV0ZXMgfSxcbiAgICAgIGRpc3BsYXlOYW1lOiBzcGFuLm5hbWUsXG4gICAgICBsaW5rczogc3Bhbi5saW5rcyxcbiAgICAgIHNwYW5LaW5kOiBpbXBvcnRfYXBpLlNwYW5LaW5kW3NwYW4ua2luZF0sXG4gICAgICBwYXJlbnRTcGFuSWQ6IHNwYW4ucGFyZW50U3BhbklkLFxuICAgICAgc2FtZVByb2Nlc3NBc1BhcmVudFNwYW46IHsgdmFsdWU6ICFzcGFuLnNwYW5Db250ZXh0KCkuaXNSZW1vdGUgfSxcbiAgICAgIHN0YXR1czogc3Bhbi5zdGF0dXMsXG4gICAgICB0aW1lRXZlbnRzOiB7XG4gICAgICAgIHRpbWVFdmVudDogc3Bhbi5ldmVudHMubWFwKChlKSA9PiAoe1xuICAgICAgICAgIHRpbWU6IHRyYW5zZm9ybVRpbWUoZS50aW1lKSxcbiAgICAgICAgICBhbm5vdGF0aW9uOiB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBlLmF0dHJpYnV0ZXMgPz8ge30sXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogZS5uYW1lXG4gICAgICAgICAgfVxuICAgICAgICB9KSlcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChzcGFuLmluc3RydW1lbnRhdGlvbkxpYnJhcnkgIT09IHZvaWQgMCkge1xuICAgICAgc3BhbkRhdGEuaW5zdHJ1bWVudGF0aW9uTGlicmFyeSA9IHtcbiAgICAgICAgbmFtZTogc3Bhbi5pbnN0cnVtZW50YXRpb25MaWJyYXJ5Lm5hbWVcbiAgICAgIH07XG4gICAgICBpZiAoc3Bhbi5pbnN0cnVtZW50YXRpb25MaWJyYXJ5LnNjaGVtYVVybCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHNwYW5EYXRhLmluc3RydW1lbnRhdGlvbkxpYnJhcnkuc2NoZW1hVXJsID0gc3Bhbi5pbnN0cnVtZW50YXRpb25MaWJyYXJ5LnNjaGVtYVVybDtcbiAgICAgIH1cbiAgICAgIGlmIChzcGFuLmluc3RydW1lbnRhdGlvbkxpYnJhcnkudmVyc2lvbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHNwYW5EYXRhLmluc3RydW1lbnRhdGlvbkxpYnJhcnkudmVyc2lvbiA9IHNwYW4uaW5zdHJ1bWVudGF0aW9uTGlicmFyeS52ZXJzaW9uO1xuICAgICAgfVxuICAgIH1cbiAgICAoMCwgaW1wb3J0X3V0aWxzLmRlbGV0ZVVuZGVmaW5lZFByb3BzKShzcGFuRGF0YSk7XG4gICAgcmV0dXJuIHNwYW5EYXRhO1xuICB9XG4gIC8qKlxuICAgKiBFeHBvcnRzIGFueSBwZW5kaW5nIHNwYW5zIGluIGV4cG9ydGVyXG4gICAqL1xuICBmb3JjZUZsdXNoKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICBhc3luYyBfc2VuZFNwYW5zKHNwYW5zLCBkb25lKSB7XG4gICAgY29uc3QgdHJhY2VzID0ge307XG4gICAgZm9yIChjb25zdCBzcGFuIG9mIHNwYW5zKSB7XG4gICAgICBpZiAoIXRyYWNlc1tzcGFuLnNwYW5Db250ZXh0KCkudHJhY2VJZF0pIHtcbiAgICAgICAgdHJhY2VzW3NwYW4uc3BhbkNvbnRleHQoKS50cmFjZUlkXSA9IFtdO1xuICAgICAgfVxuICAgICAgdHJhY2VzW3NwYW4uc3BhbkNvbnRleHQoKS50cmFjZUlkXS5wdXNoKHNwYW4pO1xuICAgIH1cbiAgICBsZXQgZXJyb3IgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHRyYWNlSWQgb2YgT2JqZWN0LmtleXModHJhY2VzKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlKHRyYWNlSWQsIHRyYWNlc1t0cmFjZUlkXSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yID0gdHJ1ZTtcbiAgICAgICAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gc2F2ZSB0cmFjZSAke3RyYWNlSWR9YCwgZSk7XG4gICAgICB9XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICByZXR1cm4gZG9uZSh7XG4gICAgICAgICAgY29kZTogZXJyb3IgPyBpbXBvcnRfY29yZS5FeHBvcnRSZXN1bHRDb2RlLkZBSUxFRCA6IGltcG9ydF9jb3JlLkV4cG9ydFJlc3VsdENvZGUuU1VDQ0VTU1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXN5bmMgc2F2ZSh0cmFjZUlkLCBzcGFucykge1xuICAgIGlmICghdGVsZW1ldHJ5U2VydmVyVXJsKSB7XG4gICAgICBpbXBvcnRfbG9nZ2luZy5sb2dnZXIuZGVidWcoXG4gICAgICAgIGBUZWxlbWV0cnkgc2VydmVyIGlzIG5vdCBjb25maWd1cmVkLCB0cmFjZSAke3RyYWNlSWR9IG5vdCBzYXZlZCFgXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgdHJhY2VJZCxcbiAgICAgIHNwYW5zOiB7fVxuICAgIH07XG4gICAgZm9yIChjb25zdCBzcGFuIG9mIHNwYW5zKSB7XG4gICAgICBjb25zdCBjb252ZXJ0ZWRTcGFuID0gdGhpcy5fZXhwb3J0SW5mbyhzcGFuKTtcbiAgICAgIGRhdGEuc3BhbnNbY29udmVydGVkU3Bhbi5zcGFuSWRdID0gY29udmVydGVkU3BhbjtcbiAgICAgIGlmICghY29udmVydGVkU3Bhbi5wYXJlbnRTcGFuSWQpIHtcbiAgICAgICAgZGF0YS5kaXNwbGF5TmFtZSA9IGNvbnZlcnRlZFNwYW4uZGlzcGxheU5hbWU7XG4gICAgICAgIGRhdGEuc3RhcnRUaW1lID0gY29udmVydGVkU3Bhbi5zdGFydFRpbWU7XG4gICAgICAgIGRhdGEuZW5kVGltZSA9IGNvbnZlcnRlZFNwYW4uZW5kVGltZTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXdhaXQgZmV0Y2goYCR7dGVsZW1ldHJ5U2VydmVyVXJsfS9hcGkvdHJhY2VzYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1UaW1lKHRpbWUpIHtcbiAgcmV0dXJuICgwLCBpbXBvcnRfY29yZS5oclRpbWVUb01pbGxpc2Vjb25kcykodGltZSk7XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgVHJhY2VTZXJ2ZXJFeHBvcnRlcixcbiAgc2V0VGVsZW1ldHJ5U2VydmVyVXJsLFxuICB0ZWxlbWV0cnlTZXJ2ZXJVcmxcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhwb3J0ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/exporter.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/instrumentation.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/tracing/instrumentation.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar instrumentation_exports = {};\n__export(instrumentation_exports, {\n  ATTR_PREFIX: () => ATTR_PREFIX,\n  SPAN_TYPE_ATTR: () => SPAN_TYPE_ATTR,\n  appendSpan: () => appendSpan,\n  disableOTelRootSpanDetection: () => disableOTelRootSpanDetection,\n  runInNewSpan: () => runInNewSpan,\n  setCustomMetadataAttribute: () => setCustomMetadataAttribute,\n  setCustomMetadataAttributes: () => setCustomMetadataAttributes,\n  spanMetadataAlsKey: () => spanMetadataAlsKey,\n  toDisplayPath: () => toDisplayPath\n});\nmodule.exports = __toCommonJS(instrumentation_exports);\nvar import_api = __webpack_require__(/*! @opentelemetry/api */ \"(action-browser)/./node_modules/@opentelemetry/api/build/esm/index.js\");\nvar import_node_perf_hooks = __webpack_require__(/*! node:perf_hooks */ \"node:perf_hooks\");\nvar import_async_context = __webpack_require__(/*! ../async-context.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/async-context.js\");\nvar import_tracing = __webpack_require__(/*! ../tracing.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing.js\");\nconst spanMetadataAlsKey = \"core.tracing.instrumentation.span\";\nconst ATTR_PREFIX = \"genkit\";\nconst SPAN_TYPE_ATTR = ATTR_PREFIX + \":type\";\nconst TRACER_NAME = \"genkit-tracer\";\nconst TRACER_VERSION = \"v1\";\nasync function runInNewSpan(registryOrOprs, optsOrFn, fnMaybe) {\n  let opts;\n  let fn;\n  if (arguments.length === 3) {\n    opts = optsOrFn;\n    fn = fnMaybe;\n  } else {\n    opts = registryOrOprs;\n    fn = optsOrFn;\n  }\n  await (0, import_tracing.ensureBasicTelemetryInstrumentation)();\n  const tracer = import_api.trace.getTracer(TRACER_NAME, TRACER_VERSION);\n  const parentStep = (0, import_async_context.getAsyncContext)().getStore(spanMetadataAlsKey);\n  const isInRoot = parentStep?.metadata?.isRoot === true;\n  if (!parentStep) opts.metadata.isRoot ||= true;\n  const spanOptions = { links: opts.links };\n  if (!isDisableRootSpanDetection()) {\n    spanOptions.root = opts.metadata.isRoot;\n  }\n  return await tracer.startActiveSpan(\n    opts.metadata.name,\n    spanOptions,\n    async (otSpan) => {\n      if (opts.labels) otSpan.setAttributes(opts.labels);\n      const spanContext = {\n        ...parentStep,\n        metadata: opts.metadata\n      };\n      try {\n        opts.metadata.path = buildPath(\n          opts.metadata.name,\n          parentStep?.metadata?.path || \"\",\n          opts.labels\n        );\n        const output = await (0, import_async_context.getAsyncContext)().run(\n          spanMetadataAlsKey,\n          spanContext,\n          () => fn(opts.metadata, otSpan, isInRoot)\n        );\n        if (opts.metadata.state !== \"error\") {\n          opts.metadata.state = \"success\";\n        }\n        recordPath(opts.metadata, spanContext);\n        return output;\n      } catch (e) {\n        recordPath(opts.metadata, spanContext, e);\n        opts.metadata.state = \"error\";\n        otSpan.setStatus({\n          code: import_api.SpanStatusCode.ERROR,\n          message: getErrorMessage(e)\n        });\n        if (e instanceof Error) {\n          otSpan.recordException(e);\n        }\n        if (typeof e === \"object\") {\n          if (!e.ignoreFailedSpan) {\n            opts.metadata.isFailureSource = true;\n          }\n          e.ignoreFailedSpan = true;\n        }\n        throw e;\n      } finally {\n        otSpan.setAttributes(metadataToAttributes(opts.metadata));\n        otSpan.end();\n      }\n    }\n  );\n}\nasync function appendSpan(traceId, parentSpanId, metadata, labels) {\n  await (0, import_tracing.ensureBasicTelemetryInstrumentation)();\n  const tracer = import_api.trace.getTracer(TRACER_NAME, TRACER_VERSION);\n  const spanContext = import_api.trace.setSpanContext(import_api.ROOT_CONTEXT, {\n    traceId,\n    traceFlags: 1,\n    // sampled\n    spanId: parentSpanId\n  });\n  const span = tracer.startSpan(metadata.name, {}, spanContext);\n  span.setAttributes(metadataToAttributes(metadata));\n  if (labels) {\n    span.setAttributes(labels);\n  }\n  span.end();\n}\nfunction getErrorMessage(e) {\n  if (e instanceof Error) {\n    return e.message;\n  }\n  return `${e}`;\n}\nfunction metadataToAttributes(metadata) {\n  const out = {};\n  Object.keys(metadata).forEach((key) => {\n    if (key === \"metadata\" && typeof metadata[key] === \"object\" && metadata.metadata) {\n      Object.entries(metadata.metadata).forEach(([metaKey, value]) => {\n        out[ATTR_PREFIX + \":metadata:\" + metaKey] = value;\n      });\n    } else if (key === \"input\" || typeof metadata[key] === \"object\") {\n      out[ATTR_PREFIX + \":\" + key] = JSON.stringify(metadata[key]);\n    } else {\n      out[ATTR_PREFIX + \":\" + key] = metadata[key];\n    }\n  });\n  return out;\n}\nfunction setCustomMetadataAttribute(key, value) {\n  const currentStep = getCurrentSpan();\n  if (!currentStep) {\n    return;\n  }\n  if (!currentStep.metadata) {\n    currentStep.metadata = {};\n  }\n  currentStep.metadata[key] = value;\n}\nfunction setCustomMetadataAttributes(values) {\n  const currentStep = getCurrentSpan();\n  if (!currentStep) {\n    return;\n  }\n  if (!currentStep.metadata) {\n    currentStep.metadata = {};\n  }\n  for (const [key, value] of Object.entries(values)) {\n    currentStep.metadata[key] = value;\n  }\n}\nfunction toDisplayPath(path) {\n  const pathPartRegex = /\\{([^\\,}]+),[^\\}]+\\}/g;\n  return Array.from(path.matchAll(pathPartRegex), (m) => m[1]).join(\" > \");\n}\nfunction getCurrentSpan() {\n  const step = (0, import_async_context.getAsyncContext)().getStore(spanMetadataAlsKey);\n  if (!step) {\n    throw new Error(\"running outside step context\");\n  }\n  return step.metadata;\n}\nfunction buildPath(name, parentPath, labels) {\n  const stepType = labels && labels[\"genkit:type\"] ? `,t:${labels[\"genkit:metadata:subtype\"] === \"flow\" ? \"flow\" : labels[\"genkit:type\"]}` : \"\";\n  return parentPath + `/{${name}${stepType}}`;\n}\nfunction recordPath(spanMeta, spanContext, err) {\n  const path = spanMeta.path || \"\";\n  const decoratedPath = decoratePathWithSubtype(spanMeta);\n  const paths = Array.from(spanContext?.paths || /* @__PURE__ */ new Set());\n  const status = err ? \"failure\" : \"success\";\n  if (!paths.some((p) => p.path.startsWith(path) && p.status === status)) {\n    const now = import_node_perf_hooks.performance.now();\n    const start = spanContext?.timestamp || now;\n    spanContext?.paths?.add({\n      path: decoratedPath,\n      error: err?.name,\n      latency: now - start,\n      status\n    });\n  }\n  spanMeta.path = decoratedPath;\n}\nfunction decoratePathWithSubtype(metadata) {\n  if (!metadata.path) {\n    return \"\";\n  }\n  const pathComponents = metadata.path.split(\"}/{\");\n  if (pathComponents.length == 1) {\n    return metadata.path;\n  }\n  const stepSubtype = metadata.metadata && metadata.metadata[\"subtype\"] ? `,s:${metadata.metadata[\"subtype\"]}` : \"\";\n  const root = `${pathComponents.slice(0, -1).join(\"}/{\")}}/`;\n  const decoratedStep = `{${pathComponents.at(-1)?.slice(0, -1)}${stepSubtype}}`;\n  return root + decoratedStep;\n}\nconst rootSpanDetectionKey = \"__genkit_disableRootSpanDetection\";\nfunction isDisableRootSpanDetection() {\n  return global[rootSpanDetectionKey] === true;\n}\nfunction disableOTelRootSpanDetection() {\n  global[rootSpanDetectionKey] = true;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=instrumentation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3RyYWNpbmcvaW5zdHJ1bWVudGF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLGlHQUFvQjtBQUM3Qyw2QkFBNkIsbUJBQU8sQ0FBQyx3Q0FBaUI7QUFDdEQsMkJBQTJCLG1CQUFPLENBQUMsaUdBQXFCO0FBQ3hELHFCQUFxQixtQkFBTyxDQUFDLHFGQUFlO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxFQUFFO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsTUFBTSxRQUFRLElBQUk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsOEVBQThFO0FBQ3pJLHlCQUF5QixFQUFFLEtBQUssRUFBRSxVQUFVO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsRUFBRTtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsNkJBQTZCO0FBQzdHLGtCQUFrQixtQ0FBbUMsRUFBRSxJQUFJO0FBQzNELDBCQUEwQixFQUFFLG9DQUFvQyxFQUFFLGFBQWE7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBVUw7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcY29yZVxcbGliXFx0cmFjaW5nXFxpbnN0cnVtZW50YXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIGluc3RydW1lbnRhdGlvbl9leHBvcnRzID0ge307XG5fX2V4cG9ydChpbnN0cnVtZW50YXRpb25fZXhwb3J0cywge1xuICBBVFRSX1BSRUZJWDogKCkgPT4gQVRUUl9QUkVGSVgsXG4gIFNQQU5fVFlQRV9BVFRSOiAoKSA9PiBTUEFOX1RZUEVfQVRUUixcbiAgYXBwZW5kU3BhbjogKCkgPT4gYXBwZW5kU3BhbixcbiAgZGlzYWJsZU9UZWxSb290U3BhbkRldGVjdGlvbjogKCkgPT4gZGlzYWJsZU9UZWxSb290U3BhbkRldGVjdGlvbixcbiAgcnVuSW5OZXdTcGFuOiAoKSA9PiBydW5Jbk5ld1NwYW4sXG4gIHNldEN1c3RvbU1ldGFkYXRhQXR0cmlidXRlOiAoKSA9PiBzZXRDdXN0b21NZXRhZGF0YUF0dHJpYnV0ZSxcbiAgc2V0Q3VzdG9tTWV0YWRhdGFBdHRyaWJ1dGVzOiAoKSA9PiBzZXRDdXN0b21NZXRhZGF0YUF0dHJpYnV0ZXMsXG4gIHNwYW5NZXRhZGF0YUFsc0tleTogKCkgPT4gc3Bhbk1ldGFkYXRhQWxzS2V5LFxuICB0b0Rpc3BsYXlQYXRoOiAoKSA9PiB0b0Rpc3BsYXlQYXRoXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKGluc3RydW1lbnRhdGlvbl9leHBvcnRzKTtcbnZhciBpbXBvcnRfYXBpID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2FwaVwiKTtcbnZhciBpbXBvcnRfbm9kZV9wZXJmX2hvb2tzID0gcmVxdWlyZShcIm5vZGU6cGVyZl9ob29rc1wiKTtcbnZhciBpbXBvcnRfYXN5bmNfY29udGV4dCA9IHJlcXVpcmUoXCIuLi9hc3luYy1jb250ZXh0LmpzXCIpO1xudmFyIGltcG9ydF90cmFjaW5nID0gcmVxdWlyZShcIi4uL3RyYWNpbmcuanNcIik7XG5jb25zdCBzcGFuTWV0YWRhdGFBbHNLZXkgPSBcImNvcmUudHJhY2luZy5pbnN0cnVtZW50YXRpb24uc3BhblwiO1xuY29uc3QgQVRUUl9QUkVGSVggPSBcImdlbmtpdFwiO1xuY29uc3QgU1BBTl9UWVBFX0FUVFIgPSBBVFRSX1BSRUZJWCArIFwiOnR5cGVcIjtcbmNvbnN0IFRSQUNFUl9OQU1FID0gXCJnZW5raXQtdHJhY2VyXCI7XG5jb25zdCBUUkFDRVJfVkVSU0lPTiA9IFwidjFcIjtcbmFzeW5jIGZ1bmN0aW9uIHJ1bkluTmV3U3BhbihyZWdpc3RyeU9yT3Bycywgb3B0c09yRm4sIGZuTWF5YmUpIHtcbiAgbGV0IG9wdHM7XG4gIGxldCBmbjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBvcHRzID0gb3B0c09yRm47XG4gICAgZm4gPSBmbk1heWJlO1xuICB9IGVsc2Uge1xuICAgIG9wdHMgPSByZWdpc3RyeU9yT3BycztcbiAgICBmbiA9IG9wdHNPckZuO1xuICB9XG4gIGF3YWl0ICgwLCBpbXBvcnRfdHJhY2luZy5lbnN1cmVCYXNpY1RlbGVtZXRyeUluc3RydW1lbnRhdGlvbikoKTtcbiAgY29uc3QgdHJhY2VyID0gaW1wb3J0X2FwaS50cmFjZS5nZXRUcmFjZXIoVFJBQ0VSX05BTUUsIFRSQUNFUl9WRVJTSU9OKTtcbiAgY29uc3QgcGFyZW50U3RlcCA9ICgwLCBpbXBvcnRfYXN5bmNfY29udGV4dC5nZXRBc3luY0NvbnRleHQpKCkuZ2V0U3RvcmUoc3Bhbk1ldGFkYXRhQWxzS2V5KTtcbiAgY29uc3QgaXNJblJvb3QgPSBwYXJlbnRTdGVwPy5tZXRhZGF0YT8uaXNSb290ID09PSB0cnVlO1xuICBpZiAoIXBhcmVudFN0ZXApIG9wdHMubWV0YWRhdGEuaXNSb290IHx8PSB0cnVlO1xuICBjb25zdCBzcGFuT3B0aW9ucyA9IHsgbGlua3M6IG9wdHMubGlua3MgfTtcbiAgaWYgKCFpc0Rpc2FibGVSb290U3BhbkRldGVjdGlvbigpKSB7XG4gICAgc3Bhbk9wdGlvbnMucm9vdCA9IG9wdHMubWV0YWRhdGEuaXNSb290O1xuICB9XG4gIHJldHVybiBhd2FpdCB0cmFjZXIuc3RhcnRBY3RpdmVTcGFuKFxuICAgIG9wdHMubWV0YWRhdGEubmFtZSxcbiAgICBzcGFuT3B0aW9ucyxcbiAgICBhc3luYyAob3RTcGFuKSA9PiB7XG4gICAgICBpZiAob3B0cy5sYWJlbHMpIG90U3Bhbi5zZXRBdHRyaWJ1dGVzKG9wdHMubGFiZWxzKTtcbiAgICAgIGNvbnN0IHNwYW5Db250ZXh0ID0ge1xuICAgICAgICAuLi5wYXJlbnRTdGVwLFxuICAgICAgICBtZXRhZGF0YTogb3B0cy5tZXRhZGF0YVxuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG9wdHMubWV0YWRhdGEucGF0aCA9IGJ1aWxkUGF0aChcbiAgICAgICAgICBvcHRzLm1ldGFkYXRhLm5hbWUsXG4gICAgICAgICAgcGFyZW50U3RlcD8ubWV0YWRhdGE/LnBhdGggfHwgXCJcIixcbiAgICAgICAgICBvcHRzLmxhYmVsc1xuICAgICAgICApO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCAoMCwgaW1wb3J0X2FzeW5jX2NvbnRleHQuZ2V0QXN5bmNDb250ZXh0KSgpLnJ1bihcbiAgICAgICAgICBzcGFuTWV0YWRhdGFBbHNLZXksXG4gICAgICAgICAgc3BhbkNvbnRleHQsXG4gICAgICAgICAgKCkgPT4gZm4ob3B0cy5tZXRhZGF0YSwgb3RTcGFuLCBpc0luUm9vdClcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKG9wdHMubWV0YWRhdGEuc3RhdGUgIT09IFwiZXJyb3JcIikge1xuICAgICAgICAgIG9wdHMubWV0YWRhdGEuc3RhdGUgPSBcInN1Y2Nlc3NcIjtcbiAgICAgICAgfVxuICAgICAgICByZWNvcmRQYXRoKG9wdHMubWV0YWRhdGEsIHNwYW5Db250ZXh0KTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVjb3JkUGF0aChvcHRzLm1ldGFkYXRhLCBzcGFuQ29udGV4dCwgZSk7XG4gICAgICAgIG9wdHMubWV0YWRhdGEuc3RhdGUgPSBcImVycm9yXCI7XG4gICAgICAgIG90U3Bhbi5zZXRTdGF0dXMoe1xuICAgICAgICAgIGNvZGU6IGltcG9ydF9hcGkuU3BhblN0YXR1c0NvZGUuRVJST1IsXG4gICAgICAgICAgbWVzc2FnZTogZ2V0RXJyb3JNZXNzYWdlKGUpXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgb3RTcGFuLnJlY29yZEV4Y2VwdGlvbihlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBpZiAoIWUuaWdub3JlRmFpbGVkU3Bhbikge1xuICAgICAgICAgICAgb3B0cy5tZXRhZGF0YS5pc0ZhaWx1cmVTb3VyY2UgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlLmlnbm9yZUZhaWxlZFNwYW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBvdFNwYW4uc2V0QXR0cmlidXRlcyhtZXRhZGF0YVRvQXR0cmlidXRlcyhvcHRzLm1ldGFkYXRhKSk7XG4gICAgICAgIG90U3Bhbi5lbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBhcHBlbmRTcGFuKHRyYWNlSWQsIHBhcmVudFNwYW5JZCwgbWV0YWRhdGEsIGxhYmVscykge1xuICBhd2FpdCAoMCwgaW1wb3J0X3RyYWNpbmcuZW5zdXJlQmFzaWNUZWxlbWV0cnlJbnN0cnVtZW50YXRpb24pKCk7XG4gIGNvbnN0IHRyYWNlciA9IGltcG9ydF9hcGkudHJhY2UuZ2V0VHJhY2VyKFRSQUNFUl9OQU1FLCBUUkFDRVJfVkVSU0lPTik7XG4gIGNvbnN0IHNwYW5Db250ZXh0ID0gaW1wb3J0X2FwaS50cmFjZS5zZXRTcGFuQ29udGV4dChpbXBvcnRfYXBpLlJPT1RfQ09OVEVYVCwge1xuICAgIHRyYWNlSWQsXG4gICAgdHJhY2VGbGFnczogMSxcbiAgICAvLyBzYW1wbGVkXG4gICAgc3BhbklkOiBwYXJlbnRTcGFuSWRcbiAgfSk7XG4gIGNvbnN0IHNwYW4gPSB0cmFjZXIuc3RhcnRTcGFuKG1ldGFkYXRhLm5hbWUsIHt9LCBzcGFuQ29udGV4dCk7XG4gIHNwYW4uc2V0QXR0cmlidXRlcyhtZXRhZGF0YVRvQXR0cmlidXRlcyhtZXRhZGF0YSkpO1xuICBpZiAobGFiZWxzKSB7XG4gICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKGxhYmVscyk7XG4gIH1cbiAgc3Bhbi5lbmQoKTtcbn1cbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShlKSB7XG4gIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gZS5tZXNzYWdlO1xuICB9XG4gIHJldHVybiBgJHtlfWA7XG59XG5mdW5jdGlvbiBtZXRhZGF0YVRvQXR0cmlidXRlcyhtZXRhZGF0YSkge1xuICBjb25zdCBvdXQgPSB7fTtcbiAgT2JqZWN0LmtleXMobWV0YWRhdGEpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmIChrZXkgPT09IFwibWV0YWRhdGFcIiAmJiB0eXBlb2YgbWV0YWRhdGFba2V5XSA9PT0gXCJvYmplY3RcIiAmJiBtZXRhZGF0YS5tZXRhZGF0YSkge1xuICAgICAgT2JqZWN0LmVudHJpZXMobWV0YWRhdGEubWV0YWRhdGEpLmZvckVhY2goKFttZXRhS2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgb3V0W0FUVFJfUFJFRklYICsgXCI6bWV0YWRhdGE6XCIgKyBtZXRhS2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiaW5wdXRcIiB8fCB0eXBlb2YgbWV0YWRhdGFba2V5XSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgb3V0W0FUVFJfUFJFRklYICsgXCI6XCIgKyBrZXldID0gSlNPTi5zdHJpbmdpZnkobWV0YWRhdGFba2V5XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dFtBVFRSX1BSRUZJWCArIFwiOlwiICsga2V5XSA9IG1ldGFkYXRhW2tleV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIHNldEN1c3RvbU1ldGFkYXRhQXR0cmlidXRlKGtleSwgdmFsdWUpIHtcbiAgY29uc3QgY3VycmVudFN0ZXAgPSBnZXRDdXJyZW50U3BhbigpO1xuICBpZiAoIWN1cnJlbnRTdGVwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghY3VycmVudFN0ZXAubWV0YWRhdGEpIHtcbiAgICBjdXJyZW50U3RlcC5tZXRhZGF0YSA9IHt9O1xuICB9XG4gIGN1cnJlbnRTdGVwLm1ldGFkYXRhW2tleV0gPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldEN1c3RvbU1ldGFkYXRhQXR0cmlidXRlcyh2YWx1ZXMpIHtcbiAgY29uc3QgY3VycmVudFN0ZXAgPSBnZXRDdXJyZW50U3BhbigpO1xuICBpZiAoIWN1cnJlbnRTdGVwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghY3VycmVudFN0ZXAubWV0YWRhdGEpIHtcbiAgICBjdXJyZW50U3RlcC5tZXRhZGF0YSA9IHt9O1xuICB9XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlcykpIHtcbiAgICBjdXJyZW50U3RlcC5tZXRhZGF0YVtrZXldID0gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvRGlzcGxheVBhdGgocGF0aCkge1xuICBjb25zdCBwYXRoUGFydFJlZ2V4ID0gL1xceyhbXlxcLH1dKyksW15cXH1dK1xcfS9nO1xuICByZXR1cm4gQXJyYXkuZnJvbShwYXRoLm1hdGNoQWxsKHBhdGhQYXJ0UmVnZXgpLCAobSkgPT4gbVsxXSkuam9pbihcIiA+IFwiKTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRTcGFuKCkge1xuICBjb25zdCBzdGVwID0gKDAsIGltcG9ydF9hc3luY19jb250ZXh0LmdldEFzeW5jQ29udGV4dCkoKS5nZXRTdG9yZShzcGFuTWV0YWRhdGFBbHNLZXkpO1xuICBpZiAoIXN0ZXApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJydW5uaW5nIG91dHNpZGUgc3RlcCBjb250ZXh0XCIpO1xuICB9XG4gIHJldHVybiBzdGVwLm1ldGFkYXRhO1xufVxuZnVuY3Rpb24gYnVpbGRQYXRoKG5hbWUsIHBhcmVudFBhdGgsIGxhYmVscykge1xuICBjb25zdCBzdGVwVHlwZSA9IGxhYmVscyAmJiBsYWJlbHNbXCJnZW5raXQ6dHlwZVwiXSA/IGAsdDoke2xhYmVsc1tcImdlbmtpdDptZXRhZGF0YTpzdWJ0eXBlXCJdID09PSBcImZsb3dcIiA/IFwiZmxvd1wiIDogbGFiZWxzW1wiZ2Vua2l0OnR5cGVcIl19YCA6IFwiXCI7XG4gIHJldHVybiBwYXJlbnRQYXRoICsgYC97JHtuYW1lfSR7c3RlcFR5cGV9fWA7XG59XG5mdW5jdGlvbiByZWNvcmRQYXRoKHNwYW5NZXRhLCBzcGFuQ29udGV4dCwgZXJyKSB7XG4gIGNvbnN0IHBhdGggPSBzcGFuTWV0YS5wYXRoIHx8IFwiXCI7XG4gIGNvbnN0IGRlY29yYXRlZFBhdGggPSBkZWNvcmF0ZVBhdGhXaXRoU3VidHlwZShzcGFuTWV0YSk7XG4gIGNvbnN0IHBhdGhzID0gQXJyYXkuZnJvbShzcGFuQ29udGV4dD8ucGF0aHMgfHwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gIGNvbnN0IHN0YXR1cyA9IGVyciA/IFwiZmFpbHVyZVwiIDogXCJzdWNjZXNzXCI7XG4gIGlmICghcGF0aHMuc29tZSgocCkgPT4gcC5wYXRoLnN0YXJ0c1dpdGgocGF0aCkgJiYgcC5zdGF0dXMgPT09IHN0YXR1cykpIHtcbiAgICBjb25zdCBub3cgPSBpbXBvcnRfbm9kZV9wZXJmX2hvb2tzLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IHN0YXJ0ID0gc3BhbkNvbnRleHQ/LnRpbWVzdGFtcCB8fCBub3c7XG4gICAgc3BhbkNvbnRleHQ/LnBhdGhzPy5hZGQoe1xuICAgICAgcGF0aDogZGVjb3JhdGVkUGF0aCxcbiAgICAgIGVycm9yOiBlcnI/Lm5hbWUsXG4gICAgICBsYXRlbmN5OiBub3cgLSBzdGFydCxcbiAgICAgIHN0YXR1c1xuICAgIH0pO1xuICB9XG4gIHNwYW5NZXRhLnBhdGggPSBkZWNvcmF0ZWRQYXRoO1xufVxuZnVuY3Rpb24gZGVjb3JhdGVQYXRoV2l0aFN1YnR5cGUobWV0YWRhdGEpIHtcbiAgaWYgKCFtZXRhZGF0YS5wYXRoKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgY29uc3QgcGF0aENvbXBvbmVudHMgPSBtZXRhZGF0YS5wYXRoLnNwbGl0KFwifS97XCIpO1xuICBpZiAocGF0aENvbXBvbmVudHMubGVuZ3RoID09IDEpIHtcbiAgICByZXR1cm4gbWV0YWRhdGEucGF0aDtcbiAgfVxuICBjb25zdCBzdGVwU3VidHlwZSA9IG1ldGFkYXRhLm1ldGFkYXRhICYmIG1ldGFkYXRhLm1ldGFkYXRhW1wic3VidHlwZVwiXSA/IGAsczoke21ldGFkYXRhLm1ldGFkYXRhW1wic3VidHlwZVwiXX1gIDogXCJcIjtcbiAgY29uc3Qgcm9vdCA9IGAke3BhdGhDb21wb25lbnRzLnNsaWNlKDAsIC0xKS5qb2luKFwifS97XCIpfX0vYDtcbiAgY29uc3QgZGVjb3JhdGVkU3RlcCA9IGB7JHtwYXRoQ29tcG9uZW50cy5hdCgtMSk/LnNsaWNlKDAsIC0xKX0ke3N0ZXBTdWJ0eXBlfX1gO1xuICByZXR1cm4gcm9vdCArIGRlY29yYXRlZFN0ZXA7XG59XG5jb25zdCByb290U3BhbkRldGVjdGlvbktleSA9IFwiX19nZW5raXRfZGlzYWJsZVJvb3RTcGFuRGV0ZWN0aW9uXCI7XG5mdW5jdGlvbiBpc0Rpc2FibGVSb290U3BhbkRldGVjdGlvbigpIHtcbiAgcmV0dXJuIGdsb2JhbFtyb290U3BhbkRldGVjdGlvbktleV0gPT09IHRydWU7XG59XG5mdW5jdGlvbiBkaXNhYmxlT1RlbFJvb3RTcGFuRGV0ZWN0aW9uKCkge1xuICBnbG9iYWxbcm9vdFNwYW5EZXRlY3Rpb25LZXldID0gdHJ1ZTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBBVFRSX1BSRUZJWCxcbiAgU1BBTl9UWVBFX0FUVFIsXG4gIGFwcGVuZFNwYW4sXG4gIGRpc2FibGVPVGVsUm9vdFNwYW5EZXRlY3Rpb24sXG4gIHJ1bkluTmV3U3BhbixcbiAgc2V0Q3VzdG9tTWV0YWRhdGFBdHRyaWJ1dGUsXG4gIHNldEN1c3RvbU1ldGFkYXRhQXR0cmlidXRlcyxcbiAgc3Bhbk1ldGFkYXRhQWxzS2V5LFxuICB0b0Rpc3BsYXlQYXRoXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluc3RydW1lbnRhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/instrumentation.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/node-telemetry-provider.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/tracing/node-telemetry-provider.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar node_telemetry_provider_exports = {};\n__export(node_telemetry_provider_exports, {\n  initNodeTelemetryProvider: () => initNodeTelemetryProvider\n});\nmodule.exports = __toCommonJS(node_telemetry_provider_exports);\nvar import_sdk_node = __webpack_require__(/*! @opentelemetry/sdk-node */ \"(action-browser)/./node_modules/@opentelemetry/sdk-node/build/src/index.js\");\nvar import_sdk_trace_base = __webpack_require__(/*! @opentelemetry/sdk-trace-base */ \"(action-browser)/./node_modules/@opentelemetry/sdk-trace-base/build/esm/index.js\");\nvar import_logging = __webpack_require__(/*! ../logging.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/logging.js\");\nvar import_tracing = __webpack_require__(/*! ../tracing.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing.js\");\nvar import_utils = __webpack_require__(/*! ../utils.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/utils.js\");\nvar import_exporter = __webpack_require__(/*! ./exporter.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/exporter.js\");\nlet telemetrySDK = null;\nlet nodeOtelConfig = null;\nfunction initNodeTelemetryProvider() {\n  (0, import_tracing.setTelemetryProvider)({\n    enableTelemetry,\n    flushTracing\n  });\n}\nasync function enableTelemetry(telemetryConfig) {\n  if (process.env.GENKIT_TELEMETRY_SERVER) {\n    (0, import_exporter.setTelemetryServerUrl)(process.env.GENKIT_TELEMETRY_SERVER);\n  }\n  telemetryConfig = telemetryConfig instanceof Promise ? await telemetryConfig : telemetryConfig;\n  nodeOtelConfig = telemetryConfig || {};\n  const processors = [createTelemetryServerProcessor()];\n  if (nodeOtelConfig.traceExporter) {\n    throw new Error(\"Please specify spanProcessors instead.\");\n  }\n  if (nodeOtelConfig.spanProcessors) {\n    processors.push(...nodeOtelConfig.spanProcessors);\n  }\n  if (nodeOtelConfig.spanProcessor) {\n    processors.push(nodeOtelConfig.spanProcessor);\n    delete nodeOtelConfig.spanProcessor;\n  }\n  nodeOtelConfig.spanProcessors = processors;\n  telemetrySDK = new import_sdk_node.NodeSDK(nodeOtelConfig);\n  telemetrySDK.start();\n  process.on(\"SIGTERM\", async () => await cleanUpTracing());\n}\nasync function cleanUpTracing() {\n  if (!telemetrySDK) {\n    return;\n  }\n  await maybeFlushMetrics();\n  await telemetrySDK.shutdown();\n  import_logging.logger.debug(\"OpenTelemetry SDK shut down.\");\n  telemetrySDK = null;\n}\nfunction createTelemetryServerProcessor() {\n  const exporter = new import_exporter.TraceServerExporter();\n  return (0, import_utils.isDevEnv)() ? new import_sdk_trace_base.SimpleSpanProcessor(exporter) : new import_sdk_trace_base.BatchSpanProcessor(exporter);\n}\nfunction maybeFlushMetrics() {\n  if (nodeOtelConfig?.metricReader) {\n    return nodeOtelConfig.metricReader.forceFlush();\n  }\n  return Promise.resolve();\n}\nasync function flushTracing() {\n  if (nodeOtelConfig?.spanProcessors) {\n    await Promise.all(nodeOtelConfig.spanProcessors.map((p) => p.forceFlush()));\n  }\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=node-telemetry-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3RyYWNpbmcvbm9kZS10ZWxlbWV0cnktcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQywyR0FBeUI7QUFDdkQsNEJBQTRCLG1CQUFPLENBQUMsdUhBQStCO0FBQ25FLHFCQUFxQixtQkFBTyxDQUFDLHFGQUFlO0FBQzVDLHFCQUFxQixtQkFBTyxDQUFDLHFGQUFlO0FBQzVDLG1CQUFtQixtQkFBTyxDQUFDLGlGQUFhO0FBQ3hDLHNCQUFzQixtQkFBTyxDQUFDLDhGQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBRUw7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcY29yZVxcbGliXFx0cmFjaW5nXFxub2RlLXRlbGVtZXRyeS1wcm92aWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgbm9kZV90ZWxlbWV0cnlfcHJvdmlkZXJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobm9kZV90ZWxlbWV0cnlfcHJvdmlkZXJfZXhwb3J0cywge1xuICBpbml0Tm9kZVRlbGVtZXRyeVByb3ZpZGVyOiAoKSA9PiBpbml0Tm9kZVRlbGVtZXRyeVByb3ZpZGVyXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKG5vZGVfdGVsZW1ldHJ5X3Byb3ZpZGVyX2V4cG9ydHMpO1xudmFyIGltcG9ydF9zZGtfbm9kZSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9zZGstbm9kZVwiKTtcbnZhciBpbXBvcnRfc2RrX3RyYWNlX2Jhc2UgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2VcIik7XG52YXIgaW1wb3J0X2xvZ2dpbmcgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy5qc1wiKTtcbnZhciBpbXBvcnRfdHJhY2luZyA9IHJlcXVpcmUoXCIuLi90cmFjaW5nLmpzXCIpO1xudmFyIGltcG9ydF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy5qc1wiKTtcbnZhciBpbXBvcnRfZXhwb3J0ZXIgPSByZXF1aXJlKFwiLi9leHBvcnRlci5qc1wiKTtcbmxldCB0ZWxlbWV0cnlTREsgPSBudWxsO1xubGV0IG5vZGVPdGVsQ29uZmlnID0gbnVsbDtcbmZ1bmN0aW9uIGluaXROb2RlVGVsZW1ldHJ5UHJvdmlkZXIoKSB7XG4gICgwLCBpbXBvcnRfdHJhY2luZy5zZXRUZWxlbWV0cnlQcm92aWRlcikoe1xuICAgIGVuYWJsZVRlbGVtZXRyeSxcbiAgICBmbHVzaFRyYWNpbmdcbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBlbmFibGVUZWxlbWV0cnkodGVsZW1ldHJ5Q29uZmlnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5HRU5LSVRfVEVMRU1FVFJZX1NFUlZFUikge1xuICAgICgwLCBpbXBvcnRfZXhwb3J0ZXIuc2V0VGVsZW1ldHJ5U2VydmVyVXJsKShwcm9jZXNzLmVudi5HRU5LSVRfVEVMRU1FVFJZX1NFUlZFUik7XG4gIH1cbiAgdGVsZW1ldHJ5Q29uZmlnID0gdGVsZW1ldHJ5Q29uZmlnIGluc3RhbmNlb2YgUHJvbWlzZSA/IGF3YWl0IHRlbGVtZXRyeUNvbmZpZyA6IHRlbGVtZXRyeUNvbmZpZztcbiAgbm9kZU90ZWxDb25maWcgPSB0ZWxlbWV0cnlDb25maWcgfHwge307XG4gIGNvbnN0IHByb2Nlc3NvcnMgPSBbY3JlYXRlVGVsZW1ldHJ5U2VydmVyUHJvY2Vzc29yKCldO1xuICBpZiAobm9kZU90ZWxDb25maWcudHJhY2VFeHBvcnRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBzcGVjaWZ5IHNwYW5Qcm9jZXNzb3JzIGluc3RlYWQuXCIpO1xuICB9XG4gIGlmIChub2RlT3RlbENvbmZpZy5zcGFuUHJvY2Vzc29ycykge1xuICAgIHByb2Nlc3NvcnMucHVzaCguLi5ub2RlT3RlbENvbmZpZy5zcGFuUHJvY2Vzc29ycyk7XG4gIH1cbiAgaWYgKG5vZGVPdGVsQ29uZmlnLnNwYW5Qcm9jZXNzb3IpIHtcbiAgICBwcm9jZXNzb3JzLnB1c2gobm9kZU90ZWxDb25maWcuc3BhblByb2Nlc3Nvcik7XG4gICAgZGVsZXRlIG5vZGVPdGVsQ29uZmlnLnNwYW5Qcm9jZXNzb3I7XG4gIH1cbiAgbm9kZU90ZWxDb25maWcuc3BhblByb2Nlc3NvcnMgPSBwcm9jZXNzb3JzO1xuICB0ZWxlbWV0cnlTREsgPSBuZXcgaW1wb3J0X3Nka19ub2RlLk5vZGVTREsobm9kZU90ZWxDb25maWcpO1xuICB0ZWxlbWV0cnlTREsuc3RhcnQoKTtcbiAgcHJvY2Vzcy5vbihcIlNJR1RFUk1cIiwgYXN5bmMgKCkgPT4gYXdhaXQgY2xlYW5VcFRyYWNpbmcoKSk7XG59XG5hc3luYyBmdW5jdGlvbiBjbGVhblVwVHJhY2luZygpIHtcbiAgaWYgKCF0ZWxlbWV0cnlTREspIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYXdhaXQgbWF5YmVGbHVzaE1ldHJpY3MoKTtcbiAgYXdhaXQgdGVsZW1ldHJ5U0RLLnNodXRkb3duKCk7XG4gIGltcG9ydF9sb2dnaW5nLmxvZ2dlci5kZWJ1ZyhcIk9wZW5UZWxlbWV0cnkgU0RLIHNodXQgZG93bi5cIik7XG4gIHRlbGVtZXRyeVNESyA9IG51bGw7XG59XG5mdW5jdGlvbiBjcmVhdGVUZWxlbWV0cnlTZXJ2ZXJQcm9jZXNzb3IoKSB7XG4gIGNvbnN0IGV4cG9ydGVyID0gbmV3IGltcG9ydF9leHBvcnRlci5UcmFjZVNlcnZlckV4cG9ydGVyKCk7XG4gIHJldHVybiAoMCwgaW1wb3J0X3V0aWxzLmlzRGV2RW52KSgpID8gbmV3IGltcG9ydF9zZGtfdHJhY2VfYmFzZS5TaW1wbGVTcGFuUHJvY2Vzc29yKGV4cG9ydGVyKSA6IG5ldyBpbXBvcnRfc2RrX3RyYWNlX2Jhc2UuQmF0Y2hTcGFuUHJvY2Vzc29yKGV4cG9ydGVyKTtcbn1cbmZ1bmN0aW9uIG1heWJlRmx1c2hNZXRyaWNzKCkge1xuICBpZiAobm9kZU90ZWxDb25maWc/Lm1ldHJpY1JlYWRlcikge1xuICAgIHJldHVybiBub2RlT3RlbENvbmZpZy5tZXRyaWNSZWFkZXIuZm9yY2VGbHVzaCgpO1xuICB9XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZsdXNoVHJhY2luZygpIHtcbiAgaWYgKG5vZGVPdGVsQ29uZmlnPy5zcGFuUHJvY2Vzc29ycykge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKG5vZGVPdGVsQ29uZmlnLnNwYW5Qcm9jZXNzb3JzLm1hcCgocCkgPT4gcC5mb3JjZUZsdXNoKCkpKTtcbiAgfVxufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluaXROb2RlVGVsZW1ldHJ5UHJvdmlkZXJcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9kZS10ZWxlbWV0cnktcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/node-telemetry-provider.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/types.js":
/*!***********************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/tracing/types.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar types_exports = {};\n__export(types_exports, {\n  InstrumentationLibrarySchema: () => InstrumentationLibrarySchema,\n  LinkSchema: () => LinkSchema,\n  PathMetadataSchema: () => PathMetadataSchema,\n  SpanContextSchema: () => SpanContextSchema,\n  SpanDataSchema: () => SpanDataSchema,\n  SpanMetadataSchema: () => SpanMetadataSchema,\n  SpanStatusSchema: () => SpanStatusSchema,\n  TimeEventSchema: () => TimeEventSchema,\n  TraceDataSchema: () => TraceDataSchema,\n  TraceMetadataSchema: () => TraceMetadataSchema\n});\nmodule.exports = __toCommonJS(types_exports);\nvar import_zod = __webpack_require__(/*! zod */ \"(action-browser)/./node_modules/zod/lib/index.js\");\nconst PathMetadataSchema = import_zod.z.object({\n  path: import_zod.z.string(),\n  status: import_zod.z.string(),\n  error: import_zod.z.string().optional(),\n  latency: import_zod.z.number()\n});\nconst TraceMetadataSchema = import_zod.z.object({\n  featureName: import_zod.z.string().optional(),\n  paths: import_zod.z.set(PathMetadataSchema).optional(),\n  timestamp: import_zod.z.number()\n});\nconst SpanMetadataSchema = import_zod.z.object({\n  name: import_zod.z.string(),\n  state: import_zod.z.enum([\"success\", \"error\"]).optional(),\n  input: import_zod.z.any().optional(),\n  output: import_zod.z.any().optional(),\n  isRoot: import_zod.z.boolean().optional(),\n  metadata: import_zod.z.record(import_zod.z.string(), import_zod.z.string()).optional(),\n  path: import_zod.z.string().optional(),\n  // Indicates a \"leaf\" span that is the source of a failure.\n  isFailureSource: import_zod.z.boolean().optional()\n});\nconst SpanStatusSchema = import_zod.z.object({\n  code: import_zod.z.number(),\n  message: import_zod.z.string().optional()\n});\nconst TimeEventSchema = import_zod.z.object({\n  time: import_zod.z.number(),\n  annotation: import_zod.z.object({\n    attributes: import_zod.z.record(import_zod.z.string(), import_zod.z.any()),\n    description: import_zod.z.string()\n  })\n});\nconst SpanContextSchema = import_zod.z.object({\n  traceId: import_zod.z.string(),\n  spanId: import_zod.z.string(),\n  isRemote: import_zod.z.boolean().optional(),\n  traceFlags: import_zod.z.number()\n});\nconst LinkSchema = import_zod.z.object({\n  context: SpanContextSchema.optional(),\n  attributes: import_zod.z.record(import_zod.z.string(), import_zod.z.any()).optional(),\n  droppedAttributesCount: import_zod.z.number().optional()\n});\nconst InstrumentationLibrarySchema = import_zod.z.object({\n  name: import_zod.z.string().readonly(),\n  version: import_zod.z.string().optional().readonly(),\n  schemaUrl: import_zod.z.string().optional().readonly()\n});\nconst SpanDataSchema = import_zod.z.object({\n  spanId: import_zod.z.string(),\n  traceId: import_zod.z.string(),\n  parentSpanId: import_zod.z.string().optional(),\n  startTime: import_zod.z.number(),\n  endTime: import_zod.z.number(),\n  attributes: import_zod.z.record(import_zod.z.string(), import_zod.z.any()),\n  displayName: import_zod.z.string(),\n  links: import_zod.z.array(LinkSchema).optional(),\n  instrumentationLibrary: InstrumentationLibrarySchema,\n  spanKind: import_zod.z.string(),\n  sameProcessAsParentSpan: import_zod.z.object({ value: import_zod.z.boolean() }).optional(),\n  status: SpanStatusSchema.optional(),\n  timeEvents: import_zod.z.object({\n    timeEvent: import_zod.z.array(TimeEventSchema)\n  }).optional(),\n  truncated: import_zod.z.boolean().optional()\n});\nconst TraceDataSchema = import_zod.z.object({\n  traceId: import_zod.z.string(),\n  displayName: import_zod.z.string().optional(),\n  startTime: import_zod.z.number().optional().describe(\"trace start time in milliseconds since the epoch\"),\n  endTime: import_zod.z.number().optional().describe(\"end time in milliseconds since the epoch\"),\n  spans: import_zod.z.record(import_zod.z.string(), SpanDataSchema)\n});\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3RyYWNpbmcvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyw2REFBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsK0JBQStCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxNQUFNLENBV0w7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcY29yZVxcbGliXFx0cmFjaW5nXFx0eXBlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgdHlwZXNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodHlwZXNfZXhwb3J0cywge1xuICBJbnN0cnVtZW50YXRpb25MaWJyYXJ5U2NoZW1hOiAoKSA9PiBJbnN0cnVtZW50YXRpb25MaWJyYXJ5U2NoZW1hLFxuICBMaW5rU2NoZW1hOiAoKSA9PiBMaW5rU2NoZW1hLFxuICBQYXRoTWV0YWRhdGFTY2hlbWE6ICgpID0+IFBhdGhNZXRhZGF0YVNjaGVtYSxcbiAgU3BhbkNvbnRleHRTY2hlbWE6ICgpID0+IFNwYW5Db250ZXh0U2NoZW1hLFxuICBTcGFuRGF0YVNjaGVtYTogKCkgPT4gU3BhbkRhdGFTY2hlbWEsXG4gIFNwYW5NZXRhZGF0YVNjaGVtYTogKCkgPT4gU3Bhbk1ldGFkYXRhU2NoZW1hLFxuICBTcGFuU3RhdHVzU2NoZW1hOiAoKSA9PiBTcGFuU3RhdHVzU2NoZW1hLFxuICBUaW1lRXZlbnRTY2hlbWE6ICgpID0+IFRpbWVFdmVudFNjaGVtYSxcbiAgVHJhY2VEYXRhU2NoZW1hOiAoKSA9PiBUcmFjZURhdGFTY2hlbWEsXG4gIFRyYWNlTWV0YWRhdGFTY2hlbWE6ICgpID0+IFRyYWNlTWV0YWRhdGFTY2hlbWFcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlModHlwZXNfZXhwb3J0cyk7XG52YXIgaW1wb3J0X3pvZCA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBQYXRoTWV0YWRhdGFTY2hlbWEgPSBpbXBvcnRfem9kLnoub2JqZWN0KHtcbiAgcGF0aDogaW1wb3J0X3pvZC56LnN0cmluZygpLFxuICBzdGF0dXM6IGltcG9ydF96b2Quei5zdHJpbmcoKSxcbiAgZXJyb3I6IGltcG9ydF96b2Quei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBsYXRlbmN5OiBpbXBvcnRfem9kLnoubnVtYmVyKClcbn0pO1xuY29uc3QgVHJhY2VNZXRhZGF0YVNjaGVtYSA9IGltcG9ydF96b2Quei5vYmplY3Qoe1xuICBmZWF0dXJlTmFtZTogaW1wb3J0X3pvZC56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIHBhdGhzOiBpbXBvcnRfem9kLnouc2V0KFBhdGhNZXRhZGF0YVNjaGVtYSkub3B0aW9uYWwoKSxcbiAgdGltZXN0YW1wOiBpbXBvcnRfem9kLnoubnVtYmVyKClcbn0pO1xuY29uc3QgU3Bhbk1ldGFkYXRhU2NoZW1hID0gaW1wb3J0X3pvZC56Lm9iamVjdCh7XG4gIG5hbWU6IGltcG9ydF96b2Quei5zdHJpbmcoKSxcbiAgc3RhdGU6IGltcG9ydF96b2Quei5lbnVtKFtcInN1Y2Nlc3NcIiwgXCJlcnJvclwiXSkub3B0aW9uYWwoKSxcbiAgaW5wdXQ6IGltcG9ydF96b2Quei5hbnkoKS5vcHRpb25hbCgpLFxuICBvdXRwdXQ6IGltcG9ydF96b2Quei5hbnkoKS5vcHRpb25hbCgpLFxuICBpc1Jvb3Q6IGltcG9ydF96b2Quei5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgbWV0YWRhdGE6IGltcG9ydF96b2Quei5yZWNvcmQoaW1wb3J0X3pvZC56LnN0cmluZygpLCBpbXBvcnRfem9kLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gIHBhdGg6IGltcG9ydF96b2Quei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAvLyBJbmRpY2F0ZXMgYSBcImxlYWZcIiBzcGFuIHRoYXQgaXMgdGhlIHNvdXJjZSBvZiBhIGZhaWx1cmUuXG4gIGlzRmFpbHVyZVNvdXJjZTogaW1wb3J0X3pvZC56LmJvb2xlYW4oKS5vcHRpb25hbCgpXG59KTtcbmNvbnN0IFNwYW5TdGF0dXNTY2hlbWEgPSBpbXBvcnRfem9kLnoub2JqZWN0KHtcbiAgY29kZTogaW1wb3J0X3pvZC56Lm51bWJlcigpLFxuICBtZXNzYWdlOiBpbXBvcnRfem9kLnouc3RyaW5nKCkub3B0aW9uYWwoKVxufSk7XG5jb25zdCBUaW1lRXZlbnRTY2hlbWEgPSBpbXBvcnRfem9kLnoub2JqZWN0KHtcbiAgdGltZTogaW1wb3J0X3pvZC56Lm51bWJlcigpLFxuICBhbm5vdGF0aW9uOiBpbXBvcnRfem9kLnoub2JqZWN0KHtcbiAgICBhdHRyaWJ1dGVzOiBpbXBvcnRfem9kLnoucmVjb3JkKGltcG9ydF96b2Quei5zdHJpbmcoKSwgaW1wb3J0X3pvZC56LmFueSgpKSxcbiAgICBkZXNjcmlwdGlvbjogaW1wb3J0X3pvZC56LnN0cmluZygpXG4gIH0pXG59KTtcbmNvbnN0IFNwYW5Db250ZXh0U2NoZW1hID0gaW1wb3J0X3pvZC56Lm9iamVjdCh7XG4gIHRyYWNlSWQ6IGltcG9ydF96b2Quei5zdHJpbmcoKSxcbiAgc3BhbklkOiBpbXBvcnRfem9kLnouc3RyaW5nKCksXG4gIGlzUmVtb3RlOiBpbXBvcnRfem9kLnouYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gIHRyYWNlRmxhZ3M6IGltcG9ydF96b2Quei5udW1iZXIoKVxufSk7XG5jb25zdCBMaW5rU2NoZW1hID0gaW1wb3J0X3pvZC56Lm9iamVjdCh7XG4gIGNvbnRleHQ6IFNwYW5Db250ZXh0U2NoZW1hLm9wdGlvbmFsKCksXG4gIGF0dHJpYnV0ZXM6IGltcG9ydF96b2Quei5yZWNvcmQoaW1wb3J0X3pvZC56LnN0cmluZygpLCBpbXBvcnRfem9kLnouYW55KCkpLm9wdGlvbmFsKCksXG4gIGRyb3BwZWRBdHRyaWJ1dGVzQ291bnQ6IGltcG9ydF96b2Quei5udW1iZXIoKS5vcHRpb25hbCgpXG59KTtcbmNvbnN0IEluc3RydW1lbnRhdGlvbkxpYnJhcnlTY2hlbWEgPSBpbXBvcnRfem9kLnoub2JqZWN0KHtcbiAgbmFtZTogaW1wb3J0X3pvZC56LnN0cmluZygpLnJlYWRvbmx5KCksXG4gIHZlcnNpb246IGltcG9ydF96b2Quei5zdHJpbmcoKS5vcHRpb25hbCgpLnJlYWRvbmx5KCksXG4gIHNjaGVtYVVybDogaW1wb3J0X3pvZC56LnN0cmluZygpLm9wdGlvbmFsKCkucmVhZG9ubHkoKVxufSk7XG5jb25zdCBTcGFuRGF0YVNjaGVtYSA9IGltcG9ydF96b2Quei5vYmplY3Qoe1xuICBzcGFuSWQ6IGltcG9ydF96b2Quei5zdHJpbmcoKSxcbiAgdHJhY2VJZDogaW1wb3J0X3pvZC56LnN0cmluZygpLFxuICBwYXJlbnRTcGFuSWQ6IGltcG9ydF96b2Quei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBzdGFydFRpbWU6IGltcG9ydF96b2Quei5udW1iZXIoKSxcbiAgZW5kVGltZTogaW1wb3J0X3pvZC56Lm51bWJlcigpLFxuICBhdHRyaWJ1dGVzOiBpbXBvcnRfem9kLnoucmVjb3JkKGltcG9ydF96b2Quei5zdHJpbmcoKSwgaW1wb3J0X3pvZC56LmFueSgpKSxcbiAgZGlzcGxheU5hbWU6IGltcG9ydF96b2Quei5zdHJpbmcoKSxcbiAgbGlua3M6IGltcG9ydF96b2Quei5hcnJheShMaW5rU2NoZW1hKS5vcHRpb25hbCgpLFxuICBpbnN0cnVtZW50YXRpb25MaWJyYXJ5OiBJbnN0cnVtZW50YXRpb25MaWJyYXJ5U2NoZW1hLFxuICBzcGFuS2luZDogaW1wb3J0X3pvZC56LnN0cmluZygpLFxuICBzYW1lUHJvY2Vzc0FzUGFyZW50U3BhbjogaW1wb3J0X3pvZC56Lm9iamVjdCh7IHZhbHVlOiBpbXBvcnRfem9kLnouYm9vbGVhbigpIH0pLm9wdGlvbmFsKCksXG4gIHN0YXR1czogU3BhblN0YXR1c1NjaGVtYS5vcHRpb25hbCgpLFxuICB0aW1lRXZlbnRzOiBpbXBvcnRfem9kLnoub2JqZWN0KHtcbiAgICB0aW1lRXZlbnQ6IGltcG9ydF96b2Quei5hcnJheShUaW1lRXZlbnRTY2hlbWEpXG4gIH0pLm9wdGlvbmFsKCksXG4gIHRydW5jYXRlZDogaW1wb3J0X3pvZC56LmJvb2xlYW4oKS5vcHRpb25hbCgpXG59KTtcbmNvbnN0IFRyYWNlRGF0YVNjaGVtYSA9IGltcG9ydF96b2Quei5vYmplY3Qoe1xuICB0cmFjZUlkOiBpbXBvcnRfem9kLnouc3RyaW5nKCksXG4gIGRpc3BsYXlOYW1lOiBpbXBvcnRfem9kLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgc3RhcnRUaW1lOiBpbXBvcnRfem9kLnoubnVtYmVyKCkub3B0aW9uYWwoKS5kZXNjcmliZShcInRyYWNlIHN0YXJ0IHRpbWUgaW4gbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBlcG9jaFwiKSxcbiAgZW5kVGltZTogaW1wb3J0X3pvZC56Lm51bWJlcigpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJlbmQgdGltZSBpbiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGVwb2NoXCIpLFxuICBzcGFuczogaW1wb3J0X3pvZC56LnJlY29yZChpbXBvcnRfem9kLnouc3RyaW5nKCksIFNwYW5EYXRhU2NoZW1hKVxufSk7XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgSW5zdHJ1bWVudGF0aW9uTGlicmFyeVNjaGVtYSxcbiAgTGlua1NjaGVtYSxcbiAgUGF0aE1ldGFkYXRhU2NoZW1hLFxuICBTcGFuQ29udGV4dFNjaGVtYSxcbiAgU3BhbkRhdGFTY2hlbWEsXG4gIFNwYW5NZXRhZGF0YVNjaGVtYSxcbiAgU3BhblN0YXR1c1NjaGVtYSxcbiAgVGltZUV2ZW50U2NoZW1hLFxuICBUcmFjZURhdGFTY2hlbWEsXG4gIFRyYWNlTWV0YWRhdGFTY2hlbWFcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/types.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/utils.js":
/*!***************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/utils.js ***!
  \***************************************************/
/***/ ((module) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar utils_exports = {};\n__export(utils_exports, {\n  deleteUndefinedProps: () => deleteUndefinedProps,\n  featureMetadataPrefix: () => featureMetadataPrefix,\n  getCurrentEnv: () => getCurrentEnv,\n  isDevEnv: () => isDevEnv,\n  stripUndefinedProps: () => stripUndefinedProps\n});\nmodule.exports = __toCommonJS(utils_exports);\nfunction deleteUndefinedProps(obj) {\n  for (const prop in obj) {\n    if (obj[prop] === void 0) {\n      delete obj[prop];\n    } else {\n      if (typeof obj[prop] === \"object\") {\n        deleteUndefinedProps(obj[prop]);\n      }\n    }\n  }\n}\nfunction stripUndefinedProps(input) {\n  if (input === void 0 || input === null || Array.isArray(input) || typeof input !== \"object\") {\n    return input;\n  }\n  const out = {};\n  for (const key in input) {\n    if (input[key] !== void 0) {\n      out[key] = stripUndefinedProps(input[key]);\n    }\n  }\n  return out;\n}\nfunction getCurrentEnv() {\n  return process.env.GENKIT_ENV || \"prod\";\n}\nfunction isDevEnv() {\n  return getCurrentEnv() === \"dev\";\n}\nfunction featureMetadataPrefix(name) {\n  return `feature:${name}`;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCO0FBQ0E7QUFDQSxNQUFNLENBTUw7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcY29yZVxcbGliXFx1dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgdXRpbHNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodXRpbHNfZXhwb3J0cywge1xuICBkZWxldGVVbmRlZmluZWRQcm9wczogKCkgPT4gZGVsZXRlVW5kZWZpbmVkUHJvcHMsXG4gIGZlYXR1cmVNZXRhZGF0YVByZWZpeDogKCkgPT4gZmVhdHVyZU1ldGFkYXRhUHJlZml4LFxuICBnZXRDdXJyZW50RW52OiAoKSA9PiBnZXRDdXJyZW50RW52LFxuICBpc0RldkVudjogKCkgPT4gaXNEZXZFbnYsXG4gIHN0cmlwVW5kZWZpbmVkUHJvcHM6ICgpID0+IHN0cmlwVW5kZWZpbmVkUHJvcHNcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlModXRpbHNfZXhwb3J0cyk7XG5mdW5jdGlvbiBkZWxldGVVbmRlZmluZWRQcm9wcyhvYmopIHtcbiAgZm9yIChjb25zdCBwcm9wIGluIG9iaikge1xuICAgIGlmIChvYmpbcHJvcF0gPT09IHZvaWQgMCkge1xuICAgICAgZGVsZXRlIG9ialtwcm9wXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBvYmpbcHJvcF0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZGVsZXRlVW5kZWZpbmVkUHJvcHMob2JqW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHN0cmlwVW5kZWZpbmVkUHJvcHMoaW5wdXQpIHtcbiAgaWYgKGlucHV0ID09PSB2b2lkIDAgfHwgaW5wdXQgPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheShpbnB1dCkgfHwgdHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIGNvbnN0IG91dCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBpbnB1dCkge1xuICAgIGlmIChpbnB1dFtrZXldICE9PSB2b2lkIDApIHtcbiAgICAgIG91dFtrZXldID0gc3RyaXBVbmRlZmluZWRQcm9wcyhpbnB1dFtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRFbnYoKSB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5HRU5LSVRfRU5WIHx8IFwicHJvZFwiO1xufVxuZnVuY3Rpb24gaXNEZXZFbnYoKSB7XG4gIHJldHVybiBnZXRDdXJyZW50RW52KCkgPT09IFwiZGV2XCI7XG59XG5mdW5jdGlvbiBmZWF0dXJlTWV0YWRhdGFQcmVmaXgobmFtZSkge1xuICByZXR1cm4gYGZlYXR1cmU6JHtuYW1lfWA7XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVsZXRlVW5kZWZpbmVkUHJvcHMsXG4gIGZlYXR1cmVNZXRhZGF0YVByZWZpeCxcbiAgZ2V0Q3VycmVudEVudixcbiAgaXNEZXZFbnYsXG4gIHN0cmlwVW5kZWZpbmVkUHJvcHNcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/utils.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/google-genai/lib/common/converters.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@genkit-ai/google-genai/lib/common/converters.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar converters_exports = {};\n__export(converters_exports, {\n  fromGeminiCandidate: () => fromGeminiCandidate,\n  toGeminiFunctionModeEnum: () => toGeminiFunctionModeEnum,\n  toGeminiMessage: () => toGeminiMessage,\n  toGeminiSystemInstruction: () => toGeminiSystemInstruction,\n  toGeminiTool: () => toGeminiTool\n});\nmodule.exports = __toCommonJS(converters_exports);\nvar import_genkit = __webpack_require__(/*! genkit */ \"(action-browser)/./node_modules/genkit/lib/index.js\");\nvar import_types = __webpack_require__(/*! ./types.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/common/types.js\");\nfunction toGeminiTool(tool) {\n  const declaration = {\n    name: tool.name.replace(/\\//g, \"__\"),\n    // Gemini throws on '/' in tool name\n    description: tool.description,\n    parameters: toGeminiSchemaProperty(tool.inputSchema)\n  };\n  return declaration;\n}\nfunction toGeminiSchemaProperty(property) {\n  if (!property || !property.type) {\n    return void 0;\n  }\n  const baseSchema = {};\n  if (property.description) {\n    baseSchema.description = property.description;\n  }\n  if (property.enum) {\n    baseSchema.enum = property.enum;\n  }\n  if (property.nullable) {\n    baseSchema.nullable = property.nullable;\n  }\n  let propertyType;\n  if (Array.isArray(property.type)) {\n    const types = property.type;\n    if (types.includes(\"null\")) {\n      baseSchema.nullable = true;\n    }\n    propertyType = types.find((t) => t !== \"null\");\n  } else {\n    propertyType = property.type;\n  }\n  if (propertyType === \"object\") {\n    const nestedProperties = {};\n    Object.keys(property.properties).forEach((key) => {\n      nestedProperties[key] = toGeminiSchemaProperty(property.properties[key]);\n    });\n    return {\n      ...baseSchema,\n      type: import_types.SchemaType.OBJECT,\n      properties: nestedProperties,\n      required: property.required\n    };\n  } else if (propertyType === \"array\") {\n    return {\n      ...baseSchema,\n      type: import_types.SchemaType.ARRAY,\n      items: toGeminiSchemaProperty(property.items)\n    };\n  } else {\n    const schemaType = import_types.SchemaType[propertyType.toUpperCase()];\n    if (!schemaType) {\n      throw new import_genkit.GenkitError({\n        status: \"INVALID_ARGUMENT\",\n        message: `Unsupported property type ${propertyType.toUpperCase()}`\n      });\n    }\n    return {\n      ...baseSchema,\n      type: schemaType\n    };\n  }\n}\nfunction toGeminiMedia(part) {\n  if (part.media?.url.startsWith(\"data:\")) {\n    const dataUrl = part.media.url;\n    const b64Data = dataUrl.substring(dataUrl.indexOf(\",\") + 1);\n    const contentType = part.media.contentType || dataUrl.substring(dataUrl.indexOf(\":\") + 1, dataUrl.indexOf(\";\"));\n    return { inlineData: { mimeType: contentType, data: b64Data } };\n  }\n  if (!part.media?.contentType) {\n    throw Error(\n      \"Must supply a `contentType` when sending File URIs to Gemini.\"\n    );\n  }\n  return {\n    fileData: {\n      mimeType: part.media.contentType,\n      fileUri: part.media.url\n    }\n  };\n}\nfunction toGeminiToolRequest(part) {\n  if (!part.toolRequest?.input) {\n    throw Error(\"Invalid ToolRequestPart: input was missing.\");\n  }\n  return {\n    functionCall: {\n      name: part.toolRequest.name,\n      args: part.toolRequest.input\n    }\n  };\n}\nfunction toGeminiToolResponse(part) {\n  if (!part.toolResponse?.output) {\n    throw Error(\"Invalid ToolResponsePart: output was missing.\");\n  }\n  return {\n    functionResponse: {\n      name: part.toolResponse.name,\n      response: {\n        name: part.toolResponse.name,\n        content: part.toolResponse.output\n      }\n    }\n  };\n}\nfunction toGeminiReasoning(part) {\n  const out = { thought: true };\n  if (typeof part.metadata?.thoughtSignature === \"string\") {\n    out.thoughtSignature = part.metadata.thoughtSignature;\n  }\n  if (part.reasoning?.length) {\n    out.text = part.reasoning;\n  }\n  return out;\n}\nfunction toGeminiCustom(part) {\n  if (part.custom?.codeExecutionResult) {\n    return {\n      codeExecutionResult: part.custom.codeExecutionResult\n    };\n  }\n  if (part.custom?.executableCode) {\n    return {\n      executableCode: part.custom.executableCode\n    };\n  }\n  throw new Error(\"Unsupported Custom Part type\");\n}\nfunction toGeminiPart(part) {\n  if (part.text) {\n    return { text: part.text };\n  }\n  if (part.media) {\n    return toGeminiMedia(part);\n  }\n  if (part.toolRequest) {\n    return toGeminiToolRequest(part);\n  }\n  if (part.toolResponse) {\n    return toGeminiToolResponse(part);\n  }\n  if (typeof part.reasoning === \"string\") {\n    return toGeminiReasoning(part);\n  }\n  if (part.custom) {\n    return toGeminiCustom(part);\n  }\n  throw new Error(\"Unsupported Part type \" + JSON.stringify(part));\n}\nfunction toGeminiRole(role, model) {\n  switch (role) {\n    case \"user\":\n      return \"user\";\n    case \"model\":\n      return \"model\";\n    case \"system\":\n      if (model?.info?.supports?.systemRole) {\n        throw new Error(\n          \"system role is only supported for a single message in the first position\"\n        );\n      } else {\n        throw new Error(\"system role is not supported\");\n      }\n    case \"tool\":\n      return \"function\";\n    default:\n      return \"user\";\n  }\n}\nfunction toGeminiMessage(message, model) {\n  let sortedParts = message.content;\n  if (message.role === \"tool\") {\n    sortedParts = [...message.content].sort((a, b) => {\n      const aRef = a.toolResponse?.ref;\n      const bRef = b.toolResponse?.ref;\n      if (!aRef && !bRef) return 0;\n      if (!aRef) return 1;\n      if (!bRef) return -1;\n      return parseInt(aRef, 10) - parseInt(bRef, 10);\n    });\n  }\n  return {\n    role: toGeminiRole(message.role, model),\n    parts: sortedParts.map(toGeminiPart)\n  };\n}\nfunction toGeminiSystemInstruction(message) {\n  return {\n    role: \"user\",\n    parts: message.content.map(toGeminiPart)\n  };\n}\nfunction toGeminiFunctionModeEnum(from) {\n  if (from === void 0) {\n    return void 0;\n  }\n  switch (from) {\n    case \"MODE_UNSPECIFIED\": {\n      return import_types.FunctionCallingMode.MODE_UNSPECIFIED;\n    }\n    case \"required\":\n    case \"ANY\": {\n      return import_types.FunctionCallingMode.ANY;\n    }\n    case \"auto\":\n    case \"AUTO\": {\n      return import_types.FunctionCallingMode.AUTO;\n    }\n    case \"none\":\n    case \"NONE\": {\n      return import_types.FunctionCallingMode.NONE;\n    }\n    default:\n      throw new Error(`unsupported function calling mode: ${from}`);\n  }\n}\nfunction fromGeminiFinishReason(reason) {\n  if (!reason) return \"unknown\";\n  switch (reason) {\n    case \"STOP\":\n      return \"stop\";\n    case \"MAX_TOKENS\":\n      return \"length\";\n    case \"SAFETY\":\n    // blocked for safety\n    case \"RECITATION\":\n    // blocked for reciting training data\n    case \"LANGUAGE\":\n    // blocked for using an unsupported language\n    case \"BLOCKLIST\":\n    // blocked for forbidden terms\n    case \"PROHIBITED_CONTENT\":\n    // blocked for potentially containing prohibited content\n    case \"SPII\":\n      return \"blocked\";\n    case \"MALFORMED_FUNCTION_CALL\":\n    case \"OTHER\":\n      return \"other\";\n    default:\n      return \"unknown\";\n  }\n}\nfunction fromGeminiThought(part) {\n  return {\n    reasoning: part.text || \"\",\n    metadata: { thoughtSignature: part.thoughtSignature }\n  };\n}\nfunction fromGeminiInlineData(part) {\n  if (!part.inlineData || !part.inlineData.hasOwnProperty(\"mimeType\") || !part.inlineData.hasOwnProperty(\"data\")) {\n    throw new Error(\"Invalid GeminiPart: missing required properties\");\n  }\n  const { mimeType, data } = part.inlineData;\n  const dataUrl = `data:${mimeType};base64,${data}`;\n  return {\n    media: {\n      url: dataUrl,\n      contentType: mimeType\n    }\n  };\n}\nfunction fromGeminiFileData(part) {\n  if (!part.fileData || !part.fileData.hasOwnProperty(\"mimeType\") || !part.fileData.hasOwnProperty(\"fileUri\")) {\n    throw new Error(\n      \"Invalid Gemini File Data Part: missing required properties\"\n    );\n  }\n  return {\n    media: {\n      url: part.fileData?.fileUri,\n      contentType: part.fileData?.mimeType\n    }\n  };\n}\nfunction fromGeminiFunctionCall(part, ref) {\n  if (!part.functionCall) {\n    throw Error(\n      \"Invalid Gemini Function Call Part: missing function call data\"\n    );\n  }\n  return {\n    toolRequest: {\n      name: part.functionCall.name,\n      input: part.functionCall.args,\n      ref\n    }\n  };\n}\nfunction fromGeminiFunctionResponse(part, ref) {\n  if (!part.functionResponse) {\n    throw new Error(\n      \"Invalid Gemini Function Call Part: missing function call data\"\n    );\n  }\n  return {\n    toolResponse: {\n      name: part.functionResponse.name.replace(/__/g, \"/\"),\n      // restore slashes\n      output: part.functionResponse.response,\n      ref\n    }\n  };\n}\nfunction fromExecutableCode(part) {\n  if (!part.executableCode) {\n    throw new Error(\"Invalid GeminiPart: missing executableCode\");\n  }\n  return {\n    custom: {\n      executableCode: {\n        language: part.executableCode.language,\n        code: part.executableCode.code\n      }\n    }\n  };\n}\nfunction fromCodeExecutionResult(part) {\n  if (!part.codeExecutionResult) {\n    throw new Error(\"Invalid GeminiPart: missing codeExecutionResult\");\n  }\n  return {\n    custom: {\n      codeExecutionResult: {\n        outcome: part.codeExecutionResult.outcome,\n        output: part.codeExecutionResult.output\n      }\n    }\n  };\n}\nfunction fromGeminiPart(part, ref) {\n  if (part.thought) return fromGeminiThought(part);\n  if (typeof part.text === \"string\") return { text: part.text };\n  if (part.inlineData) return fromGeminiInlineData(part);\n  if (part.fileData) return fromGeminiFileData(part);\n  if (part.functionCall) return fromGeminiFunctionCall(part, ref);\n  if (part.functionResponse) return fromGeminiFunctionResponse(part, ref);\n  if (part.executableCode) return fromExecutableCode(part);\n  if (part.codeExecutionResult) return fromCodeExecutionResult(part);\n  throw new Error(\"Unsupported GeminiPart type \" + JSON.stringify(part));\n}\nfunction fromGeminiCandidate(candidate) {\n  const parts = candidate.content?.parts || [];\n  const genkitCandidate = {\n    index: candidate.index || 0,\n    message: {\n      role: \"model\",\n      content: parts.filter((p) => Object.keys(p).length > 0).map((part, index) => fromGeminiPart(part, index.toString()))\n    },\n    finishReason: fromGeminiFinishReason(candidate.finishReason),\n    finishMessage: candidate.finishMessage,\n    custom: {\n      safetyRatings: candidate.safetyRatings,\n      citationMetadata: candidate.citationMetadata\n    }\n  };\n  return genkitCandidate;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=converters.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2dvb2dsZS1nZW5haS9saWIvY29tbW9uL2NvbnZlcnRlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLG1FQUFRO0FBQ3BDLG1CQUFtQixtQkFBTyxDQUFDLCtGQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMkJBQTJCO0FBQ3pFLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0hBQWdIO0FBQ2hILGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsS0FBSztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQiwwQkFBMEIsVUFBVSxTQUFTLEtBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBTUw7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcZ29vZ2xlLWdlbmFpXFxsaWJcXGNvbW1vblxcY29udmVydGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgY29udmVydGVyc19leHBvcnRzID0ge307XG5fX2V4cG9ydChjb252ZXJ0ZXJzX2V4cG9ydHMsIHtcbiAgZnJvbUdlbWluaUNhbmRpZGF0ZTogKCkgPT4gZnJvbUdlbWluaUNhbmRpZGF0ZSxcbiAgdG9HZW1pbmlGdW5jdGlvbk1vZGVFbnVtOiAoKSA9PiB0b0dlbWluaUZ1bmN0aW9uTW9kZUVudW0sXG4gIHRvR2VtaW5pTWVzc2FnZTogKCkgPT4gdG9HZW1pbmlNZXNzYWdlLFxuICB0b0dlbWluaVN5c3RlbUluc3RydWN0aW9uOiAoKSA9PiB0b0dlbWluaVN5c3RlbUluc3RydWN0aW9uLFxuICB0b0dlbWluaVRvb2w6ICgpID0+IHRvR2VtaW5pVG9vbFxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhjb252ZXJ0ZXJzX2V4cG9ydHMpO1xudmFyIGltcG9ydF9nZW5raXQgPSByZXF1aXJlKFwiZ2Vua2l0XCIpO1xudmFyIGltcG9ydF90eXBlcyA9IHJlcXVpcmUoXCIuL3R5cGVzLmpzXCIpO1xuZnVuY3Rpb24gdG9HZW1pbmlUb29sKHRvb2wpIHtcbiAgY29uc3QgZGVjbGFyYXRpb24gPSB7XG4gICAgbmFtZTogdG9vbC5uYW1lLnJlcGxhY2UoL1xcLy9nLCBcIl9fXCIpLFxuICAgIC8vIEdlbWluaSB0aHJvd3Mgb24gJy8nIGluIHRvb2wgbmFtZVxuICAgIGRlc2NyaXB0aW9uOiB0b29sLmRlc2NyaXB0aW9uLFxuICAgIHBhcmFtZXRlcnM6IHRvR2VtaW5pU2NoZW1hUHJvcGVydHkodG9vbC5pbnB1dFNjaGVtYSlcbiAgfTtcbiAgcmV0dXJuIGRlY2xhcmF0aW9uO1xufVxuZnVuY3Rpb24gdG9HZW1pbmlTY2hlbWFQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICBpZiAoIXByb3BlcnR5IHx8ICFwcm9wZXJ0eS50eXBlKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCBiYXNlU2NoZW1hID0ge307XG4gIGlmIChwcm9wZXJ0eS5kZXNjcmlwdGlvbikge1xuICAgIGJhc2VTY2hlbWEuZGVzY3JpcHRpb24gPSBwcm9wZXJ0eS5kZXNjcmlwdGlvbjtcbiAgfVxuICBpZiAocHJvcGVydHkuZW51bSkge1xuICAgIGJhc2VTY2hlbWEuZW51bSA9IHByb3BlcnR5LmVudW07XG4gIH1cbiAgaWYgKHByb3BlcnR5Lm51bGxhYmxlKSB7XG4gICAgYmFzZVNjaGVtYS5udWxsYWJsZSA9IHByb3BlcnR5Lm51bGxhYmxlO1xuICB9XG4gIGxldCBwcm9wZXJ0eVR5cGU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BlcnR5LnR5cGUpKSB7XG4gICAgY29uc3QgdHlwZXMgPSBwcm9wZXJ0eS50eXBlO1xuICAgIGlmICh0eXBlcy5pbmNsdWRlcyhcIm51bGxcIikpIHtcbiAgICAgIGJhc2VTY2hlbWEubnVsbGFibGUgPSB0cnVlO1xuICAgIH1cbiAgICBwcm9wZXJ0eVR5cGUgPSB0eXBlcy5maW5kKCh0KSA9PiB0ICE9PSBcIm51bGxcIik7XG4gIH0gZWxzZSB7XG4gICAgcHJvcGVydHlUeXBlID0gcHJvcGVydHkudHlwZTtcbiAgfVxuICBpZiAocHJvcGVydHlUeXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29uc3QgbmVzdGVkUHJvcGVydGllcyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKHByb3BlcnR5LnByb3BlcnRpZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgbmVzdGVkUHJvcGVydGllc1trZXldID0gdG9HZW1pbmlTY2hlbWFQcm9wZXJ0eShwcm9wZXJ0eS5wcm9wZXJ0aWVzW2tleV0pO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5iYXNlU2NoZW1hLFxuICAgICAgdHlwZTogaW1wb3J0X3R5cGVzLlNjaGVtYVR5cGUuT0JKRUNULFxuICAgICAgcHJvcGVydGllczogbmVzdGVkUHJvcGVydGllcyxcbiAgICAgIHJlcXVpcmVkOiBwcm9wZXJ0eS5yZXF1aXJlZFxuICAgIH07XG4gIH0gZWxzZSBpZiAocHJvcGVydHlUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uYmFzZVNjaGVtYSxcbiAgICAgIHR5cGU6IGltcG9ydF90eXBlcy5TY2hlbWFUeXBlLkFSUkFZLFxuICAgICAgaXRlbXM6IHRvR2VtaW5pU2NoZW1hUHJvcGVydHkocHJvcGVydHkuaXRlbXMpXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzY2hlbWFUeXBlID0gaW1wb3J0X3R5cGVzLlNjaGVtYVR5cGVbcHJvcGVydHlUeXBlLnRvVXBwZXJDYXNlKCldO1xuICAgIGlmICghc2NoZW1hVHlwZSkge1xuICAgICAgdGhyb3cgbmV3IGltcG9ydF9nZW5raXQuR2Vua2l0RXJyb3Ioe1xuICAgICAgICBzdGF0dXM6IFwiSU5WQUxJRF9BUkdVTUVOVFwiLFxuICAgICAgICBtZXNzYWdlOiBgVW5zdXBwb3J0ZWQgcHJvcGVydHkgdHlwZSAke3Byb3BlcnR5VHlwZS50b1VwcGVyQ2FzZSgpfWBcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4uYmFzZVNjaGVtYSxcbiAgICAgIHR5cGU6IHNjaGVtYVR5cGVcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiB0b0dlbWluaU1lZGlhKHBhcnQpIHtcbiAgaWYgKHBhcnQubWVkaWE/LnVybC5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICBjb25zdCBkYXRhVXJsID0gcGFydC5tZWRpYS51cmw7XG4gICAgY29uc3QgYjY0RGF0YSA9IGRhdGFVcmwuc3Vic3RyaW5nKGRhdGFVcmwuaW5kZXhPZihcIixcIikgKyAxKTtcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHBhcnQubWVkaWEuY29udGVudFR5cGUgfHwgZGF0YVVybC5zdWJzdHJpbmcoZGF0YVVybC5pbmRleE9mKFwiOlwiKSArIDEsIGRhdGFVcmwuaW5kZXhPZihcIjtcIikpO1xuICAgIHJldHVybiB7IGlubGluZURhdGE6IHsgbWltZVR5cGU6IGNvbnRlbnRUeXBlLCBkYXRhOiBiNjREYXRhIH0gfTtcbiAgfVxuICBpZiAoIXBhcnQubWVkaWE/LmNvbnRlbnRUeXBlKSB7XG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBcIk11c3Qgc3VwcGx5IGEgYGNvbnRlbnRUeXBlYCB3aGVuIHNlbmRpbmcgRmlsZSBVUklzIHRvIEdlbWluaS5cIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmaWxlRGF0YToge1xuICAgICAgbWltZVR5cGU6IHBhcnQubWVkaWEuY29udGVudFR5cGUsXG4gICAgICBmaWxlVXJpOiBwYXJ0Lm1lZGlhLnVybFxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHRvR2VtaW5pVG9vbFJlcXVlc3QocGFydCkge1xuICBpZiAoIXBhcnQudG9vbFJlcXVlc3Q/LmlucHV0KSB7XG4gICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIFRvb2xSZXF1ZXN0UGFydDogaW5wdXQgd2FzIG1pc3NpbmcuXCIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZnVuY3Rpb25DYWxsOiB7XG4gICAgICBuYW1lOiBwYXJ0LnRvb2xSZXF1ZXN0Lm5hbWUsXG4gICAgICBhcmdzOiBwYXJ0LnRvb2xSZXF1ZXN0LmlucHV0XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gdG9HZW1pbmlUb29sUmVzcG9uc2UocGFydCkge1xuICBpZiAoIXBhcnQudG9vbFJlc3BvbnNlPy5vdXRwdXQpIHtcbiAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgVG9vbFJlc3BvbnNlUGFydDogb3V0cHV0IHdhcyBtaXNzaW5nLlwiKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGZ1bmN0aW9uUmVzcG9uc2U6IHtcbiAgICAgIG5hbWU6IHBhcnQudG9vbFJlc3BvbnNlLm5hbWUsXG4gICAgICByZXNwb25zZToge1xuICAgICAgICBuYW1lOiBwYXJ0LnRvb2xSZXNwb25zZS5uYW1lLFxuICAgICAgICBjb250ZW50OiBwYXJ0LnRvb2xSZXNwb25zZS5vdXRwdXRcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB0b0dlbWluaVJlYXNvbmluZyhwYXJ0KSB7XG4gIGNvbnN0IG91dCA9IHsgdGhvdWdodDogdHJ1ZSB9O1xuICBpZiAodHlwZW9mIHBhcnQubWV0YWRhdGE/LnRob3VnaHRTaWduYXR1cmUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBvdXQudGhvdWdodFNpZ25hdHVyZSA9IHBhcnQubWV0YWRhdGEudGhvdWdodFNpZ25hdHVyZTtcbiAgfVxuICBpZiAocGFydC5yZWFzb25pbmc/Lmxlbmd0aCkge1xuICAgIG91dC50ZXh0ID0gcGFydC5yZWFzb25pbmc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIHRvR2VtaW5pQ3VzdG9tKHBhcnQpIHtcbiAgaWYgKHBhcnQuY3VzdG9tPy5jb2RlRXhlY3V0aW9uUmVzdWx0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGVFeGVjdXRpb25SZXN1bHQ6IHBhcnQuY3VzdG9tLmNvZGVFeGVjdXRpb25SZXN1bHRcbiAgICB9O1xuICB9XG4gIGlmIChwYXJ0LmN1c3RvbT8uZXhlY3V0YWJsZUNvZGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhlY3V0YWJsZUNvZGU6IHBhcnQuY3VzdG9tLmV4ZWN1dGFibGVDb2RlXG4gICAgfTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBDdXN0b20gUGFydCB0eXBlXCIpO1xufVxuZnVuY3Rpb24gdG9HZW1pbmlQYXJ0KHBhcnQpIHtcbiAgaWYgKHBhcnQudGV4dCkge1xuICAgIHJldHVybiB7IHRleHQ6IHBhcnQudGV4dCB9O1xuICB9XG4gIGlmIChwYXJ0Lm1lZGlhKSB7XG4gICAgcmV0dXJuIHRvR2VtaW5pTWVkaWEocGFydCk7XG4gIH1cbiAgaWYgKHBhcnQudG9vbFJlcXVlc3QpIHtcbiAgICByZXR1cm4gdG9HZW1pbmlUb29sUmVxdWVzdChwYXJ0KTtcbiAgfVxuICBpZiAocGFydC50b29sUmVzcG9uc2UpIHtcbiAgICByZXR1cm4gdG9HZW1pbmlUb29sUmVzcG9uc2UocGFydCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwYXJ0LnJlYXNvbmluZyA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB0b0dlbWluaVJlYXNvbmluZyhwYXJ0KTtcbiAgfVxuICBpZiAocGFydC5jdXN0b20pIHtcbiAgICByZXR1cm4gdG9HZW1pbmlDdXN0b20ocGFydCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgUGFydCB0eXBlIFwiICsgSlNPTi5zdHJpbmdpZnkocGFydCkpO1xufVxuZnVuY3Rpb24gdG9HZW1pbmlSb2xlKHJvbGUsIG1vZGVsKSB7XG4gIHN3aXRjaCAocm9sZSkge1xuICAgIGNhc2UgXCJ1c2VyXCI6XG4gICAgICByZXR1cm4gXCJ1c2VyXCI7XG4gICAgY2FzZSBcIm1vZGVsXCI6XG4gICAgICByZXR1cm4gXCJtb2RlbFwiO1xuICAgIGNhc2UgXCJzeXN0ZW1cIjpcbiAgICAgIGlmIChtb2RlbD8uaW5mbz8uc3VwcG9ydHM/LnN5c3RlbVJvbGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwic3lzdGVtIHJvbGUgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGEgc2luZ2xlIG1lc3NhZ2UgaW4gdGhlIGZpcnN0IHBvc2l0aW9uXCJcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN5c3RlbSByb2xlIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICB9XG4gICAgY2FzZSBcInRvb2xcIjpcbiAgICAgIHJldHVybiBcImZ1bmN0aW9uXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcInVzZXJcIjtcbiAgfVxufVxuZnVuY3Rpb24gdG9HZW1pbmlNZXNzYWdlKG1lc3NhZ2UsIG1vZGVsKSB7XG4gIGxldCBzb3J0ZWRQYXJ0cyA9IG1lc3NhZ2UuY29udGVudDtcbiAgaWYgKG1lc3NhZ2Uucm9sZSA9PT0gXCJ0b29sXCIpIHtcbiAgICBzb3J0ZWRQYXJ0cyA9IFsuLi5tZXNzYWdlLmNvbnRlbnRdLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IGFSZWYgPSBhLnRvb2xSZXNwb25zZT8ucmVmO1xuICAgICAgY29uc3QgYlJlZiA9IGIudG9vbFJlc3BvbnNlPy5yZWY7XG4gICAgICBpZiAoIWFSZWYgJiYgIWJSZWYpIHJldHVybiAwO1xuICAgICAgaWYgKCFhUmVmKSByZXR1cm4gMTtcbiAgICAgIGlmICghYlJlZikgcmV0dXJuIC0xO1xuICAgICAgcmV0dXJuIHBhcnNlSW50KGFSZWYsIDEwKSAtIHBhcnNlSW50KGJSZWYsIDEwKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJvbGU6IHRvR2VtaW5pUm9sZShtZXNzYWdlLnJvbGUsIG1vZGVsKSxcbiAgICBwYXJ0czogc29ydGVkUGFydHMubWFwKHRvR2VtaW5pUGFydClcbiAgfTtcbn1cbmZ1bmN0aW9uIHRvR2VtaW5pU3lzdGVtSW5zdHJ1Y3Rpb24obWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHJvbGU6IFwidXNlclwiLFxuICAgIHBhcnRzOiBtZXNzYWdlLmNvbnRlbnQubWFwKHRvR2VtaW5pUGFydClcbiAgfTtcbn1cbmZ1bmN0aW9uIHRvR2VtaW5pRnVuY3Rpb25Nb2RlRW51bShmcm9tKSB7XG4gIGlmIChmcm9tID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHN3aXRjaCAoZnJvbSkge1xuICAgIGNhc2UgXCJNT0RFX1VOU1BFQ0lGSUVEXCI6IHtcbiAgICAgIHJldHVybiBpbXBvcnRfdHlwZXMuRnVuY3Rpb25DYWxsaW5nTW9kZS5NT0RFX1VOU1BFQ0lGSUVEO1xuICAgIH1cbiAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICBjYXNlIFwiQU5ZXCI6IHtcbiAgICAgIHJldHVybiBpbXBvcnRfdHlwZXMuRnVuY3Rpb25DYWxsaW5nTW9kZS5BTlk7XG4gICAgfVxuICAgIGNhc2UgXCJhdXRvXCI6XG4gICAgY2FzZSBcIkFVVE9cIjoge1xuICAgICAgcmV0dXJuIGltcG9ydF90eXBlcy5GdW5jdGlvbkNhbGxpbmdNb2RlLkFVVE87XG4gICAgfVxuICAgIGNhc2UgXCJub25lXCI6XG4gICAgY2FzZSBcIk5PTkVcIjoge1xuICAgICAgcmV0dXJuIGltcG9ydF90eXBlcy5GdW5jdGlvbkNhbGxpbmdNb2RlLk5PTkU7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGZ1bmN0aW9uIGNhbGxpbmcgbW9kZTogJHtmcm9tfWApO1xuICB9XG59XG5mdW5jdGlvbiBmcm9tR2VtaW5pRmluaXNoUmVhc29uKHJlYXNvbikge1xuICBpZiAoIXJlYXNvbikgcmV0dXJuIFwidW5rbm93blwiO1xuICBzd2l0Y2ggKHJlYXNvbikge1xuICAgIGNhc2UgXCJTVE9QXCI6XG4gICAgICByZXR1cm4gXCJzdG9wXCI7XG4gICAgY2FzZSBcIk1BWF9UT0tFTlNcIjpcbiAgICAgIHJldHVybiBcImxlbmd0aFwiO1xuICAgIGNhc2UgXCJTQUZFVFlcIjpcbiAgICAvLyBibG9ja2VkIGZvciBzYWZldHlcbiAgICBjYXNlIFwiUkVDSVRBVElPTlwiOlxuICAgIC8vIGJsb2NrZWQgZm9yIHJlY2l0aW5nIHRyYWluaW5nIGRhdGFcbiAgICBjYXNlIFwiTEFOR1VBR0VcIjpcbiAgICAvLyBibG9ja2VkIGZvciB1c2luZyBhbiB1bnN1cHBvcnRlZCBsYW5ndWFnZVxuICAgIGNhc2UgXCJCTE9DS0xJU1RcIjpcbiAgICAvLyBibG9ja2VkIGZvciBmb3JiaWRkZW4gdGVybXNcbiAgICBjYXNlIFwiUFJPSElCSVRFRF9DT05URU5UXCI6XG4gICAgLy8gYmxvY2tlZCBmb3IgcG90ZW50aWFsbHkgY29udGFpbmluZyBwcm9oaWJpdGVkIGNvbnRlbnRcbiAgICBjYXNlIFwiU1BJSVwiOlxuICAgICAgcmV0dXJuIFwiYmxvY2tlZFwiO1xuICAgIGNhc2UgXCJNQUxGT1JNRURfRlVOQ1RJT05fQ0FMTFwiOlxuICAgIGNhc2UgXCJPVEhFUlwiOlxuICAgICAgcmV0dXJuIFwib3RoZXJcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwidW5rbm93blwiO1xuICB9XG59XG5mdW5jdGlvbiBmcm9tR2VtaW5pVGhvdWdodChwYXJ0KSB7XG4gIHJldHVybiB7XG4gICAgcmVhc29uaW5nOiBwYXJ0LnRleHQgfHwgXCJcIixcbiAgICBtZXRhZGF0YTogeyB0aG91Z2h0U2lnbmF0dXJlOiBwYXJ0LnRob3VnaHRTaWduYXR1cmUgfVxuICB9O1xufVxuZnVuY3Rpb24gZnJvbUdlbWluaUlubGluZURhdGEocGFydCkge1xuICBpZiAoIXBhcnQuaW5saW5lRGF0YSB8fCAhcGFydC5pbmxpbmVEYXRhLmhhc093blByb3BlcnR5KFwibWltZVR5cGVcIikgfHwgIXBhcnQuaW5saW5lRGF0YS5oYXNPd25Qcm9wZXJ0eShcImRhdGFcIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEdlbWluaVBhcnQ6IG1pc3NpbmcgcmVxdWlyZWQgcHJvcGVydGllc1wiKTtcbiAgfVxuICBjb25zdCB7IG1pbWVUeXBlLCBkYXRhIH0gPSBwYXJ0LmlubGluZURhdGE7XG4gIGNvbnN0IGRhdGFVcmwgPSBgZGF0YToke21pbWVUeXBlfTtiYXNlNjQsJHtkYXRhfWA7XG4gIHJldHVybiB7XG4gICAgbWVkaWE6IHtcbiAgICAgIHVybDogZGF0YVVybCxcbiAgICAgIGNvbnRlbnRUeXBlOiBtaW1lVHlwZVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGZyb21HZW1pbmlGaWxlRGF0YShwYXJ0KSB7XG4gIGlmICghcGFydC5maWxlRGF0YSB8fCAhcGFydC5maWxlRGF0YS5oYXNPd25Qcm9wZXJ0eShcIm1pbWVUeXBlXCIpIHx8ICFwYXJ0LmZpbGVEYXRhLmhhc093blByb3BlcnR5KFwiZmlsZVVyaVwiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiSW52YWxpZCBHZW1pbmkgRmlsZSBEYXRhIFBhcnQ6IG1pc3NpbmcgcmVxdWlyZWQgcHJvcGVydGllc1wiXG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG1lZGlhOiB7XG4gICAgICB1cmw6IHBhcnQuZmlsZURhdGE/LmZpbGVVcmksXG4gICAgICBjb250ZW50VHlwZTogcGFydC5maWxlRGF0YT8ubWltZVR5cGVcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBmcm9tR2VtaW5pRnVuY3Rpb25DYWxsKHBhcnQsIHJlZikge1xuICBpZiAoIXBhcnQuZnVuY3Rpb25DYWxsKSB7XG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBcIkludmFsaWQgR2VtaW5pIEZ1bmN0aW9uIENhbGwgUGFydDogbWlzc2luZyBmdW5jdGlvbiBjYWxsIGRhdGFcIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b29sUmVxdWVzdDoge1xuICAgICAgbmFtZTogcGFydC5mdW5jdGlvbkNhbGwubmFtZSxcbiAgICAgIGlucHV0OiBwYXJ0LmZ1bmN0aW9uQ2FsbC5hcmdzLFxuICAgICAgcmVmXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZnJvbUdlbWluaUZ1bmN0aW9uUmVzcG9uc2UocGFydCwgcmVmKSB7XG4gIGlmICghcGFydC5mdW5jdGlvblJlc3BvbnNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJJbnZhbGlkIEdlbWluaSBGdW5jdGlvbiBDYWxsIFBhcnQ6IG1pc3NpbmcgZnVuY3Rpb24gY2FsbCBkYXRhXCJcbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgdG9vbFJlc3BvbnNlOiB7XG4gICAgICBuYW1lOiBwYXJ0LmZ1bmN0aW9uUmVzcG9uc2UubmFtZS5yZXBsYWNlKC9fXy9nLCBcIi9cIiksXG4gICAgICAvLyByZXN0b3JlIHNsYXNoZXNcbiAgICAgIG91dHB1dDogcGFydC5mdW5jdGlvblJlc3BvbnNlLnJlc3BvbnNlLFxuICAgICAgcmVmXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZnJvbUV4ZWN1dGFibGVDb2RlKHBhcnQpIHtcbiAgaWYgKCFwYXJ0LmV4ZWN1dGFibGVDb2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBHZW1pbmlQYXJ0OiBtaXNzaW5nIGV4ZWN1dGFibGVDb2RlXCIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgY3VzdG9tOiB7XG4gICAgICBleGVjdXRhYmxlQ29kZToge1xuICAgICAgICBsYW5ndWFnZTogcGFydC5leGVjdXRhYmxlQ29kZS5sYW5ndWFnZSxcbiAgICAgICAgY29kZTogcGFydC5leGVjdXRhYmxlQ29kZS5jb2RlXG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQocGFydCkge1xuICBpZiAoIXBhcnQuY29kZUV4ZWN1dGlvblJlc3VsdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgR2VtaW5pUGFydDogbWlzc2luZyBjb2RlRXhlY3V0aW9uUmVzdWx0XCIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgY3VzdG9tOiB7XG4gICAgICBjb2RlRXhlY3V0aW9uUmVzdWx0OiB7XG4gICAgICAgIG91dGNvbWU6IHBhcnQuY29kZUV4ZWN1dGlvblJlc3VsdC5vdXRjb21lLFxuICAgICAgICBvdXRwdXQ6IHBhcnQuY29kZUV4ZWN1dGlvblJlc3VsdC5vdXRwdXRcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBmcm9tR2VtaW5pUGFydChwYXJ0LCByZWYpIHtcbiAgaWYgKHBhcnQudGhvdWdodCkgcmV0dXJuIGZyb21HZW1pbmlUaG91Z2h0KHBhcnQpO1xuICBpZiAodHlwZW9mIHBhcnQudGV4dCA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHsgdGV4dDogcGFydC50ZXh0IH07XG4gIGlmIChwYXJ0LmlubGluZURhdGEpIHJldHVybiBmcm9tR2VtaW5pSW5saW5lRGF0YShwYXJ0KTtcbiAgaWYgKHBhcnQuZmlsZURhdGEpIHJldHVybiBmcm9tR2VtaW5pRmlsZURhdGEocGFydCk7XG4gIGlmIChwYXJ0LmZ1bmN0aW9uQ2FsbCkgcmV0dXJuIGZyb21HZW1pbmlGdW5jdGlvbkNhbGwocGFydCwgcmVmKTtcbiAgaWYgKHBhcnQuZnVuY3Rpb25SZXNwb25zZSkgcmV0dXJuIGZyb21HZW1pbmlGdW5jdGlvblJlc3BvbnNlKHBhcnQsIHJlZik7XG4gIGlmIChwYXJ0LmV4ZWN1dGFibGVDb2RlKSByZXR1cm4gZnJvbUV4ZWN1dGFibGVDb2RlKHBhcnQpO1xuICBpZiAocGFydC5jb2RlRXhlY3V0aW9uUmVzdWx0KSByZXR1cm4gZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQocGFydCk7XG4gIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIEdlbWluaVBhcnQgdHlwZSBcIiArIEpTT04uc3RyaW5naWZ5KHBhcnQpKTtcbn1cbmZ1bmN0aW9uIGZyb21HZW1pbmlDYW5kaWRhdGUoY2FuZGlkYXRlKSB7XG4gIGNvbnN0IHBhcnRzID0gY2FuZGlkYXRlLmNvbnRlbnQ/LnBhcnRzIHx8IFtdO1xuICBjb25zdCBnZW5raXRDYW5kaWRhdGUgPSB7XG4gICAgaW5kZXg6IGNhbmRpZGF0ZS5pbmRleCB8fCAwLFxuICAgIG1lc3NhZ2U6IHtcbiAgICAgIHJvbGU6IFwibW9kZWxcIixcbiAgICAgIGNvbnRlbnQ6IHBhcnRzLmZpbHRlcigocCkgPT4gT2JqZWN0LmtleXMocCkubGVuZ3RoID4gMCkubWFwKChwYXJ0LCBpbmRleCkgPT4gZnJvbUdlbWluaVBhcnQocGFydCwgaW5kZXgudG9TdHJpbmcoKSkpXG4gICAgfSxcbiAgICBmaW5pc2hSZWFzb246IGZyb21HZW1pbmlGaW5pc2hSZWFzb24oY2FuZGlkYXRlLmZpbmlzaFJlYXNvbiksXG4gICAgZmluaXNoTWVzc2FnZTogY2FuZGlkYXRlLmZpbmlzaE1lc3NhZ2UsXG4gICAgY3VzdG9tOiB7XG4gICAgICBzYWZldHlSYXRpbmdzOiBjYW5kaWRhdGUuc2FmZXR5UmF0aW5ncyxcbiAgICAgIGNpdGF0aW9uTWV0YWRhdGE6IGNhbmRpZGF0ZS5jaXRhdGlvbk1ldGFkYXRhXG4gICAgfVxuICB9O1xuICByZXR1cm4gZ2Vua2l0Q2FuZGlkYXRlO1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIGZyb21HZW1pbmlDYW5kaWRhdGUsXG4gIHRvR2VtaW5pRnVuY3Rpb25Nb2RlRW51bSxcbiAgdG9HZW1pbmlNZXNzYWdlLFxuICB0b0dlbWluaVN5c3RlbUluc3RydWN0aW9uLFxuICB0b0dlbWluaVRvb2xcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udmVydGVycy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/google-genai/lib/common/converters.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/google-genai/lib/common/types.js":
/*!******************************************************************!*\
  !*** ./node_modules/@genkit-ai/google-genai/lib/common/types.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar types_exports = {};\n__export(types_exports, {\n  BlockReason: () => BlockReason,\n  DynamicRetrievalMode: () => DynamicRetrievalMode,\n  ExecutableCodeLanguage: () => ExecutableCodeLanguage,\n  FinishReason: () => FinishReason,\n  FunctionCallingMode: () => FunctionCallingMode,\n  HarmBlockThreshold: () => HarmBlockThreshold,\n  HarmCategory: () => HarmCategory,\n  HarmProbability: () => HarmProbability,\n  HarmSeverity: () => HarmSeverity,\n  Outcome: () => Outcome,\n  SchemaType: () => SchemaType,\n  TaskTypeSchema: () => TaskTypeSchema,\n  isCodeExecutionTool: () => isCodeExecutionTool,\n  isFunctionDeclarationsTool: () => isFunctionDeclarationsTool,\n  isGoogleSearchRetrievalTool: () => isGoogleSearchRetrievalTool,\n  isObject: () => isObject,\n  isRetrievalTool: () => isRetrievalTool\n});\nmodule.exports = __toCommonJS(types_exports);\nvar import_genkit = __webpack_require__(/*! genkit */ \"(action-browser)/./node_modules/genkit/lib/index.js\");\nvar FunctionCallingMode = /* @__PURE__ */ ((FunctionCallingMode2) => {\n  FunctionCallingMode2[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n  FunctionCallingMode2[\"AUTO\"] = \"AUTO\";\n  FunctionCallingMode2[\"ANY\"] = \"ANY\";\n  FunctionCallingMode2[\"NONE\"] = \"NONE\";\n  return FunctionCallingMode2;\n})(FunctionCallingMode || {});\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null;\n}\nvar BlockReason = /* @__PURE__ */ ((BlockReason2) => {\n  BlockReason2[\"BLOCKED_REASON_UNSPECIFIED\"] = \"BLOCKED_REASON_UNSPECIFIED\";\n  BlockReason2[\"BLOCK_REASON_UNSPECIFIED\"] = \"BLOCK_REASON_UNSPECIFIED\";\n  BlockReason2[\"SAFETY\"] = \"SAFETY\";\n  BlockReason2[\"OTHER\"] = \"OTHER\";\n  BlockReason2[\"BLOCKLIST\"] = \"BLOCKLIST\";\n  BlockReason2[\"PROHIBITED_CONTENT\"] = \"PROHIBITED_CONTENT\";\n  return BlockReason2;\n})(BlockReason || {});\nvar HarmCategory = /* @__PURE__ */ ((HarmCategory2) => {\n  HarmCategory2[\"HARM_CATEGORY_UNSPECIFIED\"] = \"HARM_CATEGORY_UNSPECIFIED\";\n  HarmCategory2[\"HARM_CATEGORY_HATE_SPEECH\"] = \"HARM_CATEGORY_HATE_SPEECH\";\n  HarmCategory2[\"HARM_CATEGORY_SEXUALLY_EXPLICIT\"] = \"HARM_CATEGORY_SEXUALLY_EXPLICIT\";\n  HarmCategory2[\"HARM_CATEGORY_HARASSMENT\"] = \"HARM_CATEGORY_HARASSMENT\";\n  HarmCategory2[\"HARM_CATEGORY_DANGEROUS_CONTENT\"] = \"HARM_CATEGORY_DANGEROUS_CONTENT\";\n  HarmCategory2[\"HARM_CATEGORY_CIVIC_INTEGRITY\"] = \"HARM_CATEGORY_CIVIC_INTEGRITY\";\n  return HarmCategory2;\n})(HarmCategory || {});\nvar HarmBlockThreshold = /* @__PURE__ */ ((HarmBlockThreshold2) => {\n  HarmBlockThreshold2[\"HARM_BLOCK_THRESHOLD_UNSPECIFIED\"] = \"HARM_BLOCK_THRESHOLD_UNSPECIFIED\";\n  HarmBlockThreshold2[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n  HarmBlockThreshold2[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n  HarmBlockThreshold2[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n  HarmBlockThreshold2[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n  HarmBlockThreshold2[\"OFF\"] = \"OFF\";\n  return HarmBlockThreshold2;\n})(HarmBlockThreshold || {});\nvar HarmProbability = /* @__PURE__ */ ((HarmProbability2) => {\n  HarmProbability2[\"HARM_PROBABILITY_UNSPECIFIED\"] = \"HARM_PROBABILITY_UNSPECIFIED\";\n  HarmProbability2[\"NEGLIGIBLE\"] = \"NEGLIGIBLE\";\n  HarmProbability2[\"LOW\"] = \"LOW\";\n  HarmProbability2[\"MEDIUM\"] = \"MEDIUM\";\n  HarmProbability2[\"HIGH\"] = \"HIGH\";\n  return HarmProbability2;\n})(HarmProbability || {});\nvar DynamicRetrievalMode = /* @__PURE__ */ ((DynamicRetrievalMode2) => {\n  DynamicRetrievalMode2[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n  DynamicRetrievalMode2[\"MODE_DYNAMIC\"] = \"MODE_DYNAMIC\";\n  return DynamicRetrievalMode2;\n})(DynamicRetrievalMode || {});\nfunction isGoogleSearchRetrievalTool(tool) {\n  return tool.googleSearchRetrieval !== void 0 || tool.googleSearch !== void 0;\n}\nvar HarmSeverity = /* @__PURE__ */ ((HarmSeverity2) => {\n  HarmSeverity2[\"HARM_SEVERITY_UNSPECIFIED\"] = \"HARM_SEVERITY_UNSPECIFIED\";\n  HarmSeverity2[\"HARM_SEVERITY_NEGLIGIBLE\"] = \"HARM_SEVERITY_NEGLIGIBLE\";\n  HarmSeverity2[\"HARM_SEVERITY_LOW\"] = \"HARM_SEVERITY_LOW\";\n  HarmSeverity2[\"HARM_SEVERITY_MEDIUM\"] = \"HARM_SEVERITY_MEDIUM\";\n  HarmSeverity2[\"HARM_SEVERITY_HIGH\"] = \"HARM_SEVERITY_HIGH\";\n  return HarmSeverity2;\n})(HarmSeverity || {});\nvar SchemaType = /* @__PURE__ */ ((SchemaType2) => {\n  SchemaType2[\"STRING\"] = \"STRING\";\n  SchemaType2[\"NUMBER\"] = \"NUMBER\";\n  SchemaType2[\"INTEGER\"] = \"INTEGER\";\n  SchemaType2[\"BOOLEAN\"] = \"BOOLEAN\";\n  SchemaType2[\"ARRAY\"] = \"ARRAY\";\n  SchemaType2[\"OBJECT\"] = \"OBJECT\";\n  return SchemaType2;\n})(SchemaType || {});\nconst TaskTypeSchema = import_genkit.z.enum([\n  \"RETRIEVAL_DOCUMENT\",\n  \"RETRIEVAL_QUERY\",\n  \"SEMANTIC_SIMILARITY\",\n  \"CLASSIFICATION\",\n  \"CLUSTERING\"\n]);\nvar FinishReason = /* @__PURE__ */ ((FinishReason2) => {\n  FinishReason2[\"FINISH_REASON_UNSPECIFIED\"] = \"FINISH_REASON_UNSPECIFIED\";\n  FinishReason2[\"STOP\"] = \"STOP\";\n  FinishReason2[\"MAX_TOKENS\"] = \"MAX_TOKENS\";\n  FinishReason2[\"SAFETY\"] = \"SAFETY\";\n  FinishReason2[\"RECITATION\"] = \"RECITATION\";\n  FinishReason2[\"LANGUAGE\"] = \"LANGUAGE\";\n  FinishReason2[\"BLOCKLIST\"] = \"BLOCKLIST\";\n  FinishReason2[\"PROHIBITED_CONTENT\"] = \"PROHIBITED_CONTENT\";\n  FinishReason2[\"SPII\"] = \"SPII\";\n  FinishReason2[\"MALFORMED_FUNCTION_CALL\"] = \"MALFORMED_FUNCTION_CALL\";\n  FinishReason2[\"OTHER\"] = \"OTHER\";\n  return FinishReason2;\n})(FinishReason || {});\nvar ExecutableCodeLanguage = /* @__PURE__ */ ((ExecutableCodeLanguage2) => {\n  ExecutableCodeLanguage2[\"LANGUAGE_UNSPECIFIED\"] = \"LANGUAGE_UNSPECIFIED\";\n  ExecutableCodeLanguage2[\"PYTHON\"] = \"PYTHON\";\n  return ExecutableCodeLanguage2;\n})(ExecutableCodeLanguage || {});\nvar Outcome = /* @__PURE__ */ ((Outcome2) => {\n  Outcome2[\"OUTCOME_UNSPECIFIED\"] = \"OUTCOME_UNSPECIFIED\";\n  Outcome2[\"OUTCOME_OK\"] = \"OUTCOME_OK\";\n  Outcome2[\"OUTCOME_FAILED\"] = \"OUTCOME_FAILED\";\n  Outcome2[\"OUTCOME_DEADLINE_EXCEEDED\"] = \"OUTCOME_DEADLINE_EXCEEDED\";\n  return Outcome2;\n})(Outcome || {});\nfunction isFunctionDeclarationsTool(tool) {\n  return tool.functionDeclarations !== void 0;\n}\nfunction isCodeExecutionTool(tool) {\n  return tool.codeExecution !== void 0;\n}\nfunction isRetrievalTool(tool) {\n  return tool.retrieval !== void 0;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2dvb2dsZS1nZW5haS9saWIvY29tbW9uL3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyxtRUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxtQkFBbUI7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsdUJBQXVCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQkFBa0I7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxlQUFlO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQWtCTDtBQUNEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEtSYW1hY2hhXFxEb2N1bWVudHNcXFN1c3RBSW5leCBHSXQgQ29kZVxcbm9kZV9tb2R1bGVzXFxAZ2Vua2l0LWFpXFxnb29nbGUtZ2VuYWlcXGxpYlxcY29tbW9uXFx0eXBlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgdHlwZXNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodHlwZXNfZXhwb3J0cywge1xuICBCbG9ja1JlYXNvbjogKCkgPT4gQmxvY2tSZWFzb24sXG4gIER5bmFtaWNSZXRyaWV2YWxNb2RlOiAoKSA9PiBEeW5hbWljUmV0cmlldmFsTW9kZSxcbiAgRXhlY3V0YWJsZUNvZGVMYW5ndWFnZTogKCkgPT4gRXhlY3V0YWJsZUNvZGVMYW5ndWFnZSxcbiAgRmluaXNoUmVhc29uOiAoKSA9PiBGaW5pc2hSZWFzb24sXG4gIEZ1bmN0aW9uQ2FsbGluZ01vZGU6ICgpID0+IEZ1bmN0aW9uQ2FsbGluZ01vZGUsXG4gIEhhcm1CbG9ja1RocmVzaG9sZDogKCkgPT4gSGFybUJsb2NrVGhyZXNob2xkLFxuICBIYXJtQ2F0ZWdvcnk6ICgpID0+IEhhcm1DYXRlZ29yeSxcbiAgSGFybVByb2JhYmlsaXR5OiAoKSA9PiBIYXJtUHJvYmFiaWxpdHksXG4gIEhhcm1TZXZlcml0eTogKCkgPT4gSGFybVNldmVyaXR5LFxuICBPdXRjb21lOiAoKSA9PiBPdXRjb21lLFxuICBTY2hlbWFUeXBlOiAoKSA9PiBTY2hlbWFUeXBlLFxuICBUYXNrVHlwZVNjaGVtYTogKCkgPT4gVGFza1R5cGVTY2hlbWEsXG4gIGlzQ29kZUV4ZWN1dGlvblRvb2w6ICgpID0+IGlzQ29kZUV4ZWN1dGlvblRvb2wsXG4gIGlzRnVuY3Rpb25EZWNsYXJhdGlvbnNUb29sOiAoKSA9PiBpc0Z1bmN0aW9uRGVjbGFyYXRpb25zVG9vbCxcbiAgaXNHb29nbGVTZWFyY2hSZXRyaWV2YWxUb29sOiAoKSA9PiBpc0dvb2dsZVNlYXJjaFJldHJpZXZhbFRvb2wsXG4gIGlzT2JqZWN0OiAoKSA9PiBpc09iamVjdCxcbiAgaXNSZXRyaWV2YWxUb29sOiAoKSA9PiBpc1JldHJpZXZhbFRvb2xcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlModHlwZXNfZXhwb3J0cyk7XG52YXIgaW1wb3J0X2dlbmtpdCA9IHJlcXVpcmUoXCJnZW5raXRcIik7XG52YXIgRnVuY3Rpb25DYWxsaW5nTW9kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEZ1bmN0aW9uQ2FsbGluZ01vZGUyKSA9PiB7XG4gIEZ1bmN0aW9uQ2FsbGluZ01vZGUyW1wiTU9ERV9VTlNQRUNJRklFRFwiXSA9IFwiTU9ERV9VTlNQRUNJRklFRFwiO1xuICBGdW5jdGlvbkNhbGxpbmdNb2RlMltcIkFVVE9cIl0gPSBcIkFVVE9cIjtcbiAgRnVuY3Rpb25DYWxsaW5nTW9kZTJbXCJBTllcIl0gPSBcIkFOWVwiO1xuICBGdW5jdGlvbkNhbGxpbmdNb2RlMltcIk5PTkVcIl0gPSBcIk5PTkVcIjtcbiAgcmV0dXJuIEZ1bmN0aW9uQ2FsbGluZ01vZGUyO1xufSkoRnVuY3Rpb25DYWxsaW5nTW9kZSB8fCB7fSk7XG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsO1xufVxudmFyIEJsb2NrUmVhc29uID0gLyogQF9fUFVSRV9fICovICgoQmxvY2tSZWFzb24yKSA9PiB7XG4gIEJsb2NrUmVhc29uMltcIkJMT0NLRURfUkVBU09OX1VOU1BFQ0lGSUVEXCJdID0gXCJCTE9DS0VEX1JFQVNPTl9VTlNQRUNJRklFRFwiO1xuICBCbG9ja1JlYXNvbjJbXCJCTE9DS19SRUFTT05fVU5TUEVDSUZJRURcIl0gPSBcIkJMT0NLX1JFQVNPTl9VTlNQRUNJRklFRFwiO1xuICBCbG9ja1JlYXNvbjJbXCJTQUZFVFlcIl0gPSBcIlNBRkVUWVwiO1xuICBCbG9ja1JlYXNvbjJbXCJPVEhFUlwiXSA9IFwiT1RIRVJcIjtcbiAgQmxvY2tSZWFzb24yW1wiQkxPQ0tMSVNUXCJdID0gXCJCTE9DS0xJU1RcIjtcbiAgQmxvY2tSZWFzb24yW1wiUFJPSElCSVRFRF9DT05URU5UXCJdID0gXCJQUk9ISUJJVEVEX0NPTlRFTlRcIjtcbiAgcmV0dXJuIEJsb2NrUmVhc29uMjtcbn0pKEJsb2NrUmVhc29uIHx8IHt9KTtcbnZhciBIYXJtQ2F0ZWdvcnkgPSAvKiBAX19QVVJFX18gKi8gKChIYXJtQ2F0ZWdvcnkyKSA9PiB7XG4gIEhhcm1DYXRlZ29yeTJbXCJIQVJNX0NBVEVHT1JZX1VOU1BFQ0lGSUVEXCJdID0gXCJIQVJNX0NBVEVHT1JZX1VOU1BFQ0lGSUVEXCI7XG4gIEhhcm1DYXRlZ29yeTJbXCJIQVJNX0NBVEVHT1JZX0hBVEVfU1BFRUNIXCJdID0gXCJIQVJNX0NBVEVHT1JZX0hBVEVfU1BFRUNIXCI7XG4gIEhhcm1DYXRlZ29yeTJbXCJIQVJNX0NBVEVHT1JZX1NFWFVBTExZX0VYUExJQ0lUXCJdID0gXCJIQVJNX0NBVEVHT1JZX1NFWFVBTExZX0VYUExJQ0lUXCI7XG4gIEhhcm1DYXRlZ29yeTJbXCJIQVJNX0NBVEVHT1JZX0hBUkFTU01FTlRcIl0gPSBcIkhBUk1fQ0FURUdPUllfSEFSQVNTTUVOVFwiO1xuICBIYXJtQ2F0ZWdvcnkyW1wiSEFSTV9DQVRFR09SWV9EQU5HRVJPVVNfQ09OVEVOVFwiXSA9IFwiSEFSTV9DQVRFR09SWV9EQU5HRVJPVVNfQ09OVEVOVFwiO1xuICBIYXJtQ2F0ZWdvcnkyW1wiSEFSTV9DQVRFR09SWV9DSVZJQ19JTlRFR1JJVFlcIl0gPSBcIkhBUk1fQ0FURUdPUllfQ0lWSUNfSU5URUdSSVRZXCI7XG4gIHJldHVybiBIYXJtQ2F0ZWdvcnkyO1xufSkoSGFybUNhdGVnb3J5IHx8IHt9KTtcbnZhciBIYXJtQmxvY2tUaHJlc2hvbGQgPSAvKiBAX19QVVJFX18gKi8gKChIYXJtQmxvY2tUaHJlc2hvbGQyKSA9PiB7XG4gIEhhcm1CbG9ja1RocmVzaG9sZDJbXCJIQVJNX0JMT0NLX1RIUkVTSE9MRF9VTlNQRUNJRklFRFwiXSA9IFwiSEFSTV9CTE9DS19USFJFU0hPTERfVU5TUEVDSUZJRURcIjtcbiAgSGFybUJsb2NrVGhyZXNob2xkMltcIkJMT0NLX0xPV19BTkRfQUJPVkVcIl0gPSBcIkJMT0NLX0xPV19BTkRfQUJPVkVcIjtcbiAgSGFybUJsb2NrVGhyZXNob2xkMltcIkJMT0NLX01FRElVTV9BTkRfQUJPVkVcIl0gPSBcIkJMT0NLX01FRElVTV9BTkRfQUJPVkVcIjtcbiAgSGFybUJsb2NrVGhyZXNob2xkMltcIkJMT0NLX09OTFlfSElHSFwiXSA9IFwiQkxPQ0tfT05MWV9ISUdIXCI7XG4gIEhhcm1CbG9ja1RocmVzaG9sZDJbXCJCTE9DS19OT05FXCJdID0gXCJCTE9DS19OT05FXCI7XG4gIEhhcm1CbG9ja1RocmVzaG9sZDJbXCJPRkZcIl0gPSBcIk9GRlwiO1xuICByZXR1cm4gSGFybUJsb2NrVGhyZXNob2xkMjtcbn0pKEhhcm1CbG9ja1RocmVzaG9sZCB8fCB7fSk7XG52YXIgSGFybVByb2JhYmlsaXR5ID0gLyogQF9fUFVSRV9fICovICgoSGFybVByb2JhYmlsaXR5MikgPT4ge1xuICBIYXJtUHJvYmFiaWxpdHkyW1wiSEFSTV9QUk9CQUJJTElUWV9VTlNQRUNJRklFRFwiXSA9IFwiSEFSTV9QUk9CQUJJTElUWV9VTlNQRUNJRklFRFwiO1xuICBIYXJtUHJvYmFiaWxpdHkyW1wiTkVHTElHSUJMRVwiXSA9IFwiTkVHTElHSUJMRVwiO1xuICBIYXJtUHJvYmFiaWxpdHkyW1wiTE9XXCJdID0gXCJMT1dcIjtcbiAgSGFybVByb2JhYmlsaXR5MltcIk1FRElVTVwiXSA9IFwiTUVESVVNXCI7XG4gIEhhcm1Qcm9iYWJpbGl0eTJbXCJISUdIXCJdID0gXCJISUdIXCI7XG4gIHJldHVybiBIYXJtUHJvYmFiaWxpdHkyO1xufSkoSGFybVByb2JhYmlsaXR5IHx8IHt9KTtcbnZhciBEeW5hbWljUmV0cmlldmFsTW9kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKER5bmFtaWNSZXRyaWV2YWxNb2RlMikgPT4ge1xuICBEeW5hbWljUmV0cmlldmFsTW9kZTJbXCJNT0RFX1VOU1BFQ0lGSUVEXCJdID0gXCJNT0RFX1VOU1BFQ0lGSUVEXCI7XG4gIER5bmFtaWNSZXRyaWV2YWxNb2RlMltcIk1PREVfRFlOQU1JQ1wiXSA9IFwiTU9ERV9EWU5BTUlDXCI7XG4gIHJldHVybiBEeW5hbWljUmV0cmlldmFsTW9kZTI7XG59KShEeW5hbWljUmV0cmlldmFsTW9kZSB8fCB7fSk7XG5mdW5jdGlvbiBpc0dvb2dsZVNlYXJjaFJldHJpZXZhbFRvb2wodG9vbCkge1xuICByZXR1cm4gdG9vbC5nb29nbGVTZWFyY2hSZXRyaWV2YWwgIT09IHZvaWQgMCB8fCB0b29sLmdvb2dsZVNlYXJjaCAhPT0gdm9pZCAwO1xufVxudmFyIEhhcm1TZXZlcml0eSA9IC8qIEBfX1BVUkVfXyAqLyAoKEhhcm1TZXZlcml0eTIpID0+IHtcbiAgSGFybVNldmVyaXR5MltcIkhBUk1fU0VWRVJJVFlfVU5TUEVDSUZJRURcIl0gPSBcIkhBUk1fU0VWRVJJVFlfVU5TUEVDSUZJRURcIjtcbiAgSGFybVNldmVyaXR5MltcIkhBUk1fU0VWRVJJVFlfTkVHTElHSUJMRVwiXSA9IFwiSEFSTV9TRVZFUklUWV9ORUdMSUdJQkxFXCI7XG4gIEhhcm1TZXZlcml0eTJbXCJIQVJNX1NFVkVSSVRZX0xPV1wiXSA9IFwiSEFSTV9TRVZFUklUWV9MT1dcIjtcbiAgSGFybVNldmVyaXR5MltcIkhBUk1fU0VWRVJJVFlfTUVESVVNXCJdID0gXCJIQVJNX1NFVkVSSVRZX01FRElVTVwiO1xuICBIYXJtU2V2ZXJpdHkyW1wiSEFSTV9TRVZFUklUWV9ISUdIXCJdID0gXCJIQVJNX1NFVkVSSVRZX0hJR0hcIjtcbiAgcmV0dXJuIEhhcm1TZXZlcml0eTI7XG59KShIYXJtU2V2ZXJpdHkgfHwge30pO1xudmFyIFNjaGVtYVR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChTY2hlbWFUeXBlMikgPT4ge1xuICBTY2hlbWFUeXBlMltcIlNUUklOR1wiXSA9IFwiU1RSSU5HXCI7XG4gIFNjaGVtYVR5cGUyW1wiTlVNQkVSXCJdID0gXCJOVU1CRVJcIjtcbiAgU2NoZW1hVHlwZTJbXCJJTlRFR0VSXCJdID0gXCJJTlRFR0VSXCI7XG4gIFNjaGVtYVR5cGUyW1wiQk9PTEVBTlwiXSA9IFwiQk9PTEVBTlwiO1xuICBTY2hlbWFUeXBlMltcIkFSUkFZXCJdID0gXCJBUlJBWVwiO1xuICBTY2hlbWFUeXBlMltcIk9CSkVDVFwiXSA9IFwiT0JKRUNUXCI7XG4gIHJldHVybiBTY2hlbWFUeXBlMjtcbn0pKFNjaGVtYVR5cGUgfHwge30pO1xuY29uc3QgVGFza1R5cGVTY2hlbWEgPSBpbXBvcnRfZ2Vua2l0LnouZW51bShbXG4gIFwiUkVUUklFVkFMX0RPQ1VNRU5UXCIsXG4gIFwiUkVUUklFVkFMX1FVRVJZXCIsXG4gIFwiU0VNQU5USUNfU0lNSUxBUklUWVwiLFxuICBcIkNMQVNTSUZJQ0FUSU9OXCIsXG4gIFwiQ0xVU1RFUklOR1wiXG5dKTtcbnZhciBGaW5pc2hSZWFzb24gPSAvKiBAX19QVVJFX18gKi8gKChGaW5pc2hSZWFzb24yKSA9PiB7XG4gIEZpbmlzaFJlYXNvbjJbXCJGSU5JU0hfUkVBU09OX1VOU1BFQ0lGSUVEXCJdID0gXCJGSU5JU0hfUkVBU09OX1VOU1BFQ0lGSUVEXCI7XG4gIEZpbmlzaFJlYXNvbjJbXCJTVE9QXCJdID0gXCJTVE9QXCI7XG4gIEZpbmlzaFJlYXNvbjJbXCJNQVhfVE9LRU5TXCJdID0gXCJNQVhfVE9LRU5TXCI7XG4gIEZpbmlzaFJlYXNvbjJbXCJTQUZFVFlcIl0gPSBcIlNBRkVUWVwiO1xuICBGaW5pc2hSZWFzb24yW1wiUkVDSVRBVElPTlwiXSA9IFwiUkVDSVRBVElPTlwiO1xuICBGaW5pc2hSZWFzb24yW1wiTEFOR1VBR0VcIl0gPSBcIkxBTkdVQUdFXCI7XG4gIEZpbmlzaFJlYXNvbjJbXCJCTE9DS0xJU1RcIl0gPSBcIkJMT0NLTElTVFwiO1xuICBGaW5pc2hSZWFzb24yW1wiUFJPSElCSVRFRF9DT05URU5UXCJdID0gXCJQUk9ISUJJVEVEX0NPTlRFTlRcIjtcbiAgRmluaXNoUmVhc29uMltcIlNQSUlcIl0gPSBcIlNQSUlcIjtcbiAgRmluaXNoUmVhc29uMltcIk1BTEZPUk1FRF9GVU5DVElPTl9DQUxMXCJdID0gXCJNQUxGT1JNRURfRlVOQ1RJT05fQ0FMTFwiO1xuICBGaW5pc2hSZWFzb24yW1wiT1RIRVJcIl0gPSBcIk9USEVSXCI7XG4gIHJldHVybiBGaW5pc2hSZWFzb24yO1xufSkoRmluaXNoUmVhc29uIHx8IHt9KTtcbnZhciBFeGVjdXRhYmxlQ29kZUxhbmd1YWdlID0gLyogQF9fUFVSRV9fICovICgoRXhlY3V0YWJsZUNvZGVMYW5ndWFnZTIpID0+IHtcbiAgRXhlY3V0YWJsZUNvZGVMYW5ndWFnZTJbXCJMQU5HVUFHRV9VTlNQRUNJRklFRFwiXSA9IFwiTEFOR1VBR0VfVU5TUEVDSUZJRURcIjtcbiAgRXhlY3V0YWJsZUNvZGVMYW5ndWFnZTJbXCJQWVRIT05cIl0gPSBcIlBZVEhPTlwiO1xuICByZXR1cm4gRXhlY3V0YWJsZUNvZGVMYW5ndWFnZTI7XG59KShFeGVjdXRhYmxlQ29kZUxhbmd1YWdlIHx8IHt9KTtcbnZhciBPdXRjb21lID0gLyogQF9fUFVSRV9fICovICgoT3V0Y29tZTIpID0+IHtcbiAgT3V0Y29tZTJbXCJPVVRDT01FX1VOU1BFQ0lGSUVEXCJdID0gXCJPVVRDT01FX1VOU1BFQ0lGSUVEXCI7XG4gIE91dGNvbWUyW1wiT1VUQ09NRV9PS1wiXSA9IFwiT1VUQ09NRV9PS1wiO1xuICBPdXRjb21lMltcIk9VVENPTUVfRkFJTEVEXCJdID0gXCJPVVRDT01FX0ZBSUxFRFwiO1xuICBPdXRjb21lMltcIk9VVENPTUVfREVBRExJTkVfRVhDRUVERURcIl0gPSBcIk9VVENPTUVfREVBRExJTkVfRVhDRUVERURcIjtcbiAgcmV0dXJuIE91dGNvbWUyO1xufSkoT3V0Y29tZSB8fCB7fSk7XG5mdW5jdGlvbiBpc0Z1bmN0aW9uRGVjbGFyYXRpb25zVG9vbCh0b29sKSB7XG4gIHJldHVybiB0b29sLmZ1bmN0aW9uRGVjbGFyYXRpb25zICE9PSB2b2lkIDA7XG59XG5mdW5jdGlvbiBpc0NvZGVFeGVjdXRpb25Ub29sKHRvb2wpIHtcbiAgcmV0dXJuIHRvb2wuY29kZUV4ZWN1dGlvbiAhPT0gdm9pZCAwO1xufVxuZnVuY3Rpb24gaXNSZXRyaWV2YWxUb29sKHRvb2wpIHtcbiAgcmV0dXJuIHRvb2wucmV0cmlldmFsICE9PSB2b2lkIDA7XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgQmxvY2tSZWFzb24sXG4gIER5bmFtaWNSZXRyaWV2YWxNb2RlLFxuICBFeGVjdXRhYmxlQ29kZUxhbmd1YWdlLFxuICBGaW5pc2hSZWFzb24sXG4gIEZ1bmN0aW9uQ2FsbGluZ01vZGUsXG4gIEhhcm1CbG9ja1RocmVzaG9sZCxcbiAgSGFybUNhdGVnb3J5LFxuICBIYXJtUHJvYmFiaWxpdHksXG4gIEhhcm1TZXZlcml0eSxcbiAgT3V0Y29tZSxcbiAgU2NoZW1hVHlwZSxcbiAgVGFza1R5cGVTY2hlbWEsXG4gIGlzQ29kZUV4ZWN1dGlvblRvb2wsXG4gIGlzRnVuY3Rpb25EZWNsYXJhdGlvbnNUb29sLFxuICBpc0dvb2dsZVNlYXJjaFJldHJpZXZhbFRvb2wsXG4gIGlzT2JqZWN0LFxuICBpc1JldHJpZXZhbFRvb2xcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/google-genai/lib/common/types.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/google-genai/lib/common/utils.js":
/*!******************************************************************!*\
  !*** ./node_modules/@genkit-ai/google-genai/lib/common/utils.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar utils_exports = {};\n__export(utils_exports, {\n  checkModelName: () => checkModelName,\n  checkSupportedMimeType: () => checkSupportedMimeType,\n  cleanSchema: () => cleanSchema,\n  displayUrl: () => displayUrl,\n  extractErrMsg: () => extractErrMsg,\n  extractMedia: () => extractMedia,\n  extractMimeType: () => extractMimeType,\n  extractText: () => extractText,\n  extractVersion: () => extractVersion,\n  getGenkitClientHeader: () => getGenkitClientHeader,\n  modelName: () => modelName,\n  processStream: () => processStream\n});\nmodule.exports = __toCommonJS(utils_exports);\nvar import_genkit = __webpack_require__(/*! genkit */ \"(action-browser)/./node_modules/genkit/lib/index.js\");\nvar import_types = __webpack_require__(/*! ./types.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/common/types.js\");\nfunction extractErrMsg(e) {\n  let errorMessage = \"An unknown error occurred\";\n  if (e instanceof Error) {\n    errorMessage = e.message;\n  } else if (typeof e === \"string\") {\n    errorMessage = e;\n  } else {\n    try {\n      errorMessage = JSON.stringify(e);\n    } catch (stringifyError) {\n      errorMessage = \"Failed to stringify error object\";\n    }\n  }\n  return errorMessage;\n}\nfunction extractVersion(model) {\n  return model.version ? model.version : checkModelName(model.name);\n}\nfunction modelName(name) {\n  if (!name) return name;\n  const prefixesToRemove = /background-model\\/|model\\/|models\\/|embedders\\/|googleai\\/|vertexai\\//g;\n  return name.replace(prefixesToRemove, \"\");\n}\nfunction checkModelName(name) {\n  const version = modelName(name);\n  if (!version) {\n    throw new import_genkit.GenkitError({\n      status: \"INVALID_ARGUMENT\",\n      message: \"Model name is required.\"\n    });\n  }\n  return version;\n}\nfunction extractText(request) {\n  return request.messages.at(-1)?.content.map((c) => c.text || \"\").join(\"\") ?? \"\";\n}\nconst KNOWN_MIME_TYPES = {\n  jpg: \"image/jpeg\",\n  jpeg: \"image/jpeg\",\n  png: \"image/png\",\n  mp4: \"video/mp4\",\n  pdf: \"application/pdf\"\n};\nfunction extractMimeType(url) {\n  if (!url) {\n    return \"\";\n  }\n  const dataPrefix = \"data:\";\n  if (!url.startsWith(dataPrefix)) {\n    url.lastIndexOf(\".\");\n    const key = url.substring(url.lastIndexOf(\".\") + 1);\n    if (Object.keys(KNOWN_MIME_TYPES).includes(key)) {\n      return KNOWN_MIME_TYPES[key];\n    }\n    return \"\";\n  }\n  const commaIndex = url.indexOf(\",\");\n  if (commaIndex == -1) {\n    return \"\";\n  }\n  let mimeType = url.substring(dataPrefix.length, commaIndex);\n  const base64Marker = \";base64\";\n  if (mimeType.endsWith(base64Marker)) {\n    mimeType = mimeType.substring(0, mimeType.length - base64Marker.length);\n  }\n  return mimeType.trim();\n}\nfunction checkSupportedMimeType(media, supportedTypes) {\n  if (!supportedTypes.includes(media.contentType ?? \"\")) {\n    throw new import_genkit.GenkitError({\n      status: \"INVALID_ARGUMENT\",\n      message: `Invalid mimeType for ${displayUrl(media.url)}: \"${media.contentType}\". Supported mimeTypes: ${supportedTypes.join(\", \")}`\n    });\n  }\n}\nfunction displayUrl(url) {\n  if (url.length <= 50) {\n    return url;\n  }\n  return url.substring(0, 25) + \"...\" + url.substring(url.length - 25);\n}\nfunction extractMedia(request, params) {\n  const predicate = (part) => {\n    const media2 = part.media;\n    if (!media2) {\n      return false;\n    }\n    if (params.metadataType || params.isDefault) {\n      const metadata = part.metadata;\n      if (!metadata?.type) {\n        return !!params.isDefault;\n      } else {\n        return metadata.type == params.metadataType;\n      }\n    }\n    return true;\n  };\n  const media = request.messages.at(-1)?.content.find(predicate)?.media;\n  if (media && !media?.contentType) {\n    return {\n      url: media.url,\n      contentType: extractMimeType(media.url)\n    };\n  }\n  return media;\n}\nfunction cleanSchema(schema) {\n  const out = structuredClone(schema);\n  for (const key in out) {\n    if (key === \"$schema\" || key === \"additionalProperties\") {\n      delete out[key];\n      continue;\n    }\n    if (typeof out[key] === \"object\") {\n      out[key] = cleanSchema(out[key]);\n    }\n    if (key === \"type\" && Array.isArray(out[key])) {\n      out[key] = out[key].find((t) => t !== \"null\");\n    }\n  }\n  return out;\n}\nfunction processStream(response) {\n  if (!response.body) {\n    throw new Error(\"Error processing stream because response.body not found\");\n  }\n  const inputStream = response.body.pipeThrough(\n    new TextDecoderStream(\"utf8\", { fatal: true })\n  );\n  const responseStream = getResponseStream(inputStream);\n  const [stream1, stream2] = responseStream.tee();\n  return {\n    stream: generateResponseSequence(stream1),\n    response: getResponsePromise(stream2)\n  };\n}\nfunction getResponseStream(inputStream) {\n  const responseLineRE = /^data: (.*)(?:\\n\\n|\\r\\r|\\r\\n\\r\\n)/;\n  const reader = inputStream.getReader();\n  const stream = new ReadableStream({\n    start(controller) {\n      let currentText = \"\";\n      return pump();\n      function pump() {\n        return reader.read().then(({ value, done }) => {\n          if (done) {\n            if (currentText.trim()) {\n              controller.error(new Error(\"Failed to parse stream\"));\n              return;\n            }\n            controller.close();\n            return;\n          }\n          currentText += value;\n          let match = currentText.match(responseLineRE);\n          let parsedResponse;\n          while (match) {\n            try {\n              parsedResponse = JSON.parse(match[1]);\n            } catch (e) {\n              controller.error(\n                new Error(`Error parsing JSON response: \"${match[1]}\"`)\n              );\n              return;\n            }\n            controller.enqueue(parsedResponse);\n            currentText = currentText.substring(match[0].length);\n            match = currentText.match(responseLineRE);\n          }\n          return pump();\n        }).catch((e) => {\n          let err = e;\n          err.stack = e.stack;\n          if (err.name === \"AbortError\") {\n            err = new import_genkit.GenkitError({\n              status: \"ABORTED\",\n              message: \"Request aborted when reading from the stream\"\n            });\n          } else {\n            err = new Error(\"Error reading from the stream\");\n          }\n          throw err;\n        });\n      }\n    }\n  });\n  return stream;\n}\nasync function* generateResponseSequence(stream) {\n  const reader = stream.getReader();\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) {\n      break;\n    }\n    yield value;\n  }\n}\nasync function getResponsePromise(stream) {\n  const allResponses = [];\n  const reader = stream.getReader();\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      return aggregateResponses(allResponses);\n    }\n    allResponses.push(value);\n  }\n}\nfunction aggregateResponses(responses) {\n  const lastResponse = responses.at(-1);\n  if (lastResponse === void 0) {\n    throw new Error(\n      \"Error aggregating stream chunks because the final response in stream chunk is undefined\"\n    );\n  }\n  const aggregatedResponse = {};\n  if (lastResponse.promptFeedback) {\n    aggregatedResponse.promptFeedback = lastResponse.promptFeedback;\n  }\n  for (const response of responses) {\n    for (const candidate of response.candidates ?? []) {\n      const index = candidate.index ?? 0;\n      if (!aggregatedResponse.candidates) {\n        aggregatedResponse.candidates = [];\n      }\n      if (!aggregatedResponse.candidates[index]) {\n        aggregatedResponse.candidates[index] = {\n          index\n        };\n      }\n      const aggregatedCandidate = aggregatedResponse.candidates[index];\n      aggregateMetadata(aggregatedCandidate, candidate, \"citationMetadata\");\n      aggregateMetadata(aggregatedCandidate, candidate, \"groundingMetadata\");\n      if (candidate.safetyRatings?.length) {\n        aggregatedCandidate.safetyRatings = (aggregatedCandidate.safetyRatings ?? []).concat(candidate.safetyRatings);\n      }\n      if (candidate.finishReason !== void 0) {\n        aggregatedCandidate.finishReason = candidate.finishReason;\n      }\n      if (candidate.finishMessage !== void 0) {\n        aggregatedCandidate.finishMessage = candidate.finishMessage;\n      }\n      if (candidate.avgLogprobs !== void 0) {\n        aggregatedCandidate.avgLogprobs = candidate.avgLogprobs;\n      }\n      if (candidate.logprobsResult !== void 0) {\n        aggregatedCandidate.logprobsResult = candidate.logprobsResult;\n      }\n      if (candidate.content && candidate.content.parts) {\n        if (!aggregatedCandidate.content) {\n          aggregatedCandidate.content = {\n            role: candidate.content.role || \"user\",\n            parts: []\n          };\n        }\n        for (const part of candidate.content.parts) {\n          const newPart = {};\n          if (part.thought) {\n            newPart.thought = part.thought;\n          }\n          if (part.text) {\n            newPart.text = part.text;\n          }\n          if (part.functionCall) {\n            newPart.functionCall = part.functionCall;\n          }\n          if (part.executableCode) {\n            newPart.executableCode = part.executableCode;\n          }\n          if (part.codeExecutionResult) {\n            newPart.codeExecutionResult = part.codeExecutionResult;\n          }\n          if (Object.keys(newPart).length === 0) {\n            newPart.text = \"\";\n          }\n          aggregatedCandidate.content.parts.push(newPart);\n        }\n      }\n    }\n    if (response.usageMetadata) {\n      aggregatedResponse.usageMetadata = response.usageMetadata;\n    }\n  }\n  return aggregatedResponse;\n}\nfunction aggregateMetadata(aggCandidate, chunkCandidate, fieldName) {\n  const chunkObj = chunkCandidate[fieldName];\n  const aggObj = aggCandidate[fieldName];\n  if (chunkObj === void 0) return;\n  if (aggObj === void 0) {\n    aggCandidate[fieldName] = chunkObj;\n    return;\n  }\n  if ((0, import_types.isObject)(chunkObj)) {\n    for (const k of Object.keys(chunkObj)) {\n      if (Array.isArray(aggObj[k]) && Array.isArray(chunkObj[k])) {\n        aggObj[k] = aggObj[k].concat(chunkObj[k]);\n      } else {\n        aggObj[k] = chunkObj[k] ?? aggObj[k];\n      }\n    }\n  }\n}\nfunction getGenkitClientHeader() {\n  if (process.env.MONOSPACE_ENV == \"true\") {\n    return (0, import_genkit.getClientHeader)() + \" firebase-studio-vm\";\n  }\n  return (0, import_genkit.getClientHeader)();\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2dvb2dsZS1nZW5haS9saWIvY29tbW9uL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLG1FQUFRO0FBQ3BDLG1CQUFtQixtQkFBTyxDQUFDLCtGQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNCQUFzQixLQUFLLGtCQUFrQiwwQkFBMEIsMEJBQTBCO0FBQ3hJLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxhQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGFBQWE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLDJEQUEyRCxTQUFTO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQWFMO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcS1JhbWFjaGFcXERvY3VtZW50c1xcU3VzdEFJbmV4IEdJdCBDb2RlXFxub2RlX21vZHVsZXNcXEBnZW5raXQtYWlcXGdvb2dsZS1nZW5haVxcbGliXFxjb21tb25cXHV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciB1dGlsc19leHBvcnRzID0ge307XG5fX2V4cG9ydCh1dGlsc19leHBvcnRzLCB7XG4gIGNoZWNrTW9kZWxOYW1lOiAoKSA9PiBjaGVja01vZGVsTmFtZSxcbiAgY2hlY2tTdXBwb3J0ZWRNaW1lVHlwZTogKCkgPT4gY2hlY2tTdXBwb3J0ZWRNaW1lVHlwZSxcbiAgY2xlYW5TY2hlbWE6ICgpID0+IGNsZWFuU2NoZW1hLFxuICBkaXNwbGF5VXJsOiAoKSA9PiBkaXNwbGF5VXJsLFxuICBleHRyYWN0RXJyTXNnOiAoKSA9PiBleHRyYWN0RXJyTXNnLFxuICBleHRyYWN0TWVkaWE6ICgpID0+IGV4dHJhY3RNZWRpYSxcbiAgZXh0cmFjdE1pbWVUeXBlOiAoKSA9PiBleHRyYWN0TWltZVR5cGUsXG4gIGV4dHJhY3RUZXh0OiAoKSA9PiBleHRyYWN0VGV4dCxcbiAgZXh0cmFjdFZlcnNpb246ICgpID0+IGV4dHJhY3RWZXJzaW9uLFxuICBnZXRHZW5raXRDbGllbnRIZWFkZXI6ICgpID0+IGdldEdlbmtpdENsaWVudEhlYWRlcixcbiAgbW9kZWxOYW1lOiAoKSA9PiBtb2RlbE5hbWUsXG4gIHByb2Nlc3NTdHJlYW06ICgpID0+IHByb2Nlc3NTdHJlYW1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlModXRpbHNfZXhwb3J0cyk7XG52YXIgaW1wb3J0X2dlbmtpdCA9IHJlcXVpcmUoXCJnZW5raXRcIik7XG52YXIgaW1wb3J0X3R5cGVzID0gcmVxdWlyZShcIi4vdHlwZXMuanNcIik7XG5mdW5jdGlvbiBleHRyYWN0RXJyTXNnKGUpIHtcbiAgbGV0IGVycm9yTWVzc2FnZSA9IFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZFwiO1xuICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgZXJyb3JNZXNzYWdlID0gZS5tZXNzYWdlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgZXJyb3JNZXNzYWdlID0gZTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoZSk7XG4gICAgfSBjYXRjaCAoc3RyaW5naWZ5RXJyb3IpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IFwiRmFpbGVkIHRvIHN0cmluZ2lmeSBlcnJvciBvYmplY3RcIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVycm9yTWVzc2FnZTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RWZXJzaW9uKG1vZGVsKSB7XG4gIHJldHVybiBtb2RlbC52ZXJzaW9uID8gbW9kZWwudmVyc2lvbiA6IGNoZWNrTW9kZWxOYW1lKG1vZGVsLm5hbWUpO1xufVxuZnVuY3Rpb24gbW9kZWxOYW1lKG5hbWUpIHtcbiAgaWYgKCFuYW1lKSByZXR1cm4gbmFtZTtcbiAgY29uc3QgcHJlZml4ZXNUb1JlbW92ZSA9IC9iYWNrZ3JvdW5kLW1vZGVsXFwvfG1vZGVsXFwvfG1vZGVsc1xcL3xlbWJlZGRlcnNcXC98Z29vZ2xlYWlcXC98dmVydGV4YWlcXC8vZztcbiAgcmV0dXJuIG5hbWUucmVwbGFjZShwcmVmaXhlc1RvUmVtb3ZlLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGNoZWNrTW9kZWxOYW1lKG5hbWUpIHtcbiAgY29uc3QgdmVyc2lvbiA9IG1vZGVsTmFtZShuYW1lKTtcbiAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IGltcG9ydF9nZW5raXQuR2Vua2l0RXJyb3Ioe1xuICAgICAgc3RhdHVzOiBcIklOVkFMSURfQVJHVU1FTlRcIixcbiAgICAgIG1lc3NhZ2U6IFwiTW9kZWwgbmFtZSBpcyByZXF1aXJlZC5cIlxuICAgIH0pO1xuICB9XG4gIHJldHVybiB2ZXJzaW9uO1xufVxuZnVuY3Rpb24gZXh0cmFjdFRleHQocmVxdWVzdCkge1xuICByZXR1cm4gcmVxdWVzdC5tZXNzYWdlcy5hdCgtMSk/LmNvbnRlbnQubWFwKChjKSA9PiBjLnRleHQgfHwgXCJcIikuam9pbihcIlwiKSA/PyBcIlwiO1xufVxuY29uc3QgS05PV05fTUlNRV9UWVBFUyA9IHtcbiAganBnOiBcImltYWdlL2pwZWdcIixcbiAganBlZzogXCJpbWFnZS9qcGVnXCIsXG4gIHBuZzogXCJpbWFnZS9wbmdcIixcbiAgbXA0OiBcInZpZGVvL21wNFwiLFxuICBwZGY6IFwiYXBwbGljYXRpb24vcGRmXCJcbn07XG5mdW5jdGlvbiBleHRyYWN0TWltZVR5cGUodXJsKSB7XG4gIGlmICghdXJsKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgY29uc3QgZGF0YVByZWZpeCA9IFwiZGF0YTpcIjtcbiAgaWYgKCF1cmwuc3RhcnRzV2l0aChkYXRhUHJlZml4KSkge1xuICAgIHVybC5sYXN0SW5kZXhPZihcIi5cIik7XG4gICAgY29uc3Qga2V5ID0gdXJsLnN1YnN0cmluZyh1cmwubGFzdEluZGV4T2YoXCIuXCIpICsgMSk7XG4gICAgaWYgKE9iamVjdC5rZXlzKEtOT1dOX01JTUVfVFlQRVMpLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIHJldHVybiBLTk9XTl9NSU1FX1RZUEVTW2tleV07XG4gICAgfVxuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGNvbnN0IGNvbW1hSW5kZXggPSB1cmwuaW5kZXhPZihcIixcIik7XG4gIGlmIChjb21tYUluZGV4ID09IC0xKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgbGV0IG1pbWVUeXBlID0gdXJsLnN1YnN0cmluZyhkYXRhUHJlZml4Lmxlbmd0aCwgY29tbWFJbmRleCk7XG4gIGNvbnN0IGJhc2U2NE1hcmtlciA9IFwiO2Jhc2U2NFwiO1xuICBpZiAobWltZVR5cGUuZW5kc1dpdGgoYmFzZTY0TWFya2VyKSkge1xuICAgIG1pbWVUeXBlID0gbWltZVR5cGUuc3Vic3RyaW5nKDAsIG1pbWVUeXBlLmxlbmd0aCAtIGJhc2U2NE1hcmtlci5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBtaW1lVHlwZS50cmltKCk7XG59XG5mdW5jdGlvbiBjaGVja1N1cHBvcnRlZE1pbWVUeXBlKG1lZGlhLCBzdXBwb3J0ZWRUeXBlcykge1xuICBpZiAoIXN1cHBvcnRlZFR5cGVzLmluY2x1ZGVzKG1lZGlhLmNvbnRlbnRUeXBlID8/IFwiXCIpKSB7XG4gICAgdGhyb3cgbmV3IGltcG9ydF9nZW5raXQuR2Vua2l0RXJyb3Ioe1xuICAgICAgc3RhdHVzOiBcIklOVkFMSURfQVJHVU1FTlRcIixcbiAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkIG1pbWVUeXBlIGZvciAke2Rpc3BsYXlVcmwobWVkaWEudXJsKX06IFwiJHttZWRpYS5jb250ZW50VHlwZX1cIi4gU3VwcG9ydGVkIG1pbWVUeXBlczogJHtzdXBwb3J0ZWRUeXBlcy5qb2luKFwiLCBcIil9YFxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBkaXNwbGF5VXJsKHVybCkge1xuICBpZiAodXJsLmxlbmd0aCA8PSA1MCkge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgcmV0dXJuIHVybC5zdWJzdHJpbmcoMCwgMjUpICsgXCIuLi5cIiArIHVybC5zdWJzdHJpbmcodXJsLmxlbmd0aCAtIDI1KTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RNZWRpYShyZXF1ZXN0LCBwYXJhbXMpIHtcbiAgY29uc3QgcHJlZGljYXRlID0gKHBhcnQpID0+IHtcbiAgICBjb25zdCBtZWRpYTIgPSBwYXJ0Lm1lZGlhO1xuICAgIGlmICghbWVkaWEyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwYXJhbXMubWV0YWRhdGFUeXBlIHx8IHBhcmFtcy5pc0RlZmF1bHQpIHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gcGFydC5tZXRhZGF0YTtcbiAgICAgIGlmICghbWV0YWRhdGE/LnR5cGUpIHtcbiAgICAgICAgcmV0dXJuICEhcGFyYW1zLmlzRGVmYXVsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YS50eXBlID09IHBhcmFtcy5tZXRhZGF0YVR5cGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICBjb25zdCBtZWRpYSA9IHJlcXVlc3QubWVzc2FnZXMuYXQoLTEpPy5jb250ZW50LmZpbmQocHJlZGljYXRlKT8ubWVkaWE7XG4gIGlmIChtZWRpYSAmJiAhbWVkaWE/LmNvbnRlbnRUeXBlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVybDogbWVkaWEudXJsLFxuICAgICAgY29udGVudFR5cGU6IGV4dHJhY3RNaW1lVHlwZShtZWRpYS51cmwpXG4gICAgfTtcbiAgfVxuICByZXR1cm4gbWVkaWE7XG59XG5mdW5jdGlvbiBjbGVhblNjaGVtYShzY2hlbWEpIHtcbiAgY29uc3Qgb3V0ID0gc3RydWN0dXJlZENsb25lKHNjaGVtYSk7XG4gIGZvciAoY29uc3Qga2V5IGluIG91dCkge1xuICAgIGlmIChrZXkgPT09IFwiJHNjaGVtYVwiIHx8IGtleSA9PT0gXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiKSB7XG4gICAgICBkZWxldGUgb3V0W2tleV07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvdXRba2V5XSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgb3V0W2tleV0gPSBjbGVhblNjaGVtYShvdXRba2V5XSk7XG4gICAgfVxuICAgIGlmIChrZXkgPT09IFwidHlwZVwiICYmIEFycmF5LmlzQXJyYXkob3V0W2tleV0pKSB7XG4gICAgICBvdXRba2V5XSA9IG91dFtrZXldLmZpbmQoKHQpID0+IHQgIT09IFwibnVsbFwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NTdHJlYW0ocmVzcG9uc2UpIHtcbiAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgcHJvY2Vzc2luZyBzdHJlYW0gYmVjYXVzZSByZXNwb25zZS5ib2R5IG5vdCBmb3VuZFwiKTtcbiAgfVxuICBjb25zdCBpbnB1dFN0cmVhbSA9IHJlc3BvbnNlLmJvZHkucGlwZVRocm91Z2goXG4gICAgbmV3IFRleHREZWNvZGVyU3RyZWFtKFwidXRmOFwiLCB7IGZhdGFsOiB0cnVlIH0pXG4gICk7XG4gIGNvbnN0IHJlc3BvbnNlU3RyZWFtID0gZ2V0UmVzcG9uc2VTdHJlYW0oaW5wdXRTdHJlYW0pO1xuICBjb25zdCBbc3RyZWFtMSwgc3RyZWFtMl0gPSByZXNwb25zZVN0cmVhbS50ZWUoKTtcbiAgcmV0dXJuIHtcbiAgICBzdHJlYW06IGdlbmVyYXRlUmVzcG9uc2VTZXF1ZW5jZShzdHJlYW0xKSxcbiAgICByZXNwb25zZTogZ2V0UmVzcG9uc2VQcm9taXNlKHN0cmVhbTIpXG4gIH07XG59XG5mdW5jdGlvbiBnZXRSZXNwb25zZVN0cmVhbShpbnB1dFN0cmVhbSkge1xuICBjb25zdCByZXNwb25zZUxpbmVSRSA9IC9eZGF0YTogKC4qKSg/OlxcblxcbnxcXHJcXHJ8XFxyXFxuXFxyXFxuKS87XG4gIGNvbnN0IHJlYWRlciA9IGlucHV0U3RyZWFtLmdldFJlYWRlcigpO1xuICBjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIGxldCBjdXJyZW50VGV4dCA9IFwiXCI7XG4gICAgICByZXR1cm4gcHVtcCgpO1xuICAgICAgZnVuY3Rpb24gcHVtcCgpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkKCkudGhlbigoeyB2YWx1ZSwgZG9uZSB9KSA9PiB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGV4dC50cmltKCkpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcGFyc2Ugc3RyZWFtXCIpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50VGV4dCArPSB2YWx1ZTtcbiAgICAgICAgICBsZXQgbWF0Y2ggPSBjdXJyZW50VGV4dC5tYXRjaChyZXNwb25zZUxpbmVSRSk7XG4gICAgICAgICAgbGV0IHBhcnNlZFJlc3BvbnNlO1xuICAgICAgICAgIHdoaWxlIChtYXRjaCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcGFyc2VkUmVzcG9uc2UgPSBKU09OLnBhcnNlKG1hdGNoWzFdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihcbiAgICAgICAgICAgICAgICBuZXcgRXJyb3IoYEVycm9yIHBhcnNpbmcgSlNPTiByZXNwb25zZTogXCIke21hdGNoWzFdfVwiYClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnNlZFJlc3BvbnNlKTtcbiAgICAgICAgICAgIGN1cnJlbnRUZXh0ID0gY3VycmVudFRleHQuc3Vic3RyaW5nKG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICBtYXRjaCA9IGN1cnJlbnRUZXh0Lm1hdGNoKHJlc3BvbnNlTGluZVJFKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHB1bXAoKTtcbiAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICBsZXQgZXJyID0gZTtcbiAgICAgICAgICBlcnIuc3RhY2sgPSBlLnN0YWNrO1xuICAgICAgICAgIGlmIChlcnIubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgICAgIGVyciA9IG5ldyBpbXBvcnRfZ2Vua2l0LkdlbmtpdEVycm9yKHtcbiAgICAgICAgICAgICAgc3RhdHVzOiBcIkFCT1JURURcIixcbiAgICAgICAgICAgICAgbWVzc2FnZTogXCJSZXF1ZXN0IGFib3J0ZWQgd2hlbiByZWFkaW5nIGZyb20gdGhlIHN0cmVhbVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyID0gbmV3IEVycm9yKFwiRXJyb3IgcmVhZGluZyBmcm9tIHRoZSBzdHJlYW1cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHN0cmVhbTtcbn1cbmFzeW5jIGZ1bmN0aW9uKiBnZW5lcmF0ZVJlc3BvbnNlU2VxdWVuY2Uoc3RyZWFtKSB7XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgeWllbGQgdmFsdWU7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFJlc3BvbnNlUHJvbWlzZShzdHJlYW0pIHtcbiAgY29uc3QgYWxsUmVzcG9uc2VzID0gW107XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICByZXR1cm4gYWdncmVnYXRlUmVzcG9uc2VzKGFsbFJlc3BvbnNlcyk7XG4gICAgfVxuICAgIGFsbFJlc3BvbnNlcy5wdXNoKHZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gYWdncmVnYXRlUmVzcG9uc2VzKHJlc3BvbnNlcykge1xuICBjb25zdCBsYXN0UmVzcG9uc2UgPSByZXNwb25zZXMuYXQoLTEpO1xuICBpZiAobGFzdFJlc3BvbnNlID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkVycm9yIGFnZ3JlZ2F0aW5nIHN0cmVhbSBjaHVua3MgYmVjYXVzZSB0aGUgZmluYWwgcmVzcG9uc2UgaW4gc3RyZWFtIGNodW5rIGlzIHVuZGVmaW5lZFwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBhZ2dyZWdhdGVkUmVzcG9uc2UgPSB7fTtcbiAgaWYgKGxhc3RSZXNwb25zZS5wcm9tcHRGZWVkYmFjaykge1xuICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZS5wcm9tcHRGZWVkYmFjayA9IGxhc3RSZXNwb25zZS5wcm9tcHRGZWVkYmFjaztcbiAgfVxuICBmb3IgKGNvbnN0IHJlc3BvbnNlIG9mIHJlc3BvbnNlcykge1xuICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIHJlc3BvbnNlLmNhbmRpZGF0ZXMgPz8gW10pIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gY2FuZGlkYXRlLmluZGV4ID8/IDA7XG4gICAgICBpZiAoIWFnZ3JlZ2F0ZWRSZXNwb25zZS5jYW5kaWRhdGVzKSB7XG4gICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZS5jYW5kaWRhdGVzID0gW107XG4gICAgICB9XG4gICAgICBpZiAoIWFnZ3JlZ2F0ZWRSZXNwb25zZS5jYW5kaWRhdGVzW2luZGV4XSkge1xuICAgICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UuY2FuZGlkYXRlc1tpbmRleF0gPSB7XG4gICAgICAgICAgaW5kZXhcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFnZ3JlZ2F0ZWRDYW5kaWRhdGUgPSBhZ2dyZWdhdGVkUmVzcG9uc2UuY2FuZGlkYXRlc1tpbmRleF07XG4gICAgICBhZ2dyZWdhdGVNZXRhZGF0YShhZ2dyZWdhdGVkQ2FuZGlkYXRlLCBjYW5kaWRhdGUsIFwiY2l0YXRpb25NZXRhZGF0YVwiKTtcbiAgICAgIGFnZ3JlZ2F0ZU1ldGFkYXRhKGFnZ3JlZ2F0ZWRDYW5kaWRhdGUsIGNhbmRpZGF0ZSwgXCJncm91bmRpbmdNZXRhZGF0YVwiKTtcbiAgICAgIGlmIChjYW5kaWRhdGUuc2FmZXR5UmF0aW5ncz8ubGVuZ3RoKSB7XG4gICAgICAgIGFnZ3JlZ2F0ZWRDYW5kaWRhdGUuc2FmZXR5UmF0aW5ncyA9IChhZ2dyZWdhdGVkQ2FuZGlkYXRlLnNhZmV0eVJhdGluZ3MgPz8gW10pLmNvbmNhdChjYW5kaWRhdGUuc2FmZXR5UmF0aW5ncyk7XG4gICAgICB9XG4gICAgICBpZiAoY2FuZGlkYXRlLmZpbmlzaFJlYXNvbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGFnZ3JlZ2F0ZWRDYW5kaWRhdGUuZmluaXNoUmVhc29uID0gY2FuZGlkYXRlLmZpbmlzaFJlYXNvbjtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5kaWRhdGUuZmluaXNoTWVzc2FnZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGFnZ3JlZ2F0ZWRDYW5kaWRhdGUuZmluaXNoTWVzc2FnZSA9IGNhbmRpZGF0ZS5maW5pc2hNZXNzYWdlO1xuICAgICAgfVxuICAgICAgaWYgKGNhbmRpZGF0ZS5hdmdMb2dwcm9icyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGFnZ3JlZ2F0ZWRDYW5kaWRhdGUuYXZnTG9ncHJvYnMgPSBjYW5kaWRhdGUuYXZnTG9ncHJvYnM7XG4gICAgICB9XG4gICAgICBpZiAoY2FuZGlkYXRlLmxvZ3Byb2JzUmVzdWx0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgYWdncmVnYXRlZENhbmRpZGF0ZS5sb2dwcm9ic1Jlc3VsdCA9IGNhbmRpZGF0ZS5sb2dwcm9ic1Jlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5kaWRhdGUuY29udGVudCAmJiBjYW5kaWRhdGUuY29udGVudC5wYXJ0cykge1xuICAgICAgICBpZiAoIWFnZ3JlZ2F0ZWRDYW5kaWRhdGUuY29udGVudCkge1xuICAgICAgICAgIGFnZ3JlZ2F0ZWRDYW5kaWRhdGUuY29udGVudCA9IHtcbiAgICAgICAgICAgIHJvbGU6IGNhbmRpZGF0ZS5jb250ZW50LnJvbGUgfHwgXCJ1c2VyXCIsXG4gICAgICAgICAgICBwYXJ0czogW11cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBjYW5kaWRhdGUuY29udGVudC5wYXJ0cykge1xuICAgICAgICAgIGNvbnN0IG5ld1BhcnQgPSB7fTtcbiAgICAgICAgICBpZiAocGFydC50aG91Z2h0KSB7XG4gICAgICAgICAgICBuZXdQYXJ0LnRob3VnaHQgPSBwYXJ0LnRob3VnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJ0LnRleHQpIHtcbiAgICAgICAgICAgIG5ld1BhcnQudGV4dCA9IHBhcnQudGV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhcnQuZnVuY3Rpb25DYWxsKSB7XG4gICAgICAgICAgICBuZXdQYXJ0LmZ1bmN0aW9uQ2FsbCA9IHBhcnQuZnVuY3Rpb25DYWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFydC5leGVjdXRhYmxlQ29kZSkge1xuICAgICAgICAgICAgbmV3UGFydC5leGVjdXRhYmxlQ29kZSA9IHBhcnQuZXhlY3V0YWJsZUNvZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJ0LmNvZGVFeGVjdXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgIG5ld1BhcnQuY29kZUV4ZWN1dGlvblJlc3VsdCA9IHBhcnQuY29kZUV4ZWN1dGlvblJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG5ld1BhcnQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbmV3UGFydC50ZXh0ID0gXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWdncmVnYXRlZENhbmRpZGF0ZS5jb250ZW50LnBhcnRzLnB1c2gobmV3UGFydCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLnVzYWdlTWV0YWRhdGEpIHtcbiAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZS51c2FnZU1ldGFkYXRhID0gcmVzcG9uc2UudXNhZ2VNZXRhZGF0YTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFnZ3JlZ2F0ZWRSZXNwb25zZTtcbn1cbmZ1bmN0aW9uIGFnZ3JlZ2F0ZU1ldGFkYXRhKGFnZ0NhbmRpZGF0ZSwgY2h1bmtDYW5kaWRhdGUsIGZpZWxkTmFtZSkge1xuICBjb25zdCBjaHVua09iaiA9IGNodW5rQ2FuZGlkYXRlW2ZpZWxkTmFtZV07XG4gIGNvbnN0IGFnZ09iaiA9IGFnZ0NhbmRpZGF0ZVtmaWVsZE5hbWVdO1xuICBpZiAoY2h1bmtPYmogPT09IHZvaWQgMCkgcmV0dXJuO1xuICBpZiAoYWdnT2JqID09PSB2b2lkIDApIHtcbiAgICBhZ2dDYW5kaWRhdGVbZmllbGROYW1lXSA9IGNodW5rT2JqO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoKDAsIGltcG9ydF90eXBlcy5pc09iamVjdCkoY2h1bmtPYmopKSB7XG4gICAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKGNodW5rT2JqKSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYWdnT2JqW2tdKSAmJiBBcnJheS5pc0FycmF5KGNodW5rT2JqW2tdKSkge1xuICAgICAgICBhZ2dPYmpba10gPSBhZ2dPYmpba10uY29uY2F0KGNodW5rT2JqW2tdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFnZ09ialtrXSA9IGNodW5rT2JqW2tdID8/IGFnZ09ialtrXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEdlbmtpdENsaWVudEhlYWRlcigpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk1PTk9TUEFDRV9FTlYgPT0gXCJ0cnVlXCIpIHtcbiAgICByZXR1cm4gKDAsIGltcG9ydF9nZW5raXQuZ2V0Q2xpZW50SGVhZGVyKSgpICsgXCIgZmlyZWJhc2Utc3R1ZGlvLXZtXCI7XG4gIH1cbiAgcmV0dXJuICgwLCBpbXBvcnRfZ2Vua2l0LmdldENsaWVudEhlYWRlcikoKTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBjaGVja01vZGVsTmFtZSxcbiAgY2hlY2tTdXBwb3J0ZWRNaW1lVHlwZSxcbiAgY2xlYW5TY2hlbWEsXG4gIGRpc3BsYXlVcmwsXG4gIGV4dHJhY3RFcnJNc2csXG4gIGV4dHJhY3RNZWRpYSxcbiAgZXh0cmFjdE1pbWVUeXBlLFxuICBleHRyYWN0VGV4dCxcbiAgZXh0cmFjdFZlcnNpb24sXG4gIGdldEdlbmtpdENsaWVudEhlYWRlcixcbiAgbW9kZWxOYW1lLFxuICBwcm9jZXNzU3RyZWFtXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/google-genai/lib/common/utils.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/client.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@genkit-ai/google-genai/lib/googleai/client.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar client_exports = {};\n__export(client_exports, {\n  TEST_ONLY: () => TEST_ONLY,\n  embedContent: () => embedContent,\n  generateContent: () => generateContent,\n  generateContentStream: () => generateContentStream,\n  getGoogleAIUrl: () => getGoogleAIUrl,\n  imagenPredict: () => imagenPredict,\n  listModels: () => listModels,\n  veoCheckOperation: () => veoCheckOperation,\n  veoPredict: () => veoPredict\n});\nmodule.exports = __toCommonJS(client_exports);\nvar import_utils = __webpack_require__(/*! ../common/utils.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/common/utils.js\");\nasync function listModels(apiKey, clientOptions) {\n  const url = getGoogleAIUrl({\n    resourcePath: \"models\",\n    queryParams: \"pageSize=1000\",\n    clientOptions\n  });\n  const fetchOptions = getFetchOptions({\n    method: \"GET\",\n    apiKey,\n    clientOptions\n  });\n  const response = await makeRequest(url, fetchOptions);\n  const modelResponse = JSON.parse(await response.text());\n  return modelResponse.models;\n}\nasync function generateContent(apiKey, model, generateContentRequest, clientOptions) {\n  const url = getGoogleAIUrl({\n    resourcePath: `models/${model}`,\n    resourceMethod: \"generateContent\",\n    clientOptions\n  });\n  const fetchOptions = getFetchOptions({\n    method: \"POST\",\n    apiKey,\n    clientOptions,\n    body: JSON.stringify(generateContentRequest)\n  });\n  const response = await makeRequest(url, fetchOptions);\n  const responseJson = await response.json();\n  return responseJson;\n}\nasync function generateContentStream(apiKey, model, generateContentRequest, clientOptions) {\n  const url = getGoogleAIUrl({\n    resourcePath: `models/${model}`,\n    resourceMethod: \"streamGenerateContent\",\n    clientOptions\n  });\n  const fetchOptions = getFetchOptions({\n    method: \"POST\",\n    apiKey,\n    clientOptions,\n    body: JSON.stringify(generateContentRequest)\n  });\n  const response = await makeRequest(url, fetchOptions);\n  return (0, import_utils.processStream)(response);\n}\nasync function embedContent(apiKey, model, embedContentRequest, clientOptions) {\n  const url = getGoogleAIUrl({\n    resourcePath: `models/${model}`,\n    resourceMethod: \"embedContent\",\n    clientOptions\n  });\n  const fetchOptions = getFetchOptions({\n    method: \"POST\",\n    apiKey,\n    clientOptions,\n    body: JSON.stringify(embedContentRequest)\n  });\n  const response = await makeRequest(url, fetchOptions);\n  return response.json();\n}\nasync function imagenPredict(apiKey, model, imagenPredictRequest, clientOptions) {\n  const url = getGoogleAIUrl({\n    resourcePath: `models/${model}`,\n    resourceMethod: \"predict\",\n    clientOptions\n  });\n  const fetchOptions = getFetchOptions({\n    method: \"POST\",\n    apiKey,\n    clientOptions,\n    body: JSON.stringify(imagenPredictRequest)\n  });\n  const response = await makeRequest(url, fetchOptions);\n  return response.json();\n}\nasync function veoPredict(apiKey, model, veoPredictRequest, clientOptions) {\n  const url = getGoogleAIUrl({\n    resourcePath: `models/${model}`,\n    resourceMethod: \"predictLongRunning\",\n    clientOptions\n  });\n  const fetchOptions = getFetchOptions({\n    method: \"POST\",\n    apiKey,\n    clientOptions,\n    body: JSON.stringify(veoPredictRequest)\n  });\n  const response = await makeRequest(url, fetchOptions);\n  return response.json();\n}\nasync function veoCheckOperation(apiKey, operation, clientOptions) {\n  const url = getGoogleAIUrl({\n    resourcePath: operation,\n    clientOptions\n  });\n  const fetchOptions = getFetchOptions({\n    method: \"GET\",\n    apiKey,\n    clientOptions\n  });\n  const response = await makeRequest(url, fetchOptions);\n  return response.json();\n}\nfunction getGoogleAIUrl(params) {\n  const DEFAULT_API_VERSION = \"v1beta\";\n  const DEFAULT_BASE_URL = \"https://generativelanguage.googleapis.com\";\n  const apiVersion = params.clientOptions?.apiVersion || DEFAULT_API_VERSION;\n  const baseUrl = params.clientOptions?.baseUrl || DEFAULT_BASE_URL;\n  let url = `${baseUrl}/${apiVersion}/${params.resourcePath}`;\n  if (params.resourceMethod) {\n    url += `:${params.resourceMethod}`;\n  }\n  if (params.queryParams) {\n    url += `?${params.queryParams}`;\n  }\n  if (params.resourceMethod === \"streamGenerateContent\") {\n    url += `${params.queryParams ? \"&\" : \"?\"}alt=sse`;\n  }\n  return url;\n}\nfunction getFetchOptions(params) {\n  const fetchOptions = {\n    method: params.method,\n    headers: getHeaders(params.apiKey, params.clientOptions)\n  };\n  if (params.body) {\n    fetchOptions.body = params.body;\n  }\n  const signal = getAbortSignal(params.clientOptions);\n  if (signal) {\n    fetchOptions.signal = signal;\n  }\n  return fetchOptions;\n}\nfunction getAbortSignal(clientOptions) {\n  const hasTimeout = (clientOptions?.timeout ?? -1) >= 0;\n  if (clientOptions?.signal !== void 0 || hasTimeout) {\n    const controller = new AbortController();\n    if (hasTimeout) {\n      setTimeout(() => controller.abort(), clientOptions?.timeout);\n    }\n    if (clientOptions?.signal) {\n      clientOptions.signal.addEventListener(\"abort\", () => {\n        controller.abort();\n      });\n    }\n    return controller.signal;\n  }\n  return void 0;\n}\nfunction getHeaders(apiKey, clientOptions) {\n  let customHeaders = {};\n  if (clientOptions?.customHeaders) {\n    customHeaders = structuredClone(clientOptions.customHeaders);\n    delete customHeaders[\"x-goog-api-key\"];\n    delete customHeaders[\"x-goog-api-client\"];\n  }\n  const headers = {\n    ...customHeaders,\n    \"Content-Type\": \"application/json\",\n    \"x-goog-api-key\": apiKey,\n    \"x-goog-api-client\": (0, import_utils.getGenkitClientHeader)()\n  };\n  return headers;\n}\nasync function makeRequest(url, fetchOptions) {\n  try {\n    const response = await fetch(url, fetchOptions);\n    if (!response.ok) {\n      let errorText = await response.text();\n      let errorMessage = errorText;\n      try {\n        const json = JSON.parse(errorText);\n        if (json.error && json.error.message) {\n          errorMessage = json.error.message;\n        }\n      } catch (e) {\n      }\n      throw new Error(\n        `Error fetching from ${url}: [${response.status} ${response.statusText}] ${errorMessage}`\n      );\n    }\n    return response;\n  } catch (e) {\n    console.error(e);\n    throw new Error(`Failed to fetch from ${url}: ${(0, import_utils.extractErrMsg)(e)}`);\n  }\n}\nconst TEST_ONLY = {\n  getFetchOptions,\n  getAbortSignal,\n  getHeaders,\n  makeRequest\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2dvb2dsZS1nZW5haS9saWIvZ29vZ2xlYWkvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLHVHQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUSxHQUFHLFdBQVcsR0FBRyxvQkFBb0I7QUFDNUQ7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBLGNBQWMsK0JBQStCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsK0JBQStCLElBQUksS0FBSyxpQkFBaUIsRUFBRSxvQkFBb0IsSUFBSSxhQUFhO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLDRDQUE0QyxJQUFJLElBQUksbUNBQW1DO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FVTDtBQUNEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEtSYW1hY2hhXFxEb2N1bWVudHNcXFN1c3RBSW5leCBHSXQgQ29kZVxcbm9kZV9tb2R1bGVzXFxAZ2Vua2l0LWFpXFxnb29nbGUtZ2VuYWlcXGxpYlxcZ29vZ2xlYWlcXGNsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgY2xpZW50X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNsaWVudF9leHBvcnRzLCB7XG4gIFRFU1RfT05MWTogKCkgPT4gVEVTVF9PTkxZLFxuICBlbWJlZENvbnRlbnQ6ICgpID0+IGVtYmVkQ29udGVudCxcbiAgZ2VuZXJhdGVDb250ZW50OiAoKSA9PiBnZW5lcmF0ZUNvbnRlbnQsXG4gIGdlbmVyYXRlQ29udGVudFN0cmVhbTogKCkgPT4gZ2VuZXJhdGVDb250ZW50U3RyZWFtLFxuICBnZXRHb29nbGVBSVVybDogKCkgPT4gZ2V0R29vZ2xlQUlVcmwsXG4gIGltYWdlblByZWRpY3Q6ICgpID0+IGltYWdlblByZWRpY3QsXG4gIGxpc3RNb2RlbHM6ICgpID0+IGxpc3RNb2RlbHMsXG4gIHZlb0NoZWNrT3BlcmF0aW9uOiAoKSA9PiB2ZW9DaGVja09wZXJhdGlvbixcbiAgdmVvUHJlZGljdDogKCkgPT4gdmVvUHJlZGljdFxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhjbGllbnRfZXhwb3J0cyk7XG52YXIgaW1wb3J0X3V0aWxzID0gcmVxdWlyZShcIi4uL2NvbW1vbi91dGlscy5qc1wiKTtcbmFzeW5jIGZ1bmN0aW9uIGxpc3RNb2RlbHMoYXBpS2V5LCBjbGllbnRPcHRpb25zKSB7XG4gIGNvbnN0IHVybCA9IGdldEdvb2dsZUFJVXJsKHtcbiAgICByZXNvdXJjZVBhdGg6IFwibW9kZWxzXCIsXG4gICAgcXVlcnlQYXJhbXM6IFwicGFnZVNpemU9MTAwMFwiLFxuICAgIGNsaWVudE9wdGlvbnNcbiAgfSk7XG4gIGNvbnN0IGZldGNoT3B0aW9ucyA9IGdldEZldGNoT3B0aW9ucyh7XG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGFwaUtleSxcbiAgICBjbGllbnRPcHRpb25zXG4gIH0pO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG1ha2VSZXF1ZXN0KHVybCwgZmV0Y2hPcHRpb25zKTtcbiAgY29uc3QgbW9kZWxSZXNwb25zZSA9IEpTT04ucGFyc2UoYXdhaXQgcmVzcG9uc2UudGV4dCgpKTtcbiAgcmV0dXJuIG1vZGVsUmVzcG9uc2UubW9kZWxzO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50KGFwaUtleSwgbW9kZWwsIGdlbmVyYXRlQ29udGVudFJlcXVlc3QsIGNsaWVudE9wdGlvbnMpIHtcbiAgY29uc3QgdXJsID0gZ2V0R29vZ2xlQUlVcmwoe1xuICAgIHJlc291cmNlUGF0aDogYG1vZGVscy8ke21vZGVsfWAsXG4gICAgcmVzb3VyY2VNZXRob2Q6IFwiZ2VuZXJhdGVDb250ZW50XCIsXG4gICAgY2xpZW50T3B0aW9uc1xuICB9KTtcbiAgY29uc3QgZmV0Y2hPcHRpb25zID0gZ2V0RmV0Y2hPcHRpb25zKHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGFwaUtleSxcbiAgICBjbGllbnRPcHRpb25zLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGdlbmVyYXRlQ29udGVudFJlcXVlc3QpXG4gIH0pO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG1ha2VSZXF1ZXN0KHVybCwgZmV0Y2hPcHRpb25zKTtcbiAgY29uc3QgcmVzcG9uc2VKc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICByZXR1cm4gcmVzcG9uc2VKc29uO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50U3RyZWFtKGFwaUtleSwgbW9kZWwsIGdlbmVyYXRlQ29udGVudFJlcXVlc3QsIGNsaWVudE9wdGlvbnMpIHtcbiAgY29uc3QgdXJsID0gZ2V0R29vZ2xlQUlVcmwoe1xuICAgIHJlc291cmNlUGF0aDogYG1vZGVscy8ke21vZGVsfWAsXG4gICAgcmVzb3VyY2VNZXRob2Q6IFwic3RyZWFtR2VuZXJhdGVDb250ZW50XCIsXG4gICAgY2xpZW50T3B0aW9uc1xuICB9KTtcbiAgY29uc3QgZmV0Y2hPcHRpb25zID0gZ2V0RmV0Y2hPcHRpb25zKHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGFwaUtleSxcbiAgICBjbGllbnRPcHRpb25zLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGdlbmVyYXRlQ29udGVudFJlcXVlc3QpXG4gIH0pO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG1ha2VSZXF1ZXN0KHVybCwgZmV0Y2hPcHRpb25zKTtcbiAgcmV0dXJuICgwLCBpbXBvcnRfdXRpbHMucHJvY2Vzc1N0cmVhbSkocmVzcG9uc2UpO1xufVxuYXN5bmMgZnVuY3Rpb24gZW1iZWRDb250ZW50KGFwaUtleSwgbW9kZWwsIGVtYmVkQ29udGVudFJlcXVlc3QsIGNsaWVudE9wdGlvbnMpIHtcbiAgY29uc3QgdXJsID0gZ2V0R29vZ2xlQUlVcmwoe1xuICAgIHJlc291cmNlUGF0aDogYG1vZGVscy8ke21vZGVsfWAsXG4gICAgcmVzb3VyY2VNZXRob2Q6IFwiZW1iZWRDb250ZW50XCIsXG4gICAgY2xpZW50T3B0aW9uc1xuICB9KTtcbiAgY29uc3QgZmV0Y2hPcHRpb25zID0gZ2V0RmV0Y2hPcHRpb25zKHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGFwaUtleSxcbiAgICBjbGllbnRPcHRpb25zLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGVtYmVkQ29udGVudFJlcXVlc3QpXG4gIH0pO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG1ha2VSZXF1ZXN0KHVybCwgZmV0Y2hPcHRpb25zKTtcbiAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGltYWdlblByZWRpY3QoYXBpS2V5LCBtb2RlbCwgaW1hZ2VuUHJlZGljdFJlcXVlc3QsIGNsaWVudE9wdGlvbnMpIHtcbiAgY29uc3QgdXJsID0gZ2V0R29vZ2xlQUlVcmwoe1xuICAgIHJlc291cmNlUGF0aDogYG1vZGVscy8ke21vZGVsfWAsXG4gICAgcmVzb3VyY2VNZXRob2Q6IFwicHJlZGljdFwiLFxuICAgIGNsaWVudE9wdGlvbnNcbiAgfSk7XG4gIGNvbnN0IGZldGNoT3B0aW9ucyA9IGdldEZldGNoT3B0aW9ucyh7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBhcGlLZXksXG4gICAgY2xpZW50T3B0aW9ucyxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeShpbWFnZW5QcmVkaWN0UmVxdWVzdClcbiAgfSk7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbWFrZVJlcXVlc3QodXJsLCBmZXRjaE9wdGlvbnMpO1xuICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xufVxuYXN5bmMgZnVuY3Rpb24gdmVvUHJlZGljdChhcGlLZXksIG1vZGVsLCB2ZW9QcmVkaWN0UmVxdWVzdCwgY2xpZW50T3B0aW9ucykge1xuICBjb25zdCB1cmwgPSBnZXRHb29nbGVBSVVybCh7XG4gICAgcmVzb3VyY2VQYXRoOiBgbW9kZWxzLyR7bW9kZWx9YCxcbiAgICByZXNvdXJjZU1ldGhvZDogXCJwcmVkaWN0TG9uZ1J1bm5pbmdcIixcbiAgICBjbGllbnRPcHRpb25zXG4gIH0pO1xuICBjb25zdCBmZXRjaE9wdGlvbnMgPSBnZXRGZXRjaE9wdGlvbnMoe1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYXBpS2V5LFxuICAgIGNsaWVudE9wdGlvbnMsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkodmVvUHJlZGljdFJlcXVlc3QpXG4gIH0pO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG1ha2VSZXF1ZXN0KHVybCwgZmV0Y2hPcHRpb25zKTtcbiAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHZlb0NoZWNrT3BlcmF0aW9uKGFwaUtleSwgb3BlcmF0aW9uLCBjbGllbnRPcHRpb25zKSB7XG4gIGNvbnN0IHVybCA9IGdldEdvb2dsZUFJVXJsKHtcbiAgICByZXNvdXJjZVBhdGg6IG9wZXJhdGlvbixcbiAgICBjbGllbnRPcHRpb25zXG4gIH0pO1xuICBjb25zdCBmZXRjaE9wdGlvbnMgPSBnZXRGZXRjaE9wdGlvbnMoe1xuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBhcGlLZXksXG4gICAgY2xpZW50T3B0aW9uc1xuICB9KTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtYWtlUmVxdWVzdCh1cmwsIGZldGNoT3B0aW9ucyk7XG4gIHJldHVybiByZXNwb25zZS5qc29uKCk7XG59XG5mdW5jdGlvbiBnZXRHb29nbGVBSVVybChwYXJhbXMpIHtcbiAgY29uc3QgREVGQVVMVF9BUElfVkVSU0lPTiA9IFwidjFiZXRhXCI7XG4gIGNvbnN0IERFRkFVTFRfQkFTRV9VUkwgPSBcImh0dHBzOi8vZ2VuZXJhdGl2ZWxhbmd1YWdlLmdvb2dsZWFwaXMuY29tXCI7XG4gIGNvbnN0IGFwaVZlcnNpb24gPSBwYXJhbXMuY2xpZW50T3B0aW9ucz8uYXBpVmVyc2lvbiB8fCBERUZBVUxUX0FQSV9WRVJTSU9OO1xuICBjb25zdCBiYXNlVXJsID0gcGFyYW1zLmNsaWVudE9wdGlvbnM/LmJhc2VVcmwgfHwgREVGQVVMVF9CQVNFX1VSTDtcbiAgbGV0IHVybCA9IGAke2Jhc2VVcmx9LyR7YXBpVmVyc2lvbn0vJHtwYXJhbXMucmVzb3VyY2VQYXRofWA7XG4gIGlmIChwYXJhbXMucmVzb3VyY2VNZXRob2QpIHtcbiAgICB1cmwgKz0gYDoke3BhcmFtcy5yZXNvdXJjZU1ldGhvZH1gO1xuICB9XG4gIGlmIChwYXJhbXMucXVlcnlQYXJhbXMpIHtcbiAgICB1cmwgKz0gYD8ke3BhcmFtcy5xdWVyeVBhcmFtc31gO1xuICB9XG4gIGlmIChwYXJhbXMucmVzb3VyY2VNZXRob2QgPT09IFwic3RyZWFtR2VuZXJhdGVDb250ZW50XCIpIHtcbiAgICB1cmwgKz0gYCR7cGFyYW1zLnF1ZXJ5UGFyYW1zID8gXCImXCIgOiBcIj9cIn1hbHQ9c3NlYDtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuZnVuY3Rpb24gZ2V0RmV0Y2hPcHRpb25zKHBhcmFtcykge1xuICBjb25zdCBmZXRjaE9wdGlvbnMgPSB7XG4gICAgbWV0aG9kOiBwYXJhbXMubWV0aG9kLFxuICAgIGhlYWRlcnM6IGdldEhlYWRlcnMocGFyYW1zLmFwaUtleSwgcGFyYW1zLmNsaWVudE9wdGlvbnMpXG4gIH07XG4gIGlmIChwYXJhbXMuYm9keSkge1xuICAgIGZldGNoT3B0aW9ucy5ib2R5ID0gcGFyYW1zLmJvZHk7XG4gIH1cbiAgY29uc3Qgc2lnbmFsID0gZ2V0QWJvcnRTaWduYWwocGFyYW1zLmNsaWVudE9wdGlvbnMpO1xuICBpZiAoc2lnbmFsKSB7XG4gICAgZmV0Y2hPcHRpb25zLnNpZ25hbCA9IHNpZ25hbDtcbiAgfVxuICByZXR1cm4gZmV0Y2hPcHRpb25zO1xufVxuZnVuY3Rpb24gZ2V0QWJvcnRTaWduYWwoY2xpZW50T3B0aW9ucykge1xuICBjb25zdCBoYXNUaW1lb3V0ID0gKGNsaWVudE9wdGlvbnM/LnRpbWVvdXQgPz8gLTEpID49IDA7XG4gIGlmIChjbGllbnRPcHRpb25zPy5zaWduYWwgIT09IHZvaWQgMCB8fCBoYXNUaW1lb3V0KSB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBpZiAoaGFzVGltZW91dCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIGNsaWVudE9wdGlvbnM/LnRpbWVvdXQpO1xuICAgIH1cbiAgICBpZiAoY2xpZW50T3B0aW9ucz8uc2lnbmFsKSB7XG4gICAgICBjbGllbnRPcHRpb25zLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyb2xsZXIuc2lnbmFsO1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5mdW5jdGlvbiBnZXRIZWFkZXJzKGFwaUtleSwgY2xpZW50T3B0aW9ucykge1xuICBsZXQgY3VzdG9tSGVhZGVycyA9IHt9O1xuICBpZiAoY2xpZW50T3B0aW9ucz8uY3VzdG9tSGVhZGVycykge1xuICAgIGN1c3RvbUhlYWRlcnMgPSBzdHJ1Y3R1cmVkQ2xvbmUoY2xpZW50T3B0aW9ucy5jdXN0b21IZWFkZXJzKTtcbiAgICBkZWxldGUgY3VzdG9tSGVhZGVyc1tcIngtZ29vZy1hcGkta2V5XCJdO1xuICAgIGRlbGV0ZSBjdXN0b21IZWFkZXJzW1wieC1nb29nLWFwaS1jbGllbnRcIl07XG4gIH1cbiAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAuLi5jdXN0b21IZWFkZXJzLFxuICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIFwieC1nb29nLWFwaS1rZXlcIjogYXBpS2V5LFxuICAgIFwieC1nb29nLWFwaS1jbGllbnRcIjogKDAsIGltcG9ydF91dGlscy5nZXRHZW5raXRDbGllbnRIZWFkZXIpKClcbiAgfTtcbiAgcmV0dXJuIGhlYWRlcnM7XG59XG5hc3luYyBmdW5jdGlvbiBtYWtlUmVxdWVzdCh1cmwsIGZldGNoT3B0aW9ucykge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCBmZXRjaE9wdGlvbnMpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGxldCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICBsZXQgZXJyb3JNZXNzYWdlID0gZXJyb3JUZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UoZXJyb3JUZXh0KTtcbiAgICAgICAgaWYgKGpzb24uZXJyb3IgJiYganNvbi5lcnJvci5tZXNzYWdlKSB7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlID0ganNvbi5lcnJvci5tZXNzYWdlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBFcnJvciBmZXRjaGluZyBmcm9tICR7dXJsfTogWyR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9XSAke2Vycm9yTWVzc2FnZX1gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIGZyb20gJHt1cmx9OiAkeygwLCBpbXBvcnRfdXRpbHMuZXh0cmFjdEVyck1zZykoZSl9YCk7XG4gIH1cbn1cbmNvbnN0IFRFU1RfT05MWSA9IHtcbiAgZ2V0RmV0Y2hPcHRpb25zLFxuICBnZXRBYm9ydFNpZ25hbCxcbiAgZ2V0SGVhZGVycyxcbiAgbWFrZVJlcXVlc3Rcbn07XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgVEVTVF9PTkxZLFxuICBlbWJlZENvbnRlbnQsXG4gIGdlbmVyYXRlQ29udGVudCxcbiAgZ2VuZXJhdGVDb250ZW50U3RyZWFtLFxuICBnZXRHb29nbGVBSVVybCxcbiAgaW1hZ2VuUHJlZGljdCxcbiAgbGlzdE1vZGVscyxcbiAgdmVvQ2hlY2tPcGVyYXRpb24sXG4gIHZlb1ByZWRpY3Rcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/client.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/embedder.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@genkit-ai/google-genai/lib/googleai/embedder.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar embedder_exports = {};\n__export(embedder_exports, {\n  EmbeddingConfigSchema: () => EmbeddingConfigSchema,\n  TEST_ONLY: () => TEST_ONLY,\n  defineEmbedder: () => defineEmbedder,\n  defineKnownModels: () => defineKnownModels,\n  listActions: () => listActions,\n  model: () => model\n});\nmodule.exports = __toCommonJS(embedder_exports);\nvar import_genkit = __webpack_require__(/*! genkit */ \"(action-browser)/./node_modules/genkit/lib/index.js\");\nvar import_embedder = __webpack_require__(/*! genkit/embedder */ \"(action-browser)/./node_modules/genkit/lib/embedder.js\");\nvar import_client = __webpack_require__(/*! ./client.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/client.js\");\nvar import_types = __webpack_require__(/*! ./types.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/types.js\");\nvar import_utils = __webpack_require__(/*! ./utils.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/utils.js\");\nconst EmbeddingConfigSchema = import_genkit.z.object({\n  /** Override the API key provided at plugin initialization. */\n  apiKey: import_genkit.z.string().optional(),\n  /**\n   * The `task_type` parameter is defined as the intended downstream application to help the model\n   * produce better quality embeddings.\n   **/\n  taskType: import_types.TaskTypeSchema.optional(),\n  title: import_genkit.z.string().optional(),\n  version: import_genkit.z.string().optional(),\n  /**\n   * The `outputDimensionality` parameter allows you to specify the dimensionality of the embedding output.\n   * By default, the model generates embeddings with 768 dimensions. Models such as\n   * `text-embedding-004`, `text-embedding-005`, and `text-multilingual-embedding-002`\n   * allow the output dimensionality to be adjusted between 1 and 768.\n   * By selecting a smaller output dimensionality, users can save memory and storage space, leading to more efficient computations.\n   **/\n  outputDimensionality: import_genkit.z.number().min(1).optional()\n}).passthrough();\nfunction commonRef(name, info, configSchema = EmbeddingConfigSchema) {\n  return (0, import_embedder.embedderRef)({\n    name: `googleai/${name}`,\n    configSchema,\n    info: info ?? {\n      dimensions: 768,\n      supports: {\n        input: [\"text\"]\n      }\n    }\n  });\n}\nconst GENERIC_MODEL = commonRef(\"embedder\");\nconst KNOWN_MODELS = {\n  \"text-embedding-004\": commonRef(\"text-embedding-004\"),\n  \"gemini-embedding-001\": commonRef(\"gemini-embedding-001\")\n};\nfunction model(version, config = {}) {\n  const name = (0, import_utils.checkModelName)(version);\n  return (0, import_embedder.embedderRef)({\n    name: `googleai/${name}`,\n    config,\n    configSchema: GENERIC_MODEL.configSchema,\n    info: {\n      ...GENERIC_MODEL.info\n    }\n  });\n}\nfunction listActions(models) {\n  return models.filter((m) => m.supportedGenerationMethods.includes(\"embedContent\")).filter((m) => !m.description || !m.description.includes(\"deprecated\")).map((m) => {\n    const ref = model(m.name);\n    return (0, import_genkit.embedderActionMetadata)({\n      name: ref.name,\n      info: ref.info,\n      configSchema: ref.configSchema\n    });\n  });\n}\nfunction defineKnownModels(ai, options) {\n  for (const name of Object.keys(KNOWN_MODELS)) {\n    defineEmbedder(ai, name, options);\n  }\n}\nfunction defineEmbedder(ai, name, pluginOptions) {\n  (0, import_utils.checkApiKey)(pluginOptions?.apiKey);\n  const ref = model(name);\n  return ai.defineEmbedder(\n    {\n      name: ref.name,\n      configSchema: ref.configSchema,\n      info: ref.info\n    },\n    async (input, reqOptions) => {\n      const embedApiKey = (0, import_utils.calculateApiKey)(\n        pluginOptions?.apiKey,\n        reqOptions?.apiKey\n      );\n      const embedVersion = reqOptions?.version || (0, import_utils.extractVersion)(ref);\n      const embeddings = await Promise.all(\n        input.map(async (doc) => {\n          const response = await (0, import_client.embedContent)(embedApiKey, embedVersion, {\n            taskType: reqOptions?.taskType,\n            title: reqOptions?.title,\n            content: {\n              role: \"\",\n              parts: [{ text: doc.text }]\n            },\n            outputDimensionality: reqOptions?.outputDimensionality\n          });\n          const values = response.embedding.values;\n          return { embedding: values };\n        })\n      );\n      return { embeddings };\n    }\n  );\n}\nconst TEST_ONLY = { KNOWN_MODELS };\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=embedder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2dvb2dsZS1nZW5haS9saWIvZ29vZ2xlYWkvZW1iZWRkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsbUVBQVE7QUFDcEMsc0JBQXNCLG1CQUFPLENBQUMsK0VBQWlCO0FBQy9DLG9CQUFvQixtQkFBTyxDQUFDLG1HQUFhO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLGlHQUFZO0FBQ3ZDLG1CQUFtQixtQkFBTyxDQUFDLGlHQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBLG1CQUFtQjtBQUNuQixTQUFTO0FBQ1Q7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsTUFBTSxDQU9MO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcS1JhbWFjaGFcXERvY3VtZW50c1xcU3VzdEFJbmV4IEdJdCBDb2RlXFxub2RlX21vZHVsZXNcXEBnZW5raXQtYWlcXGdvb2dsZS1nZW5haVxcbGliXFxnb29nbGVhaVxcZW1iZWRkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIGVtYmVkZGVyX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGVtYmVkZGVyX2V4cG9ydHMsIHtcbiAgRW1iZWRkaW5nQ29uZmlnU2NoZW1hOiAoKSA9PiBFbWJlZGRpbmdDb25maWdTY2hlbWEsXG4gIFRFU1RfT05MWTogKCkgPT4gVEVTVF9PTkxZLFxuICBkZWZpbmVFbWJlZGRlcjogKCkgPT4gZGVmaW5lRW1iZWRkZXIsXG4gIGRlZmluZUtub3duTW9kZWxzOiAoKSA9PiBkZWZpbmVLbm93bk1vZGVscyxcbiAgbGlzdEFjdGlvbnM6ICgpID0+IGxpc3RBY3Rpb25zLFxuICBtb2RlbDogKCkgPT4gbW9kZWxcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoZW1iZWRkZXJfZXhwb3J0cyk7XG52YXIgaW1wb3J0X2dlbmtpdCA9IHJlcXVpcmUoXCJnZW5raXRcIik7XG52YXIgaW1wb3J0X2VtYmVkZGVyID0gcmVxdWlyZShcImdlbmtpdC9lbWJlZGRlclwiKTtcbnZhciBpbXBvcnRfY2xpZW50ID0gcmVxdWlyZShcIi4vY2xpZW50LmpzXCIpO1xudmFyIGltcG9ydF90eXBlcyA9IHJlcXVpcmUoXCIuL3R5cGVzLmpzXCIpO1xudmFyIGltcG9ydF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuY29uc3QgRW1iZWRkaW5nQ29uZmlnU2NoZW1hID0gaW1wb3J0X2dlbmtpdC56Lm9iamVjdCh7XG4gIC8qKiBPdmVycmlkZSB0aGUgQVBJIGtleSBwcm92aWRlZCBhdCBwbHVnaW4gaW5pdGlhbGl6YXRpb24uICovXG4gIGFwaUtleTogaW1wb3J0X2dlbmtpdC56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIC8qKlxuICAgKiBUaGUgYHRhc2tfdHlwZWAgcGFyYW1ldGVyIGlzIGRlZmluZWQgYXMgdGhlIGludGVuZGVkIGRvd25zdHJlYW0gYXBwbGljYXRpb24gdG8gaGVscCB0aGUgbW9kZWxcbiAgICogcHJvZHVjZSBiZXR0ZXIgcXVhbGl0eSBlbWJlZGRpbmdzLlxuICAgKiovXG4gIHRhc2tUeXBlOiBpbXBvcnRfdHlwZXMuVGFza1R5cGVTY2hlbWEub3B0aW9uYWwoKSxcbiAgdGl0bGU6IGltcG9ydF9nZW5raXQuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICB2ZXJzaW9uOiBpbXBvcnRfZ2Vua2l0Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgLyoqXG4gICAqIFRoZSBgb3V0cHV0RGltZW5zaW9uYWxpdHlgIHBhcmFtZXRlciBhbGxvd3MgeW91IHRvIHNwZWNpZnkgdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBlbWJlZGRpbmcgb3V0cHV0LlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgbW9kZWwgZ2VuZXJhdGVzIGVtYmVkZGluZ3Mgd2l0aCA3NjggZGltZW5zaW9ucy4gTW9kZWxzIHN1Y2ggYXNcbiAgICogYHRleHQtZW1iZWRkaW5nLTAwNGAsIGB0ZXh0LWVtYmVkZGluZy0wMDVgLCBhbmQgYHRleHQtbXVsdGlsaW5ndWFsLWVtYmVkZGluZy0wMDJgXG4gICAqIGFsbG93IHRoZSBvdXRwdXQgZGltZW5zaW9uYWxpdHkgdG8gYmUgYWRqdXN0ZWQgYmV0d2VlbiAxIGFuZCA3NjguXG4gICAqIEJ5IHNlbGVjdGluZyBhIHNtYWxsZXIgb3V0cHV0IGRpbWVuc2lvbmFsaXR5LCB1c2VycyBjYW4gc2F2ZSBtZW1vcnkgYW5kIHN0b3JhZ2Ugc3BhY2UsIGxlYWRpbmcgdG8gbW9yZSBlZmZpY2llbnQgY29tcHV0YXRpb25zLlxuICAgKiovXG4gIG91dHB1dERpbWVuc2lvbmFsaXR5OiBpbXBvcnRfZ2Vua2l0LnoubnVtYmVyKCkubWluKDEpLm9wdGlvbmFsKClcbn0pLnBhc3N0aHJvdWdoKCk7XG5mdW5jdGlvbiBjb21tb25SZWYobmFtZSwgaW5mbywgY29uZmlnU2NoZW1hID0gRW1iZWRkaW5nQ29uZmlnU2NoZW1hKSB7XG4gIHJldHVybiAoMCwgaW1wb3J0X2VtYmVkZGVyLmVtYmVkZGVyUmVmKSh7XG4gICAgbmFtZTogYGdvb2dsZWFpLyR7bmFtZX1gLFxuICAgIGNvbmZpZ1NjaGVtYSxcbiAgICBpbmZvOiBpbmZvID8/IHtcbiAgICAgIGRpbWVuc2lvbnM6IDc2OCxcbiAgICAgIHN1cHBvcnRzOiB7XG4gICAgICAgIGlucHV0OiBbXCJ0ZXh0XCJdXG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmNvbnN0IEdFTkVSSUNfTU9ERUwgPSBjb21tb25SZWYoXCJlbWJlZGRlclwiKTtcbmNvbnN0IEtOT1dOX01PREVMUyA9IHtcbiAgXCJ0ZXh0LWVtYmVkZGluZy0wMDRcIjogY29tbW9uUmVmKFwidGV4dC1lbWJlZGRpbmctMDA0XCIpLFxuICBcImdlbWluaS1lbWJlZGRpbmctMDAxXCI6IGNvbW1vblJlZihcImdlbWluaS1lbWJlZGRpbmctMDAxXCIpXG59O1xuZnVuY3Rpb24gbW9kZWwodmVyc2lvbiwgY29uZmlnID0ge30pIHtcbiAgY29uc3QgbmFtZSA9ICgwLCBpbXBvcnRfdXRpbHMuY2hlY2tNb2RlbE5hbWUpKHZlcnNpb24pO1xuICByZXR1cm4gKDAsIGltcG9ydF9lbWJlZGRlci5lbWJlZGRlclJlZikoe1xuICAgIG5hbWU6IGBnb29nbGVhaS8ke25hbWV9YCxcbiAgICBjb25maWcsXG4gICAgY29uZmlnU2NoZW1hOiBHRU5FUklDX01PREVMLmNvbmZpZ1NjaGVtYSxcbiAgICBpbmZvOiB7XG4gICAgICAuLi5HRU5FUklDX01PREVMLmluZm9cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbGlzdEFjdGlvbnMobW9kZWxzKSB7XG4gIHJldHVybiBtb2RlbHMuZmlsdGVyKChtKSA9PiBtLnN1cHBvcnRlZEdlbmVyYXRpb25NZXRob2RzLmluY2x1ZGVzKFwiZW1iZWRDb250ZW50XCIpKS5maWx0ZXIoKG0pID0+ICFtLmRlc2NyaXB0aW9uIHx8ICFtLmRlc2NyaXB0aW9uLmluY2x1ZGVzKFwiZGVwcmVjYXRlZFwiKSkubWFwKChtKSA9PiB7XG4gICAgY29uc3QgcmVmID0gbW9kZWwobS5uYW1lKTtcbiAgICByZXR1cm4gKDAsIGltcG9ydF9nZW5raXQuZW1iZWRkZXJBY3Rpb25NZXRhZGF0YSkoe1xuICAgICAgbmFtZTogcmVmLm5hbWUsXG4gICAgICBpbmZvOiByZWYuaW5mbyxcbiAgICAgIGNvbmZpZ1NjaGVtYTogcmVmLmNvbmZpZ1NjaGVtYVxuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGRlZmluZUtub3duTW9kZWxzKGFpLCBvcHRpb25zKSB7XG4gIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhLTk9XTl9NT0RFTFMpKSB7XG4gICAgZGVmaW5lRW1iZWRkZXIoYWksIG5hbWUsIG9wdGlvbnMpO1xuICB9XG59XG5mdW5jdGlvbiBkZWZpbmVFbWJlZGRlcihhaSwgbmFtZSwgcGx1Z2luT3B0aW9ucykge1xuICAoMCwgaW1wb3J0X3V0aWxzLmNoZWNrQXBpS2V5KShwbHVnaW5PcHRpb25zPy5hcGlLZXkpO1xuICBjb25zdCByZWYgPSBtb2RlbChuYW1lKTtcbiAgcmV0dXJuIGFpLmRlZmluZUVtYmVkZGVyKFxuICAgIHtcbiAgICAgIG5hbWU6IHJlZi5uYW1lLFxuICAgICAgY29uZmlnU2NoZW1hOiByZWYuY29uZmlnU2NoZW1hLFxuICAgICAgaW5mbzogcmVmLmluZm9cbiAgICB9LFxuICAgIGFzeW5jIChpbnB1dCwgcmVxT3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgZW1iZWRBcGlLZXkgPSAoMCwgaW1wb3J0X3V0aWxzLmNhbGN1bGF0ZUFwaUtleSkoXG4gICAgICAgIHBsdWdpbk9wdGlvbnM/LmFwaUtleSxcbiAgICAgICAgcmVxT3B0aW9ucz8uYXBpS2V5XG4gICAgICApO1xuICAgICAgY29uc3QgZW1iZWRWZXJzaW9uID0gcmVxT3B0aW9ucz8udmVyc2lvbiB8fCAoMCwgaW1wb3J0X3V0aWxzLmV4dHJhY3RWZXJzaW9uKShyZWYpO1xuICAgICAgY29uc3QgZW1iZWRkaW5ncyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBpbnB1dC5tYXAoYXN5bmMgKGRvYykgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgKDAsIGltcG9ydF9jbGllbnQuZW1iZWRDb250ZW50KShlbWJlZEFwaUtleSwgZW1iZWRWZXJzaW9uLCB7XG4gICAgICAgICAgICB0YXNrVHlwZTogcmVxT3B0aW9ucz8udGFza1R5cGUsXG4gICAgICAgICAgICB0aXRsZTogcmVxT3B0aW9ucz8udGl0bGUsXG4gICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgIHJvbGU6IFwiXCIsXG4gICAgICAgICAgICAgIHBhcnRzOiBbeyB0ZXh0OiBkb2MudGV4dCB9XVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG91dHB1dERpbWVuc2lvbmFsaXR5OiByZXFPcHRpb25zPy5vdXRwdXREaW1lbnNpb25hbGl0eVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IHJlc3BvbnNlLmVtYmVkZGluZy52YWx1ZXM7XG4gICAgICAgICAgcmV0dXJuIHsgZW1iZWRkaW5nOiB2YWx1ZXMgfTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICByZXR1cm4geyBlbWJlZGRpbmdzIH07XG4gICAgfVxuICApO1xufVxuY29uc3QgVEVTVF9PTkxZID0geyBLTk9XTl9NT0RFTFMgfTtcbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBFbWJlZGRpbmdDb25maWdTY2hlbWEsXG4gIFRFU1RfT05MWSxcbiAgZGVmaW5lRW1iZWRkZXIsXG4gIGRlZmluZUtub3duTW9kZWxzLFxuICBsaXN0QWN0aW9ucyxcbiAgbW9kZWxcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW1iZWRkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/embedder.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/gemini.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@genkit-ai/google-genai/lib/googleai/gemini.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar gemini_exports = {};\n__export(gemini_exports, {\n  GeminiConfigSchema: () => GeminiConfigSchema,\n  GeminiTtsConfigSchema: () => GeminiTtsConfigSchema,\n  GemmaConfigSchema: () => GemmaConfigSchema,\n  TEST_ONLY: () => TEST_ONLY,\n  defineKnownModels: () => defineKnownModels,\n  defineModel: () => defineModel,\n  isGeminiModelName: () => isGeminiModelName,\n  isGemmaModelName: () => isGemmaModelName,\n  isTTSModelName: () => isTTSModelName,\n  listActions: () => listActions,\n  model: () => model\n});\nmodule.exports = __toCommonJS(gemini_exports);\nvar import_genkit = __webpack_require__(/*! genkit */ \"(action-browser)/./node_modules/genkit/lib/index.js\");\nvar import_model = __webpack_require__(/*! genkit/model */ \"(action-browser)/./node_modules/genkit/lib/model.js\");\nvar import_middleware = __webpack_require__(/*! genkit/model/middleware */ \"(action-browser)/./node_modules/genkit/lib/middleware.js\");\nvar import_tracing = __webpack_require__(/*! genkit/tracing */ \"(action-browser)/./node_modules/genkit/lib/tracing.js\");\nvar import_converters = __webpack_require__(/*! ../common/converters.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/common/converters.js\");\nvar import_client = __webpack_require__(/*! ./client.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/client.js\");\nvar import_utils = __webpack_require__(/*! ./utils.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/utils.js\");\nconst SafetySettingsSchema = import_genkit.z.object({\n  category: import_genkit.z.enum([\n    \"HARM_CATEGORY_UNSPECIFIED\",\n    \"HARM_CATEGORY_HATE_SPEECH\",\n    \"HARM_CATEGORY_SEXUALLY_EXPLICIT\",\n    \"HARM_CATEGORY_HARASSMENT\",\n    \"HARM_CATEGORY_DANGEROUS_CONTENT\"\n  ]),\n  threshold: import_genkit.z.enum([\n    \"BLOCK_LOW_AND_ABOVE\",\n    \"BLOCK_MEDIUM_AND_ABOVE\",\n    \"BLOCK_ONLY_HIGH\",\n    \"BLOCK_NONE\"\n  ])\n});\nconst VoiceConfigSchema = import_genkit.z.object({\n  prebuiltVoiceConfig: import_genkit.z.object({\n    // TODO: Make this an array of objects so we can also specify the description\n    // for each voiceName.\n    voiceName: import_genkit.z.union([\n      import_genkit.z.enum([\n        \"Zephyr\",\n        \"Puck\",\n        \"Charon\",\n        \"Kore\",\n        \"Fenrir\",\n        \"Leda\",\n        \"Orus\",\n        \"Aoede\",\n        \"Callirrhoe\",\n        \"Autonoe\",\n        \"Enceladus\",\n        \"Iapetus\",\n        \"Umbriel\",\n        \"Algieba\",\n        \"Despina\",\n        \"Erinome\",\n        \"Algenib\",\n        \"Rasalgethi\",\n        \"Laomedeia\",\n        \"Achernar\",\n        \"Alnilam\",\n        \"Schedar\",\n        \"Gacrux\",\n        \"Pulcherrima\",\n        \"Achird\",\n        \"Zubenelgenubi\",\n        \"Vindemiatrix\",\n        \"Sadachbia\",\n        \"Sadaltager\",\n        \"Sulafat\"\n      ]),\n      // To allow any new string values\n      import_genkit.z.string()\n    ]).describe(\"Name of the preset voice to use\").optional()\n  }).describe(\"Configuration for the prebuilt speaker to use\").passthrough().optional()\n}).describe(\"Configuration for the voice to use\").passthrough();\nconst GeminiConfigSchema = import_model.GenerationCommonConfigSchema.extend({\n  apiKey: import_genkit.z.string().describe(\"Overrides the plugin-configured API key, if specified.\").optional(),\n  safetySettings: import_genkit.z.array(SafetySettingsSchema).describe(\n    \"Adjust how likely you are to see responses that could be harmful. Content is blocked based on the probability that it is harmful.\"\n  ).optional(),\n  codeExecution: import_genkit.z.union([import_genkit.z.boolean(), import_genkit.z.object({}).strict()]).describe(\"Enables the model to generate and run code.\").optional(),\n  contextCache: import_genkit.z.boolean().describe(\n    \"Context caching allows you to save and reuse precomputed input tokens that you wish to use repeatedly.\"\n  ).optional(),\n  functionCallingConfig: import_genkit.z.object({\n    mode: import_genkit.z.enum([\"MODE_UNSPECIFIED\", \"AUTO\", \"ANY\", \"NONE\"]).optional(),\n    allowedFunctionNames: import_genkit.z.array(import_genkit.z.string()).optional()\n  }).describe(\n    \"Controls how the model uses the provided tools (function declarations). With AUTO (Default) mode, the model decides whether to generate a natural language response or suggest a function call based on the prompt and context. With ANY, the model is constrained to always predict a function call and guarantee function schema adherence. With NONE, the model is prohibited from making function calls.\"\n  ).optional(),\n  responseModalities: import_genkit.z.array(import_genkit.z.enum([\"TEXT\", \"IMAGE\", \"AUDIO\"])).describe(\n    \"The modalities to be used in response. Only supported for 'gemini-2.0-flash-exp' model at present.\"\n  ).optional(),\n  googleSearchRetrieval: import_genkit.z.union([import_genkit.z.boolean(), import_genkit.z.object({}).passthrough()]).describe(\n    \"Retrieve public web data for grounding, powered by Google Search.\"\n  ).optional(),\n  temperature: import_genkit.z.number().min(0).max(2).describe(\n    import_model.GenerationCommonConfigDescriptions.temperature + \" The default value is 1.0.\"\n  ).optional(),\n  topP: import_genkit.z.number().min(0).max(1).describe(\n    import_model.GenerationCommonConfigDescriptions.topP + \" The default value is 0.95.\"\n  ).optional(),\n  thinkingConfig: import_genkit.z.object({\n    includeThoughts: import_genkit.z.boolean().describe(\n      \"Indicates whether to include thoughts in the response.If true, thoughts are returned only if the model supports thought and thoughts are available.\"\n    ).optional(),\n    thinkingBudget: import_genkit.z.number().min(0).max(24576).describe(\n      \"Indicates the thinking budget in tokens. 0 is DISABLED. -1 is AUTOMATIC. The default values and allowed ranges are model dependent. The thinking budget parameter gives the model guidance on the number of thinking tokens it can use when generating a response. A greater number of tokens is typically associated with more detailed thinking, which is needed for solving more complex tasks. \"\n    ).optional()\n  }).optional()\n}).passthrough();\nconst GeminiTtsConfigSchema = GeminiConfigSchema.extend({\n  speechConfig: import_genkit.z.object({\n    voiceConfig: VoiceConfigSchema.optional(),\n    multiSpeakerVoiceConfig: import_genkit.z.object({\n      speakerVoiceConfigs: import_genkit.z.array(\n        import_genkit.z.object({\n          speaker: import_genkit.z.string().describe(\"Name of the speaker to use\"),\n          voiceConfig: VoiceConfigSchema\n        }).describe(\n          \"Configuration for a single speaker in a multi speaker setup\"\n        ).passthrough()\n      ).describe(\"Configuration for all the enabled speaker voices\")\n    }).describe(\"Configuration for multi-speaker setup\").passthrough().optional()\n  }).describe(\"Speech generation config\").passthrough().optional()\n}).passthrough();\nconst GemmaConfigSchema = GeminiConfigSchema.extend({\n  temperature: import_genkit.z.number().min(0).max(1).describe(\n    import_model.GenerationCommonConfigDescriptions.temperature + \" The default value is 1.0.\"\n  ).optional()\n}).passthrough();\nfunction commonRef(name, info, configSchema = GeminiConfigSchema) {\n  return (0, import_model.modelRef)({\n    name: `googleai/${name}`,\n    configSchema,\n    info: info ?? {\n      supports: {\n        multiturn: true,\n        media: true,\n        tools: true,\n        toolChoice: true,\n        systemRole: true,\n        constrained: \"no-tools\",\n        output: [\"text\", \"json\"]\n      }\n    }\n  });\n}\nconst GENERIC_MODEL = commonRef(\"gemini\");\nconst GENERIC_TTS_MODEL = commonRef(\n  \"gemini-tts\",\n  {\n    supports: {\n      multiturn: false,\n      media: false,\n      tools: false,\n      toolChoice: false,\n      systemRole: false,\n      constrained: \"no-tools\"\n    }\n  },\n  GeminiTtsConfigSchema\n);\nconst GENERIC_GEMMA_MODEL = commonRef(\n  \"gemma-generic\",\n  void 0,\n  GemmaConfigSchema\n);\nconst KNOWN_GEMINI_MODELS = {\n  \"gemini-2.5-pro\": commonRef(\"gemini-2.5-pro\"),\n  \"gemini-2.5-flash\": commonRef(\"gemini-2.5-flash\"),\n  \"gemini-2.5-flash-lite\": commonRef(\"gemini-2.5-flash-lite\"),\n  \"gemini-2.5-flash-image-preview\": commonRef(\"gemini-2.5-flash-image-preview\"),\n  \"gemini-2.0-flash\": commonRef(\"gemini-2.0-flash\"),\n  \"gemini-2.0-flash-preview-image-generation\": commonRef(\n    \"gemini-2.0-flash-preview-image-generation\"\n  ),\n  \"gemini-2.0-flash-lite\": commonRef(\"gemini-2.0-flash-lite\")\n};\nfunction isGeminiModelName(value) {\n  return value.startsWith(\"gemini-\") && !value.endsWith(\"-tts\");\n}\nconst KNOWN_TTS_MODELS = {\n  \"gemini-2.5-flash-preview-tts\": commonRef(\n    \"gemini-2.5-flash-preview-tts\",\n    { ...GENERIC_TTS_MODEL.info },\n    GeminiTtsConfigSchema\n  ),\n  \"gemini-2.5-pro-preview-tts\": commonRef(\n    \"gemini-2.5-pro-preview-tts\",\n    { ...GENERIC_TTS_MODEL.info },\n    GeminiTtsConfigSchema\n  )\n};\nfunction isTTSModelName(value) {\n  return value.startsWith(\"gemini-\") && value.endsWith(\"-tts\");\n}\nconst KNOWN_GEMMA_MODELS = {\n  \"gemma-3-12b-it\": commonRef(\"gemma-3-12b-it\", void 0, GemmaConfigSchema),\n  \"gemma-3-1b-it\": commonRef(\"gemma-3-1b-it\", void 0, GemmaConfigSchema),\n  \"gemma-3-27b-it\": commonRef(\"gemma-3-27b-it\", void 0, GemmaConfigSchema),\n  \"gemma-3-4b-it\": commonRef(\"gemma-3-4b-it\", void 0, GemmaConfigSchema),\n  \"gemma-3n-e4b-it\": commonRef(\"gemma-3n-e4b-it\", void 0, GemmaConfigSchema)\n};\nfunction isGemmaModelName(value) {\n  return value.startsWith(\"gemma-\");\n}\nconst KNOWN_MODELS = {\n  ...KNOWN_GEMINI_MODELS,\n  ...KNOWN_TTS_MODELS,\n  ...KNOWN_GEMMA_MODELS\n};\nfunction model(version, config = {}) {\n  const name = (0, import_utils.checkModelName)(version);\n  if (isTTSModelName(name)) {\n    return (0, import_model.modelRef)({\n      name: `googleai/${name}`,\n      config,\n      configSchema: GeminiTtsConfigSchema,\n      info: { ...GENERIC_TTS_MODEL.info }\n    });\n  }\n  if (isGemmaModelName(name)) {\n    return (0, import_model.modelRef)({\n      name: `googleai/${name}`,\n      config,\n      configSchema: GemmaConfigSchema,\n      info: { ...GENERIC_GEMMA_MODEL.info }\n    });\n  }\n  return (0, import_model.modelRef)({\n    name: `googleai/${name}`,\n    config,\n    configSchema: GeminiConfigSchema,\n    info: { ...GENERIC_MODEL.info }\n  });\n}\nfunction listActions(models) {\n  return models.filter((m) => m.supportedGenerationMethods.includes(\"generateContent\")).filter((m) => !m.description || !m.description.includes(\"deprecated\")).map((m) => {\n    const ref = model(m.name);\n    return (0, import_genkit.modelActionMetadata)({\n      name: ref.name,\n      info: ref.info,\n      configSchema: ref.configSchema\n    });\n  });\n}\nfunction defineKnownModels(ai, options) {\n  for (const name of Object.keys(KNOWN_MODELS)) {\n    defineModel(ai, name, options);\n  }\n}\nfunction defineModel(ai, name, pluginOptions) {\n  (0, import_utils.checkApiKey)(pluginOptions?.apiKey);\n  const ref = model(name);\n  const clientOptions = {\n    apiVersion: pluginOptions?.apiVersion,\n    baseUrl: pluginOptions?.baseUrl\n  };\n  const middleware = [];\n  if (ref.info?.supports?.media) {\n    middleware.push(\n      (0, import_middleware.downloadRequestMedia)({\n        maxBytes: 1024 * 1024 * 10,\n        // don't downlaod files that have been uploaded using the Files API\n        filter: (part) => {\n          try {\n            const url = new URL(part.media.url);\n            if (\n              // Gemini can handle these URLs\n              [\n                \"generativelanguage.googleapis.com\",\n                \"www.youtube.com\",\n                \"youtube.com\",\n                \"youtu.be\"\n              ].includes(url.hostname)\n            )\n              return false;\n          } catch {\n          }\n          return true;\n        }\n      })\n    );\n  }\n  return ai.defineModel(\n    {\n      apiVersion: \"v2\",\n      name: ref.name,\n      ...ref.info,\n      configSchema: ref.configSchema,\n      use: middleware\n    },\n    async (request, { streamingRequested, sendChunk, abortSignal }) => {\n      const clientOpt = { ...clientOptions, signal: abortSignal };\n      const messages = [...request.messages];\n      if (messages.length === 0) throw new Error(\"No messages provided.\");\n      let systemInstruction = void 0;\n      const systemMessage = messages.find((m) => m.role === \"system\");\n      if (systemMessage) {\n        messages.splice(messages.indexOf(systemMessage), 1);\n        systemInstruction = (0, import_converters.toGeminiSystemInstruction)(systemMessage);\n      }\n      const tools = [];\n      if (request.tools?.length) {\n        tools.push({\n          functionDeclarations: request.tools.map(import_converters.toGeminiTool)\n        });\n      }\n      const requestOptions = {\n        ...request.config\n      };\n      const {\n        apiKey: apiKeyFromConfig,\n        safetySettings: safetySettingsFromConfig,\n        codeExecution: codeExecutionFromConfig,\n        version: versionFromConfig,\n        functionCallingConfig,\n        googleSearchRetrieval,\n        tools: toolsFromConfig,\n        ...restOfConfigOptions\n      } = requestOptions;\n      if (codeExecutionFromConfig) {\n        tools.push({\n          codeExecution: codeExecutionFromConfig === true ? {} : codeExecutionFromConfig\n        });\n      }\n      if (toolsFromConfig) {\n        tools.push(...toolsFromConfig);\n      }\n      if (googleSearchRetrieval) {\n        tools.push({\n          googleSearch: googleSearchRetrieval === true ? {} : googleSearchRetrieval\n        });\n      }\n      let toolConfig;\n      if (functionCallingConfig) {\n        toolConfig = {\n          functionCallingConfig: {\n            allowedFunctionNames: functionCallingConfig.allowedFunctionNames,\n            mode: (0, import_converters.toGeminiFunctionModeEnum)(functionCallingConfig.mode)\n          }\n        };\n      } else if (request.toolChoice) {\n        toolConfig = {\n          functionCallingConfig: {\n            mode: (0, import_converters.toGeminiFunctionModeEnum)(request.toolChoice)\n          }\n        };\n      }\n      const jsonMode = request.output?.format === \"json\" || request.output?.contentType === \"application/json\" && tools.length === 0;\n      const generationConfig = {\n        ...restOfConfigOptions,\n        candidateCount: request.candidates || void 0,\n        responseMimeType: jsonMode ? \"application/json\" : void 0\n      };\n      if (request.output?.constrained && jsonMode) {\n        generationConfig.responseSchema = (0, import_utils.cleanSchema)(request.output.schema);\n      }\n      const msg = (0, import_converters.toGeminiMessage)(messages[messages.length - 1], ref);\n      let generateContentRequest = {\n        systemInstruction,\n        generationConfig,\n        tools: tools.length ? tools : void 0,\n        toolConfig,\n        safetySettings: safetySettingsFromConfig?.filter(\n          (setting) => setting.category !== \"HARM_CATEGORY_UNSPECIFIED\"\n        ),\n        contents: messages.map((message) => (0, import_converters.toGeminiMessage)(message, ref))\n      };\n      const modelVersion = versionFromConfig || (0, import_utils.extractVersion)(ref);\n      const generateApiKey = (0, import_utils.calculateApiKey)(\n        pluginOptions?.apiKey,\n        requestOptions.apiKey\n      );\n      const callGemini = async () => {\n        let response;\n        if (streamingRequested) {\n          const result = await (0, import_client.generateContentStream)(\n            generateApiKey,\n            modelVersion,\n            generateContentRequest,\n            clientOpt\n          );\n          for await (const item of result.stream) {\n            item.candidates?.forEach((candidate) => {\n              const c = (0, import_converters.fromGeminiCandidate)(candidate);\n              sendChunk({\n                index: c.index,\n                content: c.message.content\n              });\n            });\n          }\n          response = await result.response;\n        } else {\n          response = await (0, import_client.generateContent)(\n            generateApiKey,\n            modelVersion,\n            generateContentRequest,\n            clientOpt\n          );\n        }\n        const candidates = response.candidates || [];\n        if (response.candidates?.[\"undefined\"]) {\n          candidates.push(response.candidates[\"undefined\"]);\n        }\n        if (!candidates.length) {\n          throw new import_genkit.GenkitError({\n            status: \"FAILED_PRECONDITION\",\n            message: \"No valid candidates returned.\"\n          });\n        }\n        const candidateData = candidates.map(import_converters.fromGeminiCandidate) || [];\n        return {\n          candidates: candidateData,\n          custom: response,\n          usage: {\n            ...(0, import_model.getBasicUsageStats)(request.messages, candidateData),\n            inputTokens: response.usageMetadata?.promptTokenCount,\n            outputTokens: response.usageMetadata?.candidatesTokenCount,\n            thoughtsTokens: response.usageMetadata?.thoughtsTokenCount,\n            totalTokens: response.usageMetadata?.totalTokenCount,\n            cachedContentTokens: response.usageMetadata?.cachedContentTokenCount\n          }\n        };\n      };\n      return pluginOptions?.experimental_debugTraces ? await (0, import_tracing.runInNewSpan)(\n        ai.registry,\n        {\n          metadata: {\n            name: streamingRequested ? \"sendMessageStream\" : \"sendMessage\"\n          }\n        },\n        async (metadata) => {\n          metadata.input = {\n            apiEndpoint: (0, import_client.getGoogleAIUrl)({\n              resourcePath: \"\",\n              clientOptions: clientOpt\n            }),\n            cache: {},\n            model: modelVersion,\n            generateContentOptions: generateContentRequest,\n            parts: msg.parts,\n            options: clientOpt\n          };\n          const response = await callGemini();\n          metadata.output = response.custom;\n          return response;\n        }\n      ) : await callGemini();\n    }\n  );\n}\nconst TEST_ONLY = { KNOWN_MODELS };\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=gemini.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2dvb2dsZS1nZW5haS9saWIvZ29vZ2xlYWkvZ2VtaW5pLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyxtRUFBUTtBQUNwQyxtQkFBbUIsbUJBQU8sQ0FBQyx5RUFBYztBQUN6Qyx3QkFBd0IsbUJBQU8sQ0FBQyx5RkFBeUI7QUFDekQscUJBQXFCLG1CQUFPLENBQUMsNkVBQWdCO0FBQzdDLHdCQUF3QixtQkFBTyxDQUFDLGlIQUF5QjtBQUN6RCxvQkFBb0IsbUJBQU8sQ0FBQyxtR0FBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyxpR0FBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMkJBQTJCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwyQkFBMkI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSztBQUMzQjtBQUNBO0FBQ0EsWUFBWTtBQUNaLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0JBQXNCLDRDQUE0QztBQUNsRSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0QsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxNQUFNLENBWUw7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcZ29vZ2xlLWdlbmFpXFxsaWJcXGdvb2dsZWFpXFxnZW1pbmkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIGdlbWluaV9leHBvcnRzID0ge307XG5fX2V4cG9ydChnZW1pbmlfZXhwb3J0cywge1xuICBHZW1pbmlDb25maWdTY2hlbWE6ICgpID0+IEdlbWluaUNvbmZpZ1NjaGVtYSxcbiAgR2VtaW5pVHRzQ29uZmlnU2NoZW1hOiAoKSA9PiBHZW1pbmlUdHNDb25maWdTY2hlbWEsXG4gIEdlbW1hQ29uZmlnU2NoZW1hOiAoKSA9PiBHZW1tYUNvbmZpZ1NjaGVtYSxcbiAgVEVTVF9PTkxZOiAoKSA9PiBURVNUX09OTFksXG4gIGRlZmluZUtub3duTW9kZWxzOiAoKSA9PiBkZWZpbmVLbm93bk1vZGVscyxcbiAgZGVmaW5lTW9kZWw6ICgpID0+IGRlZmluZU1vZGVsLFxuICBpc0dlbWluaU1vZGVsTmFtZTogKCkgPT4gaXNHZW1pbmlNb2RlbE5hbWUsXG4gIGlzR2VtbWFNb2RlbE5hbWU6ICgpID0+IGlzR2VtbWFNb2RlbE5hbWUsXG4gIGlzVFRTTW9kZWxOYW1lOiAoKSA9PiBpc1RUU01vZGVsTmFtZSxcbiAgbGlzdEFjdGlvbnM6ICgpID0+IGxpc3RBY3Rpb25zLFxuICBtb2RlbDogKCkgPT4gbW9kZWxcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoZ2VtaW5pX2V4cG9ydHMpO1xudmFyIGltcG9ydF9nZW5raXQgPSByZXF1aXJlKFwiZ2Vua2l0XCIpO1xudmFyIGltcG9ydF9tb2RlbCA9IHJlcXVpcmUoXCJnZW5raXQvbW9kZWxcIik7XG52YXIgaW1wb3J0X21pZGRsZXdhcmUgPSByZXF1aXJlKFwiZ2Vua2l0L21vZGVsL21pZGRsZXdhcmVcIik7XG52YXIgaW1wb3J0X3RyYWNpbmcgPSByZXF1aXJlKFwiZ2Vua2l0L3RyYWNpbmdcIik7XG52YXIgaW1wb3J0X2NvbnZlcnRlcnMgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbnZlcnRlcnMuanNcIik7XG52YXIgaW1wb3J0X2NsaWVudCA9IHJlcXVpcmUoXCIuL2NsaWVudC5qc1wiKTtcbnZhciBpbXBvcnRfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbmNvbnN0IFNhZmV0eVNldHRpbmdzU2NoZW1hID0gaW1wb3J0X2dlbmtpdC56Lm9iamVjdCh7XG4gIGNhdGVnb3J5OiBpbXBvcnRfZ2Vua2l0LnouZW51bShbXG4gICAgXCJIQVJNX0NBVEVHT1JZX1VOU1BFQ0lGSUVEXCIsXG4gICAgXCJIQVJNX0NBVEVHT1JZX0hBVEVfU1BFRUNIXCIsXG4gICAgXCJIQVJNX0NBVEVHT1JZX1NFWFVBTExZX0VYUExJQ0lUXCIsXG4gICAgXCJIQVJNX0NBVEVHT1JZX0hBUkFTU01FTlRcIixcbiAgICBcIkhBUk1fQ0FURUdPUllfREFOR0VST1VTX0NPTlRFTlRcIlxuICBdKSxcbiAgdGhyZXNob2xkOiBpbXBvcnRfZ2Vua2l0LnouZW51bShbXG4gICAgXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCIsXG4gICAgXCJCTE9DS19NRURJVU1fQU5EX0FCT1ZFXCIsXG4gICAgXCJCTE9DS19PTkxZX0hJR0hcIixcbiAgICBcIkJMT0NLX05PTkVcIlxuICBdKVxufSk7XG5jb25zdCBWb2ljZUNvbmZpZ1NjaGVtYSA9IGltcG9ydF9nZW5raXQuei5vYmplY3Qoe1xuICBwcmVidWlsdFZvaWNlQ29uZmlnOiBpbXBvcnRfZ2Vua2l0Lnoub2JqZWN0KHtcbiAgICAvLyBUT0RPOiBNYWtlIHRoaXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBzbyB3ZSBjYW4gYWxzbyBzcGVjaWZ5IHRoZSBkZXNjcmlwdGlvblxuICAgIC8vIGZvciBlYWNoIHZvaWNlTmFtZS5cbiAgICB2b2ljZU5hbWU6IGltcG9ydF9nZW5raXQuei51bmlvbihbXG4gICAgICBpbXBvcnRfZ2Vua2l0LnouZW51bShbXG4gICAgICAgIFwiWmVwaHlyXCIsXG4gICAgICAgIFwiUHVja1wiLFxuICAgICAgICBcIkNoYXJvblwiLFxuICAgICAgICBcIktvcmVcIixcbiAgICAgICAgXCJGZW5yaXJcIixcbiAgICAgICAgXCJMZWRhXCIsXG4gICAgICAgIFwiT3J1c1wiLFxuICAgICAgICBcIkFvZWRlXCIsXG4gICAgICAgIFwiQ2FsbGlycmhvZVwiLFxuICAgICAgICBcIkF1dG9ub2VcIixcbiAgICAgICAgXCJFbmNlbGFkdXNcIixcbiAgICAgICAgXCJJYXBldHVzXCIsXG4gICAgICAgIFwiVW1icmllbFwiLFxuICAgICAgICBcIkFsZ2llYmFcIixcbiAgICAgICAgXCJEZXNwaW5hXCIsXG4gICAgICAgIFwiRXJpbm9tZVwiLFxuICAgICAgICBcIkFsZ2VuaWJcIixcbiAgICAgICAgXCJSYXNhbGdldGhpXCIsXG4gICAgICAgIFwiTGFvbWVkZWlhXCIsXG4gICAgICAgIFwiQWNoZXJuYXJcIixcbiAgICAgICAgXCJBbG5pbGFtXCIsXG4gICAgICAgIFwiU2NoZWRhclwiLFxuICAgICAgICBcIkdhY3J1eFwiLFxuICAgICAgICBcIlB1bGNoZXJyaW1hXCIsXG4gICAgICAgIFwiQWNoaXJkXCIsXG4gICAgICAgIFwiWnViZW5lbGdlbnViaVwiLFxuICAgICAgICBcIlZpbmRlbWlhdHJpeFwiLFxuICAgICAgICBcIlNhZGFjaGJpYVwiLFxuICAgICAgICBcIlNhZGFsdGFnZXJcIixcbiAgICAgICAgXCJTdWxhZmF0XCJcbiAgICAgIF0pLFxuICAgICAgLy8gVG8gYWxsb3cgYW55IG5ldyBzdHJpbmcgdmFsdWVzXG4gICAgICBpbXBvcnRfZ2Vua2l0Lnouc3RyaW5nKClcbiAgICBdKS5kZXNjcmliZShcIk5hbWUgb2YgdGhlIHByZXNldCB2b2ljZSB0byB1c2VcIikub3B0aW9uYWwoKVxuICB9KS5kZXNjcmliZShcIkNvbmZpZ3VyYXRpb24gZm9yIHRoZSBwcmVidWlsdCBzcGVha2VyIHRvIHVzZVwiKS5wYXNzdGhyb3VnaCgpLm9wdGlvbmFsKClcbn0pLmRlc2NyaWJlKFwiQ29uZmlndXJhdGlvbiBmb3IgdGhlIHZvaWNlIHRvIHVzZVwiKS5wYXNzdGhyb3VnaCgpO1xuY29uc3QgR2VtaW5pQ29uZmlnU2NoZW1hID0gaW1wb3J0X21vZGVsLkdlbmVyYXRpb25Db21tb25Db25maWdTY2hlbWEuZXh0ZW5kKHtcbiAgYXBpS2V5OiBpbXBvcnRfZ2Vua2l0Lnouc3RyaW5nKCkuZGVzY3JpYmUoXCJPdmVycmlkZXMgdGhlIHBsdWdpbi1jb25maWd1cmVkIEFQSSBrZXksIGlmIHNwZWNpZmllZC5cIikub3B0aW9uYWwoKSxcbiAgc2FmZXR5U2V0dGluZ3M6IGltcG9ydF9nZW5raXQuei5hcnJheShTYWZldHlTZXR0aW5nc1NjaGVtYSkuZGVzY3JpYmUoXG4gICAgXCJBZGp1c3QgaG93IGxpa2VseSB5b3UgYXJlIHRvIHNlZSByZXNwb25zZXMgdGhhdCBjb3VsZCBiZSBoYXJtZnVsLiBDb250ZW50IGlzIGJsb2NrZWQgYmFzZWQgb24gdGhlIHByb2JhYmlsaXR5IHRoYXQgaXQgaXMgaGFybWZ1bC5cIlxuICApLm9wdGlvbmFsKCksXG4gIGNvZGVFeGVjdXRpb246IGltcG9ydF9nZW5raXQuei51bmlvbihbaW1wb3J0X2dlbmtpdC56LmJvb2xlYW4oKSwgaW1wb3J0X2dlbmtpdC56Lm9iamVjdCh7fSkuc3RyaWN0KCldKS5kZXNjcmliZShcIkVuYWJsZXMgdGhlIG1vZGVsIHRvIGdlbmVyYXRlIGFuZCBydW4gY29kZS5cIikub3B0aW9uYWwoKSxcbiAgY29udGV4dENhY2hlOiBpbXBvcnRfZ2Vua2l0LnouYm9vbGVhbigpLmRlc2NyaWJlKFxuICAgIFwiQ29udGV4dCBjYWNoaW5nIGFsbG93cyB5b3UgdG8gc2F2ZSBhbmQgcmV1c2UgcHJlY29tcHV0ZWQgaW5wdXQgdG9rZW5zIHRoYXQgeW91IHdpc2ggdG8gdXNlIHJlcGVhdGVkbHkuXCJcbiAgKS5vcHRpb25hbCgpLFxuICBmdW5jdGlvbkNhbGxpbmdDb25maWc6IGltcG9ydF9nZW5raXQuei5vYmplY3Qoe1xuICAgIG1vZGU6IGltcG9ydF9nZW5raXQuei5lbnVtKFtcIk1PREVfVU5TUEVDSUZJRURcIiwgXCJBVVRPXCIsIFwiQU5ZXCIsIFwiTk9ORVwiXSkub3B0aW9uYWwoKSxcbiAgICBhbGxvd2VkRnVuY3Rpb25OYW1lczogaW1wb3J0X2dlbmtpdC56LmFycmF5KGltcG9ydF9nZW5raXQuei5zdHJpbmcoKSkub3B0aW9uYWwoKVxuICB9KS5kZXNjcmliZShcbiAgICBcIkNvbnRyb2xzIGhvdyB0aGUgbW9kZWwgdXNlcyB0aGUgcHJvdmlkZWQgdG9vbHMgKGZ1bmN0aW9uIGRlY2xhcmF0aW9ucykuIFdpdGggQVVUTyAoRGVmYXVsdCkgbW9kZSwgdGhlIG1vZGVsIGRlY2lkZXMgd2hldGhlciB0byBnZW5lcmF0ZSBhIG5hdHVyYWwgbGFuZ3VhZ2UgcmVzcG9uc2Ugb3Igc3VnZ2VzdCBhIGZ1bmN0aW9uIGNhbGwgYmFzZWQgb24gdGhlIHByb21wdCBhbmQgY29udGV4dC4gV2l0aCBBTlksIHRoZSBtb2RlbCBpcyBjb25zdHJhaW5lZCB0byBhbHdheXMgcHJlZGljdCBhIGZ1bmN0aW9uIGNhbGwgYW5kIGd1YXJhbnRlZSBmdW5jdGlvbiBzY2hlbWEgYWRoZXJlbmNlLiBXaXRoIE5PTkUsIHRoZSBtb2RlbCBpcyBwcm9oaWJpdGVkIGZyb20gbWFraW5nIGZ1bmN0aW9uIGNhbGxzLlwiXG4gICkub3B0aW9uYWwoKSxcbiAgcmVzcG9uc2VNb2RhbGl0aWVzOiBpbXBvcnRfZ2Vua2l0LnouYXJyYXkoaW1wb3J0X2dlbmtpdC56LmVudW0oW1wiVEVYVFwiLCBcIklNQUdFXCIsIFwiQVVESU9cIl0pKS5kZXNjcmliZShcbiAgICBcIlRoZSBtb2RhbGl0aWVzIHRvIGJlIHVzZWQgaW4gcmVzcG9uc2UuIE9ubHkgc3VwcG9ydGVkIGZvciAnZ2VtaW5pLTIuMC1mbGFzaC1leHAnIG1vZGVsIGF0IHByZXNlbnQuXCJcbiAgKS5vcHRpb25hbCgpLFxuICBnb29nbGVTZWFyY2hSZXRyaWV2YWw6IGltcG9ydF9nZW5raXQuei51bmlvbihbaW1wb3J0X2dlbmtpdC56LmJvb2xlYW4oKSwgaW1wb3J0X2dlbmtpdC56Lm9iamVjdCh7fSkucGFzc3Rocm91Z2goKV0pLmRlc2NyaWJlKFxuICAgIFwiUmV0cmlldmUgcHVibGljIHdlYiBkYXRhIGZvciBncm91bmRpbmcsIHBvd2VyZWQgYnkgR29vZ2xlIFNlYXJjaC5cIlxuICApLm9wdGlvbmFsKCksXG4gIHRlbXBlcmF0dXJlOiBpbXBvcnRfZ2Vua2l0LnoubnVtYmVyKCkubWluKDApLm1heCgyKS5kZXNjcmliZShcbiAgICBpbXBvcnRfbW9kZWwuR2VuZXJhdGlvbkNvbW1vbkNvbmZpZ0Rlc2NyaXB0aW9ucy50ZW1wZXJhdHVyZSArIFwiIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDEuMC5cIlxuICApLm9wdGlvbmFsKCksXG4gIHRvcFA6IGltcG9ydF9nZW5raXQuei5udW1iZXIoKS5taW4oMCkubWF4KDEpLmRlc2NyaWJlKFxuICAgIGltcG9ydF9tb2RlbC5HZW5lcmF0aW9uQ29tbW9uQ29uZmlnRGVzY3JpcHRpb25zLnRvcFAgKyBcIiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAwLjk1LlwiXG4gICkub3B0aW9uYWwoKSxcbiAgdGhpbmtpbmdDb25maWc6IGltcG9ydF9nZW5raXQuei5vYmplY3Qoe1xuICAgIGluY2x1ZGVUaG91Z2h0czogaW1wb3J0X2dlbmtpdC56LmJvb2xlYW4oKS5kZXNjcmliZShcbiAgICAgIFwiSW5kaWNhdGVzIHdoZXRoZXIgdG8gaW5jbHVkZSB0aG91Z2h0cyBpbiB0aGUgcmVzcG9uc2UuSWYgdHJ1ZSwgdGhvdWdodHMgYXJlIHJldHVybmVkIG9ubHkgaWYgdGhlIG1vZGVsIHN1cHBvcnRzIHRob3VnaHQgYW5kIHRob3VnaHRzIGFyZSBhdmFpbGFibGUuXCJcbiAgICApLm9wdGlvbmFsKCksXG4gICAgdGhpbmtpbmdCdWRnZXQ6IGltcG9ydF9nZW5raXQuei5udW1iZXIoKS5taW4oMCkubWF4KDI0NTc2KS5kZXNjcmliZShcbiAgICAgIFwiSW5kaWNhdGVzIHRoZSB0aGlua2luZyBidWRnZXQgaW4gdG9rZW5zLiAwIGlzIERJU0FCTEVELiAtMSBpcyBBVVRPTUFUSUMuIFRoZSBkZWZhdWx0IHZhbHVlcyBhbmQgYWxsb3dlZCByYW5nZXMgYXJlIG1vZGVsIGRlcGVuZGVudC4gVGhlIHRoaW5raW5nIGJ1ZGdldCBwYXJhbWV0ZXIgZ2l2ZXMgdGhlIG1vZGVsIGd1aWRhbmNlIG9uIHRoZSBudW1iZXIgb2YgdGhpbmtpbmcgdG9rZW5zIGl0IGNhbiB1c2Ugd2hlbiBnZW5lcmF0aW5nIGEgcmVzcG9uc2UuIEEgZ3JlYXRlciBudW1iZXIgb2YgdG9rZW5zIGlzIHR5cGljYWxseSBhc3NvY2lhdGVkIHdpdGggbW9yZSBkZXRhaWxlZCB0aGlua2luZywgd2hpY2ggaXMgbmVlZGVkIGZvciBzb2x2aW5nIG1vcmUgY29tcGxleCB0YXNrcy4gXCJcbiAgICApLm9wdGlvbmFsKClcbiAgfSkub3B0aW9uYWwoKVxufSkucGFzc3Rocm91Z2goKTtcbmNvbnN0IEdlbWluaVR0c0NvbmZpZ1NjaGVtYSA9IEdlbWluaUNvbmZpZ1NjaGVtYS5leHRlbmQoe1xuICBzcGVlY2hDb25maWc6IGltcG9ydF9nZW5raXQuei5vYmplY3Qoe1xuICAgIHZvaWNlQ29uZmlnOiBWb2ljZUNvbmZpZ1NjaGVtYS5vcHRpb25hbCgpLFxuICAgIG11bHRpU3BlYWtlclZvaWNlQ29uZmlnOiBpbXBvcnRfZ2Vua2l0Lnoub2JqZWN0KHtcbiAgICAgIHNwZWFrZXJWb2ljZUNvbmZpZ3M6IGltcG9ydF9nZW5raXQuei5hcnJheShcbiAgICAgICAgaW1wb3J0X2dlbmtpdC56Lm9iamVjdCh7XG4gICAgICAgICAgc3BlYWtlcjogaW1wb3J0X2dlbmtpdC56LnN0cmluZygpLmRlc2NyaWJlKFwiTmFtZSBvZiB0aGUgc3BlYWtlciB0byB1c2VcIiksXG4gICAgICAgICAgdm9pY2VDb25maWc6IFZvaWNlQ29uZmlnU2NoZW1hXG4gICAgICAgIH0pLmRlc2NyaWJlKFxuICAgICAgICAgIFwiQ29uZmlndXJhdGlvbiBmb3IgYSBzaW5nbGUgc3BlYWtlciBpbiBhIG11bHRpIHNwZWFrZXIgc2V0dXBcIlxuICAgICAgICApLnBhc3N0aHJvdWdoKClcbiAgICAgICkuZGVzY3JpYmUoXCJDb25maWd1cmF0aW9uIGZvciBhbGwgdGhlIGVuYWJsZWQgc3BlYWtlciB2b2ljZXNcIilcbiAgICB9KS5kZXNjcmliZShcIkNvbmZpZ3VyYXRpb24gZm9yIG11bHRpLXNwZWFrZXIgc2V0dXBcIikucGFzc3Rocm91Z2goKS5vcHRpb25hbCgpXG4gIH0pLmRlc2NyaWJlKFwiU3BlZWNoIGdlbmVyYXRpb24gY29uZmlnXCIpLnBhc3N0aHJvdWdoKCkub3B0aW9uYWwoKVxufSkucGFzc3Rocm91Z2goKTtcbmNvbnN0IEdlbW1hQ29uZmlnU2NoZW1hID0gR2VtaW5pQ29uZmlnU2NoZW1hLmV4dGVuZCh7XG4gIHRlbXBlcmF0dXJlOiBpbXBvcnRfZ2Vua2l0LnoubnVtYmVyKCkubWluKDApLm1heCgxKS5kZXNjcmliZShcbiAgICBpbXBvcnRfbW9kZWwuR2VuZXJhdGlvbkNvbW1vbkNvbmZpZ0Rlc2NyaXB0aW9ucy50ZW1wZXJhdHVyZSArIFwiIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDEuMC5cIlxuICApLm9wdGlvbmFsKClcbn0pLnBhc3N0aHJvdWdoKCk7XG5mdW5jdGlvbiBjb21tb25SZWYobmFtZSwgaW5mbywgY29uZmlnU2NoZW1hID0gR2VtaW5pQ29uZmlnU2NoZW1hKSB7XG4gIHJldHVybiAoMCwgaW1wb3J0X21vZGVsLm1vZGVsUmVmKSh7XG4gICAgbmFtZTogYGdvb2dsZWFpLyR7bmFtZX1gLFxuICAgIGNvbmZpZ1NjaGVtYSxcbiAgICBpbmZvOiBpbmZvID8/IHtcbiAgICAgIHN1cHBvcnRzOiB7XG4gICAgICAgIG11bHRpdHVybjogdHJ1ZSxcbiAgICAgICAgbWVkaWE6IHRydWUsXG4gICAgICAgIHRvb2xzOiB0cnVlLFxuICAgICAgICB0b29sQ2hvaWNlOiB0cnVlLFxuICAgICAgICBzeXN0ZW1Sb2xlOiB0cnVlLFxuICAgICAgICBjb25zdHJhaW5lZDogXCJuby10b29sc1wiLFxuICAgICAgICBvdXRwdXQ6IFtcInRleHRcIiwgXCJqc29uXCJdXG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmNvbnN0IEdFTkVSSUNfTU9ERUwgPSBjb21tb25SZWYoXCJnZW1pbmlcIik7XG5jb25zdCBHRU5FUklDX1RUU19NT0RFTCA9IGNvbW1vblJlZihcbiAgXCJnZW1pbmktdHRzXCIsXG4gIHtcbiAgICBzdXBwb3J0czoge1xuICAgICAgbXVsdGl0dXJuOiBmYWxzZSxcbiAgICAgIG1lZGlhOiBmYWxzZSxcbiAgICAgIHRvb2xzOiBmYWxzZSxcbiAgICAgIHRvb2xDaG9pY2U6IGZhbHNlLFxuICAgICAgc3lzdGVtUm9sZTogZmFsc2UsXG4gICAgICBjb25zdHJhaW5lZDogXCJuby10b29sc1wiXG4gICAgfVxuICB9LFxuICBHZW1pbmlUdHNDb25maWdTY2hlbWFcbik7XG5jb25zdCBHRU5FUklDX0dFTU1BX01PREVMID0gY29tbW9uUmVmKFxuICBcImdlbW1hLWdlbmVyaWNcIixcbiAgdm9pZCAwLFxuICBHZW1tYUNvbmZpZ1NjaGVtYVxuKTtcbmNvbnN0IEtOT1dOX0dFTUlOSV9NT0RFTFMgPSB7XG4gIFwiZ2VtaW5pLTIuNS1wcm9cIjogY29tbW9uUmVmKFwiZ2VtaW5pLTIuNS1wcm9cIiksXG4gIFwiZ2VtaW5pLTIuNS1mbGFzaFwiOiBjb21tb25SZWYoXCJnZW1pbmktMi41LWZsYXNoXCIpLFxuICBcImdlbWluaS0yLjUtZmxhc2gtbGl0ZVwiOiBjb21tb25SZWYoXCJnZW1pbmktMi41LWZsYXNoLWxpdGVcIiksXG4gIFwiZ2VtaW5pLTIuNS1mbGFzaC1pbWFnZS1wcmV2aWV3XCI6IGNvbW1vblJlZihcImdlbWluaS0yLjUtZmxhc2gtaW1hZ2UtcHJldmlld1wiKSxcbiAgXCJnZW1pbmktMi4wLWZsYXNoXCI6IGNvbW1vblJlZihcImdlbWluaS0yLjAtZmxhc2hcIiksXG4gIFwiZ2VtaW5pLTIuMC1mbGFzaC1wcmV2aWV3LWltYWdlLWdlbmVyYXRpb25cIjogY29tbW9uUmVmKFxuICAgIFwiZ2VtaW5pLTIuMC1mbGFzaC1wcmV2aWV3LWltYWdlLWdlbmVyYXRpb25cIlxuICApLFxuICBcImdlbWluaS0yLjAtZmxhc2gtbGl0ZVwiOiBjb21tb25SZWYoXCJnZW1pbmktMi4wLWZsYXNoLWxpdGVcIilcbn07XG5mdW5jdGlvbiBpc0dlbWluaU1vZGVsTmFtZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuc3RhcnRzV2l0aChcImdlbWluaS1cIikgJiYgIXZhbHVlLmVuZHNXaXRoKFwiLXR0c1wiKTtcbn1cbmNvbnN0IEtOT1dOX1RUU19NT0RFTFMgPSB7XG4gIFwiZ2VtaW5pLTIuNS1mbGFzaC1wcmV2aWV3LXR0c1wiOiBjb21tb25SZWYoXG4gICAgXCJnZW1pbmktMi41LWZsYXNoLXByZXZpZXctdHRzXCIsXG4gICAgeyAuLi5HRU5FUklDX1RUU19NT0RFTC5pbmZvIH0sXG4gICAgR2VtaW5pVHRzQ29uZmlnU2NoZW1hXG4gICksXG4gIFwiZ2VtaW5pLTIuNS1wcm8tcHJldmlldy10dHNcIjogY29tbW9uUmVmKFxuICAgIFwiZ2VtaW5pLTIuNS1wcm8tcHJldmlldy10dHNcIixcbiAgICB7IC4uLkdFTkVSSUNfVFRTX01PREVMLmluZm8gfSxcbiAgICBHZW1pbmlUdHNDb25maWdTY2hlbWFcbiAgKVxufTtcbmZ1bmN0aW9uIGlzVFRTTW9kZWxOYW1lKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5zdGFydHNXaXRoKFwiZ2VtaW5pLVwiKSAmJiB2YWx1ZS5lbmRzV2l0aChcIi10dHNcIik7XG59XG5jb25zdCBLTk9XTl9HRU1NQV9NT0RFTFMgPSB7XG4gIFwiZ2VtbWEtMy0xMmItaXRcIjogY29tbW9uUmVmKFwiZ2VtbWEtMy0xMmItaXRcIiwgdm9pZCAwLCBHZW1tYUNvbmZpZ1NjaGVtYSksXG4gIFwiZ2VtbWEtMy0xYi1pdFwiOiBjb21tb25SZWYoXCJnZW1tYS0zLTFiLWl0XCIsIHZvaWQgMCwgR2VtbWFDb25maWdTY2hlbWEpLFxuICBcImdlbW1hLTMtMjdiLWl0XCI6IGNvbW1vblJlZihcImdlbW1hLTMtMjdiLWl0XCIsIHZvaWQgMCwgR2VtbWFDb25maWdTY2hlbWEpLFxuICBcImdlbW1hLTMtNGItaXRcIjogY29tbW9uUmVmKFwiZ2VtbWEtMy00Yi1pdFwiLCB2b2lkIDAsIEdlbW1hQ29uZmlnU2NoZW1hKSxcbiAgXCJnZW1tYS0zbi1lNGItaXRcIjogY29tbW9uUmVmKFwiZ2VtbWEtM24tZTRiLWl0XCIsIHZvaWQgMCwgR2VtbWFDb25maWdTY2hlbWEpXG59O1xuZnVuY3Rpb24gaXNHZW1tYU1vZGVsTmFtZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuc3RhcnRzV2l0aChcImdlbW1hLVwiKTtcbn1cbmNvbnN0IEtOT1dOX01PREVMUyA9IHtcbiAgLi4uS05PV05fR0VNSU5JX01PREVMUyxcbiAgLi4uS05PV05fVFRTX01PREVMUyxcbiAgLi4uS05PV05fR0VNTUFfTU9ERUxTXG59O1xuZnVuY3Rpb24gbW9kZWwodmVyc2lvbiwgY29uZmlnID0ge30pIHtcbiAgY29uc3QgbmFtZSA9ICgwLCBpbXBvcnRfdXRpbHMuY2hlY2tNb2RlbE5hbWUpKHZlcnNpb24pO1xuICBpZiAoaXNUVFNNb2RlbE5hbWUobmFtZSkpIHtcbiAgICByZXR1cm4gKDAsIGltcG9ydF9tb2RlbC5tb2RlbFJlZikoe1xuICAgICAgbmFtZTogYGdvb2dsZWFpLyR7bmFtZX1gLFxuICAgICAgY29uZmlnLFxuICAgICAgY29uZmlnU2NoZW1hOiBHZW1pbmlUdHNDb25maWdTY2hlbWEsXG4gICAgICBpbmZvOiB7IC4uLkdFTkVSSUNfVFRTX01PREVMLmluZm8gfVxuICAgIH0pO1xuICB9XG4gIGlmIChpc0dlbW1hTW9kZWxOYW1lKG5hbWUpKSB7XG4gICAgcmV0dXJuICgwLCBpbXBvcnRfbW9kZWwubW9kZWxSZWYpKHtcbiAgICAgIG5hbWU6IGBnb29nbGVhaS8ke25hbWV9YCxcbiAgICAgIGNvbmZpZyxcbiAgICAgIGNvbmZpZ1NjaGVtYTogR2VtbWFDb25maWdTY2hlbWEsXG4gICAgICBpbmZvOiB7IC4uLkdFTkVSSUNfR0VNTUFfTU9ERUwuaW5mbyB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuICgwLCBpbXBvcnRfbW9kZWwubW9kZWxSZWYpKHtcbiAgICBuYW1lOiBgZ29vZ2xlYWkvJHtuYW1lfWAsXG4gICAgY29uZmlnLFxuICAgIGNvbmZpZ1NjaGVtYTogR2VtaW5pQ29uZmlnU2NoZW1hLFxuICAgIGluZm86IHsgLi4uR0VORVJJQ19NT0RFTC5pbmZvIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBsaXN0QWN0aW9ucyhtb2RlbHMpIHtcbiAgcmV0dXJuIG1vZGVscy5maWx0ZXIoKG0pID0+IG0uc3VwcG9ydGVkR2VuZXJhdGlvbk1ldGhvZHMuaW5jbHVkZXMoXCJnZW5lcmF0ZUNvbnRlbnRcIikpLmZpbHRlcigobSkgPT4gIW0uZGVzY3JpcHRpb24gfHwgIW0uZGVzY3JpcHRpb24uaW5jbHVkZXMoXCJkZXByZWNhdGVkXCIpKS5tYXAoKG0pID0+IHtcbiAgICBjb25zdCByZWYgPSBtb2RlbChtLm5hbWUpO1xuICAgIHJldHVybiAoMCwgaW1wb3J0X2dlbmtpdC5tb2RlbEFjdGlvbk1ldGFkYXRhKSh7XG4gICAgICBuYW1lOiByZWYubmFtZSxcbiAgICAgIGluZm86IHJlZi5pbmZvLFxuICAgICAgY29uZmlnU2NoZW1hOiByZWYuY29uZmlnU2NoZW1hXG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZGVmaW5lS25vd25Nb2RlbHMoYWksIG9wdGlvbnMpIHtcbiAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKEtOT1dOX01PREVMUykpIHtcbiAgICBkZWZpbmVNb2RlbChhaSwgbmFtZSwgb3B0aW9ucyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZmluZU1vZGVsKGFpLCBuYW1lLCBwbHVnaW5PcHRpb25zKSB7XG4gICgwLCBpbXBvcnRfdXRpbHMuY2hlY2tBcGlLZXkpKHBsdWdpbk9wdGlvbnM/LmFwaUtleSk7XG4gIGNvbnN0IHJlZiA9IG1vZGVsKG5hbWUpO1xuICBjb25zdCBjbGllbnRPcHRpb25zID0ge1xuICAgIGFwaVZlcnNpb246IHBsdWdpbk9wdGlvbnM/LmFwaVZlcnNpb24sXG4gICAgYmFzZVVybDogcGx1Z2luT3B0aW9ucz8uYmFzZVVybFxuICB9O1xuICBjb25zdCBtaWRkbGV3YXJlID0gW107XG4gIGlmIChyZWYuaW5mbz8uc3VwcG9ydHM/Lm1lZGlhKSB7XG4gICAgbWlkZGxld2FyZS5wdXNoKFxuICAgICAgKDAsIGltcG9ydF9taWRkbGV3YXJlLmRvd25sb2FkUmVxdWVzdE1lZGlhKSh7XG4gICAgICAgIG1heEJ5dGVzOiAxMDI0ICogMTAyNCAqIDEwLFxuICAgICAgICAvLyBkb24ndCBkb3dubGFvZCBmaWxlcyB0aGF0IGhhdmUgYmVlbiB1cGxvYWRlZCB1c2luZyB0aGUgRmlsZXMgQVBJXG4gICAgICAgIGZpbHRlcjogKHBhcnQpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChwYXJ0Lm1lZGlhLnVybCk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIC8vIEdlbWluaSBjYW4gaGFuZGxlIHRoZXNlIFVSTHNcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiZ2VuZXJhdGl2ZWxhbmd1YWdlLmdvb2dsZWFwaXMuY29tXCIsXG4gICAgICAgICAgICAgICAgXCJ3d3cueW91dHViZS5jb21cIixcbiAgICAgICAgICAgICAgICBcInlvdXR1YmUuY29tXCIsXG4gICAgICAgICAgICAgICAgXCJ5b3V0dS5iZVwiXG4gICAgICAgICAgICAgIF0uaW5jbHVkZXModXJsLmhvc3RuYW1lKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGFpLmRlZmluZU1vZGVsKFxuICAgIHtcbiAgICAgIGFwaVZlcnNpb246IFwidjJcIixcbiAgICAgIG5hbWU6IHJlZi5uYW1lLFxuICAgICAgLi4ucmVmLmluZm8sXG4gICAgICBjb25maWdTY2hlbWE6IHJlZi5jb25maWdTY2hlbWEsXG4gICAgICB1c2U6IG1pZGRsZXdhcmVcbiAgICB9LFxuICAgIGFzeW5jIChyZXF1ZXN0LCB7IHN0cmVhbWluZ1JlcXVlc3RlZCwgc2VuZENodW5rLCBhYm9ydFNpZ25hbCB9KSA9PiB7XG4gICAgICBjb25zdCBjbGllbnRPcHQgPSB7IC4uLmNsaWVudE9wdGlvbnMsIHNpZ25hbDogYWJvcnRTaWduYWwgfTtcbiAgICAgIGNvbnN0IG1lc3NhZ2VzID0gWy4uLnJlcXVlc3QubWVzc2FnZXNdO1xuICAgICAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gbWVzc2FnZXMgcHJvdmlkZWQuXCIpO1xuICAgICAgbGV0IHN5c3RlbUluc3RydWN0aW9uID0gdm9pZCAwO1xuICAgICAgY29uc3Qgc3lzdGVtTWVzc2FnZSA9IG1lc3NhZ2VzLmZpbmQoKG0pID0+IG0ucm9sZSA9PT0gXCJzeXN0ZW1cIik7XG4gICAgICBpZiAoc3lzdGVtTWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlcy5zcGxpY2UobWVzc2FnZXMuaW5kZXhPZihzeXN0ZW1NZXNzYWdlKSwgMSk7XG4gICAgICAgIHN5c3RlbUluc3RydWN0aW9uID0gKDAsIGltcG9ydF9jb252ZXJ0ZXJzLnRvR2VtaW5pU3lzdGVtSW5zdHJ1Y3Rpb24pKHN5c3RlbU1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9vbHMgPSBbXTtcbiAgICAgIGlmIChyZXF1ZXN0LnRvb2xzPy5sZW5ndGgpIHtcbiAgICAgICAgdG9vbHMucHVzaCh7XG4gICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbnM6IHJlcXVlc3QudG9vbHMubWFwKGltcG9ydF9jb252ZXJ0ZXJzLnRvR2VtaW5pVG9vbClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgLi4ucmVxdWVzdC5jb25maWdcbiAgICAgIH07XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFwaUtleTogYXBpS2V5RnJvbUNvbmZpZyxcbiAgICAgICAgc2FmZXR5U2V0dGluZ3M6IHNhZmV0eVNldHRpbmdzRnJvbUNvbmZpZyxcbiAgICAgICAgY29kZUV4ZWN1dGlvbjogY29kZUV4ZWN1dGlvbkZyb21Db25maWcsXG4gICAgICAgIHZlcnNpb246IHZlcnNpb25Gcm9tQ29uZmlnLFxuICAgICAgICBmdW5jdGlvbkNhbGxpbmdDb25maWcsXG4gICAgICAgIGdvb2dsZVNlYXJjaFJldHJpZXZhbCxcbiAgICAgICAgdG9vbHM6IHRvb2xzRnJvbUNvbmZpZyxcbiAgICAgICAgLi4ucmVzdE9mQ29uZmlnT3B0aW9uc1xuICAgICAgfSA9IHJlcXVlc3RPcHRpb25zO1xuICAgICAgaWYgKGNvZGVFeGVjdXRpb25Gcm9tQ29uZmlnKSB7XG4gICAgICAgIHRvb2xzLnB1c2goe1xuICAgICAgICAgIGNvZGVFeGVjdXRpb246IGNvZGVFeGVjdXRpb25Gcm9tQ29uZmlnID09PSB0cnVlID8ge30gOiBjb2RlRXhlY3V0aW9uRnJvbUNvbmZpZ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0b29sc0Zyb21Db25maWcpIHtcbiAgICAgICAgdG9vbHMucHVzaCguLi50b29sc0Zyb21Db25maWcpO1xuICAgICAgfVxuICAgICAgaWYgKGdvb2dsZVNlYXJjaFJldHJpZXZhbCkge1xuICAgICAgICB0b29scy5wdXNoKHtcbiAgICAgICAgICBnb29nbGVTZWFyY2g6IGdvb2dsZVNlYXJjaFJldHJpZXZhbCA9PT0gdHJ1ZSA/IHt9IDogZ29vZ2xlU2VhcmNoUmV0cmlldmFsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbGV0IHRvb2xDb25maWc7XG4gICAgICBpZiAoZnVuY3Rpb25DYWxsaW5nQ29uZmlnKSB7XG4gICAgICAgIHRvb2xDb25maWcgPSB7XG4gICAgICAgICAgZnVuY3Rpb25DYWxsaW5nQ29uZmlnOiB7XG4gICAgICAgICAgICBhbGxvd2VkRnVuY3Rpb25OYW1lczogZnVuY3Rpb25DYWxsaW5nQ29uZmlnLmFsbG93ZWRGdW5jdGlvbk5hbWVzLFxuICAgICAgICAgICAgbW9kZTogKDAsIGltcG9ydF9jb252ZXJ0ZXJzLnRvR2VtaW5pRnVuY3Rpb25Nb2RlRW51bSkoZnVuY3Rpb25DYWxsaW5nQ29uZmlnLm1vZGUpXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0LnRvb2xDaG9pY2UpIHtcbiAgICAgICAgdG9vbENvbmZpZyA9IHtcbiAgICAgICAgICBmdW5jdGlvbkNhbGxpbmdDb25maWc6IHtcbiAgICAgICAgICAgIG1vZGU6ICgwLCBpbXBvcnRfY29udmVydGVycy50b0dlbWluaUZ1bmN0aW9uTW9kZUVudW0pKHJlcXVlc3QudG9vbENob2ljZSlcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBqc29uTW9kZSA9IHJlcXVlc3Qub3V0cHV0Py5mb3JtYXQgPT09IFwianNvblwiIHx8IHJlcXVlc3Qub3V0cHV0Py5jb250ZW50VHlwZSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uXCIgJiYgdG9vbHMubGVuZ3RoID09PSAwO1xuICAgICAgY29uc3QgZ2VuZXJhdGlvbkNvbmZpZyA9IHtcbiAgICAgICAgLi4ucmVzdE9mQ29uZmlnT3B0aW9ucyxcbiAgICAgICAgY2FuZGlkYXRlQ291bnQ6IHJlcXVlc3QuY2FuZGlkYXRlcyB8fCB2b2lkIDAsXG4gICAgICAgIHJlc3BvbnNlTWltZVR5cGU6IGpzb25Nb2RlID8gXCJhcHBsaWNhdGlvbi9qc29uXCIgOiB2b2lkIDBcbiAgICAgIH07XG4gICAgICBpZiAocmVxdWVzdC5vdXRwdXQ/LmNvbnN0cmFpbmVkICYmIGpzb25Nb2RlKSB7XG4gICAgICAgIGdlbmVyYXRpb25Db25maWcucmVzcG9uc2VTY2hlbWEgPSAoMCwgaW1wb3J0X3V0aWxzLmNsZWFuU2NoZW1hKShyZXF1ZXN0Lm91dHB1dC5zY2hlbWEpO1xuICAgICAgfVxuICAgICAgY29uc3QgbXNnID0gKDAsIGltcG9ydF9jb252ZXJ0ZXJzLnRvR2VtaW5pTWVzc2FnZSkobWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV0sIHJlZik7XG4gICAgICBsZXQgZ2VuZXJhdGVDb250ZW50UmVxdWVzdCA9IHtcbiAgICAgICAgc3lzdGVtSW5zdHJ1Y3Rpb24sXG4gICAgICAgIGdlbmVyYXRpb25Db25maWcsXG4gICAgICAgIHRvb2xzOiB0b29scy5sZW5ndGggPyB0b29scyA6IHZvaWQgMCxcbiAgICAgICAgdG9vbENvbmZpZyxcbiAgICAgICAgc2FmZXR5U2V0dGluZ3M6IHNhZmV0eVNldHRpbmdzRnJvbUNvbmZpZz8uZmlsdGVyKFxuICAgICAgICAgIChzZXR0aW5nKSA9PiBzZXR0aW5nLmNhdGVnb3J5ICE9PSBcIkhBUk1fQ0FURUdPUllfVU5TUEVDSUZJRURcIlxuICAgICAgICApLFxuICAgICAgICBjb250ZW50czogbWVzc2FnZXMubWFwKChtZXNzYWdlKSA9PiAoMCwgaW1wb3J0X2NvbnZlcnRlcnMudG9HZW1pbmlNZXNzYWdlKShtZXNzYWdlLCByZWYpKVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG1vZGVsVmVyc2lvbiA9IHZlcnNpb25Gcm9tQ29uZmlnIHx8ICgwLCBpbXBvcnRfdXRpbHMuZXh0cmFjdFZlcnNpb24pKHJlZik7XG4gICAgICBjb25zdCBnZW5lcmF0ZUFwaUtleSA9ICgwLCBpbXBvcnRfdXRpbHMuY2FsY3VsYXRlQXBpS2V5KShcbiAgICAgICAgcGx1Z2luT3B0aW9ucz8uYXBpS2V5LFxuICAgICAgICByZXF1ZXN0T3B0aW9ucy5hcGlLZXlcbiAgICAgICk7XG4gICAgICBjb25zdCBjYWxsR2VtaW5pID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGlmIChzdHJlYW1pbmdSZXF1ZXN0ZWQpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCAoMCwgaW1wb3J0X2NsaWVudC5nZW5lcmF0ZUNvbnRlbnRTdHJlYW0pKFxuICAgICAgICAgICAgZ2VuZXJhdGVBcGlLZXksXG4gICAgICAgICAgICBtb2RlbFZlcnNpb24sXG4gICAgICAgICAgICBnZW5lcmF0ZUNvbnRlbnRSZXF1ZXN0LFxuICAgICAgICAgICAgY2xpZW50T3B0XG4gICAgICAgICAgKTtcbiAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgcmVzdWx0LnN0cmVhbSkge1xuICAgICAgICAgICAgaXRlbS5jYW5kaWRhdGVzPy5mb3JFYWNoKChjYW5kaWRhdGUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgYyA9ICgwLCBpbXBvcnRfY29udmVydGVycy5mcm9tR2VtaW5pQ2FuZGlkYXRlKShjYW5kaWRhdGUpO1xuICAgICAgICAgICAgICBzZW5kQ2h1bmsoe1xuICAgICAgICAgICAgICAgIGluZGV4OiBjLmluZGV4LFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGMubWVzc2FnZS5jb250ZW50XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgcmVzdWx0LnJlc3BvbnNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgKDAsIGltcG9ydF9jbGllbnQuZ2VuZXJhdGVDb250ZW50KShcbiAgICAgICAgICAgIGdlbmVyYXRlQXBpS2V5LFxuICAgICAgICAgICAgbW9kZWxWZXJzaW9uLFxuICAgICAgICAgICAgZ2VuZXJhdGVDb250ZW50UmVxdWVzdCxcbiAgICAgICAgICAgIGNsaWVudE9wdFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FuZGlkYXRlcyA9IHJlc3BvbnNlLmNhbmRpZGF0ZXMgfHwgW107XG4gICAgICAgIGlmIChyZXNwb25zZS5jYW5kaWRhdGVzPy5bXCJ1bmRlZmluZWRcIl0pIHtcbiAgICAgICAgICBjYW5kaWRhdGVzLnB1c2gocmVzcG9uc2UuY2FuZGlkYXRlc1tcInVuZGVmaW5lZFwiXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYW5kaWRhdGVzLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBpbXBvcnRfZ2Vua2l0LkdlbmtpdEVycm9yKHtcbiAgICAgICAgICAgIHN0YXR1czogXCJGQUlMRURfUFJFQ09ORElUSU9OXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBcIk5vIHZhbGlkIGNhbmRpZGF0ZXMgcmV0dXJuZWQuXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW5kaWRhdGVEYXRhID0gY2FuZGlkYXRlcy5tYXAoaW1wb3J0X2NvbnZlcnRlcnMuZnJvbUdlbWluaUNhbmRpZGF0ZSkgfHwgW107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2FuZGlkYXRlczogY2FuZGlkYXRlRGF0YSxcbiAgICAgICAgICBjdXN0b206IHJlc3BvbnNlLFxuICAgICAgICAgIHVzYWdlOiB7XG4gICAgICAgICAgICAuLi4oMCwgaW1wb3J0X21vZGVsLmdldEJhc2ljVXNhZ2VTdGF0cykocmVxdWVzdC5tZXNzYWdlcywgY2FuZGlkYXRlRGF0YSksXG4gICAgICAgICAgICBpbnB1dFRva2VuczogcmVzcG9uc2UudXNhZ2VNZXRhZGF0YT8ucHJvbXB0VG9rZW5Db3VudCxcbiAgICAgICAgICAgIG91dHB1dFRva2VuczogcmVzcG9uc2UudXNhZ2VNZXRhZGF0YT8uY2FuZGlkYXRlc1Rva2VuQ291bnQsXG4gICAgICAgICAgICB0aG91Z2h0c1Rva2VuczogcmVzcG9uc2UudXNhZ2VNZXRhZGF0YT8udGhvdWdodHNUb2tlbkNvdW50LFxuICAgICAgICAgICAgdG90YWxUb2tlbnM6IHJlc3BvbnNlLnVzYWdlTWV0YWRhdGE/LnRvdGFsVG9rZW5Db3VudCxcbiAgICAgICAgICAgIGNhY2hlZENvbnRlbnRUb2tlbnM6IHJlc3BvbnNlLnVzYWdlTWV0YWRhdGE/LmNhY2hlZENvbnRlbnRUb2tlbkNvdW50XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHJldHVybiBwbHVnaW5PcHRpb25zPy5leHBlcmltZW50YWxfZGVidWdUcmFjZXMgPyBhd2FpdCAoMCwgaW1wb3J0X3RyYWNpbmcucnVuSW5OZXdTcGFuKShcbiAgICAgICAgYWkucmVnaXN0cnksXG4gICAgICAgIHtcbiAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgbmFtZTogc3RyZWFtaW5nUmVxdWVzdGVkID8gXCJzZW5kTWVzc2FnZVN0cmVhbVwiIDogXCJzZW5kTWVzc2FnZVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhc3luYyAobWV0YWRhdGEpID0+IHtcbiAgICAgICAgICBtZXRhZGF0YS5pbnB1dCA9IHtcbiAgICAgICAgICAgIGFwaUVuZHBvaW50OiAoMCwgaW1wb3J0X2NsaWVudC5nZXRHb29nbGVBSVVybCkoe1xuICAgICAgICAgICAgICByZXNvdXJjZVBhdGg6IFwiXCIsXG4gICAgICAgICAgICAgIGNsaWVudE9wdGlvbnM6IGNsaWVudE9wdFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBjYWNoZToge30sXG4gICAgICAgICAgICBtb2RlbDogbW9kZWxWZXJzaW9uLFxuICAgICAgICAgICAgZ2VuZXJhdGVDb250ZW50T3B0aW9uczogZ2VuZXJhdGVDb250ZW50UmVxdWVzdCxcbiAgICAgICAgICAgIHBhcnRzOiBtc2cucGFydHMsXG4gICAgICAgICAgICBvcHRpb25zOiBjbGllbnRPcHRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2FsbEdlbWluaSgpO1xuICAgICAgICAgIG1ldGFkYXRhLm91dHB1dCA9IHJlc3BvbnNlLmN1c3RvbTtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICkgOiBhd2FpdCBjYWxsR2VtaW5pKCk7XG4gICAgfVxuICApO1xufVxuY29uc3QgVEVTVF9PTkxZID0geyBLTk9XTl9NT0RFTFMgfTtcbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBHZW1pbmlDb25maWdTY2hlbWEsXG4gIEdlbWluaVR0c0NvbmZpZ1NjaGVtYSxcbiAgR2VtbWFDb25maWdTY2hlbWEsXG4gIFRFU1RfT05MWSxcbiAgZGVmaW5lS25vd25Nb2RlbHMsXG4gIGRlZmluZU1vZGVsLFxuICBpc0dlbWluaU1vZGVsTmFtZSxcbiAgaXNHZW1tYU1vZGVsTmFtZSxcbiAgaXNUVFNNb2RlbE5hbWUsXG4gIGxpc3RBY3Rpb25zLFxuICBtb2RlbFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW1pbmkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/gemini.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/imagen.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@genkit-ai/google-genai/lib/googleai/imagen.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar imagen_exports = {};\n__export(imagen_exports, {\n  ImagenConfigSchema: () => ImagenConfigSchema,\n  TEST_ONLY: () => TEST_ONLY,\n  defineKnownModels: () => defineKnownModels,\n  defineModel: () => defineModel,\n  isImagenModelName: () => isImagenModelName,\n  listActions: () => listActions,\n  model: () => model\n});\nmodule.exports = __toCommonJS(imagen_exports);\nvar import_genkit = __webpack_require__(/*! genkit */ \"(action-browser)/./node_modules/genkit/lib/index.js\");\nvar import_model = __webpack_require__(/*! genkit/model */ \"(action-browser)/./node_modules/genkit/lib/model.js\");\nvar import_client = __webpack_require__(/*! ./client.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/client.js\");\nvar import_utils = __webpack_require__(/*! ./utils.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/utils.js\");\nconst ImagenConfigSchema = import_genkit.z.object({\n  apiKey: import_genkit.z.string().describe(\"Override the API key provided at plugin initialization.\").optional(),\n  numberOfImages: import_genkit.z.number().describe(\n    \"The number of images to generate, from 1 to 4 (inclusive). The default is 1.\"\n  ).optional(),\n  aspectRatio: import_genkit.z.enum([\"1:1\", \"9:16\", \"16:9\", \"3:4\", \"4:3\"]).describe(\"Desired aspect ratio of the output image.\").optional(),\n  personGeneration: import_genkit.z.enum([\"dont_allow\", \"allow_adult\", \"allow_all\"]).describe(\n    \"Control if/how images of people will be generated by the model.\"\n  ).optional()\n}).passthrough();\nfunction commonRef(name, info, configSchema = ImagenConfigSchema) {\n  return (0, import_model.modelRef)({\n    name: `googleai/${name}`,\n    configSchema,\n    info: info ?? {\n      supports: {\n        media: true,\n        multiturn: false,\n        tools: false,\n        toolChoice: false,\n        systemRole: false,\n        output: [\"media\"]\n      }\n    }\n  });\n}\nconst GENERIC_MODEL = commonRef(\"imagen\", {\n  supports: {\n    media: true,\n    multiturn: true,\n    tools: true,\n    systemRole: true,\n    output: [\"media\"]\n  }\n});\nconst KNOWN_MODELS = {\n  \"imagen-3.0-generate-002\": commonRef(\"imagen-3.0-generate-002\"),\n  \"imagen-4.0-generate-preview-06-06\": commonRef(\n    \"imagen-4.0-generate-preview-06-06\"\n  ),\n  \"imagen-4.0-ultra-generate-preview-06-06\": commonRef(\n    \"imagen-4.0-ultra-generate-preview-06-06\"\n  )\n};\nfunction isImagenModelName(value) {\n  return !!value?.startsWith(\"imagen-\");\n}\nfunction model(version, config = {}) {\n  const name = (0, import_utils.checkModelName)(version);\n  if (KNOWN_MODELS[name]) {\n    return KNOWN_MODELS[name].withConfig(config);\n  }\n  return (0, import_model.modelRef)({\n    name: `googleai/${name}`,\n    config,\n    configSchema: ImagenConfigSchema,\n    info: {\n      ...GENERIC_MODEL.info\n    }\n  });\n}\nfunction listActions(models) {\n  return models.filter(\n    (m) => m.supportedGenerationMethods.includes(\"predict\") && isImagenModelName((0, import_utils.modelName)(m.name))\n  ).filter((m) => !m.description || !m.description.includes(\"deprecated\")).map((m) => {\n    const ref = model(m.name);\n    return (0, import_genkit.modelActionMetadata)({\n      name: ref.name,\n      info: ref.info,\n      configSchema: ref.configSchema\n    });\n  });\n}\nfunction defineKnownModels(ai, options) {\n  for (const name of Object.keys(KNOWN_MODELS)) {\n    defineModel(ai, name, options);\n  }\n}\nfunction defineModel(ai, name, pluginOptions) {\n  (0, import_utils.checkApiKey)(pluginOptions?.apiKey);\n  const ref = model(name);\n  const clientOptions = {\n    apiVersion: pluginOptions?.apiVersion,\n    baseUrl: pluginOptions?.baseUrl\n  };\n  return ai.defineModel(\n    {\n      apiVersion: \"v2\",\n      name: ref.name,\n      ...ref.info,\n      configSchema: ref.configSchema\n    },\n    async (request, { abortSignal }) => {\n      const clientOpt = { ...clientOptions, signal: abortSignal };\n      const imagenPredictRequest = {\n        instances: [\n          {\n            prompt: (0, import_utils.extractText)(request),\n            image: (0, import_utils.extractImagenImage)(request)\n          }\n        ],\n        parameters: toImagenParameters(request)\n      };\n      const predictApiKey = (0, import_utils.calculateApiKey)(\n        pluginOptions?.apiKey,\n        request.config?.apiKey\n      );\n      const response = await (0, import_client.imagenPredict)(\n        predictApiKey,\n        (0, import_utils.extractVersion)(ref),\n        imagenPredictRequest,\n        clientOpt\n      );\n      if (!response.predictions || response.predictions.length == 0) {\n        throw new Error(\n          \"Model returned no predictions. Possibly due to content filters.\"\n        );\n      }\n      const message = {\n        role: \"model\",\n        content: response.predictions.map(fromImagenPrediction)\n      };\n      return {\n        finishReason: \"stop\",\n        message,\n        usage: (0, import_model.getBasicUsageStats)(request.messages, message),\n        custom: response\n      };\n    }\n  );\n}\nfunction fromImagenPrediction(p) {\n  const b64data = p.bytesBase64Encoded;\n  const mimeType = p.mimeType;\n  return {\n    media: {\n      url: `data:${mimeType};base64,${b64data}`,\n      contentType: mimeType\n    }\n  };\n}\nfunction toImagenParameters(request) {\n  const out = {\n    sampleCount: request.config?.numberOfImages ?? 1,\n    ...request?.config\n  };\n  for (const k in out) {\n    if (!out[k]) delete out[k];\n  }\n  delete out.apiKey;\n  return out;\n}\nconst TEST_ONLY = {\n  toImagenParameters,\n  fromImagenPrediction,\n  GENERIC_MODEL,\n  KNOWN_MODELS\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=imagen.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2dvb2dsZS1nZW5haS9saWIvZ29vZ2xlYWkvaW1hZ2VuLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsbUVBQVE7QUFDcEMsbUJBQW1CLG1CQUFPLENBQUMseUVBQWM7QUFDekMsb0JBQW9CLG1CQUFPLENBQUMsbUdBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsaUdBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHNCQUFzQixhQUFhO0FBQ25DLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVSxTQUFTLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBUUw7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcZ29vZ2xlLWdlbmFpXFxsaWJcXGdvb2dsZWFpXFxpbWFnZW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIGltYWdlbl9leHBvcnRzID0ge307XG5fX2V4cG9ydChpbWFnZW5fZXhwb3J0cywge1xuICBJbWFnZW5Db25maWdTY2hlbWE6ICgpID0+IEltYWdlbkNvbmZpZ1NjaGVtYSxcbiAgVEVTVF9PTkxZOiAoKSA9PiBURVNUX09OTFksXG4gIGRlZmluZUtub3duTW9kZWxzOiAoKSA9PiBkZWZpbmVLbm93bk1vZGVscyxcbiAgZGVmaW5lTW9kZWw6ICgpID0+IGRlZmluZU1vZGVsLFxuICBpc0ltYWdlbk1vZGVsTmFtZTogKCkgPT4gaXNJbWFnZW5Nb2RlbE5hbWUsXG4gIGxpc3RBY3Rpb25zOiAoKSA9PiBsaXN0QWN0aW9ucyxcbiAgbW9kZWw6ICgpID0+IG1vZGVsXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKGltYWdlbl9leHBvcnRzKTtcbnZhciBpbXBvcnRfZ2Vua2l0ID0gcmVxdWlyZShcImdlbmtpdFwiKTtcbnZhciBpbXBvcnRfbW9kZWwgPSByZXF1aXJlKFwiZ2Vua2l0L21vZGVsXCIpO1xudmFyIGltcG9ydF9jbGllbnQgPSByZXF1aXJlKFwiLi9jbGllbnQuanNcIik7XG52YXIgaW1wb3J0X3V0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5jb25zdCBJbWFnZW5Db25maWdTY2hlbWEgPSBpbXBvcnRfZ2Vua2l0Lnoub2JqZWN0KHtcbiAgYXBpS2V5OiBpbXBvcnRfZ2Vua2l0Lnouc3RyaW5nKCkuZGVzY3JpYmUoXCJPdmVycmlkZSB0aGUgQVBJIGtleSBwcm92aWRlZCBhdCBwbHVnaW4gaW5pdGlhbGl6YXRpb24uXCIpLm9wdGlvbmFsKCksXG4gIG51bWJlck9mSW1hZ2VzOiBpbXBvcnRfZ2Vua2l0LnoubnVtYmVyKCkuZGVzY3JpYmUoXG4gICAgXCJUaGUgbnVtYmVyIG9mIGltYWdlcyB0byBnZW5lcmF0ZSwgZnJvbSAxIHRvIDQgKGluY2x1c2l2ZSkuIFRoZSBkZWZhdWx0IGlzIDEuXCJcbiAgKS5vcHRpb25hbCgpLFxuICBhc3BlY3RSYXRpbzogaW1wb3J0X2dlbmtpdC56LmVudW0oW1wiMToxXCIsIFwiOToxNlwiLCBcIjE2OjlcIiwgXCIzOjRcIiwgXCI0OjNcIl0pLmRlc2NyaWJlKFwiRGVzaXJlZCBhc3BlY3QgcmF0aW8gb2YgdGhlIG91dHB1dCBpbWFnZS5cIikub3B0aW9uYWwoKSxcbiAgcGVyc29uR2VuZXJhdGlvbjogaW1wb3J0X2dlbmtpdC56LmVudW0oW1wiZG9udF9hbGxvd1wiLCBcImFsbG93X2FkdWx0XCIsIFwiYWxsb3dfYWxsXCJdKS5kZXNjcmliZShcbiAgICBcIkNvbnRyb2wgaWYvaG93IGltYWdlcyBvZiBwZW9wbGUgd2lsbCBiZSBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLlwiXG4gICkub3B0aW9uYWwoKVxufSkucGFzc3Rocm91Z2goKTtcbmZ1bmN0aW9uIGNvbW1vblJlZihuYW1lLCBpbmZvLCBjb25maWdTY2hlbWEgPSBJbWFnZW5Db25maWdTY2hlbWEpIHtcbiAgcmV0dXJuICgwLCBpbXBvcnRfbW9kZWwubW9kZWxSZWYpKHtcbiAgICBuYW1lOiBgZ29vZ2xlYWkvJHtuYW1lfWAsXG4gICAgY29uZmlnU2NoZW1hLFxuICAgIGluZm86IGluZm8gPz8ge1xuICAgICAgc3VwcG9ydHM6IHtcbiAgICAgICAgbWVkaWE6IHRydWUsXG4gICAgICAgIG11bHRpdHVybjogZmFsc2UsXG4gICAgICAgIHRvb2xzOiBmYWxzZSxcbiAgICAgICAgdG9vbENob2ljZTogZmFsc2UsXG4gICAgICAgIHN5c3RlbVJvbGU6IGZhbHNlLFxuICAgICAgICBvdXRwdXQ6IFtcIm1lZGlhXCJdXG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmNvbnN0IEdFTkVSSUNfTU9ERUwgPSBjb21tb25SZWYoXCJpbWFnZW5cIiwge1xuICBzdXBwb3J0czoge1xuICAgIG1lZGlhOiB0cnVlLFxuICAgIG11bHRpdHVybjogdHJ1ZSxcbiAgICB0b29sczogdHJ1ZSxcbiAgICBzeXN0ZW1Sb2xlOiB0cnVlLFxuICAgIG91dHB1dDogW1wibWVkaWFcIl1cbiAgfVxufSk7XG5jb25zdCBLTk9XTl9NT0RFTFMgPSB7XG4gIFwiaW1hZ2VuLTMuMC1nZW5lcmF0ZS0wMDJcIjogY29tbW9uUmVmKFwiaW1hZ2VuLTMuMC1nZW5lcmF0ZS0wMDJcIiksXG4gIFwiaW1hZ2VuLTQuMC1nZW5lcmF0ZS1wcmV2aWV3LTA2LTA2XCI6IGNvbW1vblJlZihcbiAgICBcImltYWdlbi00LjAtZ2VuZXJhdGUtcHJldmlldy0wNi0wNlwiXG4gICksXG4gIFwiaW1hZ2VuLTQuMC11bHRyYS1nZW5lcmF0ZS1wcmV2aWV3LTA2LTA2XCI6IGNvbW1vblJlZihcbiAgICBcImltYWdlbi00LjAtdWx0cmEtZ2VuZXJhdGUtcHJldmlldy0wNi0wNlwiXG4gIClcbn07XG5mdW5jdGlvbiBpc0ltYWdlbk1vZGVsTmFtZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZT8uc3RhcnRzV2l0aChcImltYWdlbi1cIik7XG59XG5mdW5jdGlvbiBtb2RlbCh2ZXJzaW9uLCBjb25maWcgPSB7fSkge1xuICBjb25zdCBuYW1lID0gKDAsIGltcG9ydF91dGlscy5jaGVja01vZGVsTmFtZSkodmVyc2lvbik7XG4gIGlmIChLTk9XTl9NT0RFTFNbbmFtZV0pIHtcbiAgICByZXR1cm4gS05PV05fTU9ERUxTW25hbWVdLndpdGhDb25maWcoY29uZmlnKTtcbiAgfVxuICByZXR1cm4gKDAsIGltcG9ydF9tb2RlbC5tb2RlbFJlZikoe1xuICAgIG5hbWU6IGBnb29nbGVhaS8ke25hbWV9YCxcbiAgICBjb25maWcsXG4gICAgY29uZmlnU2NoZW1hOiBJbWFnZW5Db25maWdTY2hlbWEsXG4gICAgaW5mbzoge1xuICAgICAgLi4uR0VORVJJQ19NT0RFTC5pbmZvXG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGxpc3RBY3Rpb25zKG1vZGVscykge1xuICByZXR1cm4gbW9kZWxzLmZpbHRlcihcbiAgICAobSkgPT4gbS5zdXBwb3J0ZWRHZW5lcmF0aW9uTWV0aG9kcy5pbmNsdWRlcyhcInByZWRpY3RcIikgJiYgaXNJbWFnZW5Nb2RlbE5hbWUoKDAsIGltcG9ydF91dGlscy5tb2RlbE5hbWUpKG0ubmFtZSkpXG4gICkuZmlsdGVyKChtKSA9PiAhbS5kZXNjcmlwdGlvbiB8fCAhbS5kZXNjcmlwdGlvbi5pbmNsdWRlcyhcImRlcHJlY2F0ZWRcIikpLm1hcCgobSkgPT4ge1xuICAgIGNvbnN0IHJlZiA9IG1vZGVsKG0ubmFtZSk7XG4gICAgcmV0dXJuICgwLCBpbXBvcnRfZ2Vua2l0Lm1vZGVsQWN0aW9uTWV0YWRhdGEpKHtcbiAgICAgIG5hbWU6IHJlZi5uYW1lLFxuICAgICAgaW5mbzogcmVmLmluZm8sXG4gICAgICBjb25maWdTY2hlbWE6IHJlZi5jb25maWdTY2hlbWFcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBkZWZpbmVLbm93bk1vZGVscyhhaSwgb3B0aW9ucykge1xuICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoS05PV05fTU9ERUxTKSkge1xuICAgIGRlZmluZU1vZGVsKGFpLCBuYW1lLCBvcHRpb25zKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVmaW5lTW9kZWwoYWksIG5hbWUsIHBsdWdpbk9wdGlvbnMpIHtcbiAgKDAsIGltcG9ydF91dGlscy5jaGVja0FwaUtleSkocGx1Z2luT3B0aW9ucz8uYXBpS2V5KTtcbiAgY29uc3QgcmVmID0gbW9kZWwobmFtZSk7XG4gIGNvbnN0IGNsaWVudE9wdGlvbnMgPSB7XG4gICAgYXBpVmVyc2lvbjogcGx1Z2luT3B0aW9ucz8uYXBpVmVyc2lvbixcbiAgICBiYXNlVXJsOiBwbHVnaW5PcHRpb25zPy5iYXNlVXJsXG4gIH07XG4gIHJldHVybiBhaS5kZWZpbmVNb2RlbChcbiAgICB7XG4gICAgICBhcGlWZXJzaW9uOiBcInYyXCIsXG4gICAgICBuYW1lOiByZWYubmFtZSxcbiAgICAgIC4uLnJlZi5pbmZvLFxuICAgICAgY29uZmlnU2NoZW1hOiByZWYuY29uZmlnU2NoZW1hXG4gICAgfSxcbiAgICBhc3luYyAocmVxdWVzdCwgeyBhYm9ydFNpZ25hbCB9KSA9PiB7XG4gICAgICBjb25zdCBjbGllbnRPcHQgPSB7IC4uLmNsaWVudE9wdGlvbnMsIHNpZ25hbDogYWJvcnRTaWduYWwgfTtcbiAgICAgIGNvbnN0IGltYWdlblByZWRpY3RSZXF1ZXN0ID0ge1xuICAgICAgICBpbnN0YW5jZXM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwcm9tcHQ6ICgwLCBpbXBvcnRfdXRpbHMuZXh0cmFjdFRleHQpKHJlcXVlc3QpLFxuICAgICAgICAgICAgaW1hZ2U6ICgwLCBpbXBvcnRfdXRpbHMuZXh0cmFjdEltYWdlbkltYWdlKShyZXF1ZXN0KVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGFyYW1ldGVyczogdG9JbWFnZW5QYXJhbWV0ZXJzKHJlcXVlc3QpXG4gICAgICB9O1xuICAgICAgY29uc3QgcHJlZGljdEFwaUtleSA9ICgwLCBpbXBvcnRfdXRpbHMuY2FsY3VsYXRlQXBpS2V5KShcbiAgICAgICAgcGx1Z2luT3B0aW9ucz8uYXBpS2V5LFxuICAgICAgICByZXF1ZXN0LmNvbmZpZz8uYXBpS2V5XG4gICAgICApO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCAoMCwgaW1wb3J0X2NsaWVudC5pbWFnZW5QcmVkaWN0KShcbiAgICAgICAgcHJlZGljdEFwaUtleSxcbiAgICAgICAgKDAsIGltcG9ydF91dGlscy5leHRyYWN0VmVyc2lvbikocmVmKSxcbiAgICAgICAgaW1hZ2VuUHJlZGljdFJlcXVlc3QsXG4gICAgICAgIGNsaWVudE9wdFxuICAgICAgKTtcbiAgICAgIGlmICghcmVzcG9uc2UucHJlZGljdGlvbnMgfHwgcmVzcG9uc2UucHJlZGljdGlvbnMubGVuZ3RoID09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiTW9kZWwgcmV0dXJuZWQgbm8gcHJlZGljdGlvbnMuIFBvc3NpYmx5IGR1ZSB0byBjb250ZW50IGZpbHRlcnMuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgIHJvbGU6IFwibW9kZWxcIixcbiAgICAgICAgY29udGVudDogcmVzcG9uc2UucHJlZGljdGlvbnMubWFwKGZyb21JbWFnZW5QcmVkaWN0aW9uKVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZpbmlzaFJlYXNvbjogXCJzdG9wXCIsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHVzYWdlOiAoMCwgaW1wb3J0X21vZGVsLmdldEJhc2ljVXNhZ2VTdGF0cykocmVxdWVzdC5tZXNzYWdlcywgbWVzc2FnZSksXG4gICAgICAgIGN1c3RvbTogcmVzcG9uc2VcbiAgICAgIH07XG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gZnJvbUltYWdlblByZWRpY3Rpb24ocCkge1xuICBjb25zdCBiNjRkYXRhID0gcC5ieXRlc0Jhc2U2NEVuY29kZWQ7XG4gIGNvbnN0IG1pbWVUeXBlID0gcC5taW1lVHlwZTtcbiAgcmV0dXJuIHtcbiAgICBtZWRpYToge1xuICAgICAgdXJsOiBgZGF0YToke21pbWVUeXBlfTtiYXNlNjQsJHtiNjRkYXRhfWAsXG4gICAgICBjb250ZW50VHlwZTogbWltZVR5cGVcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB0b0ltYWdlblBhcmFtZXRlcnMocmVxdWVzdCkge1xuICBjb25zdCBvdXQgPSB7XG4gICAgc2FtcGxlQ291bnQ6IHJlcXVlc3QuY29uZmlnPy5udW1iZXJPZkltYWdlcyA/PyAxLFxuICAgIC4uLnJlcXVlc3Q/LmNvbmZpZ1xuICB9O1xuICBmb3IgKGNvbnN0IGsgaW4gb3V0KSB7XG4gICAgaWYgKCFvdXRba10pIGRlbGV0ZSBvdXRba107XG4gIH1cbiAgZGVsZXRlIG91dC5hcGlLZXk7XG4gIHJldHVybiBvdXQ7XG59XG5jb25zdCBURVNUX09OTFkgPSB7XG4gIHRvSW1hZ2VuUGFyYW1ldGVycyxcbiAgZnJvbUltYWdlblByZWRpY3Rpb24sXG4gIEdFTkVSSUNfTU9ERUwsXG4gIEtOT1dOX01PREVMU1xufTtcbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBJbWFnZW5Db25maWdTY2hlbWEsXG4gIFRFU1RfT05MWSxcbiAgZGVmaW5lS25vd25Nb2RlbHMsXG4gIGRlZmluZU1vZGVsLFxuICBpc0ltYWdlbk1vZGVsTmFtZSxcbiAgbGlzdEFjdGlvbnMsXG4gIG1vZGVsXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/imagen.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@genkit-ai/google-genai/lib/googleai/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar googleai_exports = {};\n__export(googleai_exports, {\n  default: () => googleai_default,\n  googleAI: () => googleAI,\n  googleAIPlugin: () => googleAIPlugin\n});\nmodule.exports = __toCommonJS(googleai_exports);\nvar import_logging = __webpack_require__(/*! genkit/logging */ \"(action-browser)/./node_modules/genkit/lib/logging.js\");\nvar import_plugin = __webpack_require__(/*! genkit/plugin */ \"(action-browser)/./node_modules/genkit/lib/plugin.js\");\nvar import_utils = __webpack_require__(/*! ../common/utils.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/common/utils.js\");\nvar import_client = __webpack_require__(/*! ./client.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/client.js\");\nvar import_utils2 = __webpack_require__(/*! ./utils.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/utils.js\");\nvar embedder = __toESM(__webpack_require__(/*! ./embedder.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/embedder.js\"));\nvar gemini = __toESM(__webpack_require__(/*! ./gemini.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/gemini.js\"));\nvar imagen = __toESM(__webpack_require__(/*! ./imagen.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/imagen.js\"));\nvar veo = __toESM(__webpack_require__(/*! ./veo.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/veo.js\"));\nasync function initializer(ai, options) {\n  imagen.defineKnownModels(ai, options);\n  gemini.defineKnownModels(ai, options);\n  embedder.defineKnownModels(ai, options);\n  veo.defineKnownModels(ai, options);\n}\nasync function resolver(ai, actionType, actionName, options) {\n  switch (actionType) {\n    case \"model\":\n      if (veo.isVeoModelName(actionName)) {\n      } else if (imagen.isImagenModelName(actionName)) {\n        imagen.defineModel(ai, actionName, options);\n      } else {\n        gemini.defineModel(ai, actionName, options);\n      }\n      break;\n    case \"background-model\":\n      if (veo.isVeoModelName(actionName)) {\n        veo.defineModel(ai, actionName, options);\n      }\n      break;\n    case \"embedder\":\n      embedder.defineEmbedder(ai, actionName, options);\n      break;\n    default:\n  }\n}\nasync function listActions(options) {\n  try {\n    const apiKey = (0, import_utils2.calculateApiKey)(options?.apiKey, void 0);\n    const allModels = await (0, import_client.listModels)(apiKey, {\n      baseUrl: options?.baseUrl,\n      apiVersion: options?.apiVersion\n    });\n    return [\n      ...gemini.listActions(allModels),\n      ...imagen.listActions(allModels),\n      ...veo.listActions(allModels),\n      ...embedder.listActions(allModels)\n    ];\n  } catch (e) {\n    import_logging.logger.error((0, import_utils.extractErrMsg)(e));\n    return [];\n  }\n}\nfunction googleAIPlugin(options) {\n  let listActionsCache;\n  return (0, import_plugin.genkitPlugin)(\n    \"googleai\",\n    async (ai) => await initializer(ai, options),\n    async (ai, actionType, actionName) => await resolver(ai, actionType, actionName, options || {}),\n    async () => {\n      if (listActionsCache) return listActionsCache;\n      listActionsCache = await listActions(options);\n      return listActionsCache;\n    }\n  );\n}\nconst googleAI = googleAIPlugin;\ngoogleAI.model = (name, config) => {\n  if (veo.isVeoModelName(name)) {\n    return veo.model(name, config);\n  }\n  if (imagen.isImagenModelName(name)) {\n    return imagen.model(name, config);\n  }\n  return gemini.model(name, config);\n};\ngoogleAI.embedder = (name, config) => {\n  return embedder.model(name, config);\n};\nvar googleai_default = googleAI;\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2dvb2dsZS1nZW5haS9saWIvZ29vZ2xlYWkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsOEJBQThCO0FBQ3ZHO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLDZFQUFnQjtBQUM3QyxvQkFBb0IsbUJBQU8sQ0FBQywyRUFBZTtBQUMzQyxtQkFBbUIsbUJBQU8sQ0FBQyx1R0FBb0I7QUFDL0Msb0JBQW9CLG1CQUFPLENBQUMsbUdBQWE7QUFDekMsb0JBQW9CLG1CQUFPLENBQUMsaUdBQVk7QUFDeEMsdUJBQXVCLG1CQUFPLENBQUMsdUdBQWU7QUFDOUMscUJBQXFCLG1CQUFPLENBQUMsbUdBQWE7QUFDMUMscUJBQXFCLG1CQUFPLENBQUMsbUdBQWE7QUFDMUMsa0JBQWtCLG1CQUFPLENBQUMsNkZBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUdMO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcS1JhbWFjaGFcXERvY3VtZW50c1xcU3VzdEFJbmV4IEdJdCBDb2RlXFxub2RlX21vZHVsZXNcXEBnZW5raXQtYWlcXGdvb2dsZS1nZW5haVxcbGliXFxnb29nbGVhaVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgLy8gSWYgdGhlIGltcG9ydGVyIGlzIGluIG5vZGUgY29tcGF0aWJpbGl0eSBtb2RlIG9yIHRoaXMgaXMgbm90IGFuIEVTTVxuICAvLyBmaWxlIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIHRvIGEgQ29tbW9uSlMgZmlsZSB1c2luZyBhIEJhYmVsLVxuICAvLyBjb21wYXRpYmxlIHRyYW5zZm9ybSAoaS5lLiBcIl9fZXNNb2R1bGVcIiBoYXMgbm90IGJlZW4gc2V0KSwgdGhlbiBzZXRcbiAgLy8gXCJkZWZhdWx0XCIgdG8gdGhlIENvbW1vbkpTIFwibW9kdWxlLmV4cG9ydHNcIiBmb3Igbm9kZSBjb21wYXRpYmlsaXR5LlxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIGdvb2dsZWFpX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGdvb2dsZWFpX2V4cG9ydHMsIHtcbiAgZGVmYXVsdDogKCkgPT4gZ29vZ2xlYWlfZGVmYXVsdCxcbiAgZ29vZ2xlQUk6ICgpID0+IGdvb2dsZUFJLFxuICBnb29nbGVBSVBsdWdpbjogKCkgPT4gZ29vZ2xlQUlQbHVnaW5cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoZ29vZ2xlYWlfZXhwb3J0cyk7XG52YXIgaW1wb3J0X2xvZ2dpbmcgPSByZXF1aXJlKFwiZ2Vua2l0L2xvZ2dpbmdcIik7XG52YXIgaW1wb3J0X3BsdWdpbiA9IHJlcXVpcmUoXCJnZW5raXQvcGx1Z2luXCIpO1xudmFyIGltcG9ydF91dGlscyA9IHJlcXVpcmUoXCIuLi9jb21tb24vdXRpbHMuanNcIik7XG52YXIgaW1wb3J0X2NsaWVudCA9IHJlcXVpcmUoXCIuL2NsaWVudC5qc1wiKTtcbnZhciBpbXBvcnRfdXRpbHMyID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG52YXIgZW1iZWRkZXIgPSBfX3RvRVNNKHJlcXVpcmUoXCIuL2VtYmVkZGVyLmpzXCIpKTtcbnZhciBnZW1pbmkgPSBfX3RvRVNNKHJlcXVpcmUoXCIuL2dlbWluaS5qc1wiKSk7XG52YXIgaW1hZ2VuID0gX190b0VTTShyZXF1aXJlKFwiLi9pbWFnZW4uanNcIikpO1xudmFyIHZlbyA9IF9fdG9FU00ocmVxdWlyZShcIi4vdmVvLmpzXCIpKTtcbmFzeW5jIGZ1bmN0aW9uIGluaXRpYWxpemVyKGFpLCBvcHRpb25zKSB7XG4gIGltYWdlbi5kZWZpbmVLbm93bk1vZGVscyhhaSwgb3B0aW9ucyk7XG4gIGdlbWluaS5kZWZpbmVLbm93bk1vZGVscyhhaSwgb3B0aW9ucyk7XG4gIGVtYmVkZGVyLmRlZmluZUtub3duTW9kZWxzKGFpLCBvcHRpb25zKTtcbiAgdmVvLmRlZmluZUtub3duTW9kZWxzKGFpLCBvcHRpb25zKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVyKGFpLCBhY3Rpb25UeXBlLCBhY3Rpb25OYW1lLCBvcHRpb25zKSB7XG4gIHN3aXRjaCAoYWN0aW9uVHlwZSkge1xuICAgIGNhc2UgXCJtb2RlbFwiOlxuICAgICAgaWYgKHZlby5pc1Zlb01vZGVsTmFtZShhY3Rpb25OYW1lKSkge1xuICAgICAgfSBlbHNlIGlmIChpbWFnZW4uaXNJbWFnZW5Nb2RlbE5hbWUoYWN0aW9uTmFtZSkpIHtcbiAgICAgICAgaW1hZ2VuLmRlZmluZU1vZGVsKGFpLCBhY3Rpb25OYW1lLCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlbWluaS5kZWZpbmVNb2RlbChhaSwgYWN0aW9uTmFtZSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYmFja2dyb3VuZC1tb2RlbFwiOlxuICAgICAgaWYgKHZlby5pc1Zlb01vZGVsTmFtZShhY3Rpb25OYW1lKSkge1xuICAgICAgICB2ZW8uZGVmaW5lTW9kZWwoYWksIGFjdGlvbk5hbWUsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImVtYmVkZGVyXCI6XG4gICAgICBlbWJlZGRlci5kZWZpbmVFbWJlZGRlcihhaSwgYWN0aW9uTmFtZSwgb3B0aW9ucyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBsaXN0QWN0aW9ucyhvcHRpb25zKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgYXBpS2V5ID0gKDAsIGltcG9ydF91dGlsczIuY2FsY3VsYXRlQXBpS2V5KShvcHRpb25zPy5hcGlLZXksIHZvaWQgMCk7XG4gICAgY29uc3QgYWxsTW9kZWxzID0gYXdhaXQgKDAsIGltcG9ydF9jbGllbnQubGlzdE1vZGVscykoYXBpS2V5LCB7XG4gICAgICBiYXNlVXJsOiBvcHRpb25zPy5iYXNlVXJsLFxuICAgICAgYXBpVmVyc2lvbjogb3B0aW9ucz8uYXBpVmVyc2lvblxuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAuLi5nZW1pbmkubGlzdEFjdGlvbnMoYWxsTW9kZWxzKSxcbiAgICAgIC4uLmltYWdlbi5saXN0QWN0aW9ucyhhbGxNb2RlbHMpLFxuICAgICAgLi4udmVvLmxpc3RBY3Rpb25zKGFsbE1vZGVscyksXG4gICAgICAuLi5lbWJlZGRlci5saXN0QWN0aW9ucyhhbGxNb2RlbHMpXG4gICAgXTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGltcG9ydF9sb2dnaW5nLmxvZ2dlci5lcnJvcigoMCwgaW1wb3J0X3V0aWxzLmV4dHJhY3RFcnJNc2cpKGUpKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cbmZ1bmN0aW9uIGdvb2dsZUFJUGx1Z2luKG9wdGlvbnMpIHtcbiAgbGV0IGxpc3RBY3Rpb25zQ2FjaGU7XG4gIHJldHVybiAoMCwgaW1wb3J0X3BsdWdpbi5nZW5raXRQbHVnaW4pKFxuICAgIFwiZ29vZ2xlYWlcIixcbiAgICBhc3luYyAoYWkpID0+IGF3YWl0IGluaXRpYWxpemVyKGFpLCBvcHRpb25zKSxcbiAgICBhc3luYyAoYWksIGFjdGlvblR5cGUsIGFjdGlvbk5hbWUpID0+IGF3YWl0IHJlc29sdmVyKGFpLCBhY3Rpb25UeXBlLCBhY3Rpb25OYW1lLCBvcHRpb25zIHx8IHt9KSxcbiAgICBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAobGlzdEFjdGlvbnNDYWNoZSkgcmV0dXJuIGxpc3RBY3Rpb25zQ2FjaGU7XG4gICAgICBsaXN0QWN0aW9uc0NhY2hlID0gYXdhaXQgbGlzdEFjdGlvbnMob3B0aW9ucyk7XG4gICAgICByZXR1cm4gbGlzdEFjdGlvbnNDYWNoZTtcbiAgICB9XG4gICk7XG59XG5jb25zdCBnb29nbGVBSSA9IGdvb2dsZUFJUGx1Z2luO1xuZ29vZ2xlQUkubW9kZWwgPSAobmFtZSwgY29uZmlnKSA9PiB7XG4gIGlmICh2ZW8uaXNWZW9Nb2RlbE5hbWUobmFtZSkpIHtcbiAgICByZXR1cm4gdmVvLm1vZGVsKG5hbWUsIGNvbmZpZyk7XG4gIH1cbiAgaWYgKGltYWdlbi5pc0ltYWdlbk1vZGVsTmFtZShuYW1lKSkge1xuICAgIHJldHVybiBpbWFnZW4ubW9kZWwobmFtZSwgY29uZmlnKTtcbiAgfVxuICByZXR1cm4gZ2VtaW5pLm1vZGVsKG5hbWUsIGNvbmZpZyk7XG59O1xuZ29vZ2xlQUkuZW1iZWRkZXIgPSAobmFtZSwgY29uZmlnKSA9PiB7XG4gIHJldHVybiBlbWJlZGRlci5tb2RlbChuYW1lLCBjb25maWcpO1xufTtcbnZhciBnb29nbGVhaV9kZWZhdWx0ID0gZ29vZ2xlQUk7XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ29vZ2xlQUksXG4gIGdvb2dsZUFJUGx1Z2luXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/types.js":
/*!********************************************************************!*\
  !*** ./node_modules/@genkit-ai/google-genai/lib/googleai/types.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar types_exports = {};\n__export(types_exports, {\n  FinishReason: () => import_types.FinishReason,\n  HarmBlockThreshold: () => import_types.HarmBlockThreshold,\n  HarmCategory: () => import_types.HarmCategory,\n  TaskTypeSchema: () => import_types.TaskTypeSchema\n});\nmodule.exports = __toCommonJS(types_exports);\nvar import_types = __webpack_require__(/*! ../common/types.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/common/types.js\");\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2dvb2dsZS1nZW5haS9saWIvZ29vZ2xlYWkvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyx1R0FBb0I7QUFDL0M7QUFDQSxNQUFNLENBS0w7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcZ29vZ2xlLWdlbmFpXFxsaWJcXGdvb2dsZWFpXFx0eXBlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgdHlwZXNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodHlwZXNfZXhwb3J0cywge1xuICBGaW5pc2hSZWFzb246ICgpID0+IGltcG9ydF90eXBlcy5GaW5pc2hSZWFzb24sXG4gIEhhcm1CbG9ja1RocmVzaG9sZDogKCkgPT4gaW1wb3J0X3R5cGVzLkhhcm1CbG9ja1RocmVzaG9sZCxcbiAgSGFybUNhdGVnb3J5OiAoKSA9PiBpbXBvcnRfdHlwZXMuSGFybUNhdGVnb3J5LFxuICBUYXNrVHlwZVNjaGVtYTogKCkgPT4gaW1wb3J0X3R5cGVzLlRhc2tUeXBlU2NoZW1hXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHR5cGVzX2V4cG9ydHMpO1xudmFyIGltcG9ydF90eXBlcyA9IHJlcXVpcmUoXCIuLi9jb21tb24vdHlwZXMuanNcIik7XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgRmluaXNoUmVhc29uLFxuICBIYXJtQmxvY2tUaHJlc2hvbGQsXG4gIEhhcm1DYXRlZ29yeSxcbiAgVGFza1R5cGVTY2hlbWFcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/types.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/utils.js":
/*!********************************************************************!*\
  !*** ./node_modules/@genkit-ai/google-genai/lib/googleai/utils.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar utils_exports = {};\n__export(utils_exports, {\n  API_KEY_FALSE_ERROR: () => API_KEY_FALSE_ERROR,\n  MISSING_API_KEY_ERROR: () => MISSING_API_KEY_ERROR,\n  calculateApiKey: () => calculateApiKey,\n  checkApiKey: () => checkApiKey,\n  checkModelName: () => import_utils2.checkModelName,\n  cleanSchema: () => import_utils2.cleanSchema,\n  extractImagenImage: () => extractImagenImage,\n  extractText: () => import_utils2.extractText,\n  extractVeoImage: () => extractVeoImage,\n  extractVersion: () => import_utils2.extractVersion,\n  getApiKeyFromEnvVar: () => getApiKeyFromEnvVar,\n  modelName: () => import_utils2.modelName\n});\nmodule.exports = __toCommonJS(utils_exports);\nvar import_genkit = __webpack_require__(/*! genkit */ \"(action-browser)/./node_modules/genkit/lib/index.js\");\nvar import_process = __toESM(__webpack_require__(/*! process */ \"process\"));\nvar import_utils = __webpack_require__(/*! ../common/utils.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/common/utils.js\");\nvar import_utils2 = __webpack_require__(/*! ../common/utils.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/common/utils.js\");\nfunction getApiKeyFromEnvVar() {\n  return import_process.default.env.GEMINI_API_KEY || import_process.default.env.GOOGLE_API_KEY || import_process.default.env.GOOGLE_GENAI_API_KEY;\n}\nconst MISSING_API_KEY_ERROR = new import_genkit.GenkitError({\n  status: \"FAILED_PRECONDITION\",\n  message: \"Please pass in the API key or set the GEMINI_API_KEY or GOOGLE_API_KEY environment variable.\\nFor more details see https://genkit.dev/docs/plugins/google-genai/\"\n});\nconst API_KEY_FALSE_ERROR = new import_genkit.GenkitError({\n  status: \"INVALID_ARGUMENT\",\n  message: \"GoogleAI plugin was initialized with {apiKey: false} but no apiKey configuration was passed at call time.\"\n});\nfunction checkApiKey(pluginApiKey) {\n  let apiKey;\n  if (pluginApiKey !== false) {\n    apiKey = pluginApiKey || getApiKeyFromEnvVar();\n  }\n  if (pluginApiKey !== false && !apiKey) {\n    throw MISSING_API_KEY_ERROR;\n  }\n  return apiKey;\n}\nfunction calculateApiKey(pluginApiKey, requestApiKey) {\n  let apiKey;\n  if (pluginApiKey !== false) {\n    apiKey = pluginApiKey || getApiKeyFromEnvVar();\n  }\n  apiKey = requestApiKey || apiKey;\n  if (pluginApiKey === false && !requestApiKey) {\n    throw API_KEY_FALSE_ERROR;\n  }\n  if (!apiKey) {\n    throw MISSING_API_KEY_ERROR;\n  }\n  return apiKey;\n}\nfunction extractVeoImage(request) {\n  const media = request.messages.at(-1)?.content.find((p) => !!p.media)?.media;\n  if (media) {\n    const img = media.url.split(\",\")[1];\n    if (img && media.contentType) {\n      return {\n        bytesBase64Encoded: img,\n        mimeType: media.contentType\n      };\n    } else if (img) {\n      throw new import_genkit.GenkitError({\n        status: \"INVALID_ARGUMENT\",\n        message: \"content type is required for images\"\n      });\n    }\n  }\n  return void 0;\n}\nfunction extractImagenImage(request) {\n  const image = (0, import_utils.extractMedia)(request, {\n    metadataType: \"base\",\n    isDefault: true\n  })?.url.split(\",\")[1];\n  if (image) {\n    return { bytesBase64Encoded: image };\n  }\n  return void 0;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2dvb2dsZS1nZW5haS9saWIvZ29vZ2xlYWkvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsOEJBQThCO0FBQ3ZHO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLG1FQUFRO0FBQ3BDLDZCQUE2QixtQkFBTyxDQUFDLHdCQUFTO0FBQzlDLG1CQUFtQixtQkFBTyxDQUFDLHVHQUFvQjtBQUMvQyxvQkFBb0IsbUJBQU8sQ0FBQyx1R0FBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsZUFBZTtBQUNqRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQWFMO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcS1JhbWFjaGFcXERvY3VtZW50c1xcU3VzdEFJbmV4IEdJdCBDb2RlXFxub2RlX21vZHVsZXNcXEBnZW5raXQtYWlcXGdvb2dsZS1nZW5haVxcbGliXFxnb29nbGVhaVxcdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgLy8gSWYgdGhlIGltcG9ydGVyIGlzIGluIG5vZGUgY29tcGF0aWJpbGl0eSBtb2RlIG9yIHRoaXMgaXMgbm90IGFuIEVTTVxuICAvLyBmaWxlIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIHRvIGEgQ29tbW9uSlMgZmlsZSB1c2luZyBhIEJhYmVsLVxuICAvLyBjb21wYXRpYmxlIHRyYW5zZm9ybSAoaS5lLiBcIl9fZXNNb2R1bGVcIiBoYXMgbm90IGJlZW4gc2V0KSwgdGhlbiBzZXRcbiAgLy8gXCJkZWZhdWx0XCIgdG8gdGhlIENvbW1vbkpTIFwibW9kdWxlLmV4cG9ydHNcIiBmb3Igbm9kZSBjb21wYXRpYmlsaXR5LlxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIHV0aWxzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHV0aWxzX2V4cG9ydHMsIHtcbiAgQVBJX0tFWV9GQUxTRV9FUlJPUjogKCkgPT4gQVBJX0tFWV9GQUxTRV9FUlJPUixcbiAgTUlTU0lOR19BUElfS0VZX0VSUk9SOiAoKSA9PiBNSVNTSU5HX0FQSV9LRVlfRVJST1IsXG4gIGNhbGN1bGF0ZUFwaUtleTogKCkgPT4gY2FsY3VsYXRlQXBpS2V5LFxuICBjaGVja0FwaUtleTogKCkgPT4gY2hlY2tBcGlLZXksXG4gIGNoZWNrTW9kZWxOYW1lOiAoKSA9PiBpbXBvcnRfdXRpbHMyLmNoZWNrTW9kZWxOYW1lLFxuICBjbGVhblNjaGVtYTogKCkgPT4gaW1wb3J0X3V0aWxzMi5jbGVhblNjaGVtYSxcbiAgZXh0cmFjdEltYWdlbkltYWdlOiAoKSA9PiBleHRyYWN0SW1hZ2VuSW1hZ2UsXG4gIGV4dHJhY3RUZXh0OiAoKSA9PiBpbXBvcnRfdXRpbHMyLmV4dHJhY3RUZXh0LFxuICBleHRyYWN0VmVvSW1hZ2U6ICgpID0+IGV4dHJhY3RWZW9JbWFnZSxcbiAgZXh0cmFjdFZlcnNpb246ICgpID0+IGltcG9ydF91dGlsczIuZXh0cmFjdFZlcnNpb24sXG4gIGdldEFwaUtleUZyb21FbnZWYXI6ICgpID0+IGdldEFwaUtleUZyb21FbnZWYXIsXG4gIG1vZGVsTmFtZTogKCkgPT4gaW1wb3J0X3V0aWxzMi5tb2RlbE5hbWVcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlModXRpbHNfZXhwb3J0cyk7XG52YXIgaW1wb3J0X2dlbmtpdCA9IHJlcXVpcmUoXCJnZW5raXRcIik7XG52YXIgaW1wb3J0X3Byb2Nlc3MgPSBfX3RvRVNNKHJlcXVpcmUoXCJwcm9jZXNzXCIpKTtcbnZhciBpbXBvcnRfdXRpbHMgPSByZXF1aXJlKFwiLi4vY29tbW9uL3V0aWxzLmpzXCIpO1xudmFyIGltcG9ydF91dGlsczIgPSByZXF1aXJlKFwiLi4vY29tbW9uL3V0aWxzLmpzXCIpO1xuZnVuY3Rpb24gZ2V0QXBpS2V5RnJvbUVudlZhcigpIHtcbiAgcmV0dXJuIGltcG9ydF9wcm9jZXNzLmRlZmF1bHQuZW52LkdFTUlOSV9BUElfS0VZIHx8IGltcG9ydF9wcm9jZXNzLmRlZmF1bHQuZW52LkdPT0dMRV9BUElfS0VZIHx8IGltcG9ydF9wcm9jZXNzLmRlZmF1bHQuZW52LkdPT0dMRV9HRU5BSV9BUElfS0VZO1xufVxuY29uc3QgTUlTU0lOR19BUElfS0VZX0VSUk9SID0gbmV3IGltcG9ydF9nZW5raXQuR2Vua2l0RXJyb3Ioe1xuICBzdGF0dXM6IFwiRkFJTEVEX1BSRUNPTkRJVElPTlwiLFxuICBtZXNzYWdlOiBcIlBsZWFzZSBwYXNzIGluIHRoZSBBUEkga2V5IG9yIHNldCB0aGUgR0VNSU5JX0FQSV9LRVkgb3IgR09PR0xFX0FQSV9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGUuXFxuRm9yIG1vcmUgZGV0YWlscyBzZWUgaHR0cHM6Ly9nZW5raXQuZGV2L2RvY3MvcGx1Z2lucy9nb29nbGUtZ2VuYWkvXCJcbn0pO1xuY29uc3QgQVBJX0tFWV9GQUxTRV9FUlJPUiA9IG5ldyBpbXBvcnRfZ2Vua2l0LkdlbmtpdEVycm9yKHtcbiAgc3RhdHVzOiBcIklOVkFMSURfQVJHVU1FTlRcIixcbiAgbWVzc2FnZTogXCJHb29nbGVBSSBwbHVnaW4gd2FzIGluaXRpYWxpemVkIHdpdGgge2FwaUtleTogZmFsc2V9IGJ1dCBubyBhcGlLZXkgY29uZmlndXJhdGlvbiB3YXMgcGFzc2VkIGF0IGNhbGwgdGltZS5cIlxufSk7XG5mdW5jdGlvbiBjaGVja0FwaUtleShwbHVnaW5BcGlLZXkpIHtcbiAgbGV0IGFwaUtleTtcbiAgaWYgKHBsdWdpbkFwaUtleSAhPT0gZmFsc2UpIHtcbiAgICBhcGlLZXkgPSBwbHVnaW5BcGlLZXkgfHwgZ2V0QXBpS2V5RnJvbUVudlZhcigpO1xuICB9XG4gIGlmIChwbHVnaW5BcGlLZXkgIT09IGZhbHNlICYmICFhcGlLZXkpIHtcbiAgICB0aHJvdyBNSVNTSU5HX0FQSV9LRVlfRVJST1I7XG4gIH1cbiAgcmV0dXJuIGFwaUtleTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUFwaUtleShwbHVnaW5BcGlLZXksIHJlcXVlc3RBcGlLZXkpIHtcbiAgbGV0IGFwaUtleTtcbiAgaWYgKHBsdWdpbkFwaUtleSAhPT0gZmFsc2UpIHtcbiAgICBhcGlLZXkgPSBwbHVnaW5BcGlLZXkgfHwgZ2V0QXBpS2V5RnJvbUVudlZhcigpO1xuICB9XG4gIGFwaUtleSA9IHJlcXVlc3RBcGlLZXkgfHwgYXBpS2V5O1xuICBpZiAocGx1Z2luQXBpS2V5ID09PSBmYWxzZSAmJiAhcmVxdWVzdEFwaUtleSkge1xuICAgIHRocm93IEFQSV9LRVlfRkFMU0VfRVJST1I7XG4gIH1cbiAgaWYgKCFhcGlLZXkpIHtcbiAgICB0aHJvdyBNSVNTSU5HX0FQSV9LRVlfRVJST1I7XG4gIH1cbiAgcmV0dXJuIGFwaUtleTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RWZW9JbWFnZShyZXF1ZXN0KSB7XG4gIGNvbnN0IG1lZGlhID0gcmVxdWVzdC5tZXNzYWdlcy5hdCgtMSk/LmNvbnRlbnQuZmluZCgocCkgPT4gISFwLm1lZGlhKT8ubWVkaWE7XG4gIGlmIChtZWRpYSkge1xuICAgIGNvbnN0IGltZyA9IG1lZGlhLnVybC5zcGxpdChcIixcIilbMV07XG4gICAgaWYgKGltZyAmJiBtZWRpYS5jb250ZW50VHlwZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnl0ZXNCYXNlNjRFbmNvZGVkOiBpbWcsXG4gICAgICAgIG1pbWVUeXBlOiBtZWRpYS5jb250ZW50VHlwZVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGltZykge1xuICAgICAgdGhyb3cgbmV3IGltcG9ydF9nZW5raXQuR2Vua2l0RXJyb3Ioe1xuICAgICAgICBzdGF0dXM6IFwiSU5WQUxJRF9BUkdVTUVOVFwiLFxuICAgICAgICBtZXNzYWdlOiBcImNvbnRlbnQgdHlwZSBpcyByZXF1aXJlZCBmb3IgaW1hZ2VzXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuZnVuY3Rpb24gZXh0cmFjdEltYWdlbkltYWdlKHJlcXVlc3QpIHtcbiAgY29uc3QgaW1hZ2UgPSAoMCwgaW1wb3J0X3V0aWxzLmV4dHJhY3RNZWRpYSkocmVxdWVzdCwge1xuICAgIG1ldGFkYXRhVHlwZTogXCJiYXNlXCIsXG4gICAgaXNEZWZhdWx0OiB0cnVlXG4gIH0pPy51cmwuc3BsaXQoXCIsXCIpWzFdO1xuICBpZiAoaW1hZ2UpIHtcbiAgICByZXR1cm4geyBieXRlc0Jhc2U2NEVuY29kZWQ6IGltYWdlIH07XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBBUElfS0VZX0ZBTFNFX0VSUk9SLFxuICBNSVNTSU5HX0FQSV9LRVlfRVJST1IsXG4gIGNhbGN1bGF0ZUFwaUtleSxcbiAgY2hlY2tBcGlLZXksXG4gIGNoZWNrTW9kZWxOYW1lLFxuICBjbGVhblNjaGVtYSxcbiAgZXh0cmFjdEltYWdlbkltYWdlLFxuICBleHRyYWN0VGV4dCxcbiAgZXh0cmFjdFZlb0ltYWdlLFxuICBleHRyYWN0VmVyc2lvbixcbiAgZ2V0QXBpS2V5RnJvbUVudlZhcixcbiAgbW9kZWxOYW1lXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/utils.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/veo.js":
/*!******************************************************************!*\
  !*** ./node_modules/@genkit-ai/google-genai/lib/googleai/veo.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar veo_exports = {};\n__export(veo_exports, {\n  TEST_ONLY: () => TEST_ONLY,\n  VeoConfigSchema: () => VeoConfigSchema,\n  defineKnownModels: () => defineKnownModels,\n  defineModel: () => defineModel,\n  isVeoModelName: () => isVeoModelName,\n  listActions: () => listActions,\n  model: () => model\n});\nmodule.exports = __toCommonJS(veo_exports);\nvar import_genkit = __webpack_require__(/*! genkit */ \"(action-browser)/./node_modules/genkit/lib/index.js\");\nvar import_model = __webpack_require__(/*! genkit/model */ \"(action-browser)/./node_modules/genkit/lib/model.js\");\nvar import_client = __webpack_require__(/*! ./client.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/client.js\");\nvar import_utils = __webpack_require__(/*! ./utils.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/utils.js\");\nconst VeoConfigSchema = import_genkit.z.object({\n  // NOTE: Documentation notes numberOfVideos parameter to pick the number of\n  // output videos, but this setting does not seem to work\n  negativePrompt: import_genkit.z.string().optional(),\n  aspectRatio: import_genkit.z.enum([\"9:16\", \"16:9\"]).describe(\"Desired aspect ratio of the output video.\").optional(),\n  personGeneration: import_genkit.z.enum([\"dont_allow\", \"allow_adult\", \"allow_all\"]).describe(\n    \"Control if/how images of people will be generated by the model.\"\n  ).optional(),\n  durationSeconds: import_genkit.z.number().step(1).min(5).max(8).describe(\"Length of each output video in seconds, between 5 and 8.\").optional(),\n  enhancePrompt: import_genkit.z.boolean().describe(\"Enable or disable the prompt rewriter. Enabled by default.\").optional()\n}).passthrough();\nfunction commonRef(name, info, configSchema = VeoConfigSchema) {\n  return (0, import_model.modelRef)({\n    name: `googleai/${name}`,\n    configSchema,\n    info: info ?? {\n      supports: {\n        media: true,\n        multiturn: false,\n        tools: false,\n        systemRole: false,\n        output: [\"media\"],\n        longRunning: true\n      }\n    }\n    // TODO(ifielker): Remove this cast if we fix longRunning\n  });\n}\nconst GENERIC_MODEL = commonRef(\"veo\");\nconst KNOWN_MODELS = {\n  \"veo-3.0-generate-preview\": commonRef(\"veo-3.0-generate-preview\"),\n  \"veo-3.0-fast-generate-preview\": commonRef(\"veo-3.0-fast-generate-preview\"),\n  \"veo-2.0-generate-001\": commonRef(\"veo-2.0-generate-001\")\n};\nfunction isVeoModelName(value) {\n  return !!value?.startsWith(\"veo-\");\n}\nfunction model(version, config = {}) {\n  const name = (0, import_utils.checkModelName)(version);\n  return (0, import_model.modelRef)({\n    name: `googleai/${name}`,\n    config,\n    configSchema: VeoConfigSchema,\n    info: { ...GENERIC_MODEL.info }\n  });\n}\nfunction listActions(models) {\n  return models.filter(\n    (m) => m.supportedGenerationMethods.includes(\"predictLongRunning\") && isVeoModelName((0, import_utils.modelName)(m.name))\n  ).filter((m) => !m.description || !m.description.includes(\"deprecated\")).map((m) => {\n    const ref = model(m.name);\n    return (0, import_genkit.modelActionMetadata)({\n      name: ref.name,\n      info: ref.info,\n      configSchema: ref.configSchema\n    });\n  });\n}\nfunction defineKnownModels(ai, options) {\n  for (const name of Object.keys(KNOWN_MODELS)) {\n    defineModel(ai, name, options);\n  }\n}\nfunction defineModel(ai, name, pluginOptions) {\n  const ref = model(name);\n  const clientOptions = {\n    apiVersion: pluginOptions?.apiVersion,\n    baseUrl: pluginOptions?.baseUrl\n  };\n  return ai.defineBackgroundModel({\n    name: ref.name,\n    ...ref.info,\n    configSchema: ref.configSchema,\n    async start(request) {\n      const apiKey = (0, import_utils.calculateApiKey)(pluginOptions?.apiKey, void 0);\n      const veoPredictRequest = {\n        instances: [\n          {\n            prompt: (0, import_utils.extractText)(request),\n            image: (0, import_utils.extractVeoImage)(request)\n          }\n        ],\n        parameters: toVeoParameters(request)\n      };\n      const response = await (0, import_client.veoPredict)(\n        apiKey,\n        (0, import_utils.extractVersion)(ref),\n        veoPredictRequest,\n        clientOptions\n      );\n      return fromVeoOperation(response);\n    },\n    async check(operation) {\n      const apiKey = (0, import_utils.calculateApiKey)(pluginOptions?.apiKey, void 0);\n      const response = await (0, import_client.veoCheckOperation)(\n        apiKey,\n        operation.id,\n        clientOptions\n      );\n      return fromVeoOperation(response);\n    }\n  });\n}\nfunction toVeoParameters(request) {\n  const out = {\n    ...request?.config\n  };\n  for (const k in out) {\n    if (out[k] === null) delete out[k];\n  }\n  delete out.apiKey;\n  delete out.version;\n  return out;\n}\nfunction fromVeoOperation(apiOp) {\n  const res = { id: apiOp.name };\n  if (apiOp.done !== void 0) {\n    res.done = apiOp.done;\n  }\n  if (apiOp.error) {\n    res.error = { message: apiOp.error.message };\n  }\n  if (apiOp.response && apiOp.response.generateVideoResponse && apiOp.response.generateVideoResponse.generatedSamples) {\n    res.output = {\n      finishReason: \"stop\",\n      raw: apiOp.response,\n      message: {\n        role: \"model\",\n        content: apiOp.response.generateVideoResponse.generatedSamples.map(\n          (s) => {\n            return {\n              media: {\n                url: s.video.uri\n              }\n            };\n          }\n        )\n      }\n    };\n  }\n  return res;\n}\nconst TEST_ONLY = {\n  toVeoParameters,\n  fromVeoOperation,\n  GENERIC_MODEL,\n  KNOWN_MODELS\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=veo.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2dvb2dsZS1nZW5haS9saWIvZ29vZ2xlYWkvdmVvLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsbUVBQVE7QUFDcEMsbUJBQW1CLG1CQUFPLENBQUMseUVBQWM7QUFDekMsb0JBQW9CLG1CQUFPLENBQUMsbUdBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsaUdBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBLFlBQVk7QUFDWixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FRTDtBQUNEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEtSYW1hY2hhXFxEb2N1bWVudHNcXFN1c3RBSW5leCBHSXQgQ29kZVxcbm9kZV9tb2R1bGVzXFxAZ2Vua2l0LWFpXFxnb29nbGUtZ2VuYWlcXGxpYlxcZ29vZ2xlYWlcXHZlby5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgdmVvX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHZlb19leHBvcnRzLCB7XG4gIFRFU1RfT05MWTogKCkgPT4gVEVTVF9PTkxZLFxuICBWZW9Db25maWdTY2hlbWE6ICgpID0+IFZlb0NvbmZpZ1NjaGVtYSxcbiAgZGVmaW5lS25vd25Nb2RlbHM6ICgpID0+IGRlZmluZUtub3duTW9kZWxzLFxuICBkZWZpbmVNb2RlbDogKCkgPT4gZGVmaW5lTW9kZWwsXG4gIGlzVmVvTW9kZWxOYW1lOiAoKSA9PiBpc1Zlb01vZGVsTmFtZSxcbiAgbGlzdEFjdGlvbnM6ICgpID0+IGxpc3RBY3Rpb25zLFxuICBtb2RlbDogKCkgPT4gbW9kZWxcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlModmVvX2V4cG9ydHMpO1xudmFyIGltcG9ydF9nZW5raXQgPSByZXF1aXJlKFwiZ2Vua2l0XCIpO1xudmFyIGltcG9ydF9tb2RlbCA9IHJlcXVpcmUoXCJnZW5raXQvbW9kZWxcIik7XG52YXIgaW1wb3J0X2NsaWVudCA9IHJlcXVpcmUoXCIuL2NsaWVudC5qc1wiKTtcbnZhciBpbXBvcnRfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbmNvbnN0IFZlb0NvbmZpZ1NjaGVtYSA9IGltcG9ydF9nZW5raXQuei5vYmplY3Qoe1xuICAvLyBOT1RFOiBEb2N1bWVudGF0aW9uIG5vdGVzIG51bWJlck9mVmlkZW9zIHBhcmFtZXRlciB0byBwaWNrIHRoZSBudW1iZXIgb2ZcbiAgLy8gb3V0cHV0IHZpZGVvcywgYnV0IHRoaXMgc2V0dGluZyBkb2VzIG5vdCBzZWVtIHRvIHdvcmtcbiAgbmVnYXRpdmVQcm9tcHQ6IGltcG9ydF9nZW5raXQuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBhc3BlY3RSYXRpbzogaW1wb3J0X2dlbmtpdC56LmVudW0oW1wiOToxNlwiLCBcIjE2OjlcIl0pLmRlc2NyaWJlKFwiRGVzaXJlZCBhc3BlY3QgcmF0aW8gb2YgdGhlIG91dHB1dCB2aWRlby5cIikub3B0aW9uYWwoKSxcbiAgcGVyc29uR2VuZXJhdGlvbjogaW1wb3J0X2dlbmtpdC56LmVudW0oW1wiZG9udF9hbGxvd1wiLCBcImFsbG93X2FkdWx0XCIsIFwiYWxsb3dfYWxsXCJdKS5kZXNjcmliZShcbiAgICBcIkNvbnRyb2wgaWYvaG93IGltYWdlcyBvZiBwZW9wbGUgd2lsbCBiZSBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLlwiXG4gICkub3B0aW9uYWwoKSxcbiAgZHVyYXRpb25TZWNvbmRzOiBpbXBvcnRfZ2Vua2l0LnoubnVtYmVyKCkuc3RlcCgxKS5taW4oNSkubWF4KDgpLmRlc2NyaWJlKFwiTGVuZ3RoIG9mIGVhY2ggb3V0cHV0IHZpZGVvIGluIHNlY29uZHMsIGJldHdlZW4gNSBhbmQgOC5cIikub3B0aW9uYWwoKSxcbiAgZW5oYW5jZVByb21wdDogaW1wb3J0X2dlbmtpdC56LmJvb2xlYW4oKS5kZXNjcmliZShcIkVuYWJsZSBvciBkaXNhYmxlIHRoZSBwcm9tcHQgcmV3cml0ZXIuIEVuYWJsZWQgYnkgZGVmYXVsdC5cIikub3B0aW9uYWwoKVxufSkucGFzc3Rocm91Z2goKTtcbmZ1bmN0aW9uIGNvbW1vblJlZihuYW1lLCBpbmZvLCBjb25maWdTY2hlbWEgPSBWZW9Db25maWdTY2hlbWEpIHtcbiAgcmV0dXJuICgwLCBpbXBvcnRfbW9kZWwubW9kZWxSZWYpKHtcbiAgICBuYW1lOiBgZ29vZ2xlYWkvJHtuYW1lfWAsXG4gICAgY29uZmlnU2NoZW1hLFxuICAgIGluZm86IGluZm8gPz8ge1xuICAgICAgc3VwcG9ydHM6IHtcbiAgICAgICAgbWVkaWE6IHRydWUsXG4gICAgICAgIG11bHRpdHVybjogZmFsc2UsXG4gICAgICAgIHRvb2xzOiBmYWxzZSxcbiAgICAgICAgc3lzdGVtUm9sZTogZmFsc2UsXG4gICAgICAgIG91dHB1dDogW1wibWVkaWFcIl0sXG4gICAgICAgIGxvbmdSdW5uaW5nOiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIC8vIFRPRE8oaWZpZWxrZXIpOiBSZW1vdmUgdGhpcyBjYXN0IGlmIHdlIGZpeCBsb25nUnVubmluZ1xuICB9KTtcbn1cbmNvbnN0IEdFTkVSSUNfTU9ERUwgPSBjb21tb25SZWYoXCJ2ZW9cIik7XG5jb25zdCBLTk9XTl9NT0RFTFMgPSB7XG4gIFwidmVvLTMuMC1nZW5lcmF0ZS1wcmV2aWV3XCI6IGNvbW1vblJlZihcInZlby0zLjAtZ2VuZXJhdGUtcHJldmlld1wiKSxcbiAgXCJ2ZW8tMy4wLWZhc3QtZ2VuZXJhdGUtcHJldmlld1wiOiBjb21tb25SZWYoXCJ2ZW8tMy4wLWZhc3QtZ2VuZXJhdGUtcHJldmlld1wiKSxcbiAgXCJ2ZW8tMi4wLWdlbmVyYXRlLTAwMVwiOiBjb21tb25SZWYoXCJ2ZW8tMi4wLWdlbmVyYXRlLTAwMVwiKVxufTtcbmZ1bmN0aW9uIGlzVmVvTW9kZWxOYW1lKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlPy5zdGFydHNXaXRoKFwidmVvLVwiKTtcbn1cbmZ1bmN0aW9uIG1vZGVsKHZlcnNpb24sIGNvbmZpZyA9IHt9KSB7XG4gIGNvbnN0IG5hbWUgPSAoMCwgaW1wb3J0X3V0aWxzLmNoZWNrTW9kZWxOYW1lKSh2ZXJzaW9uKTtcbiAgcmV0dXJuICgwLCBpbXBvcnRfbW9kZWwubW9kZWxSZWYpKHtcbiAgICBuYW1lOiBgZ29vZ2xlYWkvJHtuYW1lfWAsXG4gICAgY29uZmlnLFxuICAgIGNvbmZpZ1NjaGVtYTogVmVvQ29uZmlnU2NoZW1hLFxuICAgIGluZm86IHsgLi4uR0VORVJJQ19NT0RFTC5pbmZvIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBsaXN0QWN0aW9ucyhtb2RlbHMpIHtcbiAgcmV0dXJuIG1vZGVscy5maWx0ZXIoXG4gICAgKG0pID0+IG0uc3VwcG9ydGVkR2VuZXJhdGlvbk1ldGhvZHMuaW5jbHVkZXMoXCJwcmVkaWN0TG9uZ1J1bm5pbmdcIikgJiYgaXNWZW9Nb2RlbE5hbWUoKDAsIGltcG9ydF91dGlscy5tb2RlbE5hbWUpKG0ubmFtZSkpXG4gICkuZmlsdGVyKChtKSA9PiAhbS5kZXNjcmlwdGlvbiB8fCAhbS5kZXNjcmlwdGlvbi5pbmNsdWRlcyhcImRlcHJlY2F0ZWRcIikpLm1hcCgobSkgPT4ge1xuICAgIGNvbnN0IHJlZiA9IG1vZGVsKG0ubmFtZSk7XG4gICAgcmV0dXJuICgwLCBpbXBvcnRfZ2Vua2l0Lm1vZGVsQWN0aW9uTWV0YWRhdGEpKHtcbiAgICAgIG5hbWU6IHJlZi5uYW1lLFxuICAgICAgaW5mbzogcmVmLmluZm8sXG4gICAgICBjb25maWdTY2hlbWE6IHJlZi5jb25maWdTY2hlbWFcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBkZWZpbmVLbm93bk1vZGVscyhhaSwgb3B0aW9ucykge1xuICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoS05PV05fTU9ERUxTKSkge1xuICAgIGRlZmluZU1vZGVsKGFpLCBuYW1lLCBvcHRpb25zKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVmaW5lTW9kZWwoYWksIG5hbWUsIHBsdWdpbk9wdGlvbnMpIHtcbiAgY29uc3QgcmVmID0gbW9kZWwobmFtZSk7XG4gIGNvbnN0IGNsaWVudE9wdGlvbnMgPSB7XG4gICAgYXBpVmVyc2lvbjogcGx1Z2luT3B0aW9ucz8uYXBpVmVyc2lvbixcbiAgICBiYXNlVXJsOiBwbHVnaW5PcHRpb25zPy5iYXNlVXJsXG4gIH07XG4gIHJldHVybiBhaS5kZWZpbmVCYWNrZ3JvdW5kTW9kZWwoe1xuICAgIG5hbWU6IHJlZi5uYW1lLFxuICAgIC4uLnJlZi5pbmZvLFxuICAgIGNvbmZpZ1NjaGVtYTogcmVmLmNvbmZpZ1NjaGVtYSxcbiAgICBhc3luYyBzdGFydChyZXF1ZXN0KSB7XG4gICAgICBjb25zdCBhcGlLZXkgPSAoMCwgaW1wb3J0X3V0aWxzLmNhbGN1bGF0ZUFwaUtleSkocGx1Z2luT3B0aW9ucz8uYXBpS2V5LCB2b2lkIDApO1xuICAgICAgY29uc3QgdmVvUHJlZGljdFJlcXVlc3QgPSB7XG4gICAgICAgIGluc3RhbmNlczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHByb21wdDogKDAsIGltcG9ydF91dGlscy5leHRyYWN0VGV4dCkocmVxdWVzdCksXG4gICAgICAgICAgICBpbWFnZTogKDAsIGltcG9ydF91dGlscy5leHRyYWN0VmVvSW1hZ2UpKHJlcXVlc3QpXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwYXJhbWV0ZXJzOiB0b1Zlb1BhcmFtZXRlcnMocmVxdWVzdClcbiAgICAgIH07XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0ICgwLCBpbXBvcnRfY2xpZW50LnZlb1ByZWRpY3QpKFxuICAgICAgICBhcGlLZXksXG4gICAgICAgICgwLCBpbXBvcnRfdXRpbHMuZXh0cmFjdFZlcnNpb24pKHJlZiksXG4gICAgICAgIHZlb1ByZWRpY3RSZXF1ZXN0LFxuICAgICAgICBjbGllbnRPcHRpb25zXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZyb21WZW9PcGVyYXRpb24ocmVzcG9uc2UpO1xuICAgIH0sXG4gICAgYXN5bmMgY2hlY2sob3BlcmF0aW9uKSB7XG4gICAgICBjb25zdCBhcGlLZXkgPSAoMCwgaW1wb3J0X3V0aWxzLmNhbGN1bGF0ZUFwaUtleSkocGx1Z2luT3B0aW9ucz8uYXBpS2V5LCB2b2lkIDApO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCAoMCwgaW1wb3J0X2NsaWVudC52ZW9DaGVja09wZXJhdGlvbikoXG4gICAgICAgIGFwaUtleSxcbiAgICAgICAgb3BlcmF0aW9uLmlkLFxuICAgICAgICBjbGllbnRPcHRpb25zXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZyb21WZW9PcGVyYXRpb24ocmVzcG9uc2UpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB0b1Zlb1BhcmFtZXRlcnMocmVxdWVzdCkge1xuICBjb25zdCBvdXQgPSB7XG4gICAgLi4ucmVxdWVzdD8uY29uZmlnXG4gIH07XG4gIGZvciAoY29uc3QgayBpbiBvdXQpIHtcbiAgICBpZiAob3V0W2tdID09PSBudWxsKSBkZWxldGUgb3V0W2tdO1xuICB9XG4gIGRlbGV0ZSBvdXQuYXBpS2V5O1xuICBkZWxldGUgb3V0LnZlcnNpb247XG4gIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBmcm9tVmVvT3BlcmF0aW9uKGFwaU9wKSB7XG4gIGNvbnN0IHJlcyA9IHsgaWQ6IGFwaU9wLm5hbWUgfTtcbiAgaWYgKGFwaU9wLmRvbmUgIT09IHZvaWQgMCkge1xuICAgIHJlcy5kb25lID0gYXBpT3AuZG9uZTtcbiAgfVxuICBpZiAoYXBpT3AuZXJyb3IpIHtcbiAgICByZXMuZXJyb3IgPSB7IG1lc3NhZ2U6IGFwaU9wLmVycm9yLm1lc3NhZ2UgfTtcbiAgfVxuICBpZiAoYXBpT3AucmVzcG9uc2UgJiYgYXBpT3AucmVzcG9uc2UuZ2VuZXJhdGVWaWRlb1Jlc3BvbnNlICYmIGFwaU9wLnJlc3BvbnNlLmdlbmVyYXRlVmlkZW9SZXNwb25zZS5nZW5lcmF0ZWRTYW1wbGVzKSB7XG4gICAgcmVzLm91dHB1dCA9IHtcbiAgICAgIGZpbmlzaFJlYXNvbjogXCJzdG9wXCIsXG4gICAgICByYXc6IGFwaU9wLnJlc3BvbnNlLFxuICAgICAgbWVzc2FnZToge1xuICAgICAgICByb2xlOiBcIm1vZGVsXCIsXG4gICAgICAgIGNvbnRlbnQ6IGFwaU9wLnJlc3BvbnNlLmdlbmVyYXRlVmlkZW9SZXNwb25zZS5nZW5lcmF0ZWRTYW1wbGVzLm1hcChcbiAgICAgICAgICAocykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgbWVkaWE6IHtcbiAgICAgICAgICAgICAgICB1cmw6IHMudmlkZW8udXJpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuY29uc3QgVEVTVF9PTkxZID0ge1xuICB0b1Zlb1BhcmFtZXRlcnMsXG4gIGZyb21WZW9PcGVyYXRpb24sXG4gIEdFTkVSSUNfTU9ERUwsXG4gIEtOT1dOX01PREVMU1xufTtcbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBURVNUX09OTFksXG4gIFZlb0NvbmZpZ1NjaGVtYSxcbiAgZGVmaW5lS25vd25Nb2RlbHMsXG4gIGRlZmluZU1vZGVsLFxuICBpc1Zlb01vZGVsTmFtZSxcbiAgbGlzdEFjdGlvbnMsXG4gIG1vZGVsXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlby5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/veo.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/client.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@genkit-ai/google-genai/lib/vertexai/client.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar client_exports = {};\n__export(client_exports, {\n  TEST_ONLY: () => TEST_ONLY,\n  embedContent: () => embedContent,\n  generateContent: () => generateContent,\n  generateContentStream: () => generateContentStream,\n  getVertexAIUrl: () => getVertexAIUrl,\n  imagenPredict: () => imagenPredict,\n  listModels: () => listModels,\n  lyriaPredict: () => lyriaPredict,\n  veoCheckOperation: () => veoCheckOperation,\n  veoPredict: () => veoPredict\n});\nmodule.exports = __toCommonJS(client_exports);\nvar import_utils = __webpack_require__(/*! ../common/utils.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/common/utils.js\");\nvar import_utils2 = __webpack_require__(/*! ./utils.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/utils.js\");\nasync function listModels(clientOptions) {\n  const url = getVertexAIUrl({\n    includeProjectAndLocation: false,\n    resourcePath: \"publishers/google/models\",\n    clientOptions\n  });\n  const fetchOptions = await getFetchOptions({\n    method: \"GET\",\n    clientOptions\n  });\n  const response = await makeRequest(url, fetchOptions);\n  const modelResponse = await response.json();\n  return modelResponse.publisherModels;\n}\nasync function generateContent(model, generateContentRequest, clientOptions) {\n  let url;\n  if (model.includes(\"endpoints/\")) {\n    url = getVertexAIUrl({\n      includeProjectAndLocation: !model.startsWith(\"projects/\"),\n      resourcePath: model,\n      resourceMethod: \"generateContent\",\n      clientOptions\n    });\n  } else {\n    url = getVertexAIUrl({\n      includeProjectAndLocation: true,\n      resourcePath: `publishers/google/models/${model}`,\n      resourceMethod: \"generateContent\",\n      clientOptions\n    });\n  }\n  const fetchOptions = await getFetchOptions({\n    method: \"POST\",\n    clientOptions,\n    body: JSON.stringify(generateContentRequest)\n  });\n  const response = await makeRequest(url, fetchOptions);\n  const responseJson = await response.json();\n  return responseJson;\n}\nasync function generateContentStream(model, generateContentRequest, clientOptions) {\n  let url;\n  if (model.includes(\"endpoints/\")) {\n    url = getVertexAIUrl({\n      includeProjectAndLocation: !model.startsWith(\"projects/\"),\n      resourcePath: model,\n      resourceMethod: \"streamGenerateContent\",\n      clientOptions\n    });\n  } else {\n    url = getVertexAIUrl({\n      includeProjectAndLocation: true,\n      resourcePath: `publishers/google/models/${model}`,\n      resourceMethod: \"streamGenerateContent\",\n      clientOptions\n    });\n  }\n  const fetchOptions = await getFetchOptions({\n    method: \"POST\",\n    clientOptions,\n    body: JSON.stringify(generateContentRequest)\n  });\n  const response = await makeRequest(url, fetchOptions);\n  return (0, import_utils.processStream)(response);\n}\nasync function internalPredict(model, body, clientOptions) {\n  const url = getVertexAIUrl({\n    includeProjectAndLocation: true,\n    resourcePath: `publishers/google/models/${model}`,\n    resourceMethod: \"predict\",\n    clientOptions\n  });\n  const fetchOptions = await getFetchOptions({\n    method: \"POST\",\n    clientOptions,\n    body\n  });\n  return await makeRequest(url, fetchOptions);\n}\nasync function embedContent(model, embedContentRequest, clientOptions) {\n  const response = await internalPredict(\n    model,\n    JSON.stringify(embedContentRequest),\n    clientOptions\n  );\n  return response.json();\n}\nasync function imagenPredict(model, imagenPredictRequest, clientOptions) {\n  const response = await internalPredict(\n    model,\n    JSON.stringify(imagenPredictRequest),\n    clientOptions\n  );\n  return response.json();\n}\nasync function lyriaPredict(model, lyriaPredictRequest, clientOptions) {\n  const response = await internalPredict(\n    model,\n    JSON.stringify(lyriaPredictRequest),\n    clientOptions\n  );\n  return response.json();\n}\nasync function veoPredict(model, veoPredictRequest, clientOptions) {\n  const url = getVertexAIUrl({\n    includeProjectAndLocation: true,\n    resourcePath: `publishers/google/models/${model}`,\n    resourceMethod: \"predictLongRunning\",\n    clientOptions\n  });\n  const fetchOptions = await getFetchOptions({\n    method: \"POST\",\n    clientOptions,\n    body: JSON.stringify(veoPredictRequest)\n  });\n  const response = await makeRequest(url, fetchOptions);\n  return response.json();\n}\nasync function veoCheckOperation(model, veoOperationRequest, clientOptions) {\n  const url = getVertexAIUrl({\n    includeProjectAndLocation: true,\n    resourcePath: `publishers/google/models/${model}`,\n    resourceMethod: \"fetchPredictOperation\",\n    clientOptions\n  });\n  const fetchOptions = await getFetchOptions({\n    method: \"POST\",\n    clientOptions,\n    body: JSON.stringify(veoOperationRequest)\n  });\n  const response = await makeRequest(url, fetchOptions);\n  return response.json();\n}\nfunction getVertexAIUrl(params) {\n  (0, import_utils2.checkSupportedResourceMethod)(params);\n  const DEFAULT_API_VERSION = \"v1beta1\";\n  const API_BASE_PATH = \"aiplatform.googleapis.com\";\n  let basePath;\n  if (params.clientOptions.kind == \"regional\") {\n    basePath = `${params.clientOptions.location}-${API_BASE_PATH}`;\n  } else {\n    basePath = API_BASE_PATH;\n  }\n  let resourcePath = params.resourcePath;\n  if (params.clientOptions.kind != \"express\" && params.includeProjectAndLocation) {\n    const parent = `projects/${params.clientOptions.projectId}/locations/${params.clientOptions.location}`;\n    resourcePath = `${parent}/${params.resourcePath}`;\n  }\n  let url = `https://${basePath}/${DEFAULT_API_VERSION}/${resourcePath}`;\n  if (params.resourceMethod) {\n    url += `:${params.resourceMethod}`;\n  }\n  let joiner = \"?\";\n  if (params.queryParams) {\n    url += `${joiner}${params.queryParams}`;\n    joiner = \"&\";\n  }\n  if (params.resourceMethod === \"streamGenerateContent\") {\n    url += `${joiner}alt=sse`;\n    joiner = \"&\";\n  }\n  return url;\n}\nasync function getFetchOptions(params) {\n  const fetchOptions = {\n    method: params.method,\n    headers: await getHeaders(params.clientOptions)\n  };\n  if (params.body) {\n    fetchOptions.body = params.body;\n  }\n  const signal = getAbortSignal(params.clientOptions);\n  if (signal) {\n    fetchOptions.signal = signal;\n  }\n  return fetchOptions;\n}\nfunction getAbortSignal(clientOptions) {\n  const hasTimeout = (clientOptions.timeout ?? -1) >= 0;\n  if (clientOptions.signal !== void 0 || hasTimeout) {\n    const controller = new AbortController();\n    if (hasTimeout) {\n      setTimeout(() => controller.abort(), clientOptions.timeout);\n    }\n    if (clientOptions?.signal) {\n      clientOptions.signal.addEventListener(\"abort\", () => {\n        controller.abort();\n      });\n    }\n    return controller.signal;\n  }\n  return void 0;\n}\nasync function getHeaders(clientOptions) {\n  if (clientOptions.kind == \"express\") {\n    const headers = {\n      \"x-goog-api-key\": (0, import_utils2.calculateApiKey)(clientOptions.apiKey, void 0),\n      \"Content-Type\": \"application/json\",\n      \"X-Goog-Api-Client\": (0, import_utils.getGenkitClientHeader)(),\n      \"User-Agent\": (0, import_utils.getGenkitClientHeader)()\n    };\n    return headers;\n  } else {\n    const token = await getToken(clientOptions.authClient);\n    const headers = {\n      Authorization: `Bearer ${token}`,\n      \"x-goog-user-project\": clientOptions.projectId,\n      \"Content-Type\": \"application/json\",\n      \"X-Goog-Api-Client\": (0, import_utils.getGenkitClientHeader)(),\n      \"User-Agent\": (0, import_utils.getGenkitClientHeader)()\n    };\n    if (clientOptions.apiKey) {\n      headers[\"x-goog-api-key\"] = clientOptions.apiKey;\n    }\n    return headers;\n  }\n}\nasync function getToken(authClient) {\n  const CREDENTIAL_ERROR_MESSAGE = \"\\nUnable to authenticate your request        \\nDepending on your run time environment, you can get authentication by        \\n- if in local instance or cloud shell: `!gcloud auth login`        \\n- if in Colab:        \\n    -`from google.colab import auth`        \\n    -`auth.authenticate_user()`        \\n- if in service account or other: please follow guidance in https://cloud.google.com/docs/authentication\";\n  const token = await authClient.getAccessToken().catch((e) => {\n    throw new Error(CREDENTIAL_ERROR_MESSAGE, e);\n  });\n  if (!token) {\n    throw new Error(CREDENTIAL_ERROR_MESSAGE);\n  }\n  return token;\n}\nasync function makeRequest(url, fetchOptions) {\n  try {\n    const response = await fetch(url, fetchOptions);\n    if (!response.ok) {\n      let errorText = await response.text();\n      let errorMessage = errorText;\n      try {\n        const json = JSON.parse(errorText);\n        if (json.error && json.error.message) {\n          errorMessage = json.error.message;\n        }\n      } catch (e) {\n      }\n      throw new Error(\n        `Error fetching from ${url}: [${response.status} ${response.statusText}] ${errorMessage}`\n      );\n    }\n    return response;\n  } catch (e) {\n    console.error(e);\n    throw new Error(`Failed to fetch from ${url}: ${(0, import_utils.extractErrMsg)(e)}`);\n  }\n}\nconst TEST_ONLY = {\n  getFetchOptions,\n  getAbortSignal,\n  getHeaders,\n  makeRequest\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2dvb2dsZS1nZW5haS9saWIvdmVydGV4YWkvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsdUdBQW9CO0FBQy9DLG9CQUFvQixtQkFBTyxDQUFDLGlHQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLGdEQUFnRCxNQUFNO0FBQ3REO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQSxnREFBZ0QsTUFBTTtBQUN0RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE1BQU07QUFDcEQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE1BQU07QUFDcEQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTTtBQUNwRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4QkFBOEIsR0FBRyxjQUFjO0FBQ2pFLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwrQkFBK0IsYUFBYSw4QkFBOEI7QUFDekcsc0JBQXNCLE9BQU8sR0FBRyxvQkFBb0I7QUFDcEQ7QUFDQSx1QkFBdUIsU0FBUyxHQUFHLG9CQUFvQixHQUFHLGFBQWE7QUFDdkU7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU8sRUFBRSxtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsK0JBQStCLElBQUksS0FBSyxpQkFBaUIsRUFBRSxvQkFBb0IsSUFBSSxhQUFhO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLDRDQUE0QyxJQUFJLElBQUksbUNBQW1DO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FXTDtBQUNEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEtSYW1hY2hhXFxEb2N1bWVudHNcXFN1c3RBSW5leCBHSXQgQ29kZVxcbm9kZV9tb2R1bGVzXFxAZ2Vua2l0LWFpXFxnb29nbGUtZ2VuYWlcXGxpYlxcdmVydGV4YWlcXGNsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgY2xpZW50X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNsaWVudF9leHBvcnRzLCB7XG4gIFRFU1RfT05MWTogKCkgPT4gVEVTVF9PTkxZLFxuICBlbWJlZENvbnRlbnQ6ICgpID0+IGVtYmVkQ29udGVudCxcbiAgZ2VuZXJhdGVDb250ZW50OiAoKSA9PiBnZW5lcmF0ZUNvbnRlbnQsXG4gIGdlbmVyYXRlQ29udGVudFN0cmVhbTogKCkgPT4gZ2VuZXJhdGVDb250ZW50U3RyZWFtLFxuICBnZXRWZXJ0ZXhBSVVybDogKCkgPT4gZ2V0VmVydGV4QUlVcmwsXG4gIGltYWdlblByZWRpY3Q6ICgpID0+IGltYWdlblByZWRpY3QsXG4gIGxpc3RNb2RlbHM6ICgpID0+IGxpc3RNb2RlbHMsXG4gIGx5cmlhUHJlZGljdDogKCkgPT4gbHlyaWFQcmVkaWN0LFxuICB2ZW9DaGVja09wZXJhdGlvbjogKCkgPT4gdmVvQ2hlY2tPcGVyYXRpb24sXG4gIHZlb1ByZWRpY3Q6ICgpID0+IHZlb1ByZWRpY3Rcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoY2xpZW50X2V4cG9ydHMpO1xudmFyIGltcG9ydF91dGlscyA9IHJlcXVpcmUoXCIuLi9jb21tb24vdXRpbHMuanNcIik7XG52YXIgaW1wb3J0X3V0aWxzMiA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuYXN5bmMgZnVuY3Rpb24gbGlzdE1vZGVscyhjbGllbnRPcHRpb25zKSB7XG4gIGNvbnN0IHVybCA9IGdldFZlcnRleEFJVXJsKHtcbiAgICBpbmNsdWRlUHJvamVjdEFuZExvY2F0aW9uOiBmYWxzZSxcbiAgICByZXNvdXJjZVBhdGg6IFwicHVibGlzaGVycy9nb29nbGUvbW9kZWxzXCIsXG4gICAgY2xpZW50T3B0aW9uc1xuICB9KTtcbiAgY29uc3QgZmV0Y2hPcHRpb25zID0gYXdhaXQgZ2V0RmV0Y2hPcHRpb25zKHtcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgY2xpZW50T3B0aW9uc1xuICB9KTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtYWtlUmVxdWVzdCh1cmwsIGZldGNoT3B0aW9ucyk7XG4gIGNvbnN0IG1vZGVsUmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIHJldHVybiBtb2RlbFJlc3BvbnNlLnB1Ymxpc2hlck1vZGVscztcbn1cbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudChtb2RlbCwgZ2VuZXJhdGVDb250ZW50UmVxdWVzdCwgY2xpZW50T3B0aW9ucykge1xuICBsZXQgdXJsO1xuICBpZiAobW9kZWwuaW5jbHVkZXMoXCJlbmRwb2ludHMvXCIpKSB7XG4gICAgdXJsID0gZ2V0VmVydGV4QUlVcmwoe1xuICAgICAgaW5jbHVkZVByb2plY3RBbmRMb2NhdGlvbjogIW1vZGVsLnN0YXJ0c1dpdGgoXCJwcm9qZWN0cy9cIiksXG4gICAgICByZXNvdXJjZVBhdGg6IG1vZGVsLFxuICAgICAgcmVzb3VyY2VNZXRob2Q6IFwiZ2VuZXJhdGVDb250ZW50XCIsXG4gICAgICBjbGllbnRPcHRpb25zXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdXJsID0gZ2V0VmVydGV4QUlVcmwoe1xuICAgICAgaW5jbHVkZVByb2plY3RBbmRMb2NhdGlvbjogdHJ1ZSxcbiAgICAgIHJlc291cmNlUGF0aDogYHB1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscy8ke21vZGVsfWAsXG4gICAgICByZXNvdXJjZU1ldGhvZDogXCJnZW5lcmF0ZUNvbnRlbnRcIixcbiAgICAgIGNsaWVudE9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICBjb25zdCBmZXRjaE9wdGlvbnMgPSBhd2FpdCBnZXRGZXRjaE9wdGlvbnMoe1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgY2xpZW50T3B0aW9ucyxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeShnZW5lcmF0ZUNvbnRlbnRSZXF1ZXN0KVxuICB9KTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtYWtlUmVxdWVzdCh1cmwsIGZldGNoT3B0aW9ucyk7XG4gIGNvbnN0IHJlc3BvbnNlSnNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgcmV0dXJuIHJlc3BvbnNlSnNvbjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudFN0cmVhbShtb2RlbCwgZ2VuZXJhdGVDb250ZW50UmVxdWVzdCwgY2xpZW50T3B0aW9ucykge1xuICBsZXQgdXJsO1xuICBpZiAobW9kZWwuaW5jbHVkZXMoXCJlbmRwb2ludHMvXCIpKSB7XG4gICAgdXJsID0gZ2V0VmVydGV4QUlVcmwoe1xuICAgICAgaW5jbHVkZVByb2plY3RBbmRMb2NhdGlvbjogIW1vZGVsLnN0YXJ0c1dpdGgoXCJwcm9qZWN0cy9cIiksXG4gICAgICByZXNvdXJjZVBhdGg6IG1vZGVsLFxuICAgICAgcmVzb3VyY2VNZXRob2Q6IFwic3RyZWFtR2VuZXJhdGVDb250ZW50XCIsXG4gICAgICBjbGllbnRPcHRpb25zXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdXJsID0gZ2V0VmVydGV4QUlVcmwoe1xuICAgICAgaW5jbHVkZVByb2plY3RBbmRMb2NhdGlvbjogdHJ1ZSxcbiAgICAgIHJlc291cmNlUGF0aDogYHB1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscy8ke21vZGVsfWAsXG4gICAgICByZXNvdXJjZU1ldGhvZDogXCJzdHJlYW1HZW5lcmF0ZUNvbnRlbnRcIixcbiAgICAgIGNsaWVudE9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICBjb25zdCBmZXRjaE9wdGlvbnMgPSBhd2FpdCBnZXRGZXRjaE9wdGlvbnMoe1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgY2xpZW50T3B0aW9ucyxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeShnZW5lcmF0ZUNvbnRlbnRSZXF1ZXN0KVxuICB9KTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtYWtlUmVxdWVzdCh1cmwsIGZldGNoT3B0aW9ucyk7XG4gIHJldHVybiAoMCwgaW1wb3J0X3V0aWxzLnByb2Nlc3NTdHJlYW0pKHJlc3BvbnNlKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGludGVybmFsUHJlZGljdChtb2RlbCwgYm9keSwgY2xpZW50T3B0aW9ucykge1xuICBjb25zdCB1cmwgPSBnZXRWZXJ0ZXhBSVVybCh7XG4gICAgaW5jbHVkZVByb2plY3RBbmRMb2NhdGlvbjogdHJ1ZSxcbiAgICByZXNvdXJjZVBhdGg6IGBwdWJsaXNoZXJzL2dvb2dsZS9tb2RlbHMvJHttb2RlbH1gLFxuICAgIHJlc291cmNlTWV0aG9kOiBcInByZWRpY3RcIixcbiAgICBjbGllbnRPcHRpb25zXG4gIH0pO1xuICBjb25zdCBmZXRjaE9wdGlvbnMgPSBhd2FpdCBnZXRGZXRjaE9wdGlvbnMoe1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgY2xpZW50T3B0aW9ucyxcbiAgICBib2R5XG4gIH0pO1xuICByZXR1cm4gYXdhaXQgbWFrZVJlcXVlc3QodXJsLCBmZXRjaE9wdGlvbnMpO1xufVxuYXN5bmMgZnVuY3Rpb24gZW1iZWRDb250ZW50KG1vZGVsLCBlbWJlZENvbnRlbnRSZXF1ZXN0LCBjbGllbnRPcHRpb25zKSB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaW50ZXJuYWxQcmVkaWN0KFxuICAgIG1vZGVsLFxuICAgIEpTT04uc3RyaW5naWZ5KGVtYmVkQ29udGVudFJlcXVlc3QpLFxuICAgIGNsaWVudE9wdGlvbnNcbiAgKTtcbiAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGltYWdlblByZWRpY3QobW9kZWwsIGltYWdlblByZWRpY3RSZXF1ZXN0LCBjbGllbnRPcHRpb25zKSB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaW50ZXJuYWxQcmVkaWN0KFxuICAgIG1vZGVsLFxuICAgIEpTT04uc3RyaW5naWZ5KGltYWdlblByZWRpY3RSZXF1ZXN0KSxcbiAgICBjbGllbnRPcHRpb25zXG4gICk7XG4gIHJldHVybiByZXNwb25zZS5qc29uKCk7XG59XG5hc3luYyBmdW5jdGlvbiBseXJpYVByZWRpY3QobW9kZWwsIGx5cmlhUHJlZGljdFJlcXVlc3QsIGNsaWVudE9wdGlvbnMpIHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBpbnRlcm5hbFByZWRpY3QoXG4gICAgbW9kZWwsXG4gICAgSlNPTi5zdHJpbmdpZnkobHlyaWFQcmVkaWN0UmVxdWVzdCksXG4gICAgY2xpZW50T3B0aW9uc1xuICApO1xuICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xufVxuYXN5bmMgZnVuY3Rpb24gdmVvUHJlZGljdChtb2RlbCwgdmVvUHJlZGljdFJlcXVlc3QsIGNsaWVudE9wdGlvbnMpIHtcbiAgY29uc3QgdXJsID0gZ2V0VmVydGV4QUlVcmwoe1xuICAgIGluY2x1ZGVQcm9qZWN0QW5kTG9jYXRpb246IHRydWUsXG4gICAgcmVzb3VyY2VQYXRoOiBgcHVibGlzaGVycy9nb29nbGUvbW9kZWxzLyR7bW9kZWx9YCxcbiAgICByZXNvdXJjZU1ldGhvZDogXCJwcmVkaWN0TG9uZ1J1bm5pbmdcIixcbiAgICBjbGllbnRPcHRpb25zXG4gIH0pO1xuICBjb25zdCBmZXRjaE9wdGlvbnMgPSBhd2FpdCBnZXRGZXRjaE9wdGlvbnMoe1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgY2xpZW50T3B0aW9ucyxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh2ZW9QcmVkaWN0UmVxdWVzdClcbiAgfSk7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbWFrZVJlcXVlc3QodXJsLCBmZXRjaE9wdGlvbnMpO1xuICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xufVxuYXN5bmMgZnVuY3Rpb24gdmVvQ2hlY2tPcGVyYXRpb24obW9kZWwsIHZlb09wZXJhdGlvblJlcXVlc3QsIGNsaWVudE9wdGlvbnMpIHtcbiAgY29uc3QgdXJsID0gZ2V0VmVydGV4QUlVcmwoe1xuICAgIGluY2x1ZGVQcm9qZWN0QW5kTG9jYXRpb246IHRydWUsXG4gICAgcmVzb3VyY2VQYXRoOiBgcHVibGlzaGVycy9nb29nbGUvbW9kZWxzLyR7bW9kZWx9YCxcbiAgICByZXNvdXJjZU1ldGhvZDogXCJmZXRjaFByZWRpY3RPcGVyYXRpb25cIixcbiAgICBjbGllbnRPcHRpb25zXG4gIH0pO1xuICBjb25zdCBmZXRjaE9wdGlvbnMgPSBhd2FpdCBnZXRGZXRjaE9wdGlvbnMoe1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgY2xpZW50T3B0aW9ucyxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh2ZW9PcGVyYXRpb25SZXF1ZXN0KVxuICB9KTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtYWtlUmVxdWVzdCh1cmwsIGZldGNoT3B0aW9ucyk7XG4gIHJldHVybiByZXNwb25zZS5qc29uKCk7XG59XG5mdW5jdGlvbiBnZXRWZXJ0ZXhBSVVybChwYXJhbXMpIHtcbiAgKDAsIGltcG9ydF91dGlsczIuY2hlY2tTdXBwb3J0ZWRSZXNvdXJjZU1ldGhvZCkocGFyYW1zKTtcbiAgY29uc3QgREVGQVVMVF9BUElfVkVSU0lPTiA9IFwidjFiZXRhMVwiO1xuICBjb25zdCBBUElfQkFTRV9QQVRIID0gXCJhaXBsYXRmb3JtLmdvb2dsZWFwaXMuY29tXCI7XG4gIGxldCBiYXNlUGF0aDtcbiAgaWYgKHBhcmFtcy5jbGllbnRPcHRpb25zLmtpbmQgPT0gXCJyZWdpb25hbFwiKSB7XG4gICAgYmFzZVBhdGggPSBgJHtwYXJhbXMuY2xpZW50T3B0aW9ucy5sb2NhdGlvbn0tJHtBUElfQkFTRV9QQVRIfWA7XG4gIH0gZWxzZSB7XG4gICAgYmFzZVBhdGggPSBBUElfQkFTRV9QQVRIO1xuICB9XG4gIGxldCByZXNvdXJjZVBhdGggPSBwYXJhbXMucmVzb3VyY2VQYXRoO1xuICBpZiAocGFyYW1zLmNsaWVudE9wdGlvbnMua2luZCAhPSBcImV4cHJlc3NcIiAmJiBwYXJhbXMuaW5jbHVkZVByb2plY3RBbmRMb2NhdGlvbikge1xuICAgIGNvbnN0IHBhcmVudCA9IGBwcm9qZWN0cy8ke3BhcmFtcy5jbGllbnRPcHRpb25zLnByb2plY3RJZH0vbG9jYXRpb25zLyR7cGFyYW1zLmNsaWVudE9wdGlvbnMubG9jYXRpb259YDtcbiAgICByZXNvdXJjZVBhdGggPSBgJHtwYXJlbnR9LyR7cGFyYW1zLnJlc291cmNlUGF0aH1gO1xuICB9XG4gIGxldCB1cmwgPSBgaHR0cHM6Ly8ke2Jhc2VQYXRofS8ke0RFRkFVTFRfQVBJX1ZFUlNJT059LyR7cmVzb3VyY2VQYXRofWA7XG4gIGlmIChwYXJhbXMucmVzb3VyY2VNZXRob2QpIHtcbiAgICB1cmwgKz0gYDoke3BhcmFtcy5yZXNvdXJjZU1ldGhvZH1gO1xuICB9XG4gIGxldCBqb2luZXIgPSBcIj9cIjtcbiAgaWYgKHBhcmFtcy5xdWVyeVBhcmFtcykge1xuICAgIHVybCArPSBgJHtqb2luZXJ9JHtwYXJhbXMucXVlcnlQYXJhbXN9YDtcbiAgICBqb2luZXIgPSBcIiZcIjtcbiAgfVxuICBpZiAocGFyYW1zLnJlc291cmNlTWV0aG9kID09PSBcInN0cmVhbUdlbmVyYXRlQ29udGVudFwiKSB7XG4gICAgdXJsICs9IGAke2pvaW5lcn1hbHQ9c3NlYDtcbiAgICBqb2luZXIgPSBcIiZcIjtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0RmV0Y2hPcHRpb25zKHBhcmFtcykge1xuICBjb25zdCBmZXRjaE9wdGlvbnMgPSB7XG4gICAgbWV0aG9kOiBwYXJhbXMubWV0aG9kLFxuICAgIGhlYWRlcnM6IGF3YWl0IGdldEhlYWRlcnMocGFyYW1zLmNsaWVudE9wdGlvbnMpXG4gIH07XG4gIGlmIChwYXJhbXMuYm9keSkge1xuICAgIGZldGNoT3B0aW9ucy5ib2R5ID0gcGFyYW1zLmJvZHk7XG4gIH1cbiAgY29uc3Qgc2lnbmFsID0gZ2V0QWJvcnRTaWduYWwocGFyYW1zLmNsaWVudE9wdGlvbnMpO1xuICBpZiAoc2lnbmFsKSB7XG4gICAgZmV0Y2hPcHRpb25zLnNpZ25hbCA9IHNpZ25hbDtcbiAgfVxuICByZXR1cm4gZmV0Y2hPcHRpb25zO1xufVxuZnVuY3Rpb24gZ2V0QWJvcnRTaWduYWwoY2xpZW50T3B0aW9ucykge1xuICBjb25zdCBoYXNUaW1lb3V0ID0gKGNsaWVudE9wdGlvbnMudGltZW91dCA/PyAtMSkgPj0gMDtcbiAgaWYgKGNsaWVudE9wdGlvbnMuc2lnbmFsICE9PSB2b2lkIDAgfHwgaGFzVGltZW91dCkge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgaWYgKGhhc1RpbWVvdXQpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCBjbGllbnRPcHRpb25zLnRpbWVvdXQpO1xuICAgIH1cbiAgICBpZiAoY2xpZW50T3B0aW9ucz8uc2lnbmFsKSB7XG4gICAgICBjbGllbnRPcHRpb25zLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyb2xsZXIuc2lnbmFsO1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRIZWFkZXJzKGNsaWVudE9wdGlvbnMpIHtcbiAgaWYgKGNsaWVudE9wdGlvbnMua2luZCA9PSBcImV4cHJlc3NcIikge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICBcIngtZ29vZy1hcGkta2V5XCI6ICgwLCBpbXBvcnRfdXRpbHMyLmNhbGN1bGF0ZUFwaUtleSkoY2xpZW50T3B0aW9ucy5hcGlLZXksIHZvaWQgMCksXG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIFwiWC1Hb29nLUFwaS1DbGllbnRcIjogKDAsIGltcG9ydF91dGlscy5nZXRHZW5raXRDbGllbnRIZWFkZXIpKCksXG4gICAgICBcIlVzZXItQWdlbnRcIjogKDAsIGltcG9ydF91dGlscy5nZXRHZW5raXRDbGllbnRIZWFkZXIpKClcbiAgICB9O1xuICAgIHJldHVybiBoZWFkZXJzO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHRva2VuID0gYXdhaXQgZ2V0VG9rZW4oY2xpZW50T3B0aW9ucy5hdXRoQ2xpZW50KTtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICBcIngtZ29vZy11c2VyLXByb2plY3RcIjogY2xpZW50T3B0aW9ucy5wcm9qZWN0SWQsXG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIFwiWC1Hb29nLUFwaS1DbGllbnRcIjogKDAsIGltcG9ydF91dGlscy5nZXRHZW5raXRDbGllbnRIZWFkZXIpKCksXG4gICAgICBcIlVzZXItQWdlbnRcIjogKDAsIGltcG9ydF91dGlscy5nZXRHZW5raXRDbGllbnRIZWFkZXIpKClcbiAgICB9O1xuICAgIGlmIChjbGllbnRPcHRpb25zLmFwaUtleSkge1xuICAgICAgaGVhZGVyc1tcIngtZ29vZy1hcGkta2V5XCJdID0gY2xpZW50T3B0aW9ucy5hcGlLZXk7XG4gICAgfVxuICAgIHJldHVybiBoZWFkZXJzO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRUb2tlbihhdXRoQ2xpZW50KSB7XG4gIGNvbnN0IENSRURFTlRJQUxfRVJST1JfTUVTU0FHRSA9IFwiXFxuVW5hYmxlIHRvIGF1dGhlbnRpY2F0ZSB5b3VyIHJlcXVlc3QgICAgICAgIFxcbkRlcGVuZGluZyBvbiB5b3VyIHJ1biB0aW1lIGVudmlyb25tZW50LCB5b3UgY2FuIGdldCBhdXRoZW50aWNhdGlvbiBieSAgICAgICAgXFxuLSBpZiBpbiBsb2NhbCBpbnN0YW5jZSBvciBjbG91ZCBzaGVsbDogYCFnY2xvdWQgYXV0aCBsb2dpbmAgICAgICAgIFxcbi0gaWYgaW4gQ29sYWI6ICAgICAgICBcXG4gICAgLWBmcm9tIGdvb2dsZS5jb2xhYiBpbXBvcnQgYXV0aGAgICAgICAgIFxcbiAgICAtYGF1dGguYXV0aGVudGljYXRlX3VzZXIoKWAgICAgICAgIFxcbi0gaWYgaW4gc2VydmljZSBhY2NvdW50IG9yIG90aGVyOiBwbGVhc2UgZm9sbG93IGd1aWRhbmNlIGluIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9kb2NzL2F1dGhlbnRpY2F0aW9uXCI7XG4gIGNvbnN0IHRva2VuID0gYXdhaXQgYXV0aENsaWVudC5nZXRBY2Nlc3NUb2tlbigpLmNhdGNoKChlKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKENSRURFTlRJQUxfRVJST1JfTUVTU0FHRSwgZSk7XG4gIH0pO1xuICBpZiAoIXRva2VuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKENSRURFTlRJQUxfRVJST1JfTUVTU0FHRSk7XG4gIH1cbiAgcmV0dXJuIHRva2VuO1xufVxuYXN5bmMgZnVuY3Rpb24gbWFrZVJlcXVlc3QodXJsLCBmZXRjaE9wdGlvbnMpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwgZmV0Y2hPcHRpb25zKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBsZXQgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IGVycm9yVGV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKGVycm9yVGV4dCk7XG4gICAgICAgIGlmIChqc29uLmVycm9yICYmIGpzb24uZXJyb3IubWVzc2FnZSkge1xuICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGpzb24uZXJyb3IubWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRXJyb3IgZmV0Y2hpbmcgZnJvbSAke3VybH06IFske3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fV0gJHtlcnJvck1lc3NhZ2V9YFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBmcm9tICR7dXJsfTogJHsoMCwgaW1wb3J0X3V0aWxzLmV4dHJhY3RFcnJNc2cpKGUpfWApO1xuICB9XG59XG5jb25zdCBURVNUX09OTFkgPSB7XG4gIGdldEZldGNoT3B0aW9ucyxcbiAgZ2V0QWJvcnRTaWduYWwsXG4gIGdldEhlYWRlcnMsXG4gIG1ha2VSZXF1ZXN0XG59O1xuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIFRFU1RfT05MWSxcbiAgZW1iZWRDb250ZW50LFxuICBnZW5lcmF0ZUNvbnRlbnQsXG4gIGdlbmVyYXRlQ29udGVudFN0cmVhbSxcbiAgZ2V0VmVydGV4QUlVcmwsXG4gIGltYWdlblByZWRpY3QsXG4gIGxpc3RNb2RlbHMsXG4gIGx5cmlhUHJlZGljdCxcbiAgdmVvQ2hlY2tPcGVyYXRpb24sXG4gIHZlb1ByZWRpY3Rcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/client.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/converters.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@genkit-ai/google-genai/lib/vertexai/converters.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar converters_exports = {};\n__export(converters_exports, {\n  fromImagenResponse: () => fromImagenResponse,\n  fromLyriaResponse: () => fromLyriaResponse,\n  fromVeoOperation: () => fromVeoOperation,\n  toGeminiLabels: () => toGeminiLabels,\n  toGeminiSafetySettings: () => toGeminiSafetySettings,\n  toImagenPredictRequest: () => toImagenPredictRequest,\n  toLyriaPredictRequest: () => toLyriaPredictRequest,\n  toVeoMedia: () => toVeoMedia,\n  toVeoModel: () => toVeoModel,\n  toVeoOperationRequest: () => toVeoOperationRequest,\n  toVeoPredictRequest: () => toVeoPredictRequest\n});\nmodule.exports = __toCommonJS(converters_exports);\nvar import_genkit = __webpack_require__(/*! genkit */ \"(action-browser)/./node_modules/genkit/lib/index.js\");\nvar import_model = __webpack_require__(/*! genkit/model */ \"(action-browser)/./node_modules/genkit/lib/model.js\");\nvar import_utils = __webpack_require__(/*! ./utils.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/utils.js\");\nfunction toGeminiSafetySettings(genkitSettings) {\n  if (!genkitSettings) return void 0;\n  return genkitSettings.map((s) => {\n    return {\n      category: s.category,\n      threshold: s.threshold\n    };\n  });\n}\nfunction toGeminiLabels(labels) {\n  if (!labels) {\n    return void 0;\n  }\n  const keys = Object.keys(labels);\n  const newLabels = {};\n  for (const key of keys) {\n    const value = labels[key];\n    if (!key) {\n      continue;\n    }\n    newLabels[key] = value;\n  }\n  if (Object.keys(newLabels).length == 0) {\n    return void 0;\n  }\n  return newLabels;\n}\nfunction toImagenPredictRequest(request) {\n  return {\n    instances: toImagenInstances(request),\n    parameters: toImagenParameters(request)\n  };\n}\nfunction toImagenInstances(request) {\n  let instance = {\n    prompt: (0, import_utils.extractText)(request)\n  };\n  const imageMedia = (0, import_utils.extractMedia)(request, {\n    metadataType: \"image\",\n    isDefault: true\n  });\n  if (imageMedia) {\n    const image = imageMedia.url.split(\",\")[1];\n    instance.image = {\n      bytesBase64Encoded: image\n    };\n  }\n  const maskMedia = (0, import_utils.extractMedia)(request, { metadataType: \"mask\" });\n  if (maskMedia) {\n    const mask = maskMedia.url.split(\",\")[1];\n    instance.mask = {\n      image: {\n        bytesBase64Encoded: mask\n      }\n    };\n  }\n  return [instance];\n}\nfunction toImagenParameters(request) {\n  const params = {\n    sampleCount: request.candidates ?? 1,\n    ...request?.config\n  };\n  for (const k in params) {\n    if (!params[k]) delete params[k];\n  }\n  return params;\n}\nfunction fromImagenPrediction(p, i) {\n  const b64data = p.bytesBase64Encoded;\n  const mimeType = p.mimeType;\n  return {\n    index: i,\n    finishReason: \"stop\",\n    message: {\n      role: \"model\",\n      content: [\n        {\n          media: {\n            url: `data:${mimeType};base64,${b64data}`,\n            contentType: mimeType\n          }\n        }\n      ]\n    }\n  };\n}\nfunction fromImagenResponse(response, request) {\n  const candidates = response.predictions.map(fromImagenPrediction);\n  return {\n    candidates,\n    usage: {\n      ...(0, import_model.getBasicUsageStats)(request.messages, candidates),\n      custom: { generations: candidates.length }\n    },\n    custom: response\n  };\n}\nfunction toLyriaPredictRequest(request) {\n  return {\n    instances: toLyriaInstances(request),\n    parameters: toLyriaParameters(request)\n  };\n}\nfunction toLyriaInstances(request) {\n  let config = { ...request.config };\n  delete config.sampleCount;\n  return [\n    {\n      prompt: (0, import_utils.extractText)(request),\n      ...config\n    }\n  ];\n}\nfunction toLyriaParameters(request) {\n  return {\n    sampleCount: request.config?.sampleCount || 1\n  };\n}\nfunction fromLyriaPrediction(p, i) {\n  const b64data = p.bytesBase64Encoded;\n  const mimeType = p.mimeType;\n  return {\n    index: i,\n    finishReason: \"stop\",\n    message: {\n      role: \"model\",\n      content: [\n        {\n          media: {\n            url: `data:${mimeType};base64,${b64data}`,\n            contentType: mimeType\n          }\n        }\n      ]\n    }\n  };\n}\nfunction fromLyriaResponse(response, request) {\n  const candidates = response.predictions.map(fromLyriaPrediction);\n  return {\n    candidates,\n    usage: {\n      ...(0, import_model.getBasicUsageStats)(request.messages, candidates),\n      custom: { generations: candidates.length }\n    },\n    custom: response\n  };\n}\nfunction toVeoPredictRequest(request) {\n  return {\n    instances: toVeoInstances(request),\n    parameters: { ...request.config }\n  };\n}\nfunction toVeoInstances(request) {\n  let instance = {\n    prompt: (0, import_utils.extractText)(request)\n  };\n  const supportedImageTypes = [\"image/jpeg\", \"image/png\"];\n  const supportedVideoTypes = [\"video/mp4\"];\n  const imageMedia = (0, import_utils.extractMedia)(request, { metadataType: \"image\" });\n  if (imageMedia) {\n    (0, import_utils.checkSupportedMimeType)(imageMedia, supportedImageTypes);\n    instance.image = toVeoMedia(imageMedia);\n  }\n  const lastFrameMedia = (0, import_utils.extractMedia)(request, { metadataType: \"lastFrame\" });\n  if (lastFrameMedia) {\n    (0, import_utils.checkSupportedMimeType)(lastFrameMedia, supportedImageTypes);\n    instance.lastFrame = toVeoMedia(lastFrameMedia);\n  }\n  const videoMedia = (0, import_utils.extractMedia)(request, { metadataType: \"video\" });\n  if (videoMedia) {\n    (0, import_utils.checkSupportedMimeType)(videoMedia, supportedVideoTypes);\n    instance.video = toVeoMedia(videoMedia);\n  }\n  return [instance];\n}\nfunction toVeoMedia(media) {\n  let mimeType = media.contentType;\n  if (!mimeType) {\n    mimeType = (0, import_utils.extractMimeType)(media.url);\n    if (!mimeType) {\n      throw new import_genkit.GenkitError({\n        status: \"INVALID_ARGUMENT\",\n        message: \"Content type is required.\"\n      });\n    }\n  }\n  if (media.url.startsWith(\"data:\")) {\n    return {\n      bytesBase64Encoded: media.url?.split(\",\")[1],\n      mimeType\n    };\n  } else if (media.url.startsWith(\"gs://\")) {\n    return {\n      gcsUri: media.url,\n      mimeType\n    };\n  } else if (media.url.startsWith(\"http\")) {\n    throw new import_genkit.GenkitError({\n      status: \"INVALID_ARGUMENT\",\n      message: \"Veo does not support http(s) URIs. Please specify a Cloud Storage URI.\"\n    });\n  } else {\n    return {\n      bytesBase64Encoded: media.url,\n      mimeType\n    };\n  }\n}\nfunction fromVeoOperation(fromOp) {\n  const toOp = { id: fromOp.name };\n  if (fromOp.done !== void 0) {\n    toOp.done = fromOp.done;\n  }\n  if (fromOp.error) {\n    toOp.error = { message: fromOp.error.message };\n  }\n  if (fromOp.response) {\n    toOp.output = {\n      finishReason: \"stop\",\n      raw: fromOp.response,\n      message: {\n        role: \"model\",\n        content: fromOp.response.videos.map((veoMedia) => {\n          if (veoMedia.bytesBase64Encoded) {\n            return {\n              media: {\n                url: `data:${veoMedia.mimeType}:base64,${veoMedia.bytesBase64Encoded}`,\n                contentType: veoMedia.mimeType\n              }\n            };\n          }\n          return {\n            media: {\n              url: veoMedia.gcsUri ?? \"\",\n              contentType: veoMedia.mimeType\n            }\n          };\n        })\n      }\n    };\n  }\n  return toOp;\n}\nfunction toVeoModel(op) {\n  return op.id.substring(\n    op.id.indexOf(\"models/\") + 7,\n    op.id.indexOf(\"/operations/\")\n  );\n}\nfunction toVeoOperationRequest(op) {\n  return {\n    operationName: op.id\n  };\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=converters.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2dvb2dsZS1nZW5haS9saWIvdmVydGV4YWkvY29udmVydGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsbUVBQVE7QUFDcEMsbUJBQW1CLG1CQUFPLENBQUMseUVBQWM7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsaUdBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsc0JBQXNCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFVBQVUsU0FBUyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVSxTQUFTLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHVCQUF1QjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSwyQkFBMkI7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsdUJBQXVCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtCQUFrQixVQUFVLDRCQUE0QjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQVlMO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcS1JhbWFjaGFcXERvY3VtZW50c1xcU3VzdEFJbmV4IEdJdCBDb2RlXFxub2RlX21vZHVsZXNcXEBnZW5raXQtYWlcXGdvb2dsZS1nZW5haVxcbGliXFx2ZXJ0ZXhhaVxcY29udmVydGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgY29udmVydGVyc19leHBvcnRzID0ge307XG5fX2V4cG9ydChjb252ZXJ0ZXJzX2V4cG9ydHMsIHtcbiAgZnJvbUltYWdlblJlc3BvbnNlOiAoKSA9PiBmcm9tSW1hZ2VuUmVzcG9uc2UsXG4gIGZyb21MeXJpYVJlc3BvbnNlOiAoKSA9PiBmcm9tTHlyaWFSZXNwb25zZSxcbiAgZnJvbVZlb09wZXJhdGlvbjogKCkgPT4gZnJvbVZlb09wZXJhdGlvbixcbiAgdG9HZW1pbmlMYWJlbHM6ICgpID0+IHRvR2VtaW5pTGFiZWxzLFxuICB0b0dlbWluaVNhZmV0eVNldHRpbmdzOiAoKSA9PiB0b0dlbWluaVNhZmV0eVNldHRpbmdzLFxuICB0b0ltYWdlblByZWRpY3RSZXF1ZXN0OiAoKSA9PiB0b0ltYWdlblByZWRpY3RSZXF1ZXN0LFxuICB0b0x5cmlhUHJlZGljdFJlcXVlc3Q6ICgpID0+IHRvTHlyaWFQcmVkaWN0UmVxdWVzdCxcbiAgdG9WZW9NZWRpYTogKCkgPT4gdG9WZW9NZWRpYSxcbiAgdG9WZW9Nb2RlbDogKCkgPT4gdG9WZW9Nb2RlbCxcbiAgdG9WZW9PcGVyYXRpb25SZXF1ZXN0OiAoKSA9PiB0b1Zlb09wZXJhdGlvblJlcXVlc3QsXG4gIHRvVmVvUHJlZGljdFJlcXVlc3Q6ICgpID0+IHRvVmVvUHJlZGljdFJlcXVlc3Rcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoY29udmVydGVyc19leHBvcnRzKTtcbnZhciBpbXBvcnRfZ2Vua2l0ID0gcmVxdWlyZShcImdlbmtpdFwiKTtcbnZhciBpbXBvcnRfbW9kZWwgPSByZXF1aXJlKFwiZ2Vua2l0L21vZGVsXCIpO1xudmFyIGltcG9ydF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuZnVuY3Rpb24gdG9HZW1pbmlTYWZldHlTZXR0aW5ncyhnZW5raXRTZXR0aW5ncykge1xuICBpZiAoIWdlbmtpdFNldHRpbmdzKSByZXR1cm4gdm9pZCAwO1xuICByZXR1cm4gZ2Vua2l0U2V0dGluZ3MubWFwKChzKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhdGVnb3J5OiBzLmNhdGVnb3J5LFxuICAgICAgdGhyZXNob2xkOiBzLnRocmVzaG9sZFxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gdG9HZW1pbmlMYWJlbHMobGFiZWxzKSB7XG4gIGlmICghbGFiZWxzKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobGFiZWxzKTtcbiAgY29uc3QgbmV3TGFiZWxzID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGxhYmVsc1trZXldO1xuICAgIGlmICgha2V5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbmV3TGFiZWxzW2tleV0gPSB2YWx1ZTtcbiAgfVxuICBpZiAoT2JqZWN0LmtleXMobmV3TGFiZWxzKS5sZW5ndGggPT0gMCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIG5ld0xhYmVscztcbn1cbmZ1bmN0aW9uIHRvSW1hZ2VuUHJlZGljdFJlcXVlc3QocmVxdWVzdCkge1xuICByZXR1cm4ge1xuICAgIGluc3RhbmNlczogdG9JbWFnZW5JbnN0YW5jZXMocmVxdWVzdCksXG4gICAgcGFyYW1ldGVyczogdG9JbWFnZW5QYXJhbWV0ZXJzKHJlcXVlc3QpXG4gIH07XG59XG5mdW5jdGlvbiB0b0ltYWdlbkluc3RhbmNlcyhyZXF1ZXN0KSB7XG4gIGxldCBpbnN0YW5jZSA9IHtcbiAgICBwcm9tcHQ6ICgwLCBpbXBvcnRfdXRpbHMuZXh0cmFjdFRleHQpKHJlcXVlc3QpXG4gIH07XG4gIGNvbnN0IGltYWdlTWVkaWEgPSAoMCwgaW1wb3J0X3V0aWxzLmV4dHJhY3RNZWRpYSkocmVxdWVzdCwge1xuICAgIG1ldGFkYXRhVHlwZTogXCJpbWFnZVwiLFxuICAgIGlzRGVmYXVsdDogdHJ1ZVxuICB9KTtcbiAgaWYgKGltYWdlTWVkaWEpIHtcbiAgICBjb25zdCBpbWFnZSA9IGltYWdlTWVkaWEudXJsLnNwbGl0KFwiLFwiKVsxXTtcbiAgICBpbnN0YW5jZS5pbWFnZSA9IHtcbiAgICAgIGJ5dGVzQmFzZTY0RW5jb2RlZDogaW1hZ2VcbiAgICB9O1xuICB9XG4gIGNvbnN0IG1hc2tNZWRpYSA9ICgwLCBpbXBvcnRfdXRpbHMuZXh0cmFjdE1lZGlhKShyZXF1ZXN0LCB7IG1ldGFkYXRhVHlwZTogXCJtYXNrXCIgfSk7XG4gIGlmIChtYXNrTWVkaWEpIHtcbiAgICBjb25zdCBtYXNrID0gbWFza01lZGlhLnVybC5zcGxpdChcIixcIilbMV07XG4gICAgaW5zdGFuY2UubWFzayA9IHtcbiAgICAgIGltYWdlOiB7XG4gICAgICAgIGJ5dGVzQmFzZTY0RW5jb2RlZDogbWFza1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIFtpbnN0YW5jZV07XG59XG5mdW5jdGlvbiB0b0ltYWdlblBhcmFtZXRlcnMocmVxdWVzdCkge1xuICBjb25zdCBwYXJhbXMgPSB7XG4gICAgc2FtcGxlQ291bnQ6IHJlcXVlc3QuY2FuZGlkYXRlcyA/PyAxLFxuICAgIC4uLnJlcXVlc3Q/LmNvbmZpZ1xuICB9O1xuICBmb3IgKGNvbnN0IGsgaW4gcGFyYW1zKSB7XG4gICAgaWYgKCFwYXJhbXNba10pIGRlbGV0ZSBwYXJhbXNba107XG4gIH1cbiAgcmV0dXJuIHBhcmFtcztcbn1cbmZ1bmN0aW9uIGZyb21JbWFnZW5QcmVkaWN0aW9uKHAsIGkpIHtcbiAgY29uc3QgYjY0ZGF0YSA9IHAuYnl0ZXNCYXNlNjRFbmNvZGVkO1xuICBjb25zdCBtaW1lVHlwZSA9IHAubWltZVR5cGU7XG4gIHJldHVybiB7XG4gICAgaW5kZXg6IGksXG4gICAgZmluaXNoUmVhc29uOiBcInN0b3BcIixcbiAgICBtZXNzYWdlOiB7XG4gICAgICByb2xlOiBcIm1vZGVsXCIsXG4gICAgICBjb250ZW50OiBbXG4gICAgICAgIHtcbiAgICAgICAgICBtZWRpYToge1xuICAgICAgICAgICAgdXJsOiBgZGF0YToke21pbWVUeXBlfTtiYXNlNjQsJHtiNjRkYXRhfWAsXG4gICAgICAgICAgICBjb250ZW50VHlwZTogbWltZVR5cGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBmcm9tSW1hZ2VuUmVzcG9uc2UocmVzcG9uc2UsIHJlcXVlc3QpIHtcbiAgY29uc3QgY2FuZGlkYXRlcyA9IHJlc3BvbnNlLnByZWRpY3Rpb25zLm1hcChmcm9tSW1hZ2VuUHJlZGljdGlvbik7XG4gIHJldHVybiB7XG4gICAgY2FuZGlkYXRlcyxcbiAgICB1c2FnZToge1xuICAgICAgLi4uKDAsIGltcG9ydF9tb2RlbC5nZXRCYXNpY1VzYWdlU3RhdHMpKHJlcXVlc3QubWVzc2FnZXMsIGNhbmRpZGF0ZXMpLFxuICAgICAgY3VzdG9tOiB7IGdlbmVyYXRpb25zOiBjYW5kaWRhdGVzLmxlbmd0aCB9XG4gICAgfSxcbiAgICBjdXN0b206IHJlc3BvbnNlXG4gIH07XG59XG5mdW5jdGlvbiB0b0x5cmlhUHJlZGljdFJlcXVlc3QocmVxdWVzdCkge1xuICByZXR1cm4ge1xuICAgIGluc3RhbmNlczogdG9MeXJpYUluc3RhbmNlcyhyZXF1ZXN0KSxcbiAgICBwYXJhbWV0ZXJzOiB0b0x5cmlhUGFyYW1ldGVycyhyZXF1ZXN0KVxuICB9O1xufVxuZnVuY3Rpb24gdG9MeXJpYUluc3RhbmNlcyhyZXF1ZXN0KSB7XG4gIGxldCBjb25maWcgPSB7IC4uLnJlcXVlc3QuY29uZmlnIH07XG4gIGRlbGV0ZSBjb25maWcuc2FtcGxlQ291bnQ7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgcHJvbXB0OiAoMCwgaW1wb3J0X3V0aWxzLmV4dHJhY3RUZXh0KShyZXF1ZXN0KSxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH1cbiAgXTtcbn1cbmZ1bmN0aW9uIHRvTHlyaWFQYXJhbWV0ZXJzKHJlcXVlc3QpIHtcbiAgcmV0dXJuIHtcbiAgICBzYW1wbGVDb3VudDogcmVxdWVzdC5jb25maWc/LnNhbXBsZUNvdW50IHx8IDFcbiAgfTtcbn1cbmZ1bmN0aW9uIGZyb21MeXJpYVByZWRpY3Rpb24ocCwgaSkge1xuICBjb25zdCBiNjRkYXRhID0gcC5ieXRlc0Jhc2U2NEVuY29kZWQ7XG4gIGNvbnN0IG1pbWVUeXBlID0gcC5taW1lVHlwZTtcbiAgcmV0dXJuIHtcbiAgICBpbmRleDogaSxcbiAgICBmaW5pc2hSZWFzb246IFwic3RvcFwiLFxuICAgIG1lc3NhZ2U6IHtcbiAgICAgIHJvbGU6IFwibW9kZWxcIixcbiAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAge1xuICAgICAgICAgIG1lZGlhOiB7XG4gICAgICAgICAgICB1cmw6IGBkYXRhOiR7bWltZVR5cGV9O2Jhc2U2NCwke2I2NGRhdGF9YCxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBtaW1lVHlwZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGZyb21MeXJpYVJlc3BvbnNlKHJlc3BvbnNlLCByZXF1ZXN0KSB7XG4gIGNvbnN0IGNhbmRpZGF0ZXMgPSByZXNwb25zZS5wcmVkaWN0aW9ucy5tYXAoZnJvbUx5cmlhUHJlZGljdGlvbik7XG4gIHJldHVybiB7XG4gICAgY2FuZGlkYXRlcyxcbiAgICB1c2FnZToge1xuICAgICAgLi4uKDAsIGltcG9ydF9tb2RlbC5nZXRCYXNpY1VzYWdlU3RhdHMpKHJlcXVlc3QubWVzc2FnZXMsIGNhbmRpZGF0ZXMpLFxuICAgICAgY3VzdG9tOiB7IGdlbmVyYXRpb25zOiBjYW5kaWRhdGVzLmxlbmd0aCB9XG4gICAgfSxcbiAgICBjdXN0b206IHJlc3BvbnNlXG4gIH07XG59XG5mdW5jdGlvbiB0b1Zlb1ByZWRpY3RSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgcmV0dXJuIHtcbiAgICBpbnN0YW5jZXM6IHRvVmVvSW5zdGFuY2VzKHJlcXVlc3QpLFxuICAgIHBhcmFtZXRlcnM6IHsgLi4ucmVxdWVzdC5jb25maWcgfVxuICB9O1xufVxuZnVuY3Rpb24gdG9WZW9JbnN0YW5jZXMocmVxdWVzdCkge1xuICBsZXQgaW5zdGFuY2UgPSB7XG4gICAgcHJvbXB0OiAoMCwgaW1wb3J0X3V0aWxzLmV4dHJhY3RUZXh0KShyZXF1ZXN0KVxuICB9O1xuICBjb25zdCBzdXBwb3J0ZWRJbWFnZVR5cGVzID0gW1wiaW1hZ2UvanBlZ1wiLCBcImltYWdlL3BuZ1wiXTtcbiAgY29uc3Qgc3VwcG9ydGVkVmlkZW9UeXBlcyA9IFtcInZpZGVvL21wNFwiXTtcbiAgY29uc3QgaW1hZ2VNZWRpYSA9ICgwLCBpbXBvcnRfdXRpbHMuZXh0cmFjdE1lZGlhKShyZXF1ZXN0LCB7IG1ldGFkYXRhVHlwZTogXCJpbWFnZVwiIH0pO1xuICBpZiAoaW1hZ2VNZWRpYSkge1xuICAgICgwLCBpbXBvcnRfdXRpbHMuY2hlY2tTdXBwb3J0ZWRNaW1lVHlwZSkoaW1hZ2VNZWRpYSwgc3VwcG9ydGVkSW1hZ2VUeXBlcyk7XG4gICAgaW5zdGFuY2UuaW1hZ2UgPSB0b1Zlb01lZGlhKGltYWdlTWVkaWEpO1xuICB9XG4gIGNvbnN0IGxhc3RGcmFtZU1lZGlhID0gKDAsIGltcG9ydF91dGlscy5leHRyYWN0TWVkaWEpKHJlcXVlc3QsIHsgbWV0YWRhdGFUeXBlOiBcImxhc3RGcmFtZVwiIH0pO1xuICBpZiAobGFzdEZyYW1lTWVkaWEpIHtcbiAgICAoMCwgaW1wb3J0X3V0aWxzLmNoZWNrU3VwcG9ydGVkTWltZVR5cGUpKGxhc3RGcmFtZU1lZGlhLCBzdXBwb3J0ZWRJbWFnZVR5cGVzKTtcbiAgICBpbnN0YW5jZS5sYXN0RnJhbWUgPSB0b1Zlb01lZGlhKGxhc3RGcmFtZU1lZGlhKTtcbiAgfVxuICBjb25zdCB2aWRlb01lZGlhID0gKDAsIGltcG9ydF91dGlscy5leHRyYWN0TWVkaWEpKHJlcXVlc3QsIHsgbWV0YWRhdGFUeXBlOiBcInZpZGVvXCIgfSk7XG4gIGlmICh2aWRlb01lZGlhKSB7XG4gICAgKDAsIGltcG9ydF91dGlscy5jaGVja1N1cHBvcnRlZE1pbWVUeXBlKSh2aWRlb01lZGlhLCBzdXBwb3J0ZWRWaWRlb1R5cGVzKTtcbiAgICBpbnN0YW5jZS52aWRlbyA9IHRvVmVvTWVkaWEodmlkZW9NZWRpYSk7XG4gIH1cbiAgcmV0dXJuIFtpbnN0YW5jZV07XG59XG5mdW5jdGlvbiB0b1Zlb01lZGlhKG1lZGlhKSB7XG4gIGxldCBtaW1lVHlwZSA9IG1lZGlhLmNvbnRlbnRUeXBlO1xuICBpZiAoIW1pbWVUeXBlKSB7XG4gICAgbWltZVR5cGUgPSAoMCwgaW1wb3J0X3V0aWxzLmV4dHJhY3RNaW1lVHlwZSkobWVkaWEudXJsKTtcbiAgICBpZiAoIW1pbWVUeXBlKSB7XG4gICAgICB0aHJvdyBuZXcgaW1wb3J0X2dlbmtpdC5HZW5raXRFcnJvcih7XG4gICAgICAgIHN0YXR1czogXCJJTlZBTElEX0FSR1VNRU5UXCIsXG4gICAgICAgIG1lc3NhZ2U6IFwiQ29udGVudCB0eXBlIGlzIHJlcXVpcmVkLlwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKG1lZGlhLnVybC5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYnl0ZXNCYXNlNjRFbmNvZGVkOiBtZWRpYS51cmw/LnNwbGl0KFwiLFwiKVsxXSxcbiAgICAgIG1pbWVUeXBlXG4gICAgfTtcbiAgfSBlbHNlIGlmIChtZWRpYS51cmwuc3RhcnRzV2l0aChcImdzOi8vXCIpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdjc1VyaTogbWVkaWEudXJsLFxuICAgICAgbWltZVR5cGVcbiAgICB9O1xuICB9IGVsc2UgaWYgKG1lZGlhLnVybC5zdGFydHNXaXRoKFwiaHR0cFwiKSkge1xuICAgIHRocm93IG5ldyBpbXBvcnRfZ2Vua2l0LkdlbmtpdEVycm9yKHtcbiAgICAgIHN0YXR1czogXCJJTlZBTElEX0FSR1VNRU5UXCIsXG4gICAgICBtZXNzYWdlOiBcIlZlbyBkb2VzIG5vdCBzdXBwb3J0IGh0dHAocykgVVJJcy4gUGxlYXNlIHNwZWNpZnkgYSBDbG91ZCBTdG9yYWdlIFVSSS5cIlxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBieXRlc0Jhc2U2NEVuY29kZWQ6IG1lZGlhLnVybCxcbiAgICAgIG1pbWVUeXBlXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gZnJvbVZlb09wZXJhdGlvbihmcm9tT3ApIHtcbiAgY29uc3QgdG9PcCA9IHsgaWQ6IGZyb21PcC5uYW1lIH07XG4gIGlmIChmcm9tT3AuZG9uZSAhPT0gdm9pZCAwKSB7XG4gICAgdG9PcC5kb25lID0gZnJvbU9wLmRvbmU7XG4gIH1cbiAgaWYgKGZyb21PcC5lcnJvcikge1xuICAgIHRvT3AuZXJyb3IgPSB7IG1lc3NhZ2U6IGZyb21PcC5lcnJvci5tZXNzYWdlIH07XG4gIH1cbiAgaWYgKGZyb21PcC5yZXNwb25zZSkge1xuICAgIHRvT3Aub3V0cHV0ID0ge1xuICAgICAgZmluaXNoUmVhc29uOiBcInN0b3BcIixcbiAgICAgIHJhdzogZnJvbU9wLnJlc3BvbnNlLFxuICAgICAgbWVzc2FnZToge1xuICAgICAgICByb2xlOiBcIm1vZGVsXCIsXG4gICAgICAgIGNvbnRlbnQ6IGZyb21PcC5yZXNwb25zZS52aWRlb3MubWFwKCh2ZW9NZWRpYSkgPT4ge1xuICAgICAgICAgIGlmICh2ZW9NZWRpYS5ieXRlc0Jhc2U2NEVuY29kZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIG1lZGlhOiB7XG4gICAgICAgICAgICAgICAgdXJsOiBgZGF0YToke3Zlb01lZGlhLm1pbWVUeXBlfTpiYXNlNjQsJHt2ZW9NZWRpYS5ieXRlc0Jhc2U2NEVuY29kZWR9YCxcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogdmVvTWVkaWEubWltZVR5cGVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lZGlhOiB7XG4gICAgICAgICAgICAgIHVybDogdmVvTWVkaWEuZ2NzVXJpID8/IFwiXCIsXG4gICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiB2ZW9NZWRpYS5taW1lVHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gdG9PcDtcbn1cbmZ1bmN0aW9uIHRvVmVvTW9kZWwob3ApIHtcbiAgcmV0dXJuIG9wLmlkLnN1YnN0cmluZyhcbiAgICBvcC5pZC5pbmRleE9mKFwibW9kZWxzL1wiKSArIDcsXG4gICAgb3AuaWQuaW5kZXhPZihcIi9vcGVyYXRpb25zL1wiKVxuICApO1xufVxuZnVuY3Rpb24gdG9WZW9PcGVyYXRpb25SZXF1ZXN0KG9wKSB7XG4gIHJldHVybiB7XG4gICAgb3BlcmF0aW9uTmFtZTogb3AuaWRcbiAgfTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBmcm9tSW1hZ2VuUmVzcG9uc2UsXG4gIGZyb21MeXJpYVJlc3BvbnNlLFxuICBmcm9tVmVvT3BlcmF0aW9uLFxuICB0b0dlbWluaUxhYmVscyxcbiAgdG9HZW1pbmlTYWZldHlTZXR0aW5ncyxcbiAgdG9JbWFnZW5QcmVkaWN0UmVxdWVzdCxcbiAgdG9MeXJpYVByZWRpY3RSZXF1ZXN0LFxuICB0b1Zlb01lZGlhLFxuICB0b1Zlb01vZGVsLFxuICB0b1Zlb09wZXJhdGlvblJlcXVlc3QsXG4gIHRvVmVvUHJlZGljdFJlcXVlc3Rcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udmVydGVycy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/converters.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/embedder.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@genkit-ai/google-genai/lib/vertexai/embedder.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar embedder_exports = {};\n__export(embedder_exports, {\n  EmbeddingConfigSchema: () => EmbeddingConfigSchema,\n  KNOWN_MODELS: () => KNOWN_MODELS,\n  TEST_ONLY: () => TEST_ONLY,\n  defineEmbedder: () => defineEmbedder,\n  defineKnownModels: () => defineKnownModels,\n  model: () => model\n});\nmodule.exports = __toCommonJS(embedder_exports);\nvar import_genkit = __webpack_require__(/*! genkit */ \"(action-browser)/./node_modules/genkit/lib/index.js\");\nvar import_embedder = __webpack_require__(/*! genkit/embedder */ \"(action-browser)/./node_modules/genkit/lib/embedder.js\");\nvar import_client = __webpack_require__(/*! ./client.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/client.js\");\nvar import_types = __webpack_require__(/*! ./types.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/types.js\");\nvar import_utils = __webpack_require__(/*! ./utils.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/utils.js\");\nconst EmbeddingConfigSchema = import_genkit.z.object({\n  /**\n   * The `task_type` parameter is defined as the intended downstream application\n   * to help the model produce better quality embeddings.\n   **/\n  taskType: import_types.TaskTypeSchema.optional(),\n  title: import_genkit.z.string().optional(),\n  location: import_genkit.z.string().optional(),\n  version: import_genkit.z.string().optional(),\n  /**\n   * The `outputDimensionality` parameter allows you to specify the dimensionality of the embedding output.\n   * By default, the model generates embeddings with 768 dimensions.\n   * By selecting a smaller output dimensionality, users can save memory and storage space, leading to more efficient computations.\n   **/\n  outputDimensionality: import_genkit.z.number().min(1).optional(),\n  /**\n   * For newly released embedders this parameter provides a hint for the proper\n   * way to call the embedder. (Multimodal embedders have a different request\n   * structure than non-multimodal embedders).\n   * For well-known embedders, this value will be ignored since we will already\n   * know if it's multimodal or not.\n   */\n  multimodal: import_genkit.z.boolean().optional()\n}).passthrough();\nfunction commonRef(name, info, configSchema = EmbeddingConfigSchema) {\n  return (0, import_embedder.embedderRef)({\n    name: `vertexai/${name}`,\n    configSchema,\n    info: info ?? {\n      dimensions: 768,\n      supports: {\n        input: [\"text\"]\n      }\n    }\n  });\n}\nconst GENERIC_TEXT_MODEL = commonRef(\"text\", {\n  dimensions: 3072,\n  supports: { input: [\"text\"] }\n});\nconst GENERIC_MULTIMODAL_MODEL = commonRef(\"multimodal\", {\n  dimensions: 768,\n  supports: { input: [\"text\", \"image\", \"video\"] }\n});\nconst KNOWN_MODELS = {\n  \"text-embedding-005\": commonRef(\"text-embedding-005\"),\n  \"text-multilingual-embedding-002\": commonRef(\n    \"text-multilingual-embedding-002\"\n  ),\n  \"multimodalembedding@001\": commonRef(\"multimodalembedding@001\", {\n    dimensions: 768,\n    supports: { input: [\"text\", \"image\", \"video\"] }\n  }),\n  \"gemini-embedding-001\": commonRef(\"gemini-embedding-001\", {\n    dimensions: 3072,\n    supports: { input: [\"text\"] }\n  })\n};\nfunction model(version, config = {}) {\n  const name = (0, import_utils.checkModelName)(version);\n  if (KNOWN_MODELS[name]) {\n    return (0, import_embedder.embedderRef)({\n      name: `vertexai/${name}`,\n      configSchema: EmbeddingConfigSchema,\n      config,\n      info: {\n        ...KNOWN_MODELS[name].info\n      }\n    });\n  }\n  if (config.multimodal) {\n    return (0, import_embedder.embedderRef)({\n      name: `vertexai/${name}`,\n      configSchema: EmbeddingConfigSchema,\n      config,\n      info: {\n        ...GENERIC_MULTIMODAL_MODEL.info\n      }\n    });\n  }\n  return (0, import_embedder.embedderRef)({\n    name: `vertexai/${name}`,\n    configSchema: EmbeddingConfigSchema,\n    config,\n    info: {\n      ...GENERIC_TEXT_MODEL.info\n    }\n  });\n}\nfunction defineKnownModels(ai, clientOptions, pluginOptions) {\n  for (const name of Object.keys(KNOWN_MODELS)) {\n    defineEmbedder(ai, name, clientOptions, pluginOptions);\n  }\n}\nfunction defineEmbedder(ai, name, clientOptions, pluginOptions) {\n  const ref = model(name);\n  return ai.defineEmbedder(\n    {\n      name: ref.name,\n      configSchema: ref.configSchema,\n      info: ref.info\n    },\n    async (input, options) => {\n      const embedContentRequest = {\n        instances: input.map(\n          (doc) => toEmbeddingInstance(ref, doc, options)\n        ),\n        parameters: { outputDimensionality: options?.outputDimensionality }\n      };\n      const response = await (0, import_client.embedContent)(\n        (0, import_utils.extractVersion)(ref),\n        embedContentRequest,\n        clientOptions\n      );\n      return {\n        embeddings: response.predictions.map(toEmbeddingResult).reduce((accumulator, value) => {\n          return accumulator.concat(value);\n        }, [])\n      };\n    }\n  );\n}\nfunction toEmbeddingInstance(embedder, doc, options) {\n  let instance;\n  if (isMultiModalEmbedder(embedder) || embedder.config?.multimodal || options?.multimodal) {\n    instance = {};\n    if (doc.text) {\n      instance.text = doc.text;\n    }\n    for (var media of doc.media) {\n      if ((0, import_types.isObject)(media) && typeof media.url === \"string\" && typeof media.contentType === \"string\") {\n        if (media.contentType?.startsWith(\"image/\")) {\n          if (media.url.startsWith(\"http\") || media.url.startsWith(\"gs://\")) {\n            instance.image = {\n              gcsUri: media.url,\n              mimeType: media.contentType\n            };\n          } else {\n            instance.image = {\n              bytesBase64Encoded: media.url,\n              mimeType: media.contentType\n            };\n          }\n        } else if (media.contentType.startsWith(\"video/\")) {\n          if (media.url.startsWith(\"http\") || media.url.startsWith(\"gs://\")) {\n            instance.video = {\n              gcsUri: media.url\n            };\n          } else {\n            instance.video = {\n              bytesBase64Encoded: media.url\n            };\n          }\n          if (instance.video && doc.metadata && doc.metadata.videoSegmentConfig) {\n            instance.video.videoSegmentConfig = doc.metadata.videoSegmentConfig;\n          }\n        } else {\n          throw new Error(`Unsupported contentType: '${media.contentType}`);\n        }\n      } else {\n        throw new Error(\"Invalid media specified.\");\n      }\n    }\n  } else {\n    instance = {\n      content: doc.text,\n      task_type: options?.taskType,\n      title: options?.title\n    };\n  }\n  return instance;\n}\nfunction toEmbeddingResult(prediction) {\n  if ((0, import_types.isMultimodalEmbeddingPrediction)(prediction)) {\n    const eArray = [];\n    if (prediction.imageEmbedding?.length) {\n      const imageResult = {\n        embedding: prediction.imageEmbedding,\n        metadata: { embedType: \"imageEmbedding\" }\n      };\n      eArray.push(imageResult);\n    }\n    if (prediction.textEmbedding?.length) {\n      const textResult = {\n        embedding: prediction.textEmbedding,\n        metadata: { embedType: \"textEmbedding\" }\n      };\n      eArray.push(textResult);\n    }\n    if (prediction.videoEmbeddings?.length) {\n      for (const ve of prediction.videoEmbeddings) {\n        if (ve.embedding?.length) {\n          const { embedding, ...metadata } = ve;\n          metadata.embedType = \"videoEmbedding\";\n          const videoResult = {\n            embedding,\n            metadata\n          };\n          eArray.push(videoResult);\n        }\n      }\n    }\n    return eArray;\n  } else {\n    return [\n      {\n        embedding: prediction.embeddings.values\n      }\n    ];\n  }\n}\nfunction isMultiModalEmbedder(embedder) {\n  if (embedder.config?.multimodal) {\n    return true;\n  }\n  const input = embedder.info?.supports?.input || \"\";\n  return input.includes(\"text\") && input.includes(\"image\") || false;\n}\nconst TEST_ONLY = { KNOWN_MODELS };\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=embedder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2dvb2dsZS1nZW5haS9saWIvdmVydGV4YWkvZW1iZWRkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsbUVBQVE7QUFDcEMsc0JBQXNCLG1CQUFPLENBQUMsK0VBQWlCO0FBQy9DLG9CQUFvQixtQkFBTyxDQUFDLG1HQUFhO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLGlHQUFZO0FBQ3ZDLG1CQUFtQixtQkFBTyxDQUFDLGlHQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGNBQWM7QUFDZCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsR0FBRztBQUNIO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHVEQUF1RCxrQkFBa0I7QUFDekU7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLE1BQU0sQ0FPTDtBQUNEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEtSYW1hY2hhXFxEb2N1bWVudHNcXFN1c3RBSW5leCBHSXQgQ29kZVxcbm9kZV9tb2R1bGVzXFxAZ2Vua2l0LWFpXFxnb29nbGUtZ2VuYWlcXGxpYlxcdmVydGV4YWlcXGVtYmVkZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBlbWJlZGRlcl9leHBvcnRzID0ge307XG5fX2V4cG9ydChlbWJlZGRlcl9leHBvcnRzLCB7XG4gIEVtYmVkZGluZ0NvbmZpZ1NjaGVtYTogKCkgPT4gRW1iZWRkaW5nQ29uZmlnU2NoZW1hLFxuICBLTk9XTl9NT0RFTFM6ICgpID0+IEtOT1dOX01PREVMUyxcbiAgVEVTVF9PTkxZOiAoKSA9PiBURVNUX09OTFksXG4gIGRlZmluZUVtYmVkZGVyOiAoKSA9PiBkZWZpbmVFbWJlZGRlcixcbiAgZGVmaW5lS25vd25Nb2RlbHM6ICgpID0+IGRlZmluZUtub3duTW9kZWxzLFxuICBtb2RlbDogKCkgPT4gbW9kZWxcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoZW1iZWRkZXJfZXhwb3J0cyk7XG52YXIgaW1wb3J0X2dlbmtpdCA9IHJlcXVpcmUoXCJnZW5raXRcIik7XG52YXIgaW1wb3J0X2VtYmVkZGVyID0gcmVxdWlyZShcImdlbmtpdC9lbWJlZGRlclwiKTtcbnZhciBpbXBvcnRfY2xpZW50ID0gcmVxdWlyZShcIi4vY2xpZW50LmpzXCIpO1xudmFyIGltcG9ydF90eXBlcyA9IHJlcXVpcmUoXCIuL3R5cGVzLmpzXCIpO1xudmFyIGltcG9ydF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuY29uc3QgRW1iZWRkaW5nQ29uZmlnU2NoZW1hID0gaW1wb3J0X2dlbmtpdC56Lm9iamVjdCh7XG4gIC8qKlxuICAgKiBUaGUgYHRhc2tfdHlwZWAgcGFyYW1ldGVyIGlzIGRlZmluZWQgYXMgdGhlIGludGVuZGVkIGRvd25zdHJlYW0gYXBwbGljYXRpb25cbiAgICogdG8gaGVscCB0aGUgbW9kZWwgcHJvZHVjZSBiZXR0ZXIgcXVhbGl0eSBlbWJlZGRpbmdzLlxuICAgKiovXG4gIHRhc2tUeXBlOiBpbXBvcnRfdHlwZXMuVGFza1R5cGVTY2hlbWEub3B0aW9uYWwoKSxcbiAgdGl0bGU6IGltcG9ydF9nZW5raXQuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBsb2NhdGlvbjogaW1wb3J0X2dlbmtpdC56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIHZlcnNpb246IGltcG9ydF9nZW5raXQuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAvKipcbiAgICogVGhlIGBvdXRwdXREaW1lbnNpb25hbGl0eWAgcGFyYW1ldGVyIGFsbG93cyB5b3UgdG8gc3BlY2lmeSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgdGhlIGVtYmVkZGluZyBvdXRwdXQuXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSBtb2RlbCBnZW5lcmF0ZXMgZW1iZWRkaW5ncyB3aXRoIDc2OCBkaW1lbnNpb25zLlxuICAgKiBCeSBzZWxlY3RpbmcgYSBzbWFsbGVyIG91dHB1dCBkaW1lbnNpb25hbGl0eSwgdXNlcnMgY2FuIHNhdmUgbWVtb3J5IGFuZCBzdG9yYWdlIHNwYWNlLCBsZWFkaW5nIHRvIG1vcmUgZWZmaWNpZW50IGNvbXB1dGF0aW9ucy5cbiAgICoqL1xuICBvdXRwdXREaW1lbnNpb25hbGl0eTogaW1wb3J0X2dlbmtpdC56Lm51bWJlcigpLm1pbigxKS5vcHRpb25hbCgpLFxuICAvKipcbiAgICogRm9yIG5ld2x5IHJlbGVhc2VkIGVtYmVkZGVycyB0aGlzIHBhcmFtZXRlciBwcm92aWRlcyBhIGhpbnQgZm9yIHRoZSBwcm9wZXJcbiAgICogd2F5IHRvIGNhbGwgdGhlIGVtYmVkZGVyLiAoTXVsdGltb2RhbCBlbWJlZGRlcnMgaGF2ZSBhIGRpZmZlcmVudCByZXF1ZXN0XG4gICAqIHN0cnVjdHVyZSB0aGFuIG5vbi1tdWx0aW1vZGFsIGVtYmVkZGVycykuXG4gICAqIEZvciB3ZWxsLWtub3duIGVtYmVkZGVycywgdGhpcyB2YWx1ZSB3aWxsIGJlIGlnbm9yZWQgc2luY2Ugd2Ugd2lsbCBhbHJlYWR5XG4gICAqIGtub3cgaWYgaXQncyBtdWx0aW1vZGFsIG9yIG5vdC5cbiAgICovXG4gIG11bHRpbW9kYWw6IGltcG9ydF9nZW5raXQuei5ib29sZWFuKCkub3B0aW9uYWwoKVxufSkucGFzc3Rocm91Z2goKTtcbmZ1bmN0aW9uIGNvbW1vblJlZihuYW1lLCBpbmZvLCBjb25maWdTY2hlbWEgPSBFbWJlZGRpbmdDb25maWdTY2hlbWEpIHtcbiAgcmV0dXJuICgwLCBpbXBvcnRfZW1iZWRkZXIuZW1iZWRkZXJSZWYpKHtcbiAgICBuYW1lOiBgdmVydGV4YWkvJHtuYW1lfWAsXG4gICAgY29uZmlnU2NoZW1hLFxuICAgIGluZm86IGluZm8gPz8ge1xuICAgICAgZGltZW5zaW9uczogNzY4LFxuICAgICAgc3VwcG9ydHM6IHtcbiAgICAgICAgaW5wdXQ6IFtcInRleHRcIl1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuY29uc3QgR0VORVJJQ19URVhUX01PREVMID0gY29tbW9uUmVmKFwidGV4dFwiLCB7XG4gIGRpbWVuc2lvbnM6IDMwNzIsXG4gIHN1cHBvcnRzOiB7IGlucHV0OiBbXCJ0ZXh0XCJdIH1cbn0pO1xuY29uc3QgR0VORVJJQ19NVUxUSU1PREFMX01PREVMID0gY29tbW9uUmVmKFwibXVsdGltb2RhbFwiLCB7XG4gIGRpbWVuc2lvbnM6IDc2OCxcbiAgc3VwcG9ydHM6IHsgaW5wdXQ6IFtcInRleHRcIiwgXCJpbWFnZVwiLCBcInZpZGVvXCJdIH1cbn0pO1xuY29uc3QgS05PV05fTU9ERUxTID0ge1xuICBcInRleHQtZW1iZWRkaW5nLTAwNVwiOiBjb21tb25SZWYoXCJ0ZXh0LWVtYmVkZGluZy0wMDVcIiksXG4gIFwidGV4dC1tdWx0aWxpbmd1YWwtZW1iZWRkaW5nLTAwMlwiOiBjb21tb25SZWYoXG4gICAgXCJ0ZXh0LW11bHRpbGluZ3VhbC1lbWJlZGRpbmctMDAyXCJcbiAgKSxcbiAgXCJtdWx0aW1vZGFsZW1iZWRkaW5nQDAwMVwiOiBjb21tb25SZWYoXCJtdWx0aW1vZGFsZW1iZWRkaW5nQDAwMVwiLCB7XG4gICAgZGltZW5zaW9uczogNzY4LFxuICAgIHN1cHBvcnRzOiB7IGlucHV0OiBbXCJ0ZXh0XCIsIFwiaW1hZ2VcIiwgXCJ2aWRlb1wiXSB9XG4gIH0pLFxuICBcImdlbWluaS1lbWJlZGRpbmctMDAxXCI6IGNvbW1vblJlZihcImdlbWluaS1lbWJlZGRpbmctMDAxXCIsIHtcbiAgICBkaW1lbnNpb25zOiAzMDcyLFxuICAgIHN1cHBvcnRzOiB7IGlucHV0OiBbXCJ0ZXh0XCJdIH1cbiAgfSlcbn07XG5mdW5jdGlvbiBtb2RlbCh2ZXJzaW9uLCBjb25maWcgPSB7fSkge1xuICBjb25zdCBuYW1lID0gKDAsIGltcG9ydF91dGlscy5jaGVja01vZGVsTmFtZSkodmVyc2lvbik7XG4gIGlmIChLTk9XTl9NT0RFTFNbbmFtZV0pIHtcbiAgICByZXR1cm4gKDAsIGltcG9ydF9lbWJlZGRlci5lbWJlZGRlclJlZikoe1xuICAgICAgbmFtZTogYHZlcnRleGFpLyR7bmFtZX1gLFxuICAgICAgY29uZmlnU2NoZW1hOiBFbWJlZGRpbmdDb25maWdTY2hlbWEsXG4gICAgICBjb25maWcsXG4gICAgICBpbmZvOiB7XG4gICAgICAgIC4uLktOT1dOX01PREVMU1tuYW1lXS5pbmZvXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaWYgKGNvbmZpZy5tdWx0aW1vZGFsKSB7XG4gICAgcmV0dXJuICgwLCBpbXBvcnRfZW1iZWRkZXIuZW1iZWRkZXJSZWYpKHtcbiAgICAgIG5hbWU6IGB2ZXJ0ZXhhaS8ke25hbWV9YCxcbiAgICAgIGNvbmZpZ1NjaGVtYTogRW1iZWRkaW5nQ29uZmlnU2NoZW1hLFxuICAgICAgY29uZmlnLFxuICAgICAgaW5mbzoge1xuICAgICAgICAuLi5HRU5FUklDX01VTFRJTU9EQUxfTU9ERUwuaW5mb1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiAoMCwgaW1wb3J0X2VtYmVkZGVyLmVtYmVkZGVyUmVmKSh7XG4gICAgbmFtZTogYHZlcnRleGFpLyR7bmFtZX1gLFxuICAgIGNvbmZpZ1NjaGVtYTogRW1iZWRkaW5nQ29uZmlnU2NoZW1hLFxuICAgIGNvbmZpZyxcbiAgICBpbmZvOiB7XG4gICAgICAuLi5HRU5FUklDX1RFWFRfTU9ERUwuaW5mb1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBkZWZpbmVLbm93bk1vZGVscyhhaSwgY2xpZW50T3B0aW9ucywgcGx1Z2luT3B0aW9ucykge1xuICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoS05PV05fTU9ERUxTKSkge1xuICAgIGRlZmluZUVtYmVkZGVyKGFpLCBuYW1lLCBjbGllbnRPcHRpb25zLCBwbHVnaW5PcHRpb25zKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVmaW5lRW1iZWRkZXIoYWksIG5hbWUsIGNsaWVudE9wdGlvbnMsIHBsdWdpbk9wdGlvbnMpIHtcbiAgY29uc3QgcmVmID0gbW9kZWwobmFtZSk7XG4gIHJldHVybiBhaS5kZWZpbmVFbWJlZGRlcihcbiAgICB7XG4gICAgICBuYW1lOiByZWYubmFtZSxcbiAgICAgIGNvbmZpZ1NjaGVtYTogcmVmLmNvbmZpZ1NjaGVtYSxcbiAgICAgIGluZm86IHJlZi5pbmZvXG4gICAgfSxcbiAgICBhc3luYyAoaW5wdXQsIG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IGVtYmVkQ29udGVudFJlcXVlc3QgPSB7XG4gICAgICAgIGluc3RhbmNlczogaW5wdXQubWFwKFxuICAgICAgICAgIChkb2MpID0+IHRvRW1iZWRkaW5nSW5zdGFuY2UocmVmLCBkb2MsIG9wdGlvbnMpXG4gICAgICAgICksXG4gICAgICAgIHBhcmFtZXRlcnM6IHsgb3V0cHV0RGltZW5zaW9uYWxpdHk6IG9wdGlvbnM/Lm91dHB1dERpbWVuc2lvbmFsaXR5IH1cbiAgICAgIH07XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0ICgwLCBpbXBvcnRfY2xpZW50LmVtYmVkQ29udGVudCkoXG4gICAgICAgICgwLCBpbXBvcnRfdXRpbHMuZXh0cmFjdFZlcnNpb24pKHJlZiksXG4gICAgICAgIGVtYmVkQ29udGVudFJlcXVlc3QsXG4gICAgICAgIGNsaWVudE9wdGlvbnNcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbWJlZGRpbmdzOiByZXNwb25zZS5wcmVkaWN0aW9ucy5tYXAodG9FbWJlZGRpbmdSZXN1bHQpLnJlZHVjZSgoYWNjdW11bGF0b3IsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yLmNvbmNhdCh2YWx1ZSk7XG4gICAgICAgIH0sIFtdKVxuICAgICAgfTtcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiB0b0VtYmVkZGluZ0luc3RhbmNlKGVtYmVkZGVyLCBkb2MsIG9wdGlvbnMpIHtcbiAgbGV0IGluc3RhbmNlO1xuICBpZiAoaXNNdWx0aU1vZGFsRW1iZWRkZXIoZW1iZWRkZXIpIHx8IGVtYmVkZGVyLmNvbmZpZz8ubXVsdGltb2RhbCB8fCBvcHRpb25zPy5tdWx0aW1vZGFsKSB7XG4gICAgaW5zdGFuY2UgPSB7fTtcbiAgICBpZiAoZG9jLnRleHQpIHtcbiAgICAgIGluc3RhbmNlLnRleHQgPSBkb2MudGV4dDtcbiAgICB9XG4gICAgZm9yICh2YXIgbWVkaWEgb2YgZG9jLm1lZGlhKSB7XG4gICAgICBpZiAoKDAsIGltcG9ydF90eXBlcy5pc09iamVjdCkobWVkaWEpICYmIHR5cGVvZiBtZWRpYS51cmwgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG1lZGlhLmNvbnRlbnRUeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChtZWRpYS5jb250ZW50VHlwZT8uc3RhcnRzV2l0aChcImltYWdlL1wiKSkge1xuICAgICAgICAgIGlmIChtZWRpYS51cmwuc3RhcnRzV2l0aChcImh0dHBcIikgfHwgbWVkaWEudXJsLnN0YXJ0c1dpdGgoXCJnczovL1wiKSkge1xuICAgICAgICAgICAgaW5zdGFuY2UuaW1hZ2UgPSB7XG4gICAgICAgICAgICAgIGdjc1VyaTogbWVkaWEudXJsLFxuICAgICAgICAgICAgICBtaW1lVHlwZTogbWVkaWEuY29udGVudFR5cGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluc3RhbmNlLmltYWdlID0ge1xuICAgICAgICAgICAgICBieXRlc0Jhc2U2NEVuY29kZWQ6IG1lZGlhLnVybCxcbiAgICAgICAgICAgICAgbWltZVR5cGU6IG1lZGlhLmNvbnRlbnRUeXBlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtZWRpYS5jb250ZW50VHlwZS5zdGFydHNXaXRoKFwidmlkZW8vXCIpKSB7XG4gICAgICAgICAgaWYgKG1lZGlhLnVybC5zdGFydHNXaXRoKFwiaHR0cFwiKSB8fCBtZWRpYS51cmwuc3RhcnRzV2l0aChcImdzOi8vXCIpKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS52aWRlbyA9IHtcbiAgICAgICAgICAgICAgZ2NzVXJpOiBtZWRpYS51cmxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnZpZGVvID0ge1xuICAgICAgICAgICAgICBieXRlc0Jhc2U2NEVuY29kZWQ6IG1lZGlhLnVybFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluc3RhbmNlLnZpZGVvICYmIGRvYy5tZXRhZGF0YSAmJiBkb2MubWV0YWRhdGEudmlkZW9TZWdtZW50Q29uZmlnKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS52aWRlby52aWRlb1NlZ21lbnRDb25maWcgPSBkb2MubWV0YWRhdGEudmlkZW9TZWdtZW50Q29uZmlnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbnRlbnRUeXBlOiAnJHttZWRpYS5jb250ZW50VHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtZWRpYSBzcGVjaWZpZWQuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpbnN0YW5jZSA9IHtcbiAgICAgIGNvbnRlbnQ6IGRvYy50ZXh0LFxuICAgICAgdGFza190eXBlOiBvcHRpb25zPy50YXNrVHlwZSxcbiAgICAgIHRpdGxlOiBvcHRpb25zPy50aXRsZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gdG9FbWJlZGRpbmdSZXN1bHQocHJlZGljdGlvbikge1xuICBpZiAoKDAsIGltcG9ydF90eXBlcy5pc011bHRpbW9kYWxFbWJlZGRpbmdQcmVkaWN0aW9uKShwcmVkaWN0aW9uKSkge1xuICAgIGNvbnN0IGVBcnJheSA9IFtdO1xuICAgIGlmIChwcmVkaWN0aW9uLmltYWdlRW1iZWRkaW5nPy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGltYWdlUmVzdWx0ID0ge1xuICAgICAgICBlbWJlZGRpbmc6IHByZWRpY3Rpb24uaW1hZ2VFbWJlZGRpbmcsXG4gICAgICAgIG1ldGFkYXRhOiB7IGVtYmVkVHlwZTogXCJpbWFnZUVtYmVkZGluZ1wiIH1cbiAgICAgIH07XG4gICAgICBlQXJyYXkucHVzaChpbWFnZVJlc3VsdCk7XG4gICAgfVxuICAgIGlmIChwcmVkaWN0aW9uLnRleHRFbWJlZGRpbmc/Lmxlbmd0aCkge1xuICAgICAgY29uc3QgdGV4dFJlc3VsdCA9IHtcbiAgICAgICAgZW1iZWRkaW5nOiBwcmVkaWN0aW9uLnRleHRFbWJlZGRpbmcsXG4gICAgICAgIG1ldGFkYXRhOiB7IGVtYmVkVHlwZTogXCJ0ZXh0RW1iZWRkaW5nXCIgfVxuICAgICAgfTtcbiAgICAgIGVBcnJheS5wdXNoKHRleHRSZXN1bHQpO1xuICAgIH1cbiAgICBpZiAocHJlZGljdGlvbi52aWRlb0VtYmVkZGluZ3M/Lmxlbmd0aCkge1xuICAgICAgZm9yIChjb25zdCB2ZSBvZiBwcmVkaWN0aW9uLnZpZGVvRW1iZWRkaW5ncykge1xuICAgICAgICBpZiAodmUuZW1iZWRkaW5nPy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCB7IGVtYmVkZGluZywgLi4ubWV0YWRhdGEgfSA9IHZlO1xuICAgICAgICAgIG1ldGFkYXRhLmVtYmVkVHlwZSA9IFwidmlkZW9FbWJlZGRpbmdcIjtcbiAgICAgICAgICBjb25zdCB2aWRlb1Jlc3VsdCA9IHtcbiAgICAgICAgICAgIGVtYmVkZGluZyxcbiAgICAgICAgICAgIG1ldGFkYXRhXG4gICAgICAgICAgfTtcbiAgICAgICAgICBlQXJyYXkucHVzaCh2aWRlb1Jlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVBcnJheTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICBlbWJlZGRpbmc6IHByZWRpY3Rpb24uZW1iZWRkaW5ncy52YWx1ZXNcbiAgICAgIH1cbiAgICBdO1xuICB9XG59XG5mdW5jdGlvbiBpc011bHRpTW9kYWxFbWJlZGRlcihlbWJlZGRlcikge1xuICBpZiAoZW1iZWRkZXIuY29uZmlnPy5tdWx0aW1vZGFsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgaW5wdXQgPSBlbWJlZGRlci5pbmZvPy5zdXBwb3J0cz8uaW5wdXQgfHwgXCJcIjtcbiAgcmV0dXJuIGlucHV0LmluY2x1ZGVzKFwidGV4dFwiKSAmJiBpbnB1dC5pbmNsdWRlcyhcImltYWdlXCIpIHx8IGZhbHNlO1xufVxuY29uc3QgVEVTVF9PTkxZID0geyBLTk9XTl9NT0RFTFMgfTtcbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBFbWJlZGRpbmdDb25maWdTY2hlbWEsXG4gIEtOT1dOX01PREVMUyxcbiAgVEVTVF9PTkxZLFxuICBkZWZpbmVFbWJlZGRlcixcbiAgZGVmaW5lS25vd25Nb2RlbHMsXG4gIG1vZGVsXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVtYmVkZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/embedder.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/gemini.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@genkit-ai/google-genai/lib/vertexai/gemini.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar gemini_exports = {};\n__export(gemini_exports, {\n  GENERIC_MODEL: () => GENERIC_MODEL,\n  GeminiConfigSchema: () => GeminiConfigSchema,\n  KNOWN_MODELS: () => KNOWN_MODELS,\n  SafetySettingsSchema: () => SafetySettingsSchema,\n  TEST_ONLY: () => TEST_ONLY,\n  defineKnownModels: () => defineKnownModels,\n  defineModel: () => defineModel,\n  isGeminiModelName: () => isGeminiModelName,\n  listActions: () => listActions,\n  model: () => model\n});\nmodule.exports = __toCommonJS(gemini_exports);\nvar import_genkit = __webpack_require__(/*! genkit */ \"(action-browser)/./node_modules/genkit/lib/index.js\");\nvar import_model = __webpack_require__(/*! genkit/model */ \"(action-browser)/./node_modules/genkit/lib/model.js\");\nvar import_middleware = __webpack_require__(/*! genkit/model/middleware */ \"(action-browser)/./node_modules/genkit/lib/middleware.js\");\nvar import_tracing = __webpack_require__(/*! genkit/tracing */ \"(action-browser)/./node_modules/genkit/lib/tracing.js\");\nvar import_converters = __webpack_require__(/*! ../common/converters.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/common/converters.js\");\nvar import_client = __webpack_require__(/*! ./client.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/client.js\");\nvar import_converters2 = __webpack_require__(/*! ./converters.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/converters.js\");\nvar import_utils = __webpack_require__(/*! ./utils.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/utils.js\");\nconst SafetySettingsSchema = import_genkit.z.object({\n  category: import_genkit.z.enum([\n    /** The harm category is unspecified. */\n    \"HARM_CATEGORY_UNSPECIFIED\",\n    /** The harm category is hate speech. */\n    \"HARM_CATEGORY_HATE_SPEECH\",\n    /** The harm category is dangerous content. */\n    \"HARM_CATEGORY_DANGEROUS_CONTENT\",\n    /** The harm category is harassment. */\n    \"HARM_CATEGORY_HARASSMENT\",\n    /** The harm category is sexually explicit content. */\n    \"HARM_CATEGORY_SEXUALLY_EXPLICIT\"\n  ]),\n  threshold: import_genkit.z.enum([\n    \"BLOCK_LOW_AND_ABOVE\",\n    \"BLOCK_MEDIUM_AND_ABOVE\",\n    \"BLOCK_ONLY_HIGH\",\n    \"BLOCK_NONE\"\n  ])\n});\nconst VertexRetrievalSchema = import_genkit.z.object({\n  datastore: import_genkit.z.object({\n    projectId: import_genkit.z.string().describe(\"Google Cloud Project ID.\").optional(),\n    location: import_genkit.z.string().describe(\"Google Cloud region e.g. us-central1.\").optional(),\n    dataStoreId: import_genkit.z.string().describe(\n      'The data store id, when project id and location are provided as separate options. Alternatively, the full path to the data store should be provided in the form: \"projects/{project}/locations/{location}/collections/default_collection/dataStores/{data_store}\".'\n    )\n  }).describe(\"Vertex AI Search data store details\"),\n  disableAttribution: import_genkit.z.boolean().describe(\n    \"Disable using the search data in detecting grounding attribution. This does not affect how the result is given to the model for generation.\"\n  ).optional()\n});\nconst GoogleSearchRetrievalSchema = import_genkit.z.object({\n  disableAttribution: import_genkit.z.boolean().describe(\n    \"Disable using the search data in detecting grounding attribution. This does not affect how the result is given to the model for generation.\"\n  ).optional()\n});\nconst GeminiConfigSchema = import_model.GenerationCommonConfigSchema.extend({\n  apiKey: import_genkit.z.string().describe(\"Overrides the plugin-configured API key, if specified.\").optional(),\n  labels: import_genkit.z.record(import_genkit.z.string()).optional().describe(\"Key-value labels to attach to the request for cost tracking.\"),\n  temperature: import_genkit.z.number().min(0).max(2).describe(\n    import_model.GenerationCommonConfigDescriptions.temperature + \" The default value is 1.0.\"\n  ).optional(),\n  topP: import_genkit.z.number().min(0).max(1).describe(\n    import_model.GenerationCommonConfigDescriptions.topP + \" The default value is 0.95.\"\n  ).optional(),\n  location: import_genkit.z.string().describe(\"Google Cloud region e.g. us-central1.\").optional(),\n  /**\n   * Safety filter settings. See: https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/configure-safety-filters#configurable-filters\n   *\n   * E.g.\n   *\n   * ```js\n   * config: {\n   *   safetySettings: [\n   *     {\n   *       category: 'HARM_CATEGORY_HATE_SPEECH',\n   *       threshold: 'BLOCK_LOW_AND_ABOVE',\n   *     },\n   *     {\n   *       category: 'HARM_CATEGORY_DANGEROUS_CONTENT',\n   *       threshold: 'BLOCK_MEDIUM_AND_ABOVE',\n   *     },\n   *     {\n   *       category: 'HARM_CATEGORY_HARASSMENT',\n   *       threshold: 'BLOCK_ONLY_HIGH',\n   *     },\n   *     {\n   *       category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',\n   *       threshold: 'BLOCK_NONE',\n   *     },\n   *   ],\n   * }\n   * ```\n   */\n  safetySettings: import_genkit.z.array(SafetySettingsSchema).describe(\n    \"Adjust how likely you are to see responses that could be harmful. Content is blocked based on the probability that it is harmful.\"\n  ).optional(),\n  /**\n   * Vertex retrieval options.\n   *\n   * E.g.\n   *\n   * ```js\n   *   config: {\n   *     vertexRetrieval: {\n   *       datastore: {\n   *         projectId: 'your-cloud-project',\n   *         location: 'us-central1',\n   *         collection: 'your-collection',\n   *       },\n   *       disableAttribution: true,\n   *     }\n   *   }\n   * ```\n   */\n  vertexRetrieval: VertexRetrievalSchema.describe(\n    \"Retrieve from Vertex AI Search data store for grounding generative responses.\"\n  ).optional(),\n  /**\n   * Google Search retrieval options.\n   *\n   * ```js\n   *   config: {\n   *     googleSearchRetrieval: {\n   *       disableAttribution: true,\n   *     }\n   *   }\n   * ```\n   */\n  googleSearchRetrieval: GoogleSearchRetrievalSchema.describe(\n    \"Retrieve public web data for grounding, powered by Google Search.\"\n  ).optional(),\n  /**\n   * Function calling options.\n   *\n   * E.g. forced tool call:\n   *\n   * ```js\n   *   config: {\n   *     functionCallingConfig: {\n   *       mode: 'ANY',\n   *     }\n   *   }\n   * ```\n   */\n  functionCallingConfig: import_genkit.z.object({\n    mode: import_genkit.z.enum([\"MODE_UNSPECIFIED\", \"AUTO\", \"ANY\", \"NONE\"]).optional(),\n    allowedFunctionNames: import_genkit.z.array(import_genkit.z.string()).optional()\n  }).describe(\n    \"Controls how the model uses the provided tools (function declarations). With AUTO (Default) mode, the model decides whether to generate a natural language response or suggest a function call based on the prompt and context. With ANY, the model is constrained to always predict a function call and guarantee function schema adherence. With NONE, the model is prohibited from making function calls.\"\n  ).optional(),\n  thinkingConfig: import_genkit.z.object({\n    includeThoughts: import_genkit.z.boolean().describe(\n      \"Indicates whether to include thoughts in the response.If true, thoughts are returned only if the model supports thought and thoughts are available.\"\n    ).optional(),\n    thinkingBudget: import_genkit.z.number().min(0).max(24576).describe(\n      \"Indicates the thinking budget in tokens. 0 is DISABLED. -1 is AUTOMATIC. The default values and allowed ranges are model dependent. The thinking budget parameter gives the model guidance on the number of thinking tokens it can use when generating a response. A greater number of tokens is typically associated with more detailed thinking, which is needed for solving more complex tasks. \"\n    ).optional()\n  }).optional()\n}).passthrough();\nfunction commonRef(name, info, configSchema = GeminiConfigSchema) {\n  return (0, import_model.modelRef)({\n    name: `vertexai/${name}`,\n    configSchema,\n    info: info ?? {\n      supports: {\n        multiturn: true,\n        media: true,\n        tools: true,\n        toolChoice: true,\n        systemRole: true,\n        constrained: \"no-tools\"\n      }\n    }\n  });\n}\nconst GENERIC_MODEL = commonRef(\"gemini\");\nconst KNOWN_MODELS = {\n  \"gemini-2.5-flash-lite\": commonRef(\"gemini-2.5-flash-lite\"),\n  \"gemini-2.5-pro\": commonRef(\"gemini-2.5-pro\"),\n  \"gemini-2.5-flash\": commonRef(\"gemini-2.5-flash\"),\n  \"gemini-2.0-flash-001\": commonRef(\"gemini-2.0-flash-001\"),\n  \"gemini-2.0-flash\": commonRef(\"gemini-2.0-flash\"),\n  \"gemini-2.0-flash-lite\": commonRef(\"gemini-2.0-flash-lite\"),\n  \"gemini-2.0-flash-lite-001\": commonRef(\"gemini-2.0-flash-lite-001\")\n};\nfunction isGeminiModelName(value) {\n  return !!value?.startsWith(\"gemini-\") && !value.includes(\"embedding\");\n}\nfunction model(version, options = {}) {\n  const name = (0, import_utils.checkModelName)(version);\n  return (0, import_model.modelRef)({\n    name: `vertexai/${name}`,\n    config: options,\n    configSchema: GeminiConfigSchema,\n    info: {\n      ...GENERIC_MODEL.info\n    }\n  });\n}\nfunction listActions(models) {\n  const KNOWN_DECOMISSIONED_MODELS = [\n    \"gemini-pro-vision\",\n    \"gemini-pro\",\n    \"gemini-ultra\",\n    \"gemini-ultra-vision\"\n  ];\n  return models.filter(\n    (m) => isGeminiModelName((0, import_utils.modelName)(m.name)) && !KNOWN_DECOMISSIONED_MODELS.includes((0, import_utils.modelName)(m.name) || \"\")\n  ).map((m) => {\n    const ref = model(m.name);\n    return (0, import_genkit.modelActionMetadata)({\n      name: ref.name,\n      info: ref.info,\n      configSchema: ref.configSchema\n    });\n  });\n}\nfunction defineKnownModels(ai, clientOptions, pluginOptions) {\n  for (const name of Object.keys(KNOWN_MODELS)) {\n    defineModel(ai, name, clientOptions, pluginOptions);\n  }\n}\nfunction defineModel(ai, name, clientOptions, pluginOptions) {\n  const ref = model(name);\n  const middlewares = [];\n  if (ref.info?.supports?.media) {\n    middlewares.push(\n      (0, import_middleware.downloadRequestMedia)({\n        maxBytes: 1024 * 1024 * 20,\n        filter: (part) => {\n          try {\n            const url = new URL(part.media.url);\n            if (\n              // Gemini can handle these URLs\n              [\"www.youtube.com\", \"youtube.com\", \"youtu.be\"].includes(\n                url.hostname\n              )\n            )\n              return false;\n          } catch {\n          }\n          return true;\n        }\n      })\n    );\n  }\n  return ai.defineModel(\n    {\n      apiVersion: \"v2\",\n      name: ref.name,\n      ...ref.info,\n      configSchema: ref.configSchema,\n      use: middlewares\n    },\n    async (request, { streamingRequested, sendChunk, abortSignal }) => {\n      let clientOpt = { ...clientOptions, signal: abortSignal };\n      const messages = structuredClone(request.messages);\n      if (messages.length === 0) throw new Error(\"No messages provided.\");\n      let systemInstruction = void 0;\n      const systemMessage = messages.find((m) => m.role === \"system\");\n      if (systemMessage) {\n        messages.splice(messages.indexOf(systemMessage), 1);\n        systemInstruction = (0, import_converters.toGeminiSystemInstruction)(systemMessage);\n      }\n      const requestConfig = { ...request.config };\n      const {\n        apiKey: apiKeyFromConfig,\n        functionCallingConfig,\n        version: versionFromConfig,\n        googleSearchRetrieval,\n        tools: toolsFromConfig,\n        vertexRetrieval,\n        location,\n        safetySettings,\n        labels: labelsFromConfig,\n        ...restOfConfig\n      } = requestConfig;\n      if (location && clientOptions.kind != \"express\" && clientOptions.location != location) {\n        if (location == \"global\") {\n          clientOpt = {\n            kind: \"global\",\n            location: \"global\",\n            projectId: clientOptions.projectId,\n            authClient: clientOptions.authClient,\n            apiKey: clientOptions.apiKey,\n            signal: abortSignal\n          };\n        } else {\n          clientOpt = {\n            kind: \"regional\",\n            location,\n            projectId: clientOptions.projectId,\n            authClient: clientOptions.authClient,\n            apiKey: clientOptions.apiKey,\n            signal: abortSignal\n          };\n        }\n      }\n      if (clientOptions.kind == \"express\") {\n        clientOpt.apiKey = (0, import_utils.calculateApiKey)(\n          clientOptions.apiKey,\n          apiKeyFromConfig\n        );\n      } else if (apiKeyFromConfig) {\n        clientOpt.apiKey = apiKeyFromConfig;\n      }\n      const labels = (0, import_converters2.toGeminiLabels)(labelsFromConfig);\n      const tools = [];\n      if (request.tools?.length) {\n        tools.push({\n          functionDeclarations: request.tools.map(import_converters.toGeminiTool)\n        });\n      }\n      let toolConfig;\n      if (functionCallingConfig) {\n        toolConfig = {\n          functionCallingConfig: {\n            allowedFunctionNames: functionCallingConfig.allowedFunctionNames,\n            mode: (0, import_converters.toGeminiFunctionModeEnum)(functionCallingConfig.mode)\n          }\n        };\n      } else if (request.toolChoice) {\n        toolConfig = {\n          functionCallingConfig: {\n            mode: (0, import_converters.toGeminiFunctionModeEnum)(request.toolChoice)\n          }\n        };\n      }\n      const jsonMode = (request.output?.format === \"json\" || !!request.output?.schema) && tools.length === 0;\n      if (toolsFromConfig) {\n        tools.push(...toolsFromConfig);\n      }\n      if (googleSearchRetrieval) {\n        if (ref.name.startsWith(\"vertexai/gemini-1.5\")) {\n          tools.push({\n            googleSearchRetrieval\n          });\n        } else {\n          tools.push({\n            googleSearch: googleSearchRetrieval\n          });\n        }\n      }\n      if (vertexRetrieval) {\n        const _projectId = vertexRetrieval.datastore.projectId || (clientOptions.kind != \"express\" ? clientOptions.projectId : void 0);\n        const _location = vertexRetrieval.datastore.location || (clientOptions.kind == \"regional\" ? clientOptions.location : void 0);\n        const _dataStoreId = vertexRetrieval.datastore.dataStoreId;\n        if (!_projectId || !_location || !_dataStoreId) {\n          throw new import_genkit.GenkitError({\n            status: \"INVALID_ARGUMENT\",\n            message: \"projectId, location and datastoreId are required for vertexRetrieval and could not be determined from configuration\"\n          });\n        }\n        const datastore = `projects/${_projectId}/locations/${_location}/collections/default_collection/dataStores/${_dataStoreId}`;\n        tools.push({\n          retrieval: {\n            vertexAiSearch: {\n              datastore\n            },\n            disableAttribution: vertexRetrieval.disableAttribution\n          }\n        });\n      }\n      const generateContentRequest = {\n        systemInstruction,\n        generationConfig: {\n          ...restOfConfig,\n          candidateCount: request.candidates || void 0,\n          responseMimeType: jsonMode ? \"application/json\" : void 0\n        },\n        tools,\n        toolConfig,\n        safetySettings: (0, import_converters2.toGeminiSafetySettings)(safetySettings),\n        contents: messages.map((message) => (0, import_converters.toGeminiMessage)(message, ref)),\n        labels\n      };\n      const modelVersion = versionFromConfig || (0, import_utils.extractVersion)(ref);\n      if (jsonMode && request.output?.constrained) {\n        generateContentRequest.generationConfig.responseSchema = (0, import_utils.cleanSchema)(\n          request.output.schema\n        );\n      }\n      const callGemini = async () => {\n        let response;\n        if (streamingRequested) {\n          const result = await (0, import_client.generateContentStream)(\n            modelVersion,\n            generateContentRequest,\n            clientOpt\n          );\n          for await (const item of result.stream) {\n            item.candidates?.forEach(\n              (candidate) => {\n                const c = (0, import_converters.fromGeminiCandidate)(candidate);\n                sendChunk({\n                  index: c.index,\n                  content: c.message.content\n                });\n              }\n            );\n          }\n          response = await result.response;\n        } else {\n          response = await (0, import_client.generateContent)(\n            modelVersion,\n            generateContentRequest,\n            clientOpt\n          );\n        }\n        if (!response.candidates?.length) {\n          throw new import_genkit.GenkitError({\n            status: \"FAILED_PRECONDITION\",\n            message: \"No valid candidates returned.\"\n          });\n        }\n        const candidateData = response.candidates.map(\n          (c) => (0, import_converters.fromGeminiCandidate)(c)\n        );\n        return {\n          candidates: candidateData,\n          custom: response,\n          usage: {\n            ...(0, import_model.getBasicUsageStats)(request.messages, candidateData),\n            inputTokens: response.usageMetadata?.promptTokenCount,\n            outputTokens: response.usageMetadata?.candidatesTokenCount,\n            thoughtsTokens: response.usageMetadata?.thoughtsTokenCount,\n            totalTokens: response.usageMetadata?.totalTokenCount,\n            cachedContentTokens: response.usageMetadata?.cachedContentTokenCount\n          }\n        };\n      };\n      const msg = (0, import_converters.toGeminiMessage)(messages[messages.length - 1], ref);\n      return pluginOptions?.experimental_debugTraces ? await (0, import_tracing.runInNewSpan)(\n        ai.registry,\n        {\n          metadata: {\n            name: streamingRequested ? \"sendMessageStream\" : \"sendMessage\"\n          }\n        },\n        async (metadata) => {\n          metadata.input = {\n            apiEndpoint: (0, import_client.getVertexAIUrl)({\n              includeProjectAndLocation: false,\n              resourcePath: \"\",\n              clientOptions: clientOpt\n            }),\n            cache: {},\n            model: modelVersion,\n            generateContentOptions: generateContentRequest,\n            parts: msg.parts,\n            options: clientOpt\n          };\n          const response = await callGemini();\n          metadata.output = response.custom;\n          return response;\n        }\n      ) : await callGemini();\n    }\n  );\n}\nconst TEST_ONLY = { KNOWN_MODELS };\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=gemini.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2dvb2dsZS1nZW5haS9saWIvdmVydGV4YWkvZ2VtaW5pLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsbUVBQVE7QUFDcEMsbUJBQW1CLG1CQUFPLENBQUMseUVBQWM7QUFDekMsd0JBQXdCLG1CQUFPLENBQUMseUZBQXlCO0FBQ3pELHFCQUFxQixtQkFBTyxDQUFDLDZFQUFnQjtBQUM3Qyx3QkFBd0IsbUJBQU8sQ0FBQyxpSEFBeUI7QUFDekQsb0JBQW9CLG1CQUFPLENBQUMsbUdBQWE7QUFDekMseUJBQXlCLG1CQUFPLENBQUMsMkdBQWlCO0FBQ2xELG1CQUFtQixtQkFBTyxDQUFDLGlHQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtTEFBbUwsUUFBUSxZQUFZLFNBQVMsNENBQTRDLFdBQVc7QUFDdlE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHNCQUFzQiw0Q0FBNEM7QUFDbEUsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxzQ0FBc0MsV0FBVyxhQUFhLFVBQVUsNkNBQTZDLGFBQWE7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxNQUFNLENBV0w7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcZ29vZ2xlLWdlbmFpXFxsaWJcXHZlcnRleGFpXFxnZW1pbmkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIGdlbWluaV9leHBvcnRzID0ge307XG5fX2V4cG9ydChnZW1pbmlfZXhwb3J0cywge1xuICBHRU5FUklDX01PREVMOiAoKSA9PiBHRU5FUklDX01PREVMLFxuICBHZW1pbmlDb25maWdTY2hlbWE6ICgpID0+IEdlbWluaUNvbmZpZ1NjaGVtYSxcbiAgS05PV05fTU9ERUxTOiAoKSA9PiBLTk9XTl9NT0RFTFMsXG4gIFNhZmV0eVNldHRpbmdzU2NoZW1hOiAoKSA9PiBTYWZldHlTZXR0aW5nc1NjaGVtYSxcbiAgVEVTVF9PTkxZOiAoKSA9PiBURVNUX09OTFksXG4gIGRlZmluZUtub3duTW9kZWxzOiAoKSA9PiBkZWZpbmVLbm93bk1vZGVscyxcbiAgZGVmaW5lTW9kZWw6ICgpID0+IGRlZmluZU1vZGVsLFxuICBpc0dlbWluaU1vZGVsTmFtZTogKCkgPT4gaXNHZW1pbmlNb2RlbE5hbWUsXG4gIGxpc3RBY3Rpb25zOiAoKSA9PiBsaXN0QWN0aW9ucyxcbiAgbW9kZWw6ICgpID0+IG1vZGVsXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKGdlbWluaV9leHBvcnRzKTtcbnZhciBpbXBvcnRfZ2Vua2l0ID0gcmVxdWlyZShcImdlbmtpdFwiKTtcbnZhciBpbXBvcnRfbW9kZWwgPSByZXF1aXJlKFwiZ2Vua2l0L21vZGVsXCIpO1xudmFyIGltcG9ydF9taWRkbGV3YXJlID0gcmVxdWlyZShcImdlbmtpdC9tb2RlbC9taWRkbGV3YXJlXCIpO1xudmFyIGltcG9ydF90cmFjaW5nID0gcmVxdWlyZShcImdlbmtpdC90cmFjaW5nXCIpO1xudmFyIGltcG9ydF9jb252ZXJ0ZXJzID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb252ZXJ0ZXJzLmpzXCIpO1xudmFyIGltcG9ydF9jbGllbnQgPSByZXF1aXJlKFwiLi9jbGllbnQuanNcIik7XG52YXIgaW1wb3J0X2NvbnZlcnRlcnMyID0gcmVxdWlyZShcIi4vY29udmVydGVycy5qc1wiKTtcbnZhciBpbXBvcnRfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbmNvbnN0IFNhZmV0eVNldHRpbmdzU2NoZW1hID0gaW1wb3J0X2dlbmtpdC56Lm9iamVjdCh7XG4gIGNhdGVnb3J5OiBpbXBvcnRfZ2Vua2l0LnouZW51bShbXG4gICAgLyoqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIHVuc3BlY2lmaWVkLiAqL1xuICAgIFwiSEFSTV9DQVRFR09SWV9VTlNQRUNJRklFRFwiLFxuICAgIC8qKiBUaGUgaGFybSBjYXRlZ29yeSBpcyBoYXRlIHNwZWVjaC4gKi9cbiAgICBcIkhBUk1fQ0FURUdPUllfSEFURV9TUEVFQ0hcIixcbiAgICAvKiogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgZGFuZ2Vyb3VzIGNvbnRlbnQuICovXG4gICAgXCJIQVJNX0NBVEVHT1JZX0RBTkdFUk9VU19DT05URU5UXCIsXG4gICAgLyoqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGhhcmFzc21lbnQuICovXG4gICAgXCJIQVJNX0NBVEVHT1JZX0hBUkFTU01FTlRcIixcbiAgICAvKiogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgc2V4dWFsbHkgZXhwbGljaXQgY29udGVudC4gKi9cbiAgICBcIkhBUk1fQ0FURUdPUllfU0VYVUFMTFlfRVhQTElDSVRcIlxuICBdKSxcbiAgdGhyZXNob2xkOiBpbXBvcnRfZ2Vua2l0LnouZW51bShbXG4gICAgXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCIsXG4gICAgXCJCTE9DS19NRURJVU1fQU5EX0FCT1ZFXCIsXG4gICAgXCJCTE9DS19PTkxZX0hJR0hcIixcbiAgICBcIkJMT0NLX05PTkVcIlxuICBdKVxufSk7XG5jb25zdCBWZXJ0ZXhSZXRyaWV2YWxTY2hlbWEgPSBpbXBvcnRfZ2Vua2l0Lnoub2JqZWN0KHtcbiAgZGF0YXN0b3JlOiBpbXBvcnRfZ2Vua2l0Lnoub2JqZWN0KHtcbiAgICBwcm9qZWN0SWQ6IGltcG9ydF9nZW5raXQuei5zdHJpbmcoKS5kZXNjcmliZShcIkdvb2dsZSBDbG91ZCBQcm9qZWN0IElELlwiKS5vcHRpb25hbCgpLFxuICAgIGxvY2F0aW9uOiBpbXBvcnRfZ2Vua2l0Lnouc3RyaW5nKCkuZGVzY3JpYmUoXCJHb29nbGUgQ2xvdWQgcmVnaW9uIGUuZy4gdXMtY2VudHJhbDEuXCIpLm9wdGlvbmFsKCksXG4gICAgZGF0YVN0b3JlSWQ6IGltcG9ydF9nZW5raXQuei5zdHJpbmcoKS5kZXNjcmliZShcbiAgICAgICdUaGUgZGF0YSBzdG9yZSBpZCwgd2hlbiBwcm9qZWN0IGlkIGFuZCBsb2NhdGlvbiBhcmUgcHJvdmlkZWQgYXMgc2VwYXJhdGUgb3B0aW9ucy4gQWx0ZXJuYXRpdmVseSwgdGhlIGZ1bGwgcGF0aCB0byB0aGUgZGF0YSBzdG9yZSBzaG91bGQgYmUgcHJvdmlkZWQgaW4gdGhlIGZvcm06IFwicHJvamVjdHMve3Byb2plY3R9L2xvY2F0aW9ucy97bG9jYXRpb259L2NvbGxlY3Rpb25zL2RlZmF1bHRfY29sbGVjdGlvbi9kYXRhU3RvcmVzL3tkYXRhX3N0b3JlfVwiLidcbiAgICApXG4gIH0pLmRlc2NyaWJlKFwiVmVydGV4IEFJIFNlYXJjaCBkYXRhIHN0b3JlIGRldGFpbHNcIiksXG4gIGRpc2FibGVBdHRyaWJ1dGlvbjogaW1wb3J0X2dlbmtpdC56LmJvb2xlYW4oKS5kZXNjcmliZShcbiAgICBcIkRpc2FibGUgdXNpbmcgdGhlIHNlYXJjaCBkYXRhIGluIGRldGVjdGluZyBncm91bmRpbmcgYXR0cmlidXRpb24uIFRoaXMgZG9lcyBub3QgYWZmZWN0IGhvdyB0aGUgcmVzdWx0IGlzIGdpdmVuIHRvIHRoZSBtb2RlbCBmb3IgZ2VuZXJhdGlvbi5cIlxuICApLm9wdGlvbmFsKClcbn0pO1xuY29uc3QgR29vZ2xlU2VhcmNoUmV0cmlldmFsU2NoZW1hID0gaW1wb3J0X2dlbmtpdC56Lm9iamVjdCh7XG4gIGRpc2FibGVBdHRyaWJ1dGlvbjogaW1wb3J0X2dlbmtpdC56LmJvb2xlYW4oKS5kZXNjcmliZShcbiAgICBcIkRpc2FibGUgdXNpbmcgdGhlIHNlYXJjaCBkYXRhIGluIGRldGVjdGluZyBncm91bmRpbmcgYXR0cmlidXRpb24uIFRoaXMgZG9lcyBub3QgYWZmZWN0IGhvdyB0aGUgcmVzdWx0IGlzIGdpdmVuIHRvIHRoZSBtb2RlbCBmb3IgZ2VuZXJhdGlvbi5cIlxuICApLm9wdGlvbmFsKClcbn0pO1xuY29uc3QgR2VtaW5pQ29uZmlnU2NoZW1hID0gaW1wb3J0X21vZGVsLkdlbmVyYXRpb25Db21tb25Db25maWdTY2hlbWEuZXh0ZW5kKHtcbiAgYXBpS2V5OiBpbXBvcnRfZ2Vua2l0Lnouc3RyaW5nKCkuZGVzY3JpYmUoXCJPdmVycmlkZXMgdGhlIHBsdWdpbi1jb25maWd1cmVkIEFQSSBrZXksIGlmIHNwZWNpZmllZC5cIikub3B0aW9uYWwoKSxcbiAgbGFiZWxzOiBpbXBvcnRfZ2Vua2l0LnoucmVjb3JkKGltcG9ydF9nZW5raXQuei5zdHJpbmcoKSkub3B0aW9uYWwoKS5kZXNjcmliZShcIktleS12YWx1ZSBsYWJlbHMgdG8gYXR0YWNoIHRvIHRoZSByZXF1ZXN0IGZvciBjb3N0IHRyYWNraW5nLlwiKSxcbiAgdGVtcGVyYXR1cmU6IGltcG9ydF9nZW5raXQuei5udW1iZXIoKS5taW4oMCkubWF4KDIpLmRlc2NyaWJlKFxuICAgIGltcG9ydF9tb2RlbC5HZW5lcmF0aW9uQ29tbW9uQ29uZmlnRGVzY3JpcHRpb25zLnRlbXBlcmF0dXJlICsgXCIgVGhlIGRlZmF1bHQgdmFsdWUgaXMgMS4wLlwiXG4gICkub3B0aW9uYWwoKSxcbiAgdG9wUDogaW1wb3J0X2dlbmtpdC56Lm51bWJlcigpLm1pbigwKS5tYXgoMSkuZGVzY3JpYmUoXG4gICAgaW1wb3J0X21vZGVsLkdlbmVyYXRpb25Db21tb25Db25maWdEZXNjcmlwdGlvbnMudG9wUCArIFwiIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDAuOTUuXCJcbiAgKS5vcHRpb25hbCgpLFxuICBsb2NhdGlvbjogaW1wb3J0X2dlbmtpdC56LnN0cmluZygpLmRlc2NyaWJlKFwiR29vZ2xlIENsb3VkIHJlZ2lvbiBlLmcuIHVzLWNlbnRyYWwxLlwiKS5vcHRpb25hbCgpLFxuICAvKipcbiAgICogU2FmZXR5IGZpbHRlciBzZXR0aW5ncy4gU2VlOiBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vdmVydGV4LWFpL2dlbmVyYXRpdmUtYWkvZG9jcy9tdWx0aW1vZGFsL2NvbmZpZ3VyZS1zYWZldHktZmlsdGVycyNjb25maWd1cmFibGUtZmlsdGVyc1xuICAgKlxuICAgKiBFLmcuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNvbmZpZzoge1xuICAgKiAgIHNhZmV0eVNldHRpbmdzOiBbXG4gICAqICAgICB7XG4gICAqICAgICAgIGNhdGVnb3J5OiAnSEFSTV9DQVRFR09SWV9IQVRFX1NQRUVDSCcsXG4gICAqICAgICAgIHRocmVzaG9sZDogJ0JMT0NLX0xPV19BTkRfQUJPVkUnLFxuICAgKiAgICAgfSxcbiAgICogICAgIHtcbiAgICogICAgICAgY2F0ZWdvcnk6ICdIQVJNX0NBVEVHT1JZX0RBTkdFUk9VU19DT05URU5UJyxcbiAgICogICAgICAgdGhyZXNob2xkOiAnQkxPQ0tfTUVESVVNX0FORF9BQk9WRScsXG4gICAqICAgICB9LFxuICAgKiAgICAge1xuICAgKiAgICAgICBjYXRlZ29yeTogJ0hBUk1fQ0FURUdPUllfSEFSQVNTTUVOVCcsXG4gICAqICAgICAgIHRocmVzaG9sZDogJ0JMT0NLX09OTFlfSElHSCcsXG4gICAqICAgICB9LFxuICAgKiAgICAge1xuICAgKiAgICAgICBjYXRlZ29yeTogJ0hBUk1fQ0FURUdPUllfU0VYVUFMTFlfRVhQTElDSVQnLFxuICAgKiAgICAgICB0aHJlc2hvbGQ6ICdCTE9DS19OT05FJyxcbiAgICogICAgIH0sXG4gICAqICAgXSxcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIHNhZmV0eVNldHRpbmdzOiBpbXBvcnRfZ2Vua2l0LnouYXJyYXkoU2FmZXR5U2V0dGluZ3NTY2hlbWEpLmRlc2NyaWJlKFxuICAgIFwiQWRqdXN0IGhvdyBsaWtlbHkgeW91IGFyZSB0byBzZWUgcmVzcG9uc2VzIHRoYXQgY291bGQgYmUgaGFybWZ1bC4gQ29udGVudCBpcyBibG9ja2VkIGJhc2VkIG9uIHRoZSBwcm9iYWJpbGl0eSB0aGF0IGl0IGlzIGhhcm1mdWwuXCJcbiAgKS5vcHRpb25hbCgpLFxuICAvKipcbiAgICogVmVydGV4IHJldHJpZXZhbCBvcHRpb25zLlxuICAgKlxuICAgKiBFLmcuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqICAgY29uZmlnOiB7XG4gICAqICAgICB2ZXJ0ZXhSZXRyaWV2YWw6IHtcbiAgICogICAgICAgZGF0YXN0b3JlOiB7XG4gICAqICAgICAgICAgcHJvamVjdElkOiAneW91ci1jbG91ZC1wcm9qZWN0JyxcbiAgICogICAgICAgICBsb2NhdGlvbjogJ3VzLWNlbnRyYWwxJyxcbiAgICogICAgICAgICBjb2xsZWN0aW9uOiAneW91ci1jb2xsZWN0aW9uJyxcbiAgICogICAgICAgfSxcbiAgICogICAgICAgZGlzYWJsZUF0dHJpYnV0aW9uOiB0cnVlLFxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICogYGBgXG4gICAqL1xuICB2ZXJ0ZXhSZXRyaWV2YWw6IFZlcnRleFJldHJpZXZhbFNjaGVtYS5kZXNjcmliZShcbiAgICBcIlJldHJpZXZlIGZyb20gVmVydGV4IEFJIFNlYXJjaCBkYXRhIHN0b3JlIGZvciBncm91bmRpbmcgZ2VuZXJhdGl2ZSByZXNwb25zZXMuXCJcbiAgKS5vcHRpb25hbCgpLFxuICAvKipcbiAgICogR29vZ2xlIFNlYXJjaCByZXRyaWV2YWwgb3B0aW9ucy5cbiAgICpcbiAgICogYGBganNcbiAgICogICBjb25maWc6IHtcbiAgICogICAgIGdvb2dsZVNlYXJjaFJldHJpZXZhbDoge1xuICAgKiAgICAgICBkaXNhYmxlQXR0cmlidXRpb246IHRydWUsXG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKiBgYGBcbiAgICovXG4gIGdvb2dsZVNlYXJjaFJldHJpZXZhbDogR29vZ2xlU2VhcmNoUmV0cmlldmFsU2NoZW1hLmRlc2NyaWJlKFxuICAgIFwiUmV0cmlldmUgcHVibGljIHdlYiBkYXRhIGZvciBncm91bmRpbmcsIHBvd2VyZWQgYnkgR29vZ2xlIFNlYXJjaC5cIlxuICApLm9wdGlvbmFsKCksXG4gIC8qKlxuICAgKiBGdW5jdGlvbiBjYWxsaW5nIG9wdGlvbnMuXG4gICAqXG4gICAqIEUuZy4gZm9yY2VkIHRvb2wgY2FsbDpcbiAgICpcbiAgICogYGBganNcbiAgICogICBjb25maWc6IHtcbiAgICogICAgIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZzoge1xuICAgKiAgICAgICBtb2RlOiAnQU5ZJyxcbiAgICogICAgIH1cbiAgICogICB9XG4gICAqIGBgYFxuICAgKi9cbiAgZnVuY3Rpb25DYWxsaW5nQ29uZmlnOiBpbXBvcnRfZ2Vua2l0Lnoub2JqZWN0KHtcbiAgICBtb2RlOiBpbXBvcnRfZ2Vua2l0LnouZW51bShbXCJNT0RFX1VOU1BFQ0lGSUVEXCIsIFwiQVVUT1wiLCBcIkFOWVwiLCBcIk5PTkVcIl0pLm9wdGlvbmFsKCksXG4gICAgYWxsb3dlZEZ1bmN0aW9uTmFtZXM6IGltcG9ydF9nZW5raXQuei5hcnJheShpbXBvcnRfZ2Vua2l0Lnouc3RyaW5nKCkpLm9wdGlvbmFsKClcbiAgfSkuZGVzY3JpYmUoXG4gICAgXCJDb250cm9scyBob3cgdGhlIG1vZGVsIHVzZXMgdGhlIHByb3ZpZGVkIHRvb2xzIChmdW5jdGlvbiBkZWNsYXJhdGlvbnMpLiBXaXRoIEFVVE8gKERlZmF1bHQpIG1vZGUsIHRoZSBtb2RlbCBkZWNpZGVzIHdoZXRoZXIgdG8gZ2VuZXJhdGUgYSBuYXR1cmFsIGxhbmd1YWdlIHJlc3BvbnNlIG9yIHN1Z2dlc3QgYSBmdW5jdGlvbiBjYWxsIGJhc2VkIG9uIHRoZSBwcm9tcHQgYW5kIGNvbnRleHQuIFdpdGggQU5ZLCB0aGUgbW9kZWwgaXMgY29uc3RyYWluZWQgdG8gYWx3YXlzIHByZWRpY3QgYSBmdW5jdGlvbiBjYWxsIGFuZCBndWFyYW50ZWUgZnVuY3Rpb24gc2NoZW1hIGFkaGVyZW5jZS4gV2l0aCBOT05FLCB0aGUgbW9kZWwgaXMgcHJvaGliaXRlZCBmcm9tIG1ha2luZyBmdW5jdGlvbiBjYWxscy5cIlxuICApLm9wdGlvbmFsKCksXG4gIHRoaW5raW5nQ29uZmlnOiBpbXBvcnRfZ2Vua2l0Lnoub2JqZWN0KHtcbiAgICBpbmNsdWRlVGhvdWdodHM6IGltcG9ydF9nZW5raXQuei5ib29sZWFuKCkuZGVzY3JpYmUoXG4gICAgICBcIkluZGljYXRlcyB3aGV0aGVyIHRvIGluY2x1ZGUgdGhvdWdodHMgaW4gdGhlIHJlc3BvbnNlLklmIHRydWUsIHRob3VnaHRzIGFyZSByZXR1cm5lZCBvbmx5IGlmIHRoZSBtb2RlbCBzdXBwb3J0cyB0aG91Z2h0IGFuZCB0aG91Z2h0cyBhcmUgYXZhaWxhYmxlLlwiXG4gICAgKS5vcHRpb25hbCgpLFxuICAgIHRoaW5raW5nQnVkZ2V0OiBpbXBvcnRfZ2Vua2l0LnoubnVtYmVyKCkubWluKDApLm1heCgyNDU3NikuZGVzY3JpYmUoXG4gICAgICBcIkluZGljYXRlcyB0aGUgdGhpbmtpbmcgYnVkZ2V0IGluIHRva2Vucy4gMCBpcyBESVNBQkxFRC4gLTEgaXMgQVVUT01BVElDLiBUaGUgZGVmYXVsdCB2YWx1ZXMgYW5kIGFsbG93ZWQgcmFuZ2VzIGFyZSBtb2RlbCBkZXBlbmRlbnQuIFRoZSB0aGlua2luZyBidWRnZXQgcGFyYW1ldGVyIGdpdmVzIHRoZSBtb2RlbCBndWlkYW5jZSBvbiB0aGUgbnVtYmVyIG9mIHRoaW5raW5nIHRva2VucyBpdCBjYW4gdXNlIHdoZW4gZ2VuZXJhdGluZyBhIHJlc3BvbnNlLiBBIGdyZWF0ZXIgbnVtYmVyIG9mIHRva2VucyBpcyB0eXBpY2FsbHkgYXNzb2NpYXRlZCB3aXRoIG1vcmUgZGV0YWlsZWQgdGhpbmtpbmcsIHdoaWNoIGlzIG5lZWRlZCBmb3Igc29sdmluZyBtb3JlIGNvbXBsZXggdGFza3MuIFwiXG4gICAgKS5vcHRpb25hbCgpXG4gIH0pLm9wdGlvbmFsKClcbn0pLnBhc3N0aHJvdWdoKCk7XG5mdW5jdGlvbiBjb21tb25SZWYobmFtZSwgaW5mbywgY29uZmlnU2NoZW1hID0gR2VtaW5pQ29uZmlnU2NoZW1hKSB7XG4gIHJldHVybiAoMCwgaW1wb3J0X21vZGVsLm1vZGVsUmVmKSh7XG4gICAgbmFtZTogYHZlcnRleGFpLyR7bmFtZX1gLFxuICAgIGNvbmZpZ1NjaGVtYSxcbiAgICBpbmZvOiBpbmZvID8/IHtcbiAgICAgIHN1cHBvcnRzOiB7XG4gICAgICAgIG11bHRpdHVybjogdHJ1ZSxcbiAgICAgICAgbWVkaWE6IHRydWUsXG4gICAgICAgIHRvb2xzOiB0cnVlLFxuICAgICAgICB0b29sQ2hvaWNlOiB0cnVlLFxuICAgICAgICBzeXN0ZW1Sb2xlOiB0cnVlLFxuICAgICAgICBjb25zdHJhaW5lZDogXCJuby10b29sc1wiXG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmNvbnN0IEdFTkVSSUNfTU9ERUwgPSBjb21tb25SZWYoXCJnZW1pbmlcIik7XG5jb25zdCBLTk9XTl9NT0RFTFMgPSB7XG4gIFwiZ2VtaW5pLTIuNS1mbGFzaC1saXRlXCI6IGNvbW1vblJlZihcImdlbWluaS0yLjUtZmxhc2gtbGl0ZVwiKSxcbiAgXCJnZW1pbmktMi41LXByb1wiOiBjb21tb25SZWYoXCJnZW1pbmktMi41LXByb1wiKSxcbiAgXCJnZW1pbmktMi41LWZsYXNoXCI6IGNvbW1vblJlZihcImdlbWluaS0yLjUtZmxhc2hcIiksXG4gIFwiZ2VtaW5pLTIuMC1mbGFzaC0wMDFcIjogY29tbW9uUmVmKFwiZ2VtaW5pLTIuMC1mbGFzaC0wMDFcIiksXG4gIFwiZ2VtaW5pLTIuMC1mbGFzaFwiOiBjb21tb25SZWYoXCJnZW1pbmktMi4wLWZsYXNoXCIpLFxuICBcImdlbWluaS0yLjAtZmxhc2gtbGl0ZVwiOiBjb21tb25SZWYoXCJnZW1pbmktMi4wLWZsYXNoLWxpdGVcIiksXG4gIFwiZ2VtaW5pLTIuMC1mbGFzaC1saXRlLTAwMVwiOiBjb21tb25SZWYoXCJnZW1pbmktMi4wLWZsYXNoLWxpdGUtMDAxXCIpXG59O1xuZnVuY3Rpb24gaXNHZW1pbmlNb2RlbE5hbWUodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWU/LnN0YXJ0c1dpdGgoXCJnZW1pbmktXCIpICYmICF2YWx1ZS5pbmNsdWRlcyhcImVtYmVkZGluZ1wiKTtcbn1cbmZ1bmN0aW9uIG1vZGVsKHZlcnNpb24sIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBuYW1lID0gKDAsIGltcG9ydF91dGlscy5jaGVja01vZGVsTmFtZSkodmVyc2lvbik7XG4gIHJldHVybiAoMCwgaW1wb3J0X21vZGVsLm1vZGVsUmVmKSh7XG4gICAgbmFtZTogYHZlcnRleGFpLyR7bmFtZX1gLFxuICAgIGNvbmZpZzogb3B0aW9ucyxcbiAgICBjb25maWdTY2hlbWE6IEdlbWluaUNvbmZpZ1NjaGVtYSxcbiAgICBpbmZvOiB7XG4gICAgICAuLi5HRU5FUklDX01PREVMLmluZm9cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbGlzdEFjdGlvbnMobW9kZWxzKSB7XG4gIGNvbnN0IEtOT1dOX0RFQ09NSVNTSU9ORURfTU9ERUxTID0gW1xuICAgIFwiZ2VtaW5pLXByby12aXNpb25cIixcbiAgICBcImdlbWluaS1wcm9cIixcbiAgICBcImdlbWluaS11bHRyYVwiLFxuICAgIFwiZ2VtaW5pLXVsdHJhLXZpc2lvblwiXG4gIF07XG4gIHJldHVybiBtb2RlbHMuZmlsdGVyKFxuICAgIChtKSA9PiBpc0dlbWluaU1vZGVsTmFtZSgoMCwgaW1wb3J0X3V0aWxzLm1vZGVsTmFtZSkobS5uYW1lKSkgJiYgIUtOT1dOX0RFQ09NSVNTSU9ORURfTU9ERUxTLmluY2x1ZGVzKCgwLCBpbXBvcnRfdXRpbHMubW9kZWxOYW1lKShtLm5hbWUpIHx8IFwiXCIpXG4gICkubWFwKChtKSA9PiB7XG4gICAgY29uc3QgcmVmID0gbW9kZWwobS5uYW1lKTtcbiAgICByZXR1cm4gKDAsIGltcG9ydF9nZW5raXQubW9kZWxBY3Rpb25NZXRhZGF0YSkoe1xuICAgICAgbmFtZTogcmVmLm5hbWUsXG4gICAgICBpbmZvOiByZWYuaW5mbyxcbiAgICAgIGNvbmZpZ1NjaGVtYTogcmVmLmNvbmZpZ1NjaGVtYVxuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGRlZmluZUtub3duTW9kZWxzKGFpLCBjbGllbnRPcHRpb25zLCBwbHVnaW5PcHRpb25zKSB7XG4gIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhLTk9XTl9NT0RFTFMpKSB7XG4gICAgZGVmaW5lTW9kZWwoYWksIG5hbWUsIGNsaWVudE9wdGlvbnMsIHBsdWdpbk9wdGlvbnMpO1xuICB9XG59XG5mdW5jdGlvbiBkZWZpbmVNb2RlbChhaSwgbmFtZSwgY2xpZW50T3B0aW9ucywgcGx1Z2luT3B0aW9ucykge1xuICBjb25zdCByZWYgPSBtb2RlbChuYW1lKTtcbiAgY29uc3QgbWlkZGxld2FyZXMgPSBbXTtcbiAgaWYgKHJlZi5pbmZvPy5zdXBwb3J0cz8ubWVkaWEpIHtcbiAgICBtaWRkbGV3YXJlcy5wdXNoKFxuICAgICAgKDAsIGltcG9ydF9taWRkbGV3YXJlLmRvd25sb2FkUmVxdWVzdE1lZGlhKSh7XG4gICAgICAgIG1heEJ5dGVzOiAxMDI0ICogMTAyNCAqIDIwLFxuICAgICAgICBmaWx0ZXI6IChwYXJ0KSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocGFydC5tZWRpYS51cmwpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAvLyBHZW1pbmkgY2FuIGhhbmRsZSB0aGVzZSBVUkxzXG4gICAgICAgICAgICAgIFtcInd3dy55b3V0dWJlLmNvbVwiLCBcInlvdXR1YmUuY29tXCIsIFwieW91dHUuYmVcIl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgICAgdXJsLmhvc3RuYW1lXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIHJldHVybiBhaS5kZWZpbmVNb2RlbChcbiAgICB7XG4gICAgICBhcGlWZXJzaW9uOiBcInYyXCIsXG4gICAgICBuYW1lOiByZWYubmFtZSxcbiAgICAgIC4uLnJlZi5pbmZvLFxuICAgICAgY29uZmlnU2NoZW1hOiByZWYuY29uZmlnU2NoZW1hLFxuICAgICAgdXNlOiBtaWRkbGV3YXJlc1xuICAgIH0sXG4gICAgYXN5bmMgKHJlcXVlc3QsIHsgc3RyZWFtaW5nUmVxdWVzdGVkLCBzZW5kQ2h1bmssIGFib3J0U2lnbmFsIH0pID0+IHtcbiAgICAgIGxldCBjbGllbnRPcHQgPSB7IC4uLmNsaWVudE9wdGlvbnMsIHNpZ25hbDogYWJvcnRTaWduYWwgfTtcbiAgICAgIGNvbnN0IG1lc3NhZ2VzID0gc3RydWN0dXJlZENsb25lKHJlcXVlc3QubWVzc2FnZXMpO1xuICAgICAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gbWVzc2FnZXMgcHJvdmlkZWQuXCIpO1xuICAgICAgbGV0IHN5c3RlbUluc3RydWN0aW9uID0gdm9pZCAwO1xuICAgICAgY29uc3Qgc3lzdGVtTWVzc2FnZSA9IG1lc3NhZ2VzLmZpbmQoKG0pID0+IG0ucm9sZSA9PT0gXCJzeXN0ZW1cIik7XG4gICAgICBpZiAoc3lzdGVtTWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlcy5zcGxpY2UobWVzc2FnZXMuaW5kZXhPZihzeXN0ZW1NZXNzYWdlKSwgMSk7XG4gICAgICAgIHN5c3RlbUluc3RydWN0aW9uID0gKDAsIGltcG9ydF9jb252ZXJ0ZXJzLnRvR2VtaW5pU3lzdGVtSW5zdHJ1Y3Rpb24pKHN5c3RlbU1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVxdWVzdENvbmZpZyA9IHsgLi4ucmVxdWVzdC5jb25maWcgfTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXBpS2V5OiBhcGlLZXlGcm9tQ29uZmlnLFxuICAgICAgICBmdW5jdGlvbkNhbGxpbmdDb25maWcsXG4gICAgICAgIHZlcnNpb246IHZlcnNpb25Gcm9tQ29uZmlnLFxuICAgICAgICBnb29nbGVTZWFyY2hSZXRyaWV2YWwsXG4gICAgICAgIHRvb2xzOiB0b29sc0Zyb21Db25maWcsXG4gICAgICAgIHZlcnRleFJldHJpZXZhbCxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIHNhZmV0eVNldHRpbmdzLFxuICAgICAgICBsYWJlbHM6IGxhYmVsc0Zyb21Db25maWcsXG4gICAgICAgIC4uLnJlc3RPZkNvbmZpZ1xuICAgICAgfSA9IHJlcXVlc3RDb25maWc7XG4gICAgICBpZiAobG9jYXRpb24gJiYgY2xpZW50T3B0aW9ucy5raW5kICE9IFwiZXhwcmVzc1wiICYmIGNsaWVudE9wdGlvbnMubG9jYXRpb24gIT0gbG9jYXRpb24pIHtcbiAgICAgICAgaWYgKGxvY2F0aW9uID09IFwiZ2xvYmFsXCIpIHtcbiAgICAgICAgICBjbGllbnRPcHQgPSB7XG4gICAgICAgICAgICBraW5kOiBcImdsb2JhbFwiLFxuICAgICAgICAgICAgbG9jYXRpb246IFwiZ2xvYmFsXCIsXG4gICAgICAgICAgICBwcm9qZWN0SWQ6IGNsaWVudE9wdGlvbnMucHJvamVjdElkLFxuICAgICAgICAgICAgYXV0aENsaWVudDogY2xpZW50T3B0aW9ucy5hdXRoQ2xpZW50LFxuICAgICAgICAgICAgYXBpS2V5OiBjbGllbnRPcHRpb25zLmFwaUtleSxcbiAgICAgICAgICAgIHNpZ25hbDogYWJvcnRTaWduYWxcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsaWVudE9wdCA9IHtcbiAgICAgICAgICAgIGtpbmQ6IFwicmVnaW9uYWxcIixcbiAgICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgICAgcHJvamVjdElkOiBjbGllbnRPcHRpb25zLnByb2plY3RJZCxcbiAgICAgICAgICAgIGF1dGhDbGllbnQ6IGNsaWVudE9wdGlvbnMuYXV0aENsaWVudCxcbiAgICAgICAgICAgIGFwaUtleTogY2xpZW50T3B0aW9ucy5hcGlLZXksXG4gICAgICAgICAgICBzaWduYWw6IGFib3J0U2lnbmFsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNsaWVudE9wdGlvbnMua2luZCA9PSBcImV4cHJlc3NcIikge1xuICAgICAgICBjbGllbnRPcHQuYXBpS2V5ID0gKDAsIGltcG9ydF91dGlscy5jYWxjdWxhdGVBcGlLZXkpKFxuICAgICAgICAgIGNsaWVudE9wdGlvbnMuYXBpS2V5LFxuICAgICAgICAgIGFwaUtleUZyb21Db25maWdcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoYXBpS2V5RnJvbUNvbmZpZykge1xuICAgICAgICBjbGllbnRPcHQuYXBpS2V5ID0gYXBpS2V5RnJvbUNvbmZpZztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhYmVscyA9ICgwLCBpbXBvcnRfY29udmVydGVyczIudG9HZW1pbmlMYWJlbHMpKGxhYmVsc0Zyb21Db25maWcpO1xuICAgICAgY29uc3QgdG9vbHMgPSBbXTtcbiAgICAgIGlmIChyZXF1ZXN0LnRvb2xzPy5sZW5ndGgpIHtcbiAgICAgICAgdG9vbHMucHVzaCh7XG4gICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbnM6IHJlcXVlc3QudG9vbHMubWFwKGltcG9ydF9jb252ZXJ0ZXJzLnRvR2VtaW5pVG9vbClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsZXQgdG9vbENvbmZpZztcbiAgICAgIGlmIChmdW5jdGlvbkNhbGxpbmdDb25maWcpIHtcbiAgICAgICAgdG9vbENvbmZpZyA9IHtcbiAgICAgICAgICBmdW5jdGlvbkNhbGxpbmdDb25maWc6IHtcbiAgICAgICAgICAgIGFsbG93ZWRGdW5jdGlvbk5hbWVzOiBmdW5jdGlvbkNhbGxpbmdDb25maWcuYWxsb3dlZEZ1bmN0aW9uTmFtZXMsXG4gICAgICAgICAgICBtb2RlOiAoMCwgaW1wb3J0X2NvbnZlcnRlcnMudG9HZW1pbmlGdW5jdGlvbk1vZGVFbnVtKShmdW5jdGlvbkNhbGxpbmdDb25maWcubW9kZSlcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHJlcXVlc3QudG9vbENob2ljZSkge1xuICAgICAgICB0b29sQ29uZmlnID0ge1xuICAgICAgICAgIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZzoge1xuICAgICAgICAgICAgbW9kZTogKDAsIGltcG9ydF9jb252ZXJ0ZXJzLnRvR2VtaW5pRnVuY3Rpb25Nb2RlRW51bSkocmVxdWVzdC50b29sQ2hvaWNlKVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGpzb25Nb2RlID0gKHJlcXVlc3Qub3V0cHV0Py5mb3JtYXQgPT09IFwianNvblwiIHx8ICEhcmVxdWVzdC5vdXRwdXQ/LnNjaGVtYSkgJiYgdG9vbHMubGVuZ3RoID09PSAwO1xuICAgICAgaWYgKHRvb2xzRnJvbUNvbmZpZykge1xuICAgICAgICB0b29scy5wdXNoKC4uLnRvb2xzRnJvbUNvbmZpZyk7XG4gICAgICB9XG4gICAgICBpZiAoZ29vZ2xlU2VhcmNoUmV0cmlldmFsKSB7XG4gICAgICAgIGlmIChyZWYubmFtZS5zdGFydHNXaXRoKFwidmVydGV4YWkvZ2VtaW5pLTEuNVwiKSkge1xuICAgICAgICAgIHRvb2xzLnB1c2goe1xuICAgICAgICAgICAgZ29vZ2xlU2VhcmNoUmV0cmlldmFsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9vbHMucHVzaCh7XG4gICAgICAgICAgICBnb29nbGVTZWFyY2g6IGdvb2dsZVNlYXJjaFJldHJpZXZhbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodmVydGV4UmV0cmlldmFsKSB7XG4gICAgICAgIGNvbnN0IF9wcm9qZWN0SWQgPSB2ZXJ0ZXhSZXRyaWV2YWwuZGF0YXN0b3JlLnByb2plY3RJZCB8fCAoY2xpZW50T3B0aW9ucy5raW5kICE9IFwiZXhwcmVzc1wiID8gY2xpZW50T3B0aW9ucy5wcm9qZWN0SWQgOiB2b2lkIDApO1xuICAgICAgICBjb25zdCBfbG9jYXRpb24gPSB2ZXJ0ZXhSZXRyaWV2YWwuZGF0YXN0b3JlLmxvY2F0aW9uIHx8IChjbGllbnRPcHRpb25zLmtpbmQgPT0gXCJyZWdpb25hbFwiID8gY2xpZW50T3B0aW9ucy5sb2NhdGlvbiA6IHZvaWQgMCk7XG4gICAgICAgIGNvbnN0IF9kYXRhU3RvcmVJZCA9IHZlcnRleFJldHJpZXZhbC5kYXRhc3RvcmUuZGF0YVN0b3JlSWQ7XG4gICAgICAgIGlmICghX3Byb2plY3RJZCB8fCAhX2xvY2F0aW9uIHx8ICFfZGF0YVN0b3JlSWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgaW1wb3J0X2dlbmtpdC5HZW5raXRFcnJvcih7XG4gICAgICAgICAgICBzdGF0dXM6IFwiSU5WQUxJRF9BUkdVTUVOVFwiLFxuICAgICAgICAgICAgbWVzc2FnZTogXCJwcm9qZWN0SWQsIGxvY2F0aW9uIGFuZCBkYXRhc3RvcmVJZCBhcmUgcmVxdWlyZWQgZm9yIHZlcnRleFJldHJpZXZhbCBhbmQgY291bGQgbm90IGJlIGRldGVybWluZWQgZnJvbSBjb25maWd1cmF0aW9uXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhc3RvcmUgPSBgcHJvamVjdHMvJHtfcHJvamVjdElkfS9sb2NhdGlvbnMvJHtfbG9jYXRpb259L2NvbGxlY3Rpb25zL2RlZmF1bHRfY29sbGVjdGlvbi9kYXRhU3RvcmVzLyR7X2RhdGFTdG9yZUlkfWA7XG4gICAgICAgIHRvb2xzLnB1c2goe1xuICAgICAgICAgIHJldHJpZXZhbDoge1xuICAgICAgICAgICAgdmVydGV4QWlTZWFyY2g6IHtcbiAgICAgICAgICAgICAgZGF0YXN0b3JlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlzYWJsZUF0dHJpYnV0aW9uOiB2ZXJ0ZXhSZXRyaWV2YWwuZGlzYWJsZUF0dHJpYnV0aW9uXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGdlbmVyYXRlQ29udGVudFJlcXVlc3QgPSB7XG4gICAgICAgIHN5c3RlbUluc3RydWN0aW9uLFxuICAgICAgICBnZW5lcmF0aW9uQ29uZmlnOiB7XG4gICAgICAgICAgLi4ucmVzdE9mQ29uZmlnLFxuICAgICAgICAgIGNhbmRpZGF0ZUNvdW50OiByZXF1ZXN0LmNhbmRpZGF0ZXMgfHwgdm9pZCAwLFxuICAgICAgICAgIHJlc3BvbnNlTWltZVR5cGU6IGpzb25Nb2RlID8gXCJhcHBsaWNhdGlvbi9qc29uXCIgOiB2b2lkIDBcbiAgICAgICAgfSxcbiAgICAgICAgdG9vbHMsXG4gICAgICAgIHRvb2xDb25maWcsXG4gICAgICAgIHNhZmV0eVNldHRpbmdzOiAoMCwgaW1wb3J0X2NvbnZlcnRlcnMyLnRvR2VtaW5pU2FmZXR5U2V0dGluZ3MpKHNhZmV0eVNldHRpbmdzKSxcbiAgICAgICAgY29udGVudHM6IG1lc3NhZ2VzLm1hcCgobWVzc2FnZSkgPT4gKDAsIGltcG9ydF9jb252ZXJ0ZXJzLnRvR2VtaW5pTWVzc2FnZSkobWVzc2FnZSwgcmVmKSksXG4gICAgICAgIGxhYmVsc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG1vZGVsVmVyc2lvbiA9IHZlcnNpb25Gcm9tQ29uZmlnIHx8ICgwLCBpbXBvcnRfdXRpbHMuZXh0cmFjdFZlcnNpb24pKHJlZik7XG4gICAgICBpZiAoanNvbk1vZGUgJiYgcmVxdWVzdC5vdXRwdXQ/LmNvbnN0cmFpbmVkKSB7XG4gICAgICAgIGdlbmVyYXRlQ29udGVudFJlcXVlc3QuZ2VuZXJhdGlvbkNvbmZpZy5yZXNwb25zZVNjaGVtYSA9ICgwLCBpbXBvcnRfdXRpbHMuY2xlYW5TY2hlbWEpKFxuICAgICAgICAgIHJlcXVlc3Qub3V0cHV0LnNjaGVtYVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FsbEdlbWluaSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBpZiAoc3RyZWFtaW5nUmVxdWVzdGVkKSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKDAsIGltcG9ydF9jbGllbnQuZ2VuZXJhdGVDb250ZW50U3RyZWFtKShcbiAgICAgICAgICAgIG1vZGVsVmVyc2lvbixcbiAgICAgICAgICAgIGdlbmVyYXRlQ29udGVudFJlcXVlc3QsXG4gICAgICAgICAgICBjbGllbnRPcHRcbiAgICAgICAgICApO1xuICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgaXRlbSBvZiByZXN1bHQuc3RyZWFtKSB7XG4gICAgICAgICAgICBpdGVtLmNhbmRpZGF0ZXM/LmZvckVhY2goXG4gICAgICAgICAgICAgIChjYW5kaWRhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gKDAsIGltcG9ydF9jb252ZXJ0ZXJzLmZyb21HZW1pbmlDYW5kaWRhdGUpKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgICAgc2VuZENodW5rKHtcbiAgICAgICAgICAgICAgICAgIGluZGV4OiBjLmluZGV4LFxuICAgICAgICAgICAgICAgICAgY29udGVudDogYy5tZXNzYWdlLmNvbnRlbnRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCByZXN1bHQucmVzcG9uc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCAoMCwgaW1wb3J0X2NsaWVudC5nZW5lcmF0ZUNvbnRlbnQpKFxuICAgICAgICAgICAgbW9kZWxWZXJzaW9uLFxuICAgICAgICAgICAgZ2VuZXJhdGVDb250ZW50UmVxdWVzdCxcbiAgICAgICAgICAgIGNsaWVudE9wdFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXNwb25zZS5jYW5kaWRhdGVzPy5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgaW1wb3J0X2dlbmtpdC5HZW5raXRFcnJvcih7XG4gICAgICAgICAgICBzdGF0dXM6IFwiRkFJTEVEX1BSRUNPTkRJVElPTlwiLFxuICAgICAgICAgICAgbWVzc2FnZTogXCJObyB2YWxpZCBjYW5kaWRhdGVzIHJldHVybmVkLlwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FuZGlkYXRlRGF0YSA9IHJlc3BvbnNlLmNhbmRpZGF0ZXMubWFwKFxuICAgICAgICAgIChjKSA9PiAoMCwgaW1wb3J0X2NvbnZlcnRlcnMuZnJvbUdlbWluaUNhbmRpZGF0ZSkoYylcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjYW5kaWRhdGVzOiBjYW5kaWRhdGVEYXRhLFxuICAgICAgICAgIGN1c3RvbTogcmVzcG9uc2UsXG4gICAgICAgICAgdXNhZ2U6IHtcbiAgICAgICAgICAgIC4uLigwLCBpbXBvcnRfbW9kZWwuZ2V0QmFzaWNVc2FnZVN0YXRzKShyZXF1ZXN0Lm1lc3NhZ2VzLCBjYW5kaWRhdGVEYXRhKSxcbiAgICAgICAgICAgIGlucHV0VG9rZW5zOiByZXNwb25zZS51c2FnZU1ldGFkYXRhPy5wcm9tcHRUb2tlbkNvdW50LFxuICAgICAgICAgICAgb3V0cHV0VG9rZW5zOiByZXNwb25zZS51c2FnZU1ldGFkYXRhPy5jYW5kaWRhdGVzVG9rZW5Db3VudCxcbiAgICAgICAgICAgIHRob3VnaHRzVG9rZW5zOiByZXNwb25zZS51c2FnZU1ldGFkYXRhPy50aG91Z2h0c1Rva2VuQ291bnQsXG4gICAgICAgICAgICB0b3RhbFRva2VuczogcmVzcG9uc2UudXNhZ2VNZXRhZGF0YT8udG90YWxUb2tlbkNvdW50LFxuICAgICAgICAgICAgY2FjaGVkQ29udGVudFRva2VuczogcmVzcG9uc2UudXNhZ2VNZXRhZGF0YT8uY2FjaGVkQ29udGVudFRva2VuQ291bnRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgY29uc3QgbXNnID0gKDAsIGltcG9ydF9jb252ZXJ0ZXJzLnRvR2VtaW5pTWVzc2FnZSkobWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV0sIHJlZik7XG4gICAgICByZXR1cm4gcGx1Z2luT3B0aW9ucz8uZXhwZXJpbWVudGFsX2RlYnVnVHJhY2VzID8gYXdhaXQgKDAsIGltcG9ydF90cmFjaW5nLnJ1bkluTmV3U3BhbikoXG4gICAgICAgIGFpLnJlZ2lzdHJ5LFxuICAgICAgICB7XG4gICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmVhbWluZ1JlcXVlc3RlZCA/IFwic2VuZE1lc3NhZ2VTdHJlYW1cIiA6IFwic2VuZE1lc3NhZ2VcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgKG1ldGFkYXRhKSA9PiB7XG4gICAgICAgICAgbWV0YWRhdGEuaW5wdXQgPSB7XG4gICAgICAgICAgICBhcGlFbmRwb2ludDogKDAsIGltcG9ydF9jbGllbnQuZ2V0VmVydGV4QUlVcmwpKHtcbiAgICAgICAgICAgICAgaW5jbHVkZVByb2plY3RBbmRMb2NhdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgIHJlc291cmNlUGF0aDogXCJcIixcbiAgICAgICAgICAgICAgY2xpZW50T3B0aW9uczogY2xpZW50T3B0XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNhY2hlOiB7fSxcbiAgICAgICAgICAgIG1vZGVsOiBtb2RlbFZlcnNpb24sXG4gICAgICAgICAgICBnZW5lcmF0ZUNvbnRlbnRPcHRpb25zOiBnZW5lcmF0ZUNvbnRlbnRSZXF1ZXN0LFxuICAgICAgICAgICAgcGFydHM6IG1zZy5wYXJ0cyxcbiAgICAgICAgICAgIG9wdGlvbnM6IGNsaWVudE9wdFxuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjYWxsR2VtaW5pKCk7XG4gICAgICAgICAgbWV0YWRhdGEub3V0cHV0ID0gcmVzcG9uc2UuY3VzdG9tO1xuICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgKSA6IGF3YWl0IGNhbGxHZW1pbmkoKTtcbiAgICB9XG4gICk7XG59XG5jb25zdCBURVNUX09OTFkgPSB7IEtOT1dOX01PREVMUyB9O1xuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdFTkVSSUNfTU9ERUwsXG4gIEdlbWluaUNvbmZpZ1NjaGVtYSxcbiAgS05PV05fTU9ERUxTLFxuICBTYWZldHlTZXR0aW5nc1NjaGVtYSxcbiAgVEVTVF9PTkxZLFxuICBkZWZpbmVLbm93bk1vZGVscyxcbiAgZGVmaW5lTW9kZWwsXG4gIGlzR2VtaW5pTW9kZWxOYW1lLFxuICBsaXN0QWN0aW9ucyxcbiAgbW9kZWxcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2VtaW5pLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/gemini.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/imagen.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@genkit-ai/google-genai/lib/vertexai/imagen.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar imagen_exports = {};\n__export(imagen_exports, {\n  ImagenConfigSchema: () => ImagenConfigSchema,\n  KNOWN_MODELS: () => KNOWN_MODELS,\n  TEST_ONLY: () => TEST_ONLY,\n  defineKnownModels: () => defineKnownModels,\n  defineModel: () => defineModel,\n  isImagenModelName: () => isImagenModelName,\n  listActions: () => listActions,\n  model: () => model\n});\nmodule.exports = __toCommonJS(imagen_exports);\nvar import_genkit = __webpack_require__(/*! genkit */ \"(action-browser)/./node_modules/genkit/lib/index.js\");\nvar import_model = __webpack_require__(/*! genkit/model */ \"(action-browser)/./node_modules/genkit/lib/model.js\");\nvar import_client = __webpack_require__(/*! ./client.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/client.js\");\nvar import_converters = __webpack_require__(/*! ./converters.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/converters.js\");\nvar import_utils = __webpack_require__(/*! ./utils.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/utils.js\");\nconst ImagenConfigSchema = import_model.GenerationCommonConfigSchema.extend({\n  // TODO: Remove common config schema extension since Imagen models don't support\n  // most of the common config parameters. Also, add more parameters like sampleCount\n  // from the above reference.\n  language: import_genkit.z.enum([\"auto\", \"en\", \"es\", \"hi\", \"ja\", \"ko\", \"pt\", \"zh-TW\", \"zh\", \"zh-CN\"]).describe(\"Language of the prompt text.\").optional(),\n  aspectRatio: import_genkit.z.enum([\"1:1\", \"9:16\", \"16:9\", \"3:4\", \"4:3\"]).describe(\"Desired aspect ratio of the output image.\").optional(),\n  negativePrompt: import_genkit.z.string().describe(\n    'A description of what to discourage in the generated images. For example: \"animals\" (removes animals), \"blurry\" (makes the image clearer), \"text\" (removes text), or \"cropped\" (removes cropped images).'\n  ).optional(),\n  seed: import_genkit.z.number().int().min(1).max(2147483647).describe(\n    \"Controls the randomization of the image generation process. Use the same seed across requests to provide consistency, or change it to introduce variety in the response.\"\n  ).optional(),\n  location: import_genkit.z.string().describe(\"Google Cloud region e.g. us-central1.\").optional(),\n  personGeneration: import_genkit.z.enum([\"dont_allow\", \"allow_adult\", \"allow_all\"]).describe(\"Control if/how images of people will be generated by the model.\").optional(),\n  safetySetting: import_genkit.z.enum([\"block_most\", \"block_some\", \"block_few\", \"block_fewest\"]).describe(\"Adds a filter level to safety filtering.\").optional(),\n  addWatermark: import_genkit.z.boolean().describe(\"Add an invisible watermark to the generated images.\").optional(),\n  storageUri: import_genkit.z.string().describe(\"Cloud Storage URI to store the generated images.\").optional(),\n  mode: import_genkit.z.enum([\"upscale\"]).describe(\"Mode must be set for upscaling requests.\").optional(),\n  /**\n   * Describes the editing intention for the request.\n   *\n   * See https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/imagen-api#edit_images_2 for details.\n   */\n  editConfig: import_genkit.z.object({\n    editMode: import_genkit.z.enum([\n      \"inpainting-insert\",\n      \"inpainting-remove\",\n      \"outpainting\",\n      \"product-image\"\n    ]).describe(\"Editing intention for the request.\").optional(),\n    maskMode: import_genkit.z.object({\n      maskType: import_genkit.z.enum([\"background\", \"foreground\", \"semantic\"]).describe(\n        '\"background\" automatically generates a mask for all regions except the primary subject(s) of the image, \"foreground\" automatically generates a mask for the primary subjects(s) of the image. \"semantic\" segments one or more of the segmentation classes using class ID.'\n      ),\n      classes: import_genkit.z.array(import_genkit.z.number()).describe(\"List of class IDs for segmentation.\").length(5).optional()\n    }).describe(\n      \"Prompts the model to generate a mask instead of you needing to provide one. Consequently, when you provide this parameter you can omit a mask object.\"\n    ).optional(),\n    maskDilation: import_genkit.z.number().describe(\"Dilation percentage of the mask provided.\").min(0).max(1).optional(),\n    guidanceScale: import_genkit.z.number().describe(\n      \"Controls how much the model adheres to the text prompt. Large values increase output and prompt alignment, but may compromise image quality. Suggested values are 0-9 (low strength), 10-20 (medium strength), 21+ (high strength).\"\n    ).optional(),\n    productPosition: import_genkit.z.enum([\"reposition\", \"fixed\"]).describe(\n      \"Defines whether the product should stay fixed or be repositioned.\"\n    ).optional()\n  }).passthrough().optional(),\n  upscaleConfig: import_genkit.z.object({\n    upscaleFactor: import_genkit.z.enum([\"x2\", \"x4\"]).describe(\"The factor to upscale the image.\")\n  }).describe(\"Configuration for upscaling.\").optional()\n}).passthrough();\nfunction commonRef(name, info, configSchema = ImagenConfigSchema) {\n  return (0, import_model.modelRef)({\n    name: `vertexai/${name}`,\n    configSchema,\n    info: info ?? {\n      supports: {\n        media: true,\n        multiturn: false,\n        tools: false,\n        toolChoice: false,\n        systemRole: false,\n        output: [\"media\"]\n      }\n    }\n  });\n}\nconst GENERIC_MODEL = commonRef(\"imagen\", {\n  supports: {\n    media: true,\n    multiturn: true,\n    tools: true,\n    systemRole: true,\n    output: [\"media\"]\n  }\n});\nconst KNOWN_MODELS = {\n  \"imagen-3.0-generate-002\": commonRef(\"imagen-3.0-generate-002\"),\n  \"imagen-3.0-generate-001\": commonRef(\"imagen-3.0-generate-001\"),\n  \"imagen-3.0-capability-001\": commonRef(\"imagen-3.0-capability-001\"),\n  \"imagen-3.0-fast-generate-001\": commonRef(\"imagen-3.0-fast-generate-001\"),\n  \"imagen-4.0-generate-preview-06-06\": commonRef(\n    \"imagen-4.0-generate-preview-06-06\"\n  ),\n  \"imagen-4.0-ultra-generate-preview-06-06\": commonRef(\n    \"imagen-4.0-ultra-generate-preview-06-06\"\n  )\n};\nfunction isImagenModelName(value) {\n  return !!value?.startsWith(\"imagen-\");\n}\nfunction model(version, config = {}) {\n  const name = (0, import_utils.checkModelName)(version);\n  if (KNOWN_MODELS[name]) {\n    return KNOWN_MODELS[name].withConfig(config);\n  }\n  return (0, import_model.modelRef)({\n    name: `vertexai/${name}`,\n    config,\n    configSchema: ImagenConfigSchema,\n    info: {\n      ...GENERIC_MODEL.info\n    }\n  });\n}\nfunction listActions(models) {\n  return models.filter((m) => isImagenModelName((0, import_utils.modelName)(m.name))).map((m) => {\n    const ref = model(m.name);\n    return (0, import_genkit.modelActionMetadata)({\n      name: ref.name,\n      info: ref.info,\n      configSchema: ref.configSchema\n    });\n  });\n}\nfunction defineKnownModels(ai, clientOptions, pluginOptions) {\n  for (const name of Object.keys(KNOWN_MODELS)) {\n    defineModel(ai, name, clientOptions, pluginOptions);\n  }\n}\nfunction defineModel(ai, name, clientOptions, pluginOptions) {\n  const ref = model(name);\n  return ai.defineModel(\n    {\n      apiVersion: \"v2\",\n      name: ref.name,\n      ...ref.info,\n      configSchema: ref.configSchema\n    },\n    async (request, { abortSignal }) => {\n      const clientOpt = { ...clientOptions, signal: abortSignal };\n      const imagenPredictRequest = (0, import_converters.toImagenPredictRequest)(request);\n      const response = await (0, import_client.imagenPredict)(\n        (0, import_utils.extractVersion)(ref),\n        imagenPredictRequest,\n        clientOpt\n      );\n      if (!response.predictions || response.predictions.length == 0) {\n        throw new Error(\n          \"Model returned no predictions. Possibly due to content filters.\"\n        );\n      }\n      return (0, import_converters.fromImagenResponse)(response, request);\n    }\n  );\n}\nconst TEST_ONLY = {\n  GENERIC_MODEL,\n  KNOWN_MODELS\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=imagen.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2dvb2dsZS1nZW5haS9saWIvdmVydGV4YWkvaW1hZ2VuLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyxtRUFBUTtBQUNwQyxtQkFBbUIsbUJBQU8sQ0FBQyx5RUFBYztBQUN6QyxvQkFBb0IsbUJBQU8sQ0FBQyxtR0FBYTtBQUN6Qyx3QkFBd0IsbUJBQU8sQ0FBQywyR0FBaUI7QUFDakQsbUJBQW1CLG1CQUFPLENBQUMsaUdBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHNCQUFzQixhQUFhO0FBQ25DLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQVNMO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcS1JhbWFjaGFcXERvY3VtZW50c1xcU3VzdEFJbmV4IEdJdCBDb2RlXFxub2RlX21vZHVsZXNcXEBnZW5raXQtYWlcXGdvb2dsZS1nZW5haVxcbGliXFx2ZXJ0ZXhhaVxcaW1hZ2VuLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBpbWFnZW5fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoaW1hZ2VuX2V4cG9ydHMsIHtcbiAgSW1hZ2VuQ29uZmlnU2NoZW1hOiAoKSA9PiBJbWFnZW5Db25maWdTY2hlbWEsXG4gIEtOT1dOX01PREVMUzogKCkgPT4gS05PV05fTU9ERUxTLFxuICBURVNUX09OTFk6ICgpID0+IFRFU1RfT05MWSxcbiAgZGVmaW5lS25vd25Nb2RlbHM6ICgpID0+IGRlZmluZUtub3duTW9kZWxzLFxuICBkZWZpbmVNb2RlbDogKCkgPT4gZGVmaW5lTW9kZWwsXG4gIGlzSW1hZ2VuTW9kZWxOYW1lOiAoKSA9PiBpc0ltYWdlbk1vZGVsTmFtZSxcbiAgbGlzdEFjdGlvbnM6ICgpID0+IGxpc3RBY3Rpb25zLFxuICBtb2RlbDogKCkgPT4gbW9kZWxcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoaW1hZ2VuX2V4cG9ydHMpO1xudmFyIGltcG9ydF9nZW5raXQgPSByZXF1aXJlKFwiZ2Vua2l0XCIpO1xudmFyIGltcG9ydF9tb2RlbCA9IHJlcXVpcmUoXCJnZW5raXQvbW9kZWxcIik7XG52YXIgaW1wb3J0X2NsaWVudCA9IHJlcXVpcmUoXCIuL2NsaWVudC5qc1wiKTtcbnZhciBpbXBvcnRfY29udmVydGVycyA9IHJlcXVpcmUoXCIuL2NvbnZlcnRlcnMuanNcIik7XG52YXIgaW1wb3J0X3V0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5jb25zdCBJbWFnZW5Db25maWdTY2hlbWEgPSBpbXBvcnRfbW9kZWwuR2VuZXJhdGlvbkNvbW1vbkNvbmZpZ1NjaGVtYS5leHRlbmQoe1xuICAvLyBUT0RPOiBSZW1vdmUgY29tbW9uIGNvbmZpZyBzY2hlbWEgZXh0ZW5zaW9uIHNpbmNlIEltYWdlbiBtb2RlbHMgZG9uJ3Qgc3VwcG9ydFxuICAvLyBtb3N0IG9mIHRoZSBjb21tb24gY29uZmlnIHBhcmFtZXRlcnMuIEFsc28sIGFkZCBtb3JlIHBhcmFtZXRlcnMgbGlrZSBzYW1wbGVDb3VudFxuICAvLyBmcm9tIHRoZSBhYm92ZSByZWZlcmVuY2UuXG4gIGxhbmd1YWdlOiBpbXBvcnRfZ2Vua2l0LnouZW51bShbXCJhdXRvXCIsIFwiZW5cIiwgXCJlc1wiLCBcImhpXCIsIFwiamFcIiwgXCJrb1wiLCBcInB0XCIsIFwiemgtVFdcIiwgXCJ6aFwiLCBcInpoLUNOXCJdKS5kZXNjcmliZShcIkxhbmd1YWdlIG9mIHRoZSBwcm9tcHQgdGV4dC5cIikub3B0aW9uYWwoKSxcbiAgYXNwZWN0UmF0aW86IGltcG9ydF9nZW5raXQuei5lbnVtKFtcIjE6MVwiLCBcIjk6MTZcIiwgXCIxNjo5XCIsIFwiMzo0XCIsIFwiNDozXCJdKS5kZXNjcmliZShcIkRlc2lyZWQgYXNwZWN0IHJhdGlvIG9mIHRoZSBvdXRwdXQgaW1hZ2UuXCIpLm9wdGlvbmFsKCksXG4gIG5lZ2F0aXZlUHJvbXB0OiBpbXBvcnRfZ2Vua2l0Lnouc3RyaW5nKCkuZGVzY3JpYmUoXG4gICAgJ0EgZGVzY3JpcHRpb24gb2Ygd2hhdCB0byBkaXNjb3VyYWdlIGluIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzLiBGb3IgZXhhbXBsZTogXCJhbmltYWxzXCIgKHJlbW92ZXMgYW5pbWFscyksIFwiYmx1cnJ5XCIgKG1ha2VzIHRoZSBpbWFnZSBjbGVhcmVyKSwgXCJ0ZXh0XCIgKHJlbW92ZXMgdGV4dCksIG9yIFwiY3JvcHBlZFwiIChyZW1vdmVzIGNyb3BwZWQgaW1hZ2VzKS4nXG4gICkub3B0aW9uYWwoKSxcbiAgc2VlZDogaW1wb3J0X2dlbmtpdC56Lm51bWJlcigpLmludCgpLm1pbigxKS5tYXgoMjE0NzQ4MzY0NykuZGVzY3JpYmUoXG4gICAgXCJDb250cm9scyB0aGUgcmFuZG9taXphdGlvbiBvZiB0aGUgaW1hZ2UgZ2VuZXJhdGlvbiBwcm9jZXNzLiBVc2UgdGhlIHNhbWUgc2VlZCBhY3Jvc3MgcmVxdWVzdHMgdG8gcHJvdmlkZSBjb25zaXN0ZW5jeSwgb3IgY2hhbmdlIGl0IHRvIGludHJvZHVjZSB2YXJpZXR5IGluIHRoZSByZXNwb25zZS5cIlxuICApLm9wdGlvbmFsKCksXG4gIGxvY2F0aW9uOiBpbXBvcnRfZ2Vua2l0Lnouc3RyaW5nKCkuZGVzY3JpYmUoXCJHb29nbGUgQ2xvdWQgcmVnaW9uIGUuZy4gdXMtY2VudHJhbDEuXCIpLm9wdGlvbmFsKCksXG4gIHBlcnNvbkdlbmVyYXRpb246IGltcG9ydF9nZW5raXQuei5lbnVtKFtcImRvbnRfYWxsb3dcIiwgXCJhbGxvd19hZHVsdFwiLCBcImFsbG93X2FsbFwiXSkuZGVzY3JpYmUoXCJDb250cm9sIGlmL2hvdyBpbWFnZXMgb2YgcGVvcGxlIHdpbGwgYmUgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbC5cIikub3B0aW9uYWwoKSxcbiAgc2FmZXR5U2V0dGluZzogaW1wb3J0X2dlbmtpdC56LmVudW0oW1wiYmxvY2tfbW9zdFwiLCBcImJsb2NrX3NvbWVcIiwgXCJibG9ja19mZXdcIiwgXCJibG9ja19mZXdlc3RcIl0pLmRlc2NyaWJlKFwiQWRkcyBhIGZpbHRlciBsZXZlbCB0byBzYWZldHkgZmlsdGVyaW5nLlwiKS5vcHRpb25hbCgpLFxuICBhZGRXYXRlcm1hcms6IGltcG9ydF9nZW5raXQuei5ib29sZWFuKCkuZGVzY3JpYmUoXCJBZGQgYW4gaW52aXNpYmxlIHdhdGVybWFyayB0byB0aGUgZ2VuZXJhdGVkIGltYWdlcy5cIikub3B0aW9uYWwoKSxcbiAgc3RvcmFnZVVyaTogaW1wb3J0X2dlbmtpdC56LnN0cmluZygpLmRlc2NyaWJlKFwiQ2xvdWQgU3RvcmFnZSBVUkkgdG8gc3RvcmUgdGhlIGdlbmVyYXRlZCBpbWFnZXMuXCIpLm9wdGlvbmFsKCksXG4gIG1vZGU6IGltcG9ydF9nZW5raXQuei5lbnVtKFtcInVwc2NhbGVcIl0pLmRlc2NyaWJlKFwiTW9kZSBtdXN0IGJlIHNldCBmb3IgdXBzY2FsaW5nIHJlcXVlc3RzLlwiKS5vcHRpb25hbCgpLFxuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSBlZGl0aW5nIGludGVudGlvbiBmb3IgdGhlIHJlcXVlc3QuXG4gICAqXG4gICAqIFNlZSBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vdmVydGV4LWFpL2dlbmVyYXRpdmUtYWkvZG9jcy9tb2RlbC1yZWZlcmVuY2UvaW1hZ2VuLWFwaSNlZGl0X2ltYWdlc18yIGZvciBkZXRhaWxzLlxuICAgKi9cbiAgZWRpdENvbmZpZzogaW1wb3J0X2dlbmtpdC56Lm9iamVjdCh7XG4gICAgZWRpdE1vZGU6IGltcG9ydF9nZW5raXQuei5lbnVtKFtcbiAgICAgIFwiaW5wYWludGluZy1pbnNlcnRcIixcbiAgICAgIFwiaW5wYWludGluZy1yZW1vdmVcIixcbiAgICAgIFwib3V0cGFpbnRpbmdcIixcbiAgICAgIFwicHJvZHVjdC1pbWFnZVwiXG4gICAgXSkuZGVzY3JpYmUoXCJFZGl0aW5nIGludGVudGlvbiBmb3IgdGhlIHJlcXVlc3QuXCIpLm9wdGlvbmFsKCksXG4gICAgbWFza01vZGU6IGltcG9ydF9nZW5raXQuei5vYmplY3Qoe1xuICAgICAgbWFza1R5cGU6IGltcG9ydF9nZW5raXQuei5lbnVtKFtcImJhY2tncm91bmRcIiwgXCJmb3JlZ3JvdW5kXCIsIFwic2VtYW50aWNcIl0pLmRlc2NyaWJlKFxuICAgICAgICAnXCJiYWNrZ3JvdW5kXCIgYXV0b21hdGljYWxseSBnZW5lcmF0ZXMgYSBtYXNrIGZvciBhbGwgcmVnaW9ucyBleGNlcHQgdGhlIHByaW1hcnkgc3ViamVjdChzKSBvZiB0aGUgaW1hZ2UsIFwiZm9yZWdyb3VuZFwiIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVzIGEgbWFzayBmb3IgdGhlIHByaW1hcnkgc3ViamVjdHMocykgb2YgdGhlIGltYWdlLiBcInNlbWFudGljXCIgc2VnbWVudHMgb25lIG9yIG1vcmUgb2YgdGhlIHNlZ21lbnRhdGlvbiBjbGFzc2VzIHVzaW5nIGNsYXNzIElELidcbiAgICAgICksXG4gICAgICBjbGFzc2VzOiBpbXBvcnRfZ2Vua2l0LnouYXJyYXkoaW1wb3J0X2dlbmtpdC56Lm51bWJlcigpKS5kZXNjcmliZShcIkxpc3Qgb2YgY2xhc3MgSURzIGZvciBzZWdtZW50YXRpb24uXCIpLmxlbmd0aCg1KS5vcHRpb25hbCgpXG4gICAgfSkuZGVzY3JpYmUoXG4gICAgICBcIlByb21wdHMgdGhlIG1vZGVsIHRvIGdlbmVyYXRlIGEgbWFzayBpbnN0ZWFkIG9mIHlvdSBuZWVkaW5nIHRvIHByb3ZpZGUgb25lLiBDb25zZXF1ZW50bHksIHdoZW4geW91IHByb3ZpZGUgdGhpcyBwYXJhbWV0ZXIgeW91IGNhbiBvbWl0IGEgbWFzayBvYmplY3QuXCJcbiAgICApLm9wdGlvbmFsKCksXG4gICAgbWFza0RpbGF0aW9uOiBpbXBvcnRfZ2Vua2l0LnoubnVtYmVyKCkuZGVzY3JpYmUoXCJEaWxhdGlvbiBwZXJjZW50YWdlIG9mIHRoZSBtYXNrIHByb3ZpZGVkLlwiKS5taW4oMCkubWF4KDEpLm9wdGlvbmFsKCksXG4gICAgZ3VpZGFuY2VTY2FsZTogaW1wb3J0X2dlbmtpdC56Lm51bWJlcigpLmRlc2NyaWJlKFxuICAgICAgXCJDb250cm9scyBob3cgbXVjaCB0aGUgbW9kZWwgYWRoZXJlcyB0byB0aGUgdGV4dCBwcm9tcHQuIExhcmdlIHZhbHVlcyBpbmNyZWFzZSBvdXRwdXQgYW5kIHByb21wdCBhbGlnbm1lbnQsIGJ1dCBtYXkgY29tcHJvbWlzZSBpbWFnZSBxdWFsaXR5LiBTdWdnZXN0ZWQgdmFsdWVzIGFyZSAwLTkgKGxvdyBzdHJlbmd0aCksIDEwLTIwIChtZWRpdW0gc3RyZW5ndGgpLCAyMSsgKGhpZ2ggc3RyZW5ndGgpLlwiXG4gICAgKS5vcHRpb25hbCgpLFxuICAgIHByb2R1Y3RQb3NpdGlvbjogaW1wb3J0X2dlbmtpdC56LmVudW0oW1wicmVwb3NpdGlvblwiLCBcImZpeGVkXCJdKS5kZXNjcmliZShcbiAgICAgIFwiRGVmaW5lcyB3aGV0aGVyIHRoZSBwcm9kdWN0IHNob3VsZCBzdGF5IGZpeGVkIG9yIGJlIHJlcG9zaXRpb25lZC5cIlxuICAgICkub3B0aW9uYWwoKVxuICB9KS5wYXNzdGhyb3VnaCgpLm9wdGlvbmFsKCksXG4gIHVwc2NhbGVDb25maWc6IGltcG9ydF9nZW5raXQuei5vYmplY3Qoe1xuICAgIHVwc2NhbGVGYWN0b3I6IGltcG9ydF9nZW5raXQuei5lbnVtKFtcIngyXCIsIFwieDRcIl0pLmRlc2NyaWJlKFwiVGhlIGZhY3RvciB0byB1cHNjYWxlIHRoZSBpbWFnZS5cIilcbiAgfSkuZGVzY3JpYmUoXCJDb25maWd1cmF0aW9uIGZvciB1cHNjYWxpbmcuXCIpLm9wdGlvbmFsKClcbn0pLnBhc3N0aHJvdWdoKCk7XG5mdW5jdGlvbiBjb21tb25SZWYobmFtZSwgaW5mbywgY29uZmlnU2NoZW1hID0gSW1hZ2VuQ29uZmlnU2NoZW1hKSB7XG4gIHJldHVybiAoMCwgaW1wb3J0X21vZGVsLm1vZGVsUmVmKSh7XG4gICAgbmFtZTogYHZlcnRleGFpLyR7bmFtZX1gLFxuICAgIGNvbmZpZ1NjaGVtYSxcbiAgICBpbmZvOiBpbmZvID8/IHtcbiAgICAgIHN1cHBvcnRzOiB7XG4gICAgICAgIG1lZGlhOiB0cnVlLFxuICAgICAgICBtdWx0aXR1cm46IGZhbHNlLFxuICAgICAgICB0b29sczogZmFsc2UsXG4gICAgICAgIHRvb2xDaG9pY2U6IGZhbHNlLFxuICAgICAgICBzeXN0ZW1Sb2xlOiBmYWxzZSxcbiAgICAgICAgb3V0cHV0OiBbXCJtZWRpYVwiXVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5jb25zdCBHRU5FUklDX01PREVMID0gY29tbW9uUmVmKFwiaW1hZ2VuXCIsIHtcbiAgc3VwcG9ydHM6IHtcbiAgICBtZWRpYTogdHJ1ZSxcbiAgICBtdWx0aXR1cm46IHRydWUsXG4gICAgdG9vbHM6IHRydWUsXG4gICAgc3lzdGVtUm9sZTogdHJ1ZSxcbiAgICBvdXRwdXQ6IFtcIm1lZGlhXCJdXG4gIH1cbn0pO1xuY29uc3QgS05PV05fTU9ERUxTID0ge1xuICBcImltYWdlbi0zLjAtZ2VuZXJhdGUtMDAyXCI6IGNvbW1vblJlZihcImltYWdlbi0zLjAtZ2VuZXJhdGUtMDAyXCIpLFxuICBcImltYWdlbi0zLjAtZ2VuZXJhdGUtMDAxXCI6IGNvbW1vblJlZihcImltYWdlbi0zLjAtZ2VuZXJhdGUtMDAxXCIpLFxuICBcImltYWdlbi0zLjAtY2FwYWJpbGl0eS0wMDFcIjogY29tbW9uUmVmKFwiaW1hZ2VuLTMuMC1jYXBhYmlsaXR5LTAwMVwiKSxcbiAgXCJpbWFnZW4tMy4wLWZhc3QtZ2VuZXJhdGUtMDAxXCI6IGNvbW1vblJlZihcImltYWdlbi0zLjAtZmFzdC1nZW5lcmF0ZS0wMDFcIiksXG4gIFwiaW1hZ2VuLTQuMC1nZW5lcmF0ZS1wcmV2aWV3LTA2LTA2XCI6IGNvbW1vblJlZihcbiAgICBcImltYWdlbi00LjAtZ2VuZXJhdGUtcHJldmlldy0wNi0wNlwiXG4gICksXG4gIFwiaW1hZ2VuLTQuMC11bHRyYS1nZW5lcmF0ZS1wcmV2aWV3LTA2LTA2XCI6IGNvbW1vblJlZihcbiAgICBcImltYWdlbi00LjAtdWx0cmEtZ2VuZXJhdGUtcHJldmlldy0wNi0wNlwiXG4gIClcbn07XG5mdW5jdGlvbiBpc0ltYWdlbk1vZGVsTmFtZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZT8uc3RhcnRzV2l0aChcImltYWdlbi1cIik7XG59XG5mdW5jdGlvbiBtb2RlbCh2ZXJzaW9uLCBjb25maWcgPSB7fSkge1xuICBjb25zdCBuYW1lID0gKDAsIGltcG9ydF91dGlscy5jaGVja01vZGVsTmFtZSkodmVyc2lvbik7XG4gIGlmIChLTk9XTl9NT0RFTFNbbmFtZV0pIHtcbiAgICByZXR1cm4gS05PV05fTU9ERUxTW25hbWVdLndpdGhDb25maWcoY29uZmlnKTtcbiAgfVxuICByZXR1cm4gKDAsIGltcG9ydF9tb2RlbC5tb2RlbFJlZikoe1xuICAgIG5hbWU6IGB2ZXJ0ZXhhaS8ke25hbWV9YCxcbiAgICBjb25maWcsXG4gICAgY29uZmlnU2NoZW1hOiBJbWFnZW5Db25maWdTY2hlbWEsXG4gICAgaW5mbzoge1xuICAgICAgLi4uR0VORVJJQ19NT0RFTC5pbmZvXG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGxpc3RBY3Rpb25zKG1vZGVscykge1xuICByZXR1cm4gbW9kZWxzLmZpbHRlcigobSkgPT4gaXNJbWFnZW5Nb2RlbE5hbWUoKDAsIGltcG9ydF91dGlscy5tb2RlbE5hbWUpKG0ubmFtZSkpKS5tYXAoKG0pID0+IHtcbiAgICBjb25zdCByZWYgPSBtb2RlbChtLm5hbWUpO1xuICAgIHJldHVybiAoMCwgaW1wb3J0X2dlbmtpdC5tb2RlbEFjdGlvbk1ldGFkYXRhKSh7XG4gICAgICBuYW1lOiByZWYubmFtZSxcbiAgICAgIGluZm86IHJlZi5pbmZvLFxuICAgICAgY29uZmlnU2NoZW1hOiByZWYuY29uZmlnU2NoZW1hXG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZGVmaW5lS25vd25Nb2RlbHMoYWksIGNsaWVudE9wdGlvbnMsIHBsdWdpbk9wdGlvbnMpIHtcbiAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKEtOT1dOX01PREVMUykpIHtcbiAgICBkZWZpbmVNb2RlbChhaSwgbmFtZSwgY2xpZW50T3B0aW9ucywgcGx1Z2luT3B0aW9ucyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZmluZU1vZGVsKGFpLCBuYW1lLCBjbGllbnRPcHRpb25zLCBwbHVnaW5PcHRpb25zKSB7XG4gIGNvbnN0IHJlZiA9IG1vZGVsKG5hbWUpO1xuICByZXR1cm4gYWkuZGVmaW5lTW9kZWwoXG4gICAge1xuICAgICAgYXBpVmVyc2lvbjogXCJ2MlwiLFxuICAgICAgbmFtZTogcmVmLm5hbWUsXG4gICAgICAuLi5yZWYuaW5mbyxcbiAgICAgIGNvbmZpZ1NjaGVtYTogcmVmLmNvbmZpZ1NjaGVtYVxuICAgIH0sXG4gICAgYXN5bmMgKHJlcXVlc3QsIHsgYWJvcnRTaWduYWwgfSkgPT4ge1xuICAgICAgY29uc3QgY2xpZW50T3B0ID0geyAuLi5jbGllbnRPcHRpb25zLCBzaWduYWw6IGFib3J0U2lnbmFsIH07XG4gICAgICBjb25zdCBpbWFnZW5QcmVkaWN0UmVxdWVzdCA9ICgwLCBpbXBvcnRfY29udmVydGVycy50b0ltYWdlblByZWRpY3RSZXF1ZXN0KShyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgKDAsIGltcG9ydF9jbGllbnQuaW1hZ2VuUHJlZGljdCkoXG4gICAgICAgICgwLCBpbXBvcnRfdXRpbHMuZXh0cmFjdFZlcnNpb24pKHJlZiksXG4gICAgICAgIGltYWdlblByZWRpY3RSZXF1ZXN0LFxuICAgICAgICBjbGllbnRPcHRcbiAgICAgICk7XG4gICAgICBpZiAoIXJlc3BvbnNlLnByZWRpY3Rpb25zIHx8IHJlc3BvbnNlLnByZWRpY3Rpb25zLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIk1vZGVsIHJldHVybmVkIG5vIHByZWRpY3Rpb25zLiBQb3NzaWJseSBkdWUgdG8gY29udGVudCBmaWx0ZXJzLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKDAsIGltcG9ydF9jb252ZXJ0ZXJzLmZyb21JbWFnZW5SZXNwb25zZSkocmVzcG9uc2UsIHJlcXVlc3QpO1xuICAgIH1cbiAgKTtcbn1cbmNvbnN0IFRFU1RfT05MWSA9IHtcbiAgR0VORVJJQ19NT0RFTCxcbiAgS05PV05fTU9ERUxTXG59O1xuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIEltYWdlbkNvbmZpZ1NjaGVtYSxcbiAgS05PV05fTU9ERUxTLFxuICBURVNUX09OTFksXG4gIGRlZmluZUtub3duTW9kZWxzLFxuICBkZWZpbmVNb2RlbCxcbiAgaXNJbWFnZW5Nb2RlbE5hbWUsXG4gIGxpc3RBY3Rpb25zLFxuICBtb2RlbFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZW4uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/imagen.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@genkit-ai/google-genai/lib/vertexai/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar vertexai_exports = {};\n__export(vertexai_exports, {\n  default: () => vertexai_default,\n  vertexAI: () => vertexAI\n});\nmodule.exports = __toCommonJS(vertexai_exports);\nvar import_plugin = __webpack_require__(/*! genkit/plugin */ \"(action-browser)/./node_modules/genkit/lib/plugin.js\");\nvar import_client = __webpack_require__(/*! ./client.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/client.js\");\nvar embedder = __toESM(__webpack_require__(/*! ./embedder.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/embedder.js\"));\nvar gemini = __toESM(__webpack_require__(/*! ./gemini.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/gemini.js\"));\nvar imagen = __toESM(__webpack_require__(/*! ./imagen.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/imagen.js\"));\nvar lyria = __toESM(__webpack_require__(/*! ./lyria.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/lyria.js\"));\nvar veo = __toESM(__webpack_require__(/*! ./veo.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/veo.js\"));\nvar import_utils = __webpack_require__(/*! ./utils.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/utils.js\");\n/**\n * @license\n *\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function initializer(ai, pluginOptions) {\n  const clientOptions = await (0, import_utils.getDerivedOptions)(pluginOptions);\n  veo.defineKnownModels(ai, clientOptions, pluginOptions);\n  imagen.defineKnownModels(ai, clientOptions, pluginOptions);\n  lyria.defineKnownModels(ai, clientOptions, pluginOptions);\n  gemini.defineKnownModels(ai, clientOptions, pluginOptions);\n  embedder.defineKnownModels(ai, clientOptions, pluginOptions);\n}\nasync function resolver(ai, actionType, actionName, pluginOptions) {\n  const clientOptions = await (0, import_utils.getDerivedOptions)(pluginOptions);\n  switch (actionType) {\n    case \"model\":\n      if (lyria.isLyriaModelName(actionName)) {\n        lyria.defineModel(ai, actionName, clientOptions, pluginOptions);\n      } else if (imagen.isImagenModelName(actionName)) {\n        imagen.defineModel(ai, actionName, clientOptions, pluginOptions);\n      } else if (veo.isVeoModelName(actionName)) {\n      } else {\n        gemini.defineModel(ai, actionName, clientOptions, pluginOptions);\n      }\n      break;\n    case \"background-model\":\n      if (veo.isVeoModelName(actionName)) {\n        veo.defineModel(ai, actionName, clientOptions, pluginOptions);\n      }\n      break;\n    case \"embedder\":\n      embedder.defineEmbedder(ai, actionName, clientOptions, pluginOptions);\n      break;\n    default:\n  }\n}\nasync function listActions(options) {\n  try {\n    const clientOptions = await (0, import_utils.getDerivedOptions)(options);\n    const models = await (0, import_client.listModels)(clientOptions);\n    return [\n      ...gemini.listActions(models),\n      ...imagen.listActions(models),\n      ...lyria.listActions(models),\n      ...veo.listActions(models)\n      // We don't list embedders here\n    ];\n  } catch (e) {\n    return [];\n  }\n}\nfunction vertexAIPlugin(options) {\n  let listActionsCache;\n  return (0, import_plugin.genkitPlugin)(\n    \"vertexai\",\n    async (ai) => await initializer(ai, options),\n    async (ai, actionType, actionName) => await resolver(ai, actionType, actionName, options),\n    async () => {\n      if (listActionsCache) return listActionsCache;\n      listActionsCache = await listActions(options);\n      return listActionsCache;\n    }\n  );\n}\nconst vertexAI = vertexAIPlugin;\nvertexAI.model = (name, config) => {\n  if (imagen.isImagenModelName(name)) {\n    return imagen.model(name, config);\n  }\n  if (lyria.isLyriaModelName(name)) {\n    return lyria.model(name, config);\n  }\n  if (veo.isVeoModelName(name)) {\n    return veo.model(name, config);\n  }\n  return gemini.model(name, config);\n};\nvertexAI.embedder = (name, config) => {\n  return embedder.model(name, config);\n};\nvar vertexai_default = vertexAI;\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2dvb2dsZS1nZW5haS9saWIvdmVydGV4YWkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsOEJBQThCO0FBQ3ZHO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQywyRUFBZTtBQUMzQyxvQkFBb0IsbUJBQU8sQ0FBQyxtR0FBYTtBQUN6Qyx1QkFBdUIsbUJBQU8sQ0FBQyx1R0FBZTtBQUM5QyxxQkFBcUIsbUJBQU8sQ0FBQyxtR0FBYTtBQUMxQyxxQkFBcUIsbUJBQU8sQ0FBQyxtR0FBYTtBQUMxQyxvQkFBb0IsbUJBQU8sQ0FBQyxpR0FBWTtBQUN4QyxrQkFBa0IsbUJBQU8sQ0FBQyw2RkFBVTtBQUNwQyxtQkFBbUIsbUJBQU8sQ0FBQyxpR0FBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBRUw7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcZ29vZ2xlLWdlbmFpXFxsaWJcXHZlcnRleGFpXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgdmVydGV4YWlfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodmVydGV4YWlfZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiB2ZXJ0ZXhhaV9kZWZhdWx0LFxuICB2ZXJ0ZXhBSTogKCkgPT4gdmVydGV4QUlcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlModmVydGV4YWlfZXhwb3J0cyk7XG52YXIgaW1wb3J0X3BsdWdpbiA9IHJlcXVpcmUoXCJnZW5raXQvcGx1Z2luXCIpO1xudmFyIGltcG9ydF9jbGllbnQgPSByZXF1aXJlKFwiLi9jbGllbnQuanNcIik7XG52YXIgZW1iZWRkZXIgPSBfX3RvRVNNKHJlcXVpcmUoXCIuL2VtYmVkZGVyLmpzXCIpKTtcbnZhciBnZW1pbmkgPSBfX3RvRVNNKHJlcXVpcmUoXCIuL2dlbWluaS5qc1wiKSk7XG52YXIgaW1hZ2VuID0gX190b0VTTShyZXF1aXJlKFwiLi9pbWFnZW4uanNcIikpO1xudmFyIGx5cmlhID0gX190b0VTTShyZXF1aXJlKFwiLi9seXJpYS5qc1wiKSk7XG52YXIgdmVvID0gX190b0VTTShyZXF1aXJlKFwiLi92ZW8uanNcIikpO1xudmFyIGltcG9ydF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLyoqXG4gKiBAbGljZW5zZVxuICpcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGluaXRpYWxpemVyKGFpLCBwbHVnaW5PcHRpb25zKSB7XG4gIGNvbnN0IGNsaWVudE9wdGlvbnMgPSBhd2FpdCAoMCwgaW1wb3J0X3V0aWxzLmdldERlcml2ZWRPcHRpb25zKShwbHVnaW5PcHRpb25zKTtcbiAgdmVvLmRlZmluZUtub3duTW9kZWxzKGFpLCBjbGllbnRPcHRpb25zLCBwbHVnaW5PcHRpb25zKTtcbiAgaW1hZ2VuLmRlZmluZUtub3duTW9kZWxzKGFpLCBjbGllbnRPcHRpb25zLCBwbHVnaW5PcHRpb25zKTtcbiAgbHlyaWEuZGVmaW5lS25vd25Nb2RlbHMoYWksIGNsaWVudE9wdGlvbnMsIHBsdWdpbk9wdGlvbnMpO1xuICBnZW1pbmkuZGVmaW5lS25vd25Nb2RlbHMoYWksIGNsaWVudE9wdGlvbnMsIHBsdWdpbk9wdGlvbnMpO1xuICBlbWJlZGRlci5kZWZpbmVLbm93bk1vZGVscyhhaSwgY2xpZW50T3B0aW9ucywgcGx1Z2luT3B0aW9ucyk7XG59XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlcihhaSwgYWN0aW9uVHlwZSwgYWN0aW9uTmFtZSwgcGx1Z2luT3B0aW9ucykge1xuICBjb25zdCBjbGllbnRPcHRpb25zID0gYXdhaXQgKDAsIGltcG9ydF91dGlscy5nZXREZXJpdmVkT3B0aW9ucykocGx1Z2luT3B0aW9ucyk7XG4gIHN3aXRjaCAoYWN0aW9uVHlwZSkge1xuICAgIGNhc2UgXCJtb2RlbFwiOlxuICAgICAgaWYgKGx5cmlhLmlzTHlyaWFNb2RlbE5hbWUoYWN0aW9uTmFtZSkpIHtcbiAgICAgICAgbHlyaWEuZGVmaW5lTW9kZWwoYWksIGFjdGlvbk5hbWUsIGNsaWVudE9wdGlvbnMsIHBsdWdpbk9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmIChpbWFnZW4uaXNJbWFnZW5Nb2RlbE5hbWUoYWN0aW9uTmFtZSkpIHtcbiAgICAgICAgaW1hZ2VuLmRlZmluZU1vZGVsKGFpLCBhY3Rpb25OYW1lLCBjbGllbnRPcHRpb25zLCBwbHVnaW5PcHRpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAodmVvLmlzVmVvTW9kZWxOYW1lKGFjdGlvbk5hbWUpKSB7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW1pbmkuZGVmaW5lTW9kZWwoYWksIGFjdGlvbk5hbWUsIGNsaWVudE9wdGlvbnMsIHBsdWdpbk9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJhY2tncm91bmQtbW9kZWxcIjpcbiAgICAgIGlmICh2ZW8uaXNWZW9Nb2RlbE5hbWUoYWN0aW9uTmFtZSkpIHtcbiAgICAgICAgdmVvLmRlZmluZU1vZGVsKGFpLCBhY3Rpb25OYW1lLCBjbGllbnRPcHRpb25zLCBwbHVnaW5PcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJlbWJlZGRlclwiOlxuICAgICAgZW1iZWRkZXIuZGVmaW5lRW1iZWRkZXIoYWksIGFjdGlvbk5hbWUsIGNsaWVudE9wdGlvbnMsIHBsdWdpbk9wdGlvbnMpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gbGlzdEFjdGlvbnMob3B0aW9ucykge1xuICB0cnkge1xuICAgIGNvbnN0IGNsaWVudE9wdGlvbnMgPSBhd2FpdCAoMCwgaW1wb3J0X3V0aWxzLmdldERlcml2ZWRPcHRpb25zKShvcHRpb25zKTtcbiAgICBjb25zdCBtb2RlbHMgPSBhd2FpdCAoMCwgaW1wb3J0X2NsaWVudC5saXN0TW9kZWxzKShjbGllbnRPcHRpb25zKTtcbiAgICByZXR1cm4gW1xuICAgICAgLi4uZ2VtaW5pLmxpc3RBY3Rpb25zKG1vZGVscyksXG4gICAgICAuLi5pbWFnZW4ubGlzdEFjdGlvbnMobW9kZWxzKSxcbiAgICAgIC4uLmx5cmlhLmxpc3RBY3Rpb25zKG1vZGVscyksXG4gICAgICAuLi52ZW8ubGlzdEFjdGlvbnMobW9kZWxzKVxuICAgICAgLy8gV2UgZG9uJ3QgbGlzdCBlbWJlZGRlcnMgaGVyZVxuICAgIF07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cbmZ1bmN0aW9uIHZlcnRleEFJUGx1Z2luKG9wdGlvbnMpIHtcbiAgbGV0IGxpc3RBY3Rpb25zQ2FjaGU7XG4gIHJldHVybiAoMCwgaW1wb3J0X3BsdWdpbi5nZW5raXRQbHVnaW4pKFxuICAgIFwidmVydGV4YWlcIixcbiAgICBhc3luYyAoYWkpID0+IGF3YWl0IGluaXRpYWxpemVyKGFpLCBvcHRpb25zKSxcbiAgICBhc3luYyAoYWksIGFjdGlvblR5cGUsIGFjdGlvbk5hbWUpID0+IGF3YWl0IHJlc29sdmVyKGFpLCBhY3Rpb25UeXBlLCBhY3Rpb25OYW1lLCBvcHRpb25zKSxcbiAgICBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAobGlzdEFjdGlvbnNDYWNoZSkgcmV0dXJuIGxpc3RBY3Rpb25zQ2FjaGU7XG4gICAgICBsaXN0QWN0aW9uc0NhY2hlID0gYXdhaXQgbGlzdEFjdGlvbnMob3B0aW9ucyk7XG4gICAgICByZXR1cm4gbGlzdEFjdGlvbnNDYWNoZTtcbiAgICB9XG4gICk7XG59XG5jb25zdCB2ZXJ0ZXhBSSA9IHZlcnRleEFJUGx1Z2luO1xudmVydGV4QUkubW9kZWwgPSAobmFtZSwgY29uZmlnKSA9PiB7XG4gIGlmIChpbWFnZW4uaXNJbWFnZW5Nb2RlbE5hbWUobmFtZSkpIHtcbiAgICByZXR1cm4gaW1hZ2VuLm1vZGVsKG5hbWUsIGNvbmZpZyk7XG4gIH1cbiAgaWYgKGx5cmlhLmlzTHlyaWFNb2RlbE5hbWUobmFtZSkpIHtcbiAgICByZXR1cm4gbHlyaWEubW9kZWwobmFtZSwgY29uZmlnKTtcbiAgfVxuICBpZiAodmVvLmlzVmVvTW9kZWxOYW1lKG5hbWUpKSB7XG4gICAgcmV0dXJuIHZlby5tb2RlbChuYW1lLCBjb25maWcpO1xuICB9XG4gIHJldHVybiBnZW1pbmkubW9kZWwobmFtZSwgY29uZmlnKTtcbn07XG52ZXJ0ZXhBSS5lbWJlZGRlciA9IChuYW1lLCBjb25maWcpID0+IHtcbiAgcmV0dXJuIGVtYmVkZGVyLm1vZGVsKG5hbWUsIGNvbmZpZyk7XG59O1xudmFyIHZlcnRleGFpX2RlZmF1bHQgPSB2ZXJ0ZXhBSTtcbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICB2ZXJ0ZXhBSVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/lyria.js":
/*!********************************************************************!*\
  !*** ./node_modules/@genkit-ai/google-genai/lib/vertexai/lyria.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar lyria_exports = {};\n__export(lyria_exports, {\n  LyriaConfigSchema: () => LyriaConfigSchema,\n  TEST_ONLY: () => TEST_ONLY,\n  defineKnownModels: () => defineKnownModels,\n  defineModel: () => defineModel,\n  isLyriaModelName: () => isLyriaModelName,\n  listActions: () => listActions,\n  model: () => model\n});\nmodule.exports = __toCommonJS(lyria_exports);\nvar import_genkit = __webpack_require__(/*! genkit */ \"(action-browser)/./node_modules/genkit/lib/index.js\");\nvar import_client = __webpack_require__(/*! ./client.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/client.js\");\nvar import_converters = __webpack_require__(/*! ./converters.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/converters.js\");\nvar import_utils = __webpack_require__(/*! ./utils.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/utils.js\");\nconst LyriaConfigSchema = import_genkit.z.object({\n  negativePrompt: import_genkit.z.string().optional().describe(\n    \"Optional. A description of what to exclude from the generated audio.\"\n  ),\n  seed: import_genkit.z.number().optional().describe(\n    \"Optional. A seed for deterministic generation. If provided, the model will attempt to produce the same audio given the same prompt and other parameters. Cannot be used with sample_count in the same request.\"\n  ),\n  sampleCount: import_genkit.z.number().optional().describe(\n    \"Optional. The number of audio samples to generate. Default is 1 if not specified and seed is not used. Cannot be used with seed in the same request.\"\n  )\n}).passthrough();\nfunction commonRef(name, info, configSchema = LyriaConfigSchema) {\n  return (0, import_genkit.modelRef)({\n    name: `vertexai/${name}`,\n    configSchema,\n    info: info ?? {\n      supports: {\n        media: true,\n        multiturn: false,\n        tools: false,\n        systemRole: false,\n        output: [\"media\"]\n      }\n    }\n  });\n}\nconst GENERIC_MODEL = commonRef(\"lyria\");\nconst KNOWN_MODELS = {\n  \"lyria-002\": commonRef(\"lyria-002\")\n};\nfunction isLyriaModelName(value) {\n  return !!value?.startsWith(\"lyria-\");\n}\nfunction model(version, config = {}) {\n  const name = (0, import_utils.checkModelName)(version);\n  return (0, import_genkit.modelRef)({\n    name: `vertexai/${name}`,\n    config,\n    configSchema: LyriaConfigSchema,\n    info: { ...GENERIC_MODEL.info }\n  });\n}\nfunction listActions(models) {\n  return models.filter((m) => isLyriaModelName(m.name)).map((m) => {\n    const ref = model(m.name);\n    return (0, import_genkit.modelActionMetadata)({\n      name: ref.name,\n      info: ref.info,\n      configSchema: ref.configSchema\n    });\n  });\n}\nfunction defineKnownModels(ai, clientOptions, pluginOptions) {\n  for (const name of Object.keys(KNOWN_MODELS)) {\n    defineModel(ai, name, clientOptions, pluginOptions);\n  }\n}\nfunction defineModel(ai, name, clientOptions, pluginOptions) {\n  const ref = model(name);\n  return ai.defineModel(\n    {\n      apiVersion: \"v2\",\n      name: ref.name,\n      ...ref.info,\n      configSchema: ref.configSchema\n    },\n    async (request, { abortSignal }) => {\n      const clientOpt = { ...clientOptions, signal: abortSignal };\n      const lyriaPredictRequest = (0, import_converters.toLyriaPredictRequest)(request);\n      const response = await (0, import_client.lyriaPredict)(\n        (0, import_utils.extractVersion)(ref),\n        lyriaPredictRequest,\n        clientOpt\n      );\n      if (!response.predictions || response.predictions.length == 0) {\n        throw new Error(\n          \"Model returned no predictions. Possibly due to content filters.\"\n        );\n      }\n      return (0, import_converters.fromLyriaResponse)(response, request);\n    }\n  );\n}\nconst TEST_ONLY = {\n  GENERIC_MODEL,\n  KNOWN_MODELS\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=lyria.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2dvb2dsZS1nZW5haS9saWIvdmVydGV4YWkvbHlyaWEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyxtRUFBUTtBQUNwQyxvQkFBb0IsbUJBQU8sQ0FBQyxtR0FBYTtBQUN6Qyx3QkFBd0IsbUJBQU8sQ0FBQywyR0FBaUI7QUFDakQsbUJBQW1CLG1CQUFPLENBQUMsaUdBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7QUFDQSxZQUFZO0FBQ1osR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0JBQXNCLGFBQWE7QUFDbkMsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBUUw7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcZ29vZ2xlLWdlbmFpXFxsaWJcXHZlcnRleGFpXFxseXJpYS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgbHlyaWFfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobHlyaWFfZXhwb3J0cywge1xuICBMeXJpYUNvbmZpZ1NjaGVtYTogKCkgPT4gTHlyaWFDb25maWdTY2hlbWEsXG4gIFRFU1RfT05MWTogKCkgPT4gVEVTVF9PTkxZLFxuICBkZWZpbmVLbm93bk1vZGVsczogKCkgPT4gZGVmaW5lS25vd25Nb2RlbHMsXG4gIGRlZmluZU1vZGVsOiAoKSA9PiBkZWZpbmVNb2RlbCxcbiAgaXNMeXJpYU1vZGVsTmFtZTogKCkgPT4gaXNMeXJpYU1vZGVsTmFtZSxcbiAgbGlzdEFjdGlvbnM6ICgpID0+IGxpc3RBY3Rpb25zLFxuICBtb2RlbDogKCkgPT4gbW9kZWxcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMobHlyaWFfZXhwb3J0cyk7XG52YXIgaW1wb3J0X2dlbmtpdCA9IHJlcXVpcmUoXCJnZW5raXRcIik7XG52YXIgaW1wb3J0X2NsaWVudCA9IHJlcXVpcmUoXCIuL2NsaWVudC5qc1wiKTtcbnZhciBpbXBvcnRfY29udmVydGVycyA9IHJlcXVpcmUoXCIuL2NvbnZlcnRlcnMuanNcIik7XG52YXIgaW1wb3J0X3V0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5jb25zdCBMeXJpYUNvbmZpZ1NjaGVtYSA9IGltcG9ydF9nZW5raXQuei5vYmplY3Qoe1xuICBuZWdhdGl2ZVByb21wdDogaW1wb3J0X2dlbmtpdC56LnN0cmluZygpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXG4gICAgXCJPcHRpb25hbC4gQSBkZXNjcmlwdGlvbiBvZiB3aGF0IHRvIGV4Y2x1ZGUgZnJvbSB0aGUgZ2VuZXJhdGVkIGF1ZGlvLlwiXG4gICksXG4gIHNlZWQ6IGltcG9ydF9nZW5raXQuei5udW1iZXIoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFxuICAgIFwiT3B0aW9uYWwuIEEgc2VlZCBmb3IgZGV0ZXJtaW5pc3RpYyBnZW5lcmF0aW9uLiBJZiBwcm92aWRlZCwgdGhlIG1vZGVsIHdpbGwgYXR0ZW1wdCB0byBwcm9kdWNlIHRoZSBzYW1lIGF1ZGlvIGdpdmVuIHRoZSBzYW1lIHByb21wdCBhbmQgb3RoZXIgcGFyYW1ldGVycy4gQ2Fubm90IGJlIHVzZWQgd2l0aCBzYW1wbGVfY291bnQgaW4gdGhlIHNhbWUgcmVxdWVzdC5cIlxuICApLFxuICBzYW1wbGVDb3VudDogaW1wb3J0X2dlbmtpdC56Lm51bWJlcigpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXG4gICAgXCJPcHRpb25hbC4gVGhlIG51bWJlciBvZiBhdWRpbyBzYW1wbGVzIHRvIGdlbmVyYXRlLiBEZWZhdWx0IGlzIDEgaWYgbm90IHNwZWNpZmllZCBhbmQgc2VlZCBpcyBub3QgdXNlZC4gQ2Fubm90IGJlIHVzZWQgd2l0aCBzZWVkIGluIHRoZSBzYW1lIHJlcXVlc3QuXCJcbiAgKVxufSkucGFzc3Rocm91Z2goKTtcbmZ1bmN0aW9uIGNvbW1vblJlZihuYW1lLCBpbmZvLCBjb25maWdTY2hlbWEgPSBMeXJpYUNvbmZpZ1NjaGVtYSkge1xuICByZXR1cm4gKDAsIGltcG9ydF9nZW5raXQubW9kZWxSZWYpKHtcbiAgICBuYW1lOiBgdmVydGV4YWkvJHtuYW1lfWAsXG4gICAgY29uZmlnU2NoZW1hLFxuICAgIGluZm86IGluZm8gPz8ge1xuICAgICAgc3VwcG9ydHM6IHtcbiAgICAgICAgbWVkaWE6IHRydWUsXG4gICAgICAgIG11bHRpdHVybjogZmFsc2UsXG4gICAgICAgIHRvb2xzOiBmYWxzZSxcbiAgICAgICAgc3lzdGVtUm9sZTogZmFsc2UsXG4gICAgICAgIG91dHB1dDogW1wibWVkaWFcIl1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuY29uc3QgR0VORVJJQ19NT0RFTCA9IGNvbW1vblJlZihcImx5cmlhXCIpO1xuY29uc3QgS05PV05fTU9ERUxTID0ge1xuICBcImx5cmlhLTAwMlwiOiBjb21tb25SZWYoXCJseXJpYS0wMDJcIilcbn07XG5mdW5jdGlvbiBpc0x5cmlhTW9kZWxOYW1lKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlPy5zdGFydHNXaXRoKFwibHlyaWEtXCIpO1xufVxuZnVuY3Rpb24gbW9kZWwodmVyc2lvbiwgY29uZmlnID0ge30pIHtcbiAgY29uc3QgbmFtZSA9ICgwLCBpbXBvcnRfdXRpbHMuY2hlY2tNb2RlbE5hbWUpKHZlcnNpb24pO1xuICByZXR1cm4gKDAsIGltcG9ydF9nZW5raXQubW9kZWxSZWYpKHtcbiAgICBuYW1lOiBgdmVydGV4YWkvJHtuYW1lfWAsXG4gICAgY29uZmlnLFxuICAgIGNvbmZpZ1NjaGVtYTogTHlyaWFDb25maWdTY2hlbWEsXG4gICAgaW5mbzogeyAuLi5HRU5FUklDX01PREVMLmluZm8gfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGxpc3RBY3Rpb25zKG1vZGVscykge1xuICByZXR1cm4gbW9kZWxzLmZpbHRlcigobSkgPT4gaXNMeXJpYU1vZGVsTmFtZShtLm5hbWUpKS5tYXAoKG0pID0+IHtcbiAgICBjb25zdCByZWYgPSBtb2RlbChtLm5hbWUpO1xuICAgIHJldHVybiAoMCwgaW1wb3J0X2dlbmtpdC5tb2RlbEFjdGlvbk1ldGFkYXRhKSh7XG4gICAgICBuYW1lOiByZWYubmFtZSxcbiAgICAgIGluZm86IHJlZi5pbmZvLFxuICAgICAgY29uZmlnU2NoZW1hOiByZWYuY29uZmlnU2NoZW1hXG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZGVmaW5lS25vd25Nb2RlbHMoYWksIGNsaWVudE9wdGlvbnMsIHBsdWdpbk9wdGlvbnMpIHtcbiAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKEtOT1dOX01PREVMUykpIHtcbiAgICBkZWZpbmVNb2RlbChhaSwgbmFtZSwgY2xpZW50T3B0aW9ucywgcGx1Z2luT3B0aW9ucyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZmluZU1vZGVsKGFpLCBuYW1lLCBjbGllbnRPcHRpb25zLCBwbHVnaW5PcHRpb25zKSB7XG4gIGNvbnN0IHJlZiA9IG1vZGVsKG5hbWUpO1xuICByZXR1cm4gYWkuZGVmaW5lTW9kZWwoXG4gICAge1xuICAgICAgYXBpVmVyc2lvbjogXCJ2MlwiLFxuICAgICAgbmFtZTogcmVmLm5hbWUsXG4gICAgICAuLi5yZWYuaW5mbyxcbiAgICAgIGNvbmZpZ1NjaGVtYTogcmVmLmNvbmZpZ1NjaGVtYVxuICAgIH0sXG4gICAgYXN5bmMgKHJlcXVlc3QsIHsgYWJvcnRTaWduYWwgfSkgPT4ge1xuICAgICAgY29uc3QgY2xpZW50T3B0ID0geyAuLi5jbGllbnRPcHRpb25zLCBzaWduYWw6IGFib3J0U2lnbmFsIH07XG4gICAgICBjb25zdCBseXJpYVByZWRpY3RSZXF1ZXN0ID0gKDAsIGltcG9ydF9jb252ZXJ0ZXJzLnRvTHlyaWFQcmVkaWN0UmVxdWVzdCkocmVxdWVzdCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0ICgwLCBpbXBvcnRfY2xpZW50Lmx5cmlhUHJlZGljdCkoXG4gICAgICAgICgwLCBpbXBvcnRfdXRpbHMuZXh0cmFjdFZlcnNpb24pKHJlZiksXG4gICAgICAgIGx5cmlhUHJlZGljdFJlcXVlc3QsXG4gICAgICAgIGNsaWVudE9wdFxuICAgICAgKTtcbiAgICAgIGlmICghcmVzcG9uc2UucHJlZGljdGlvbnMgfHwgcmVzcG9uc2UucHJlZGljdGlvbnMubGVuZ3RoID09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiTW9kZWwgcmV0dXJuZWQgbm8gcHJlZGljdGlvbnMuIFBvc3NpYmx5IGR1ZSB0byBjb250ZW50IGZpbHRlcnMuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoMCwgaW1wb3J0X2NvbnZlcnRlcnMuZnJvbUx5cmlhUmVzcG9uc2UpKHJlc3BvbnNlLCByZXF1ZXN0KTtcbiAgICB9XG4gICk7XG59XG5jb25zdCBURVNUX09OTFkgPSB7XG4gIEdFTkVSSUNfTU9ERUwsXG4gIEtOT1dOX01PREVMU1xufTtcbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBMeXJpYUNvbmZpZ1NjaGVtYSxcbiAgVEVTVF9PTkxZLFxuICBkZWZpbmVLbm93bk1vZGVscyxcbiAgZGVmaW5lTW9kZWwsXG4gIGlzTHlyaWFNb2RlbE5hbWUsXG4gIGxpc3RBY3Rpb25zLFxuICBtb2RlbFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1seXJpYS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/lyria.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/types.js":
/*!********************************************************************!*\
  !*** ./node_modules/@genkit-ai/google-genai/lib/vertexai/types.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar types_exports = {};\n__export(types_exports, {\n  FunctionCallingMode: () => import_types.FunctionCallingMode,\n  HarmBlockThreshold: () => import_types.HarmBlockThreshold,\n  HarmCategory: () => import_types.HarmCategory,\n  TaskTypeSchema: () => import_types.TaskTypeSchema,\n  isCodeExecutionTool: () => import_types.isCodeExecutionTool,\n  isFunctionDeclarationsTool: () => import_types.isFunctionDeclarationsTool,\n  isGoogleSearchRetrievalTool: () => import_types.isGoogleSearchRetrievalTool,\n  isMultimodalEmbeddingPrediction: () => isMultimodalEmbeddingPrediction,\n  isObject: () => import_types.isObject,\n  isRetrievalTool: () => import_types.isRetrievalTool\n});\nmodule.exports = __toCommonJS(types_exports);\nvar import_types = __webpack_require__(/*! ../common/types.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/common/types.js\");\nfunction isMultimodalEmbeddingPrediction(value) {\n  if (!(0, import_types.isObject)(value)) {\n    return false;\n  }\n  if (!value.textEmbedding && !value.imageEmbedding && !value.videoEmbeddings) {\n    return false;\n  }\n  if (value.textEmbedding && !Array.isArray(value.textEmbedding)) {\n    return false;\n  }\n  if (value.imageEmbedding && !Array.isArray(value.imageEmbedding)) {\n    return false;\n  }\n  if (value.videoEmbeddings && !Array.isArray(value.videoEmbeddings)) {\n    return false;\n  }\n  if (value.videoEmbeddings) {\n    for (const emb of value.videoEmbeddings) {\n      if (!(0, import_types.isObject)(emb)) {\n        return false;\n      }\n      if (!emb.embedding || !Array.isArray(emb.embedding)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2dvb2dsZS1nZW5haS9saWIvdmVydGV4YWkvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyx1R0FBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FXTDtBQUNEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEtSYW1hY2hhXFxEb2N1bWVudHNcXFN1c3RBSW5leCBHSXQgQ29kZVxcbm9kZV9tb2R1bGVzXFxAZ2Vua2l0LWFpXFxnb29nbGUtZ2VuYWlcXGxpYlxcdmVydGV4YWlcXHR5cGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciB0eXBlc19leHBvcnRzID0ge307XG5fX2V4cG9ydCh0eXBlc19leHBvcnRzLCB7XG4gIEZ1bmN0aW9uQ2FsbGluZ01vZGU6ICgpID0+IGltcG9ydF90eXBlcy5GdW5jdGlvbkNhbGxpbmdNb2RlLFxuICBIYXJtQmxvY2tUaHJlc2hvbGQ6ICgpID0+IGltcG9ydF90eXBlcy5IYXJtQmxvY2tUaHJlc2hvbGQsXG4gIEhhcm1DYXRlZ29yeTogKCkgPT4gaW1wb3J0X3R5cGVzLkhhcm1DYXRlZ29yeSxcbiAgVGFza1R5cGVTY2hlbWE6ICgpID0+IGltcG9ydF90eXBlcy5UYXNrVHlwZVNjaGVtYSxcbiAgaXNDb2RlRXhlY3V0aW9uVG9vbDogKCkgPT4gaW1wb3J0X3R5cGVzLmlzQ29kZUV4ZWN1dGlvblRvb2wsXG4gIGlzRnVuY3Rpb25EZWNsYXJhdGlvbnNUb29sOiAoKSA9PiBpbXBvcnRfdHlwZXMuaXNGdW5jdGlvbkRlY2xhcmF0aW9uc1Rvb2wsXG4gIGlzR29vZ2xlU2VhcmNoUmV0cmlldmFsVG9vbDogKCkgPT4gaW1wb3J0X3R5cGVzLmlzR29vZ2xlU2VhcmNoUmV0cmlldmFsVG9vbCxcbiAgaXNNdWx0aW1vZGFsRW1iZWRkaW5nUHJlZGljdGlvbjogKCkgPT4gaXNNdWx0aW1vZGFsRW1iZWRkaW5nUHJlZGljdGlvbixcbiAgaXNPYmplY3Q6ICgpID0+IGltcG9ydF90eXBlcy5pc09iamVjdCxcbiAgaXNSZXRyaWV2YWxUb29sOiAoKSA9PiBpbXBvcnRfdHlwZXMuaXNSZXRyaWV2YWxUb29sXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHR5cGVzX2V4cG9ydHMpO1xudmFyIGltcG9ydF90eXBlcyA9IHJlcXVpcmUoXCIuLi9jb21tb24vdHlwZXMuanNcIik7XG5mdW5jdGlvbiBpc011bHRpbW9kYWxFbWJlZGRpbmdQcmVkaWN0aW9uKHZhbHVlKSB7XG4gIGlmICghKDAsIGltcG9ydF90eXBlcy5pc09iamVjdCkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghdmFsdWUudGV4dEVtYmVkZGluZyAmJiAhdmFsdWUuaW1hZ2VFbWJlZGRpbmcgJiYgIXZhbHVlLnZpZGVvRW1iZWRkaW5ncykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodmFsdWUudGV4dEVtYmVkZGluZyAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZS50ZXh0RW1iZWRkaW5nKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodmFsdWUuaW1hZ2VFbWJlZGRpbmcgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUuaW1hZ2VFbWJlZGRpbmcpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh2YWx1ZS52aWRlb0VtYmVkZGluZ3MgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUudmlkZW9FbWJlZGRpbmdzKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodmFsdWUudmlkZW9FbWJlZGRpbmdzKSB7XG4gICAgZm9yIChjb25zdCBlbWIgb2YgdmFsdWUudmlkZW9FbWJlZGRpbmdzKSB7XG4gICAgICBpZiAoISgwLCBpbXBvcnRfdHlwZXMuaXNPYmplY3QpKGVtYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFlbWIuZW1iZWRkaW5nIHx8ICFBcnJheS5pc0FycmF5KGVtYi5lbWJlZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgRnVuY3Rpb25DYWxsaW5nTW9kZSxcbiAgSGFybUJsb2NrVGhyZXNob2xkLFxuICBIYXJtQ2F0ZWdvcnksXG4gIFRhc2tUeXBlU2NoZW1hLFxuICBpc0NvZGVFeGVjdXRpb25Ub29sLFxuICBpc0Z1bmN0aW9uRGVjbGFyYXRpb25zVG9vbCxcbiAgaXNHb29nbGVTZWFyY2hSZXRyaWV2YWxUb29sLFxuICBpc011bHRpbW9kYWxFbWJlZGRpbmdQcmVkaWN0aW9uLFxuICBpc09iamVjdCxcbiAgaXNSZXRyaWV2YWxUb29sXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/types.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/utils.js":
/*!********************************************************************!*\
  !*** ./node_modules/@genkit-ai/google-genai/lib/vertexai/utils.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar utils_exports = {};\n__export(utils_exports, {\n  API_KEY_FALSE_ERROR: () => API_KEY_FALSE_ERROR,\n  MISSING_API_KEY_ERROR: () => MISSING_API_KEY_ERROR,\n  NOT_SUPPORTED_IN_EXPRESS_ERROR: () => NOT_SUPPORTED_IN_EXPRESS_ERROR,\n  TEST_ONLY: () => TEST_ONLY,\n  calculateApiKey: () => calculateApiKey,\n  checkApiKey: () => checkApiKey,\n  checkModelName: () => import_utils.checkModelName,\n  checkSupportedMimeType: () => import_utils.checkSupportedMimeType,\n  checkSupportedResourceMethod: () => checkSupportedResourceMethod,\n  cleanSchema: () => import_utils.cleanSchema,\n  extractMedia: () => import_utils.extractMedia,\n  extractMimeType: () => import_utils.extractMimeType,\n  extractText: () => import_utils.extractText,\n  extractVersion: () => import_utils.extractVersion,\n  getApiKeyFromEnvVar: () => getApiKeyFromEnvVar,\n  getDerivedOptions: () => getDerivedOptions,\n  modelName: () => import_utils.modelName\n});\nmodule.exports = __toCommonJS(utils_exports);\nvar import_genkit = __webpack_require__(/*! genkit */ \"(action-browser)/./node_modules/genkit/lib/index.js\");\nvar import_google_auth_library = __webpack_require__(/*! google-auth-library */ \"(action-browser)/./node_modules/google-auth-library/build/src/index.js\");\nvar import_utils = __webpack_require__(/*! ../common/utils.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/common/utils.js\");\nconst CLOUD_PLATFORM_OAUTH_SCOPE = \"https://www.googleapis.com/auth/cloud-platform\";\nfunction parseFirebaseProjectId() {\n  if (!process.env.FIREBASE_CONFIG) return void 0;\n  try {\n    return JSON.parse(process.env.FIREBASE_CONFIG).projectId;\n  } catch {\n    return void 0;\n  }\n}\nlet __mockDerivedOptions = void 0;\nfunction setMockDerivedOptions(options) {\n  __mockDerivedOptions = options;\n}\nconst TEST_ONLY = { setMockDerivedOptions };\nasync function getDerivedOptions(options, AuthClass = import_google_auth_library.GoogleAuth) {\n  if (__mockDerivedOptions) {\n    return Promise.resolve(__mockDerivedOptions);\n  }\n  if (options?.location == \"global\") {\n    return await getGlobalDerivedOptions(AuthClass, options);\n  } else if (options?.location) {\n    return await getRegionalDerivedOptions(AuthClass, options);\n  } else if (options?.apiKey !== void 0) {\n    return getExpressDerivedOptions(options);\n  }\n  try {\n    const regionalOptions = await getRegionalDerivedOptions(AuthClass, options);\n    return regionalOptions;\n  } catch (e) {\n  }\n  try {\n    const globalOptions = await getGlobalDerivedOptions(AuthClass, options);\n    return globalOptions;\n  } catch (e) {\n  }\n  try {\n    const expressOptions = getExpressDerivedOptions(options);\n    return expressOptions;\n  } catch (e) {\n  }\n  throw new import_genkit.GenkitError({\n    status: \"INVALID_ARGUMENT\",\n    message: \"Unable to determine client options. Please set either apiKey or projectId and location\"\n  });\n}\nasync function getGlobalDerivedOptions(AuthClass, options) {\n  let authOptions = options?.googleAuth;\n  let authClient;\n  const providedProjectId = options?.projectId || process.env.GCLOUD_PROJECT || parseFirebaseProjectId();\n  if (process.env.GCLOUD_SERVICE_ACCOUNT_CREDS) {\n    const serviceAccountCreds = JSON.parse(\n      process.env.GCLOUD_SERVICE_ACCOUNT_CREDS\n    );\n    authOptions = {\n      credentials: serviceAccountCreds,\n      scopes: [CLOUD_PLATFORM_OAUTH_SCOPE],\n      projectId: providedProjectId\n    };\n    authClient = new AuthClass(authOptions);\n  } else {\n    authClient = new AuthClass(\n      authOptions ?? {\n        scopes: [CLOUD_PLATFORM_OAUTH_SCOPE],\n        projectId: providedProjectId\n      }\n    );\n  }\n  const projectId = options?.projectId || process.env.GCLOUD_PROJECT || await authClient.getProjectId();\n  if (!projectId) {\n    throw new Error(\n      `VertexAI Plugin is missing the 'project' configuration. Please set the 'GCLOUD_PROJECT' environment variable or explicitly pass 'project' into genkit config.`\n    );\n  }\n  const clientOpt = {\n    kind: \"global\",\n    location: \"global\",\n    projectId,\n    authClient\n  };\n  if (options?.apiKey) {\n    clientOpt.apiKey = options.apiKey;\n  }\n  return clientOpt;\n}\nfunction getExpressDerivedOptions(options) {\n  const apiKey = checkApiKey(options?.apiKey);\n  return {\n    kind: \"express\",\n    apiKey\n  };\n}\nasync function getRegionalDerivedOptions(AuthClass, options) {\n  let authOptions = options?.googleAuth;\n  let authClient;\n  const providedProjectId = options?.projectId || process.env.GCLOUD_PROJECT || parseFirebaseProjectId();\n  if (process.env.GCLOUD_SERVICE_ACCOUNT_CREDS) {\n    const serviceAccountCreds = JSON.parse(\n      process.env.GCLOUD_SERVICE_ACCOUNT_CREDS\n    );\n    authOptions = {\n      credentials: serviceAccountCreds,\n      scopes: [CLOUD_PLATFORM_OAUTH_SCOPE],\n      projectId: providedProjectId\n    };\n    authClient = new AuthClass(authOptions);\n  } else {\n    authClient = new AuthClass(\n      authOptions ?? {\n        scopes: [CLOUD_PLATFORM_OAUTH_SCOPE],\n        projectId: providedProjectId\n      }\n    );\n  }\n  const projectId = options?.projectId || process.env.GCLOUD_PROJECT || await authClient.getProjectId();\n  const location = options?.location || process.env.GCLOUD_LOCATION || \"us-central1\";\n  if (!location) {\n    throw new Error(\n      `VertexAI Plugin is missing the 'location' configuration. Please set the 'GCLOUD_LOCATION' environment variable or explicitly pass 'location' into genkit config.`\n    );\n  }\n  if (!projectId) {\n    throw new Error(\n      `VertexAI Plugin is missing the 'project' configuration. Please set the 'GCLOUD_PROJECT' environment variable or explicitly pass 'project' into genkit config.`\n    );\n  }\n  const clientOpt = {\n    kind: \"regional\",\n    location,\n    projectId,\n    authClient\n  };\n  if (options?.apiKey) {\n    clientOpt.apiKey = options.apiKey;\n  }\n  return clientOpt;\n}\nfunction getApiKeyFromEnvVar() {\n  return process.env.VERTEX_API_KEY || process.env.GOOGLE_API_KEY || process.env.GOOGLE_GENAI_API_KEY;\n}\nconst MISSING_API_KEY_ERROR = new import_genkit.GenkitError({\n  status: \"FAILED_PRECONDITION\",\n  message: \"Please pass in the API key or set the VERTEX_API_KEY or GOOGLE_API_KEY environment variable.\\nFor more details see https://firebase.google.com/docs/genkit/plugins/google-genai\"\n});\nconst API_KEY_FALSE_ERROR = new import_genkit.GenkitError({\n  status: \"INVALID_ARGUMENT\",\n  message: \"VertexAI plugin was initialized with {apiKey: false} but no apiKey configuration was passed at call time.\"\n});\nconst NOT_SUPPORTED_IN_EXPRESS_ERROR = new import_genkit.GenkitError({\n  status: \"PERMISSION_DENIED\",\n  message: \"This method or model is not supported in Vertex AI Express Mode.\\nFor more details see https://cloud.google.com/vertex-ai/generative-ai/docs/start/express-mode/vertex-ai-express-mode-api-reference\"\n});\nfunction checkApiKey(pluginApiKey) {\n  let apiKey;\n  if (pluginApiKey !== false) {\n    apiKey = pluginApiKey || getApiKeyFromEnvVar();\n  }\n  if (pluginApiKey !== false && !apiKey) {\n    throw MISSING_API_KEY_ERROR;\n  }\n  return apiKey;\n}\nfunction calculateApiKey(pluginApiKey, requestApiKey) {\n  let apiKey;\n  if (pluginApiKey !== false) {\n    apiKey = pluginApiKey || getApiKeyFromEnvVar();\n  }\n  apiKey = requestApiKey || apiKey;\n  if (pluginApiKey === false && !requestApiKey) {\n    throw API_KEY_FALSE_ERROR;\n  }\n  if (!apiKey) {\n    throw MISSING_API_KEY_ERROR;\n  }\n  return apiKey;\n}\nfunction checkSupportedResourceMethod(params) {\n  if (params.resourcePath == \"\") {\n    return;\n  }\n  const supportedExpressMethods = [\n    \"countTokens\",\n    \"generateContent\",\n    \"streamGenerateContent\"\n  ];\n  if (params.clientOptions.kind === \"express\" && (!supportedExpressMethods.includes(params.resourceMethod ?? \"\") || params.resourcePath?.includes(\"endpoints/\"))) {\n    throw NOT_SUPPORTED_IN_EXPRESS_ERROR;\n  }\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2dvb2dsZS1nZW5haS9saWIvdmVydGV4YWkvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLG1FQUFRO0FBQ3BDLGlDQUFpQyxtQkFBTyxDQUFDLG1HQUFxQjtBQUM5RCxtQkFBbUIsbUJBQU8sQ0FBQyx1R0FBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGVBQWU7QUFDakUsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQWtCTDtBQUNEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEtSYW1hY2hhXFxEb2N1bWVudHNcXFN1c3RBSW5leCBHSXQgQ29kZVxcbm9kZV9tb2R1bGVzXFxAZ2Vua2l0LWFpXFxnb29nbGUtZ2VuYWlcXGxpYlxcdmVydGV4YWlcXHV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciB1dGlsc19leHBvcnRzID0ge307XG5fX2V4cG9ydCh1dGlsc19leHBvcnRzLCB7XG4gIEFQSV9LRVlfRkFMU0VfRVJST1I6ICgpID0+IEFQSV9LRVlfRkFMU0VfRVJST1IsXG4gIE1JU1NJTkdfQVBJX0tFWV9FUlJPUjogKCkgPT4gTUlTU0lOR19BUElfS0VZX0VSUk9SLFxuICBOT1RfU1VQUE9SVEVEX0lOX0VYUFJFU1NfRVJST1I6ICgpID0+IE5PVF9TVVBQT1JURURfSU5fRVhQUkVTU19FUlJPUixcbiAgVEVTVF9PTkxZOiAoKSA9PiBURVNUX09OTFksXG4gIGNhbGN1bGF0ZUFwaUtleTogKCkgPT4gY2FsY3VsYXRlQXBpS2V5LFxuICBjaGVja0FwaUtleTogKCkgPT4gY2hlY2tBcGlLZXksXG4gIGNoZWNrTW9kZWxOYW1lOiAoKSA9PiBpbXBvcnRfdXRpbHMuY2hlY2tNb2RlbE5hbWUsXG4gIGNoZWNrU3VwcG9ydGVkTWltZVR5cGU6ICgpID0+IGltcG9ydF91dGlscy5jaGVja1N1cHBvcnRlZE1pbWVUeXBlLFxuICBjaGVja1N1cHBvcnRlZFJlc291cmNlTWV0aG9kOiAoKSA9PiBjaGVja1N1cHBvcnRlZFJlc291cmNlTWV0aG9kLFxuICBjbGVhblNjaGVtYTogKCkgPT4gaW1wb3J0X3V0aWxzLmNsZWFuU2NoZW1hLFxuICBleHRyYWN0TWVkaWE6ICgpID0+IGltcG9ydF91dGlscy5leHRyYWN0TWVkaWEsXG4gIGV4dHJhY3RNaW1lVHlwZTogKCkgPT4gaW1wb3J0X3V0aWxzLmV4dHJhY3RNaW1lVHlwZSxcbiAgZXh0cmFjdFRleHQ6ICgpID0+IGltcG9ydF91dGlscy5leHRyYWN0VGV4dCxcbiAgZXh0cmFjdFZlcnNpb246ICgpID0+IGltcG9ydF91dGlscy5leHRyYWN0VmVyc2lvbixcbiAgZ2V0QXBpS2V5RnJvbUVudlZhcjogKCkgPT4gZ2V0QXBpS2V5RnJvbUVudlZhcixcbiAgZ2V0RGVyaXZlZE9wdGlvbnM6ICgpID0+IGdldERlcml2ZWRPcHRpb25zLFxuICBtb2RlbE5hbWU6ICgpID0+IGltcG9ydF91dGlscy5tb2RlbE5hbWVcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlModXRpbHNfZXhwb3J0cyk7XG52YXIgaW1wb3J0X2dlbmtpdCA9IHJlcXVpcmUoXCJnZW5raXRcIik7XG52YXIgaW1wb3J0X2dvb2dsZV9hdXRoX2xpYnJhcnkgPSByZXF1aXJlKFwiZ29vZ2xlLWF1dGgtbGlicmFyeVwiKTtcbnZhciBpbXBvcnRfdXRpbHMgPSByZXF1aXJlKFwiLi4vY29tbW9uL3V0aWxzLmpzXCIpO1xuY29uc3QgQ0xPVURfUExBVEZPUk1fT0FVVEhfU0NPUEUgPSBcImh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvY2xvdWQtcGxhdGZvcm1cIjtcbmZ1bmN0aW9uIHBhcnNlRmlyZWJhc2VQcm9qZWN0SWQoKSB7XG4gIGlmICghcHJvY2Vzcy5lbnYuRklSRUJBU0VfQ09ORklHKSByZXR1cm4gdm9pZCAwO1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHByb2Nlc3MuZW52LkZJUkVCQVNFX0NPTkZJRykucHJvamVjdElkO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59XG5sZXQgX19tb2NrRGVyaXZlZE9wdGlvbnMgPSB2b2lkIDA7XG5mdW5jdGlvbiBzZXRNb2NrRGVyaXZlZE9wdGlvbnMob3B0aW9ucykge1xuICBfX21vY2tEZXJpdmVkT3B0aW9ucyA9IG9wdGlvbnM7XG59XG5jb25zdCBURVNUX09OTFkgPSB7IHNldE1vY2tEZXJpdmVkT3B0aW9ucyB9O1xuYXN5bmMgZnVuY3Rpb24gZ2V0RGVyaXZlZE9wdGlvbnMob3B0aW9ucywgQXV0aENsYXNzID0gaW1wb3J0X2dvb2dsZV9hdXRoX2xpYnJhcnkuR29vZ2xlQXV0aCkge1xuICBpZiAoX19tb2NrRGVyaXZlZE9wdGlvbnMpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKF9fbW9ja0Rlcml2ZWRPcHRpb25zKTtcbiAgfVxuICBpZiAob3B0aW9ucz8ubG9jYXRpb24gPT0gXCJnbG9iYWxcIikge1xuICAgIHJldHVybiBhd2FpdCBnZXRHbG9iYWxEZXJpdmVkT3B0aW9ucyhBdXRoQ2xhc3MsIG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKG9wdGlvbnM/LmxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGF3YWl0IGdldFJlZ2lvbmFsRGVyaXZlZE9wdGlvbnMoQXV0aENsYXNzLCBvcHRpb25zKTtcbiAgfSBlbHNlIGlmIChvcHRpb25zPy5hcGlLZXkgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBnZXRFeHByZXNzRGVyaXZlZE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCByZWdpb25hbE9wdGlvbnMgPSBhd2FpdCBnZXRSZWdpb25hbERlcml2ZWRPcHRpb25zKEF1dGhDbGFzcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlZ2lvbmFsT3B0aW9ucztcbiAgfSBjYXRjaCAoZSkge1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgZ2xvYmFsT3B0aW9ucyA9IGF3YWl0IGdldEdsb2JhbERlcml2ZWRPcHRpb25zKEF1dGhDbGFzcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGdsb2JhbE9wdGlvbnM7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IGV4cHJlc3NPcHRpb25zID0gZ2V0RXhwcmVzc0Rlcml2ZWRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHJldHVybiBleHByZXNzT3B0aW9ucztcbiAgfSBjYXRjaCAoZSkge1xuICB9XG4gIHRocm93IG5ldyBpbXBvcnRfZ2Vua2l0LkdlbmtpdEVycm9yKHtcbiAgICBzdGF0dXM6IFwiSU5WQUxJRF9BUkdVTUVOVFwiLFxuICAgIG1lc3NhZ2U6IFwiVW5hYmxlIHRvIGRldGVybWluZSBjbGllbnQgb3B0aW9ucy4gUGxlYXNlIHNldCBlaXRoZXIgYXBpS2V5IG9yIHByb2plY3RJZCBhbmQgbG9jYXRpb25cIlxuICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEdsb2JhbERlcml2ZWRPcHRpb25zKEF1dGhDbGFzcywgb3B0aW9ucykge1xuICBsZXQgYXV0aE9wdGlvbnMgPSBvcHRpb25zPy5nb29nbGVBdXRoO1xuICBsZXQgYXV0aENsaWVudDtcbiAgY29uc3QgcHJvdmlkZWRQcm9qZWN0SWQgPSBvcHRpb25zPy5wcm9qZWN0SWQgfHwgcHJvY2Vzcy5lbnYuR0NMT1VEX1BST0pFQ1QgfHwgcGFyc2VGaXJlYmFzZVByb2plY3RJZCgpO1xuICBpZiAocHJvY2Vzcy5lbnYuR0NMT1VEX1NFUlZJQ0VfQUNDT1VOVF9DUkVEUykge1xuICAgIGNvbnN0IHNlcnZpY2VBY2NvdW50Q3JlZHMgPSBKU09OLnBhcnNlKFxuICAgICAgcHJvY2Vzcy5lbnYuR0NMT1VEX1NFUlZJQ0VfQUNDT1VOVF9DUkVEU1xuICAgICk7XG4gICAgYXV0aE9wdGlvbnMgPSB7XG4gICAgICBjcmVkZW50aWFsczogc2VydmljZUFjY291bnRDcmVkcyxcbiAgICAgIHNjb3BlczogW0NMT1VEX1BMQVRGT1JNX09BVVRIX1NDT1BFXSxcbiAgICAgIHByb2plY3RJZDogcHJvdmlkZWRQcm9qZWN0SWRcbiAgICB9O1xuICAgIGF1dGhDbGllbnQgPSBuZXcgQXV0aENsYXNzKGF1dGhPcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBhdXRoQ2xpZW50ID0gbmV3IEF1dGhDbGFzcyhcbiAgICAgIGF1dGhPcHRpb25zID8/IHtcbiAgICAgICAgc2NvcGVzOiBbQ0xPVURfUExBVEZPUk1fT0FVVEhfU0NPUEVdLFxuICAgICAgICBwcm9qZWN0SWQ6IHByb3ZpZGVkUHJvamVjdElkXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBjb25zdCBwcm9qZWN0SWQgPSBvcHRpb25zPy5wcm9qZWN0SWQgfHwgcHJvY2Vzcy5lbnYuR0NMT1VEX1BST0pFQ1QgfHwgYXdhaXQgYXV0aENsaWVudC5nZXRQcm9qZWN0SWQoKTtcbiAgaWYgKCFwcm9qZWN0SWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVmVydGV4QUkgUGx1Z2luIGlzIG1pc3NpbmcgdGhlICdwcm9qZWN0JyBjb25maWd1cmF0aW9uLiBQbGVhc2Ugc2V0IHRoZSAnR0NMT1VEX1BST0pFQ1QnIGVudmlyb25tZW50IHZhcmlhYmxlIG9yIGV4cGxpY2l0bHkgcGFzcyAncHJvamVjdCcgaW50byBnZW5raXQgY29uZmlnLmBcbiAgICApO1xuICB9XG4gIGNvbnN0IGNsaWVudE9wdCA9IHtcbiAgICBraW5kOiBcImdsb2JhbFwiLFxuICAgIGxvY2F0aW9uOiBcImdsb2JhbFwiLFxuICAgIHByb2plY3RJZCxcbiAgICBhdXRoQ2xpZW50XG4gIH07XG4gIGlmIChvcHRpb25zPy5hcGlLZXkpIHtcbiAgICBjbGllbnRPcHQuYXBpS2V5ID0gb3B0aW9ucy5hcGlLZXk7XG4gIH1cbiAgcmV0dXJuIGNsaWVudE9wdDtcbn1cbmZ1bmN0aW9uIGdldEV4cHJlc3NEZXJpdmVkT3B0aW9ucyhvcHRpb25zKSB7XG4gIGNvbnN0IGFwaUtleSA9IGNoZWNrQXBpS2V5KG9wdGlvbnM/LmFwaUtleSk7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJleHByZXNzXCIsXG4gICAgYXBpS2V5XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBnZXRSZWdpb25hbERlcml2ZWRPcHRpb25zKEF1dGhDbGFzcywgb3B0aW9ucykge1xuICBsZXQgYXV0aE9wdGlvbnMgPSBvcHRpb25zPy5nb29nbGVBdXRoO1xuICBsZXQgYXV0aENsaWVudDtcbiAgY29uc3QgcHJvdmlkZWRQcm9qZWN0SWQgPSBvcHRpb25zPy5wcm9qZWN0SWQgfHwgcHJvY2Vzcy5lbnYuR0NMT1VEX1BST0pFQ1QgfHwgcGFyc2VGaXJlYmFzZVByb2plY3RJZCgpO1xuICBpZiAocHJvY2Vzcy5lbnYuR0NMT1VEX1NFUlZJQ0VfQUNDT1VOVF9DUkVEUykge1xuICAgIGNvbnN0IHNlcnZpY2VBY2NvdW50Q3JlZHMgPSBKU09OLnBhcnNlKFxuICAgICAgcHJvY2Vzcy5lbnYuR0NMT1VEX1NFUlZJQ0VfQUNDT1VOVF9DUkVEU1xuICAgICk7XG4gICAgYXV0aE9wdGlvbnMgPSB7XG4gICAgICBjcmVkZW50aWFsczogc2VydmljZUFjY291bnRDcmVkcyxcbiAgICAgIHNjb3BlczogW0NMT1VEX1BMQVRGT1JNX09BVVRIX1NDT1BFXSxcbiAgICAgIHByb2plY3RJZDogcHJvdmlkZWRQcm9qZWN0SWRcbiAgICB9O1xuICAgIGF1dGhDbGllbnQgPSBuZXcgQXV0aENsYXNzKGF1dGhPcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBhdXRoQ2xpZW50ID0gbmV3IEF1dGhDbGFzcyhcbiAgICAgIGF1dGhPcHRpb25zID8/IHtcbiAgICAgICAgc2NvcGVzOiBbQ0xPVURfUExBVEZPUk1fT0FVVEhfU0NPUEVdLFxuICAgICAgICBwcm9qZWN0SWQ6IHByb3ZpZGVkUHJvamVjdElkXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBjb25zdCBwcm9qZWN0SWQgPSBvcHRpb25zPy5wcm9qZWN0SWQgfHwgcHJvY2Vzcy5lbnYuR0NMT1VEX1BST0pFQ1QgfHwgYXdhaXQgYXV0aENsaWVudC5nZXRQcm9qZWN0SWQoKTtcbiAgY29uc3QgbG9jYXRpb24gPSBvcHRpb25zPy5sb2NhdGlvbiB8fCBwcm9jZXNzLmVudi5HQ0xPVURfTE9DQVRJT04gfHwgXCJ1cy1jZW50cmFsMVwiO1xuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFZlcnRleEFJIFBsdWdpbiBpcyBtaXNzaW5nIHRoZSAnbG9jYXRpb24nIGNvbmZpZ3VyYXRpb24uIFBsZWFzZSBzZXQgdGhlICdHQ0xPVURfTE9DQVRJT04nIGVudmlyb25tZW50IHZhcmlhYmxlIG9yIGV4cGxpY2l0bHkgcGFzcyAnbG9jYXRpb24nIGludG8gZ2Vua2l0IGNvbmZpZy5gXG4gICAgKTtcbiAgfVxuICBpZiAoIXByb2plY3RJZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBWZXJ0ZXhBSSBQbHVnaW4gaXMgbWlzc2luZyB0aGUgJ3Byb2plY3QnIGNvbmZpZ3VyYXRpb24uIFBsZWFzZSBzZXQgdGhlICdHQ0xPVURfUFJPSkVDVCcgZW52aXJvbm1lbnQgdmFyaWFibGUgb3IgZXhwbGljaXRseSBwYXNzICdwcm9qZWN0JyBpbnRvIGdlbmtpdCBjb25maWcuYFxuICAgICk7XG4gIH1cbiAgY29uc3QgY2xpZW50T3B0ID0ge1xuICAgIGtpbmQ6IFwicmVnaW9uYWxcIixcbiAgICBsb2NhdGlvbixcbiAgICBwcm9qZWN0SWQsXG4gICAgYXV0aENsaWVudFxuICB9O1xuICBpZiAob3B0aW9ucz8uYXBpS2V5KSB7XG4gICAgY2xpZW50T3B0LmFwaUtleSA9IG9wdGlvbnMuYXBpS2V5O1xuICB9XG4gIHJldHVybiBjbGllbnRPcHQ7XG59XG5mdW5jdGlvbiBnZXRBcGlLZXlGcm9tRW52VmFyKCkge1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuVkVSVEVYX0FQSV9LRVkgfHwgcHJvY2Vzcy5lbnYuR09PR0xFX0FQSV9LRVkgfHwgcHJvY2Vzcy5lbnYuR09PR0xFX0dFTkFJX0FQSV9LRVk7XG59XG5jb25zdCBNSVNTSU5HX0FQSV9LRVlfRVJST1IgPSBuZXcgaW1wb3J0X2dlbmtpdC5HZW5raXRFcnJvcih7XG4gIHN0YXR1czogXCJGQUlMRURfUFJFQ09ORElUSU9OXCIsXG4gIG1lc3NhZ2U6IFwiUGxlYXNlIHBhc3MgaW4gdGhlIEFQSSBrZXkgb3Igc2V0IHRoZSBWRVJURVhfQVBJX0tFWSBvciBHT09HTEVfQVBJX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZS5cXG5Gb3IgbW9yZSBkZXRhaWxzIHNlZSBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9nZW5raXQvcGx1Z2lucy9nb29nbGUtZ2VuYWlcIlxufSk7XG5jb25zdCBBUElfS0VZX0ZBTFNFX0VSUk9SID0gbmV3IGltcG9ydF9nZW5raXQuR2Vua2l0RXJyb3Ioe1xuICBzdGF0dXM6IFwiSU5WQUxJRF9BUkdVTUVOVFwiLFxuICBtZXNzYWdlOiBcIlZlcnRleEFJIHBsdWdpbiB3YXMgaW5pdGlhbGl6ZWQgd2l0aCB7YXBpS2V5OiBmYWxzZX0gYnV0IG5vIGFwaUtleSBjb25maWd1cmF0aW9uIHdhcyBwYXNzZWQgYXQgY2FsbCB0aW1lLlwiXG59KTtcbmNvbnN0IE5PVF9TVVBQT1JURURfSU5fRVhQUkVTU19FUlJPUiA9IG5ldyBpbXBvcnRfZ2Vua2l0LkdlbmtpdEVycm9yKHtcbiAgc3RhdHVzOiBcIlBFUk1JU1NJT05fREVOSUVEXCIsXG4gIG1lc3NhZ2U6IFwiVGhpcyBtZXRob2Qgb3IgbW9kZWwgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkgRXhwcmVzcyBNb2RlLlxcbkZvciBtb3JlIGRldGFpbHMgc2VlIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS92ZXJ0ZXgtYWkvZ2VuZXJhdGl2ZS1haS9kb2NzL3N0YXJ0L2V4cHJlc3MtbW9kZS92ZXJ0ZXgtYWktZXhwcmVzcy1tb2RlLWFwaS1yZWZlcmVuY2VcIlxufSk7XG5mdW5jdGlvbiBjaGVja0FwaUtleShwbHVnaW5BcGlLZXkpIHtcbiAgbGV0IGFwaUtleTtcbiAgaWYgKHBsdWdpbkFwaUtleSAhPT0gZmFsc2UpIHtcbiAgICBhcGlLZXkgPSBwbHVnaW5BcGlLZXkgfHwgZ2V0QXBpS2V5RnJvbUVudlZhcigpO1xuICB9XG4gIGlmIChwbHVnaW5BcGlLZXkgIT09IGZhbHNlICYmICFhcGlLZXkpIHtcbiAgICB0aHJvdyBNSVNTSU5HX0FQSV9LRVlfRVJST1I7XG4gIH1cbiAgcmV0dXJuIGFwaUtleTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUFwaUtleShwbHVnaW5BcGlLZXksIHJlcXVlc3RBcGlLZXkpIHtcbiAgbGV0IGFwaUtleTtcbiAgaWYgKHBsdWdpbkFwaUtleSAhPT0gZmFsc2UpIHtcbiAgICBhcGlLZXkgPSBwbHVnaW5BcGlLZXkgfHwgZ2V0QXBpS2V5RnJvbUVudlZhcigpO1xuICB9XG4gIGFwaUtleSA9IHJlcXVlc3RBcGlLZXkgfHwgYXBpS2V5O1xuICBpZiAocGx1Z2luQXBpS2V5ID09PSBmYWxzZSAmJiAhcmVxdWVzdEFwaUtleSkge1xuICAgIHRocm93IEFQSV9LRVlfRkFMU0VfRVJST1I7XG4gIH1cbiAgaWYgKCFhcGlLZXkpIHtcbiAgICB0aHJvdyBNSVNTSU5HX0FQSV9LRVlfRVJST1I7XG4gIH1cbiAgcmV0dXJuIGFwaUtleTtcbn1cbmZ1bmN0aW9uIGNoZWNrU3VwcG9ydGVkUmVzb3VyY2VNZXRob2QocGFyYW1zKSB7XG4gIGlmIChwYXJhbXMucmVzb3VyY2VQYXRoID09IFwiXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc3VwcG9ydGVkRXhwcmVzc01ldGhvZHMgPSBbXG4gICAgXCJjb3VudFRva2Vuc1wiLFxuICAgIFwiZ2VuZXJhdGVDb250ZW50XCIsXG4gICAgXCJzdHJlYW1HZW5lcmF0ZUNvbnRlbnRcIlxuICBdO1xuICBpZiAocGFyYW1zLmNsaWVudE9wdGlvbnMua2luZCA9PT0gXCJleHByZXNzXCIgJiYgKCFzdXBwb3J0ZWRFeHByZXNzTWV0aG9kcy5pbmNsdWRlcyhwYXJhbXMucmVzb3VyY2VNZXRob2QgPz8gXCJcIikgfHwgcGFyYW1zLnJlc291cmNlUGF0aD8uaW5jbHVkZXMoXCJlbmRwb2ludHMvXCIpKSkge1xuICAgIHRocm93IE5PVF9TVVBQT1JURURfSU5fRVhQUkVTU19FUlJPUjtcbiAgfVxufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFQSV9LRVlfRkFMU0VfRVJST1IsXG4gIE1JU1NJTkdfQVBJX0tFWV9FUlJPUixcbiAgTk9UX1NVUFBPUlRFRF9JTl9FWFBSRVNTX0VSUk9SLFxuICBURVNUX09OTFksXG4gIGNhbGN1bGF0ZUFwaUtleSxcbiAgY2hlY2tBcGlLZXksXG4gIGNoZWNrTW9kZWxOYW1lLFxuICBjaGVja1N1cHBvcnRlZE1pbWVUeXBlLFxuICBjaGVja1N1cHBvcnRlZFJlc291cmNlTWV0aG9kLFxuICBjbGVhblNjaGVtYSxcbiAgZXh0cmFjdE1lZGlhLFxuICBleHRyYWN0TWltZVR5cGUsXG4gIGV4dHJhY3RUZXh0LFxuICBleHRyYWN0VmVyc2lvbixcbiAgZ2V0QXBpS2V5RnJvbUVudlZhcixcbiAgZ2V0RGVyaXZlZE9wdGlvbnMsXG4gIG1vZGVsTmFtZVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/utils.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/veo.js":
/*!******************************************************************!*\
  !*** ./node_modules/@genkit-ai/google-genai/lib/vertexai/veo.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar veo_exports = {};\n__export(veo_exports, {\n  TEST_ONLY: () => TEST_ONLY,\n  VeoConfigSchema: () => VeoConfigSchema,\n  defineKnownModels: () => defineKnownModels,\n  defineModel: () => defineModel,\n  isVeoModelName: () => isVeoModelName,\n  listActions: () => listActions,\n  model: () => model\n});\nmodule.exports = __toCommonJS(veo_exports);\nvar import_genkit = __webpack_require__(/*! genkit */ \"(action-browser)/./node_modules/genkit/lib/index.js\");\nvar import_client = __webpack_require__(/*! ./client.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/client.js\");\nvar import_converters = __webpack_require__(/*! ./converters.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/converters.js\");\nvar import_utils = __webpack_require__(/*! ./utils.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/utils.js\");\nconst VeoConfigSchema = import_genkit.z.object({\n  sampleCount: import_genkit.z.number().optional().describe(\"Number of output videos\"),\n  storageUri: import_genkit.z.string().optional().describe(\"The gcs bucket where to save the generated videos\"),\n  fps: import_genkit.z.number().optional().describe(\"Frames per second for video generation\"),\n  durationSeconds: import_genkit.z.number().optional().describe(\"Duration of the clip for video generation in seconds\"),\n  seed: import_genkit.z.number().optional().describe(\n    \"The RNG seed. If RNG seed is exactly same for each request with unchanged inputs, the prediction results will be consistent. Otherwise, a random RNG seed will be used each time to produce a different result. If the sample count is greater than 1, random seeds will be used for each sample.\"\n  ),\n  aspectRatio: import_genkit.z.enum([\"9:16\", \"16:9\"]).optional().describe(\"The aspect ratio for the generated video\"),\n  resolution: import_genkit.z.enum([\"720p\", \"1080p\"]).optional().describe(\"The resolution for the generated video\"),\n  personGeneration: import_genkit.z.enum([\"dont_allow\", \"allow_adult\", \"allow_all\"]).optional().describe(\n    \"Specifies the policy for generating persons in videos, including age restrictions\"\n  ),\n  pubsubTopic: import_genkit.z.string().optional().describe(\"The pubsub topic to publish the video generation progress to\"),\n  negativePrompt: import_genkit.z.string().optional().describe(\n    \"In addition to the text context, negative prompts can be explicitly stated here to help generate the video\"\n  ),\n  enhancePrompt: import_genkit.z.boolean().optional().describe(\n    \"If true, the prompt will be improved before it is used to generate videos. The RNG seed, if provided, will not result in consistent results if prompts are enhanced.\"\n  ),\n  generateAudio: import_genkit.z.boolean().optional().describe(\"If true, audio will be generated along with the video\"),\n  compressionQuality: import_genkit.z.enum([\"optimized\", \"lossless\"]).default(\"optimized\").optional().describe(\"Compression quality of the generated video\")\n}).passthrough();\nfunction commonRef(name, info, configSchema = VeoConfigSchema) {\n  return (0, import_genkit.modelRef)({\n    name: `vertexai/${name}`,\n    configSchema,\n    info: info ?? {\n      supports: {\n        media: true,\n        multiturn: false,\n        tools: false,\n        systemRole: false,\n        output: [\"media\"],\n        longRunning: true\n      }\n    }\n    // TODO(ifielker): Remove this cast if we fix longRunning\n  });\n}\nconst GENERIC_MODEL = commonRef(\"veo\");\nconst KNOWN_MODELS = {\n  \"veo-2.0-generate-001\": commonRef(\"veo-2.0-generate-001\"),\n  \"veo-3.0-generate-001\": commonRef(\"veo-3.0-generate-001\"),\n  \"veo-3.0-fast-generate-001\": commonRef(\"veo-3.0-fast-generate-001\"),\n  \"veo-3.0-generate-preview\": commonRef(\"veo-3.0-generate-preview\"),\n  \"veo-3.0-fast-generate-preview\": commonRef(\"veo-3.0-fast-generate-preview\")\n};\nfunction isVeoModelName(value) {\n  return !!value?.startsWith(\"veo-\");\n}\nfunction model(version, config = {}) {\n  const name = (0, import_utils.checkModelName)(version);\n  return (0, import_genkit.modelRef)({\n    name: `vertexai/${name}`,\n    config,\n    configSchema: VeoConfigSchema,\n    info: { ...GENERIC_MODEL.info }\n  });\n}\nfunction listActions(models) {\n  return models.filter((m) => isVeoModelName(m.name)).map((m) => {\n    const ref = model(m.name);\n    return (0, import_genkit.modelActionMetadata)({\n      name: ref.name,\n      info: ref.info,\n      configSchema: ref.configSchema\n    });\n  });\n}\nfunction defineKnownModels(ai, clientOptions, pluginOptions) {\n  for (const name of Object.keys(KNOWN_MODELS)) {\n    defineModel(ai, name, clientOptions, pluginOptions);\n  }\n}\nfunction defineModel(ai, name, clientOptions, pluginOptions) {\n  const ref = model(name);\n  return ai.defineBackgroundModel({\n    name: ref.name,\n    ...ref.info,\n    configSchema: ref.configSchema,\n    async start(request) {\n      const veoPredictRequest = (0, import_converters.toVeoPredictRequest)(request);\n      const response = await (0, import_client.veoPredict)(\n        (0, import_utils.extractVersion)(ref),\n        veoPredictRequest,\n        clientOptions\n      );\n      return (0, import_converters.fromVeoOperation)(response);\n    },\n    async check(operation) {\n      const response = await (0, import_client.veoCheckOperation)(\n        (0, import_converters.toVeoModel)(operation),\n        (0, import_converters.toVeoOperationRequest)(operation),\n        clientOptions\n      );\n      return (0, import_converters.fromVeoOperation)(response);\n    }\n  });\n}\nconst TEST_ONLY = {\n  GENERIC_MODEL,\n  KNOWN_MODELS\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=veo.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2dvb2dsZS1nZW5haS9saWIvdmVydGV4YWkvdmVvLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsbUVBQVE7QUFDcEMsb0JBQW9CLG1CQUFPLENBQUMsbUdBQWE7QUFDekMsd0JBQXdCLG1CQUFPLENBQUMsMkdBQWlCO0FBQ2pELG1CQUFtQixtQkFBTyxDQUFDLGlHQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSztBQUMzQjtBQUNBO0FBQ0EsWUFBWTtBQUNaLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQVFMO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcS1JhbWFjaGFcXERvY3VtZW50c1xcU3VzdEFJbmV4IEdJdCBDb2RlXFxub2RlX21vZHVsZXNcXEBnZW5raXQtYWlcXGdvb2dsZS1nZW5haVxcbGliXFx2ZXJ0ZXhhaVxcdmVvLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciB2ZW9fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodmVvX2V4cG9ydHMsIHtcbiAgVEVTVF9PTkxZOiAoKSA9PiBURVNUX09OTFksXG4gIFZlb0NvbmZpZ1NjaGVtYTogKCkgPT4gVmVvQ29uZmlnU2NoZW1hLFxuICBkZWZpbmVLbm93bk1vZGVsczogKCkgPT4gZGVmaW5lS25vd25Nb2RlbHMsXG4gIGRlZmluZU1vZGVsOiAoKSA9PiBkZWZpbmVNb2RlbCxcbiAgaXNWZW9Nb2RlbE5hbWU6ICgpID0+IGlzVmVvTW9kZWxOYW1lLFxuICBsaXN0QWN0aW9uczogKCkgPT4gbGlzdEFjdGlvbnMsXG4gIG1vZGVsOiAoKSA9PiBtb2RlbFxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyh2ZW9fZXhwb3J0cyk7XG52YXIgaW1wb3J0X2dlbmtpdCA9IHJlcXVpcmUoXCJnZW5raXRcIik7XG52YXIgaW1wb3J0X2NsaWVudCA9IHJlcXVpcmUoXCIuL2NsaWVudC5qc1wiKTtcbnZhciBpbXBvcnRfY29udmVydGVycyA9IHJlcXVpcmUoXCIuL2NvbnZlcnRlcnMuanNcIik7XG52YXIgaW1wb3J0X3V0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5jb25zdCBWZW9Db25maWdTY2hlbWEgPSBpbXBvcnRfZ2Vua2l0Lnoub2JqZWN0KHtcbiAgc2FtcGxlQ291bnQ6IGltcG9ydF9nZW5raXQuei5udW1iZXIoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiTnVtYmVyIG9mIG91dHB1dCB2aWRlb3NcIiksXG4gIHN0b3JhZ2VVcmk6IGltcG9ydF9nZW5raXQuei5zdHJpbmcoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiVGhlIGdjcyBidWNrZXQgd2hlcmUgdG8gc2F2ZSB0aGUgZ2VuZXJhdGVkIHZpZGVvc1wiKSxcbiAgZnBzOiBpbXBvcnRfZ2Vua2l0LnoubnVtYmVyKCkub3B0aW9uYWwoKS5kZXNjcmliZShcIkZyYW1lcyBwZXIgc2Vjb25kIGZvciB2aWRlbyBnZW5lcmF0aW9uXCIpLFxuICBkdXJhdGlvblNlY29uZHM6IGltcG9ydF9nZW5raXQuei5udW1iZXIoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiRHVyYXRpb24gb2YgdGhlIGNsaXAgZm9yIHZpZGVvIGdlbmVyYXRpb24gaW4gc2Vjb25kc1wiKSxcbiAgc2VlZDogaW1wb3J0X2dlbmtpdC56Lm51bWJlcigpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXG4gICAgXCJUaGUgUk5HIHNlZWQuIElmIFJORyBzZWVkIGlzIGV4YWN0bHkgc2FtZSBmb3IgZWFjaCByZXF1ZXN0IHdpdGggdW5jaGFuZ2VkIGlucHV0cywgdGhlIHByZWRpY3Rpb24gcmVzdWx0cyB3aWxsIGJlIGNvbnNpc3RlbnQuIE90aGVyd2lzZSwgYSByYW5kb20gUk5HIHNlZWQgd2lsbCBiZSB1c2VkIGVhY2ggdGltZSB0byBwcm9kdWNlIGEgZGlmZmVyZW50IHJlc3VsdC4gSWYgdGhlIHNhbXBsZSBjb3VudCBpcyBncmVhdGVyIHRoYW4gMSwgcmFuZG9tIHNlZWRzIHdpbGwgYmUgdXNlZCBmb3IgZWFjaCBzYW1wbGUuXCJcbiAgKSxcbiAgYXNwZWN0UmF0aW86IGltcG9ydF9nZW5raXQuei5lbnVtKFtcIjk6MTZcIiwgXCIxNjo5XCJdKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiVGhlIGFzcGVjdCByYXRpbyBmb3IgdGhlIGdlbmVyYXRlZCB2aWRlb1wiKSxcbiAgcmVzb2x1dGlvbjogaW1wb3J0X2dlbmtpdC56LmVudW0oW1wiNzIwcFwiLCBcIjEwODBwXCJdKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiVGhlIHJlc29sdXRpb24gZm9yIHRoZSBnZW5lcmF0ZWQgdmlkZW9cIiksXG4gIHBlcnNvbkdlbmVyYXRpb246IGltcG9ydF9nZW5raXQuei5lbnVtKFtcImRvbnRfYWxsb3dcIiwgXCJhbGxvd19hZHVsdFwiLCBcImFsbG93X2FsbFwiXSkub3B0aW9uYWwoKS5kZXNjcmliZShcbiAgICBcIlNwZWNpZmllcyB0aGUgcG9saWN5IGZvciBnZW5lcmF0aW5nIHBlcnNvbnMgaW4gdmlkZW9zLCBpbmNsdWRpbmcgYWdlIHJlc3RyaWN0aW9uc1wiXG4gICksXG4gIHB1YnN1YlRvcGljOiBpbXBvcnRfZ2Vua2l0Lnouc3RyaW5nKCkub3B0aW9uYWwoKS5kZXNjcmliZShcIlRoZSBwdWJzdWIgdG9waWMgdG8gcHVibGlzaCB0aGUgdmlkZW8gZ2VuZXJhdGlvbiBwcm9ncmVzcyB0b1wiKSxcbiAgbmVnYXRpdmVQcm9tcHQ6IGltcG9ydF9nZW5raXQuei5zdHJpbmcoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFxuICAgIFwiSW4gYWRkaXRpb24gdG8gdGhlIHRleHQgY29udGV4dCwgbmVnYXRpdmUgcHJvbXB0cyBjYW4gYmUgZXhwbGljaXRseSBzdGF0ZWQgaGVyZSB0byBoZWxwIGdlbmVyYXRlIHRoZSB2aWRlb1wiXG4gICksXG4gIGVuaGFuY2VQcm9tcHQ6IGltcG9ydF9nZW5raXQuei5ib29sZWFuKCkub3B0aW9uYWwoKS5kZXNjcmliZShcbiAgICBcIklmIHRydWUsIHRoZSBwcm9tcHQgd2lsbCBiZSBpbXByb3ZlZCBiZWZvcmUgaXQgaXMgdXNlZCB0byBnZW5lcmF0ZSB2aWRlb3MuIFRoZSBSTkcgc2VlZCwgaWYgcHJvdmlkZWQsIHdpbGwgbm90IHJlc3VsdCBpbiBjb25zaXN0ZW50IHJlc3VsdHMgaWYgcHJvbXB0cyBhcmUgZW5oYW5jZWQuXCJcbiAgKSxcbiAgZ2VuZXJhdGVBdWRpbzogaW1wb3J0X2dlbmtpdC56LmJvb2xlYW4oKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiSWYgdHJ1ZSwgYXVkaW8gd2lsbCBiZSBnZW5lcmF0ZWQgYWxvbmcgd2l0aCB0aGUgdmlkZW9cIiksXG4gIGNvbXByZXNzaW9uUXVhbGl0eTogaW1wb3J0X2dlbmtpdC56LmVudW0oW1wib3B0aW1pemVkXCIsIFwibG9zc2xlc3NcIl0pLmRlZmF1bHQoXCJvcHRpbWl6ZWRcIikub3B0aW9uYWwoKS5kZXNjcmliZShcIkNvbXByZXNzaW9uIHF1YWxpdHkgb2YgdGhlIGdlbmVyYXRlZCB2aWRlb1wiKVxufSkucGFzc3Rocm91Z2goKTtcbmZ1bmN0aW9uIGNvbW1vblJlZihuYW1lLCBpbmZvLCBjb25maWdTY2hlbWEgPSBWZW9Db25maWdTY2hlbWEpIHtcbiAgcmV0dXJuICgwLCBpbXBvcnRfZ2Vua2l0Lm1vZGVsUmVmKSh7XG4gICAgbmFtZTogYHZlcnRleGFpLyR7bmFtZX1gLFxuICAgIGNvbmZpZ1NjaGVtYSxcbiAgICBpbmZvOiBpbmZvID8/IHtcbiAgICAgIHN1cHBvcnRzOiB7XG4gICAgICAgIG1lZGlhOiB0cnVlLFxuICAgICAgICBtdWx0aXR1cm46IGZhbHNlLFxuICAgICAgICB0b29sczogZmFsc2UsXG4gICAgICAgIHN5c3RlbVJvbGU6IGZhbHNlLFxuICAgICAgICBvdXRwdXQ6IFtcIm1lZGlhXCJdLFxuICAgICAgICBsb25nUnVubmluZzogdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBUT0RPKGlmaWVsa2VyKTogUmVtb3ZlIHRoaXMgY2FzdCBpZiB3ZSBmaXggbG9uZ1J1bm5pbmdcbiAgfSk7XG59XG5jb25zdCBHRU5FUklDX01PREVMID0gY29tbW9uUmVmKFwidmVvXCIpO1xuY29uc3QgS05PV05fTU9ERUxTID0ge1xuICBcInZlby0yLjAtZ2VuZXJhdGUtMDAxXCI6IGNvbW1vblJlZihcInZlby0yLjAtZ2VuZXJhdGUtMDAxXCIpLFxuICBcInZlby0zLjAtZ2VuZXJhdGUtMDAxXCI6IGNvbW1vblJlZihcInZlby0zLjAtZ2VuZXJhdGUtMDAxXCIpLFxuICBcInZlby0zLjAtZmFzdC1nZW5lcmF0ZS0wMDFcIjogY29tbW9uUmVmKFwidmVvLTMuMC1mYXN0LWdlbmVyYXRlLTAwMVwiKSxcbiAgXCJ2ZW8tMy4wLWdlbmVyYXRlLXByZXZpZXdcIjogY29tbW9uUmVmKFwidmVvLTMuMC1nZW5lcmF0ZS1wcmV2aWV3XCIpLFxuICBcInZlby0zLjAtZmFzdC1nZW5lcmF0ZS1wcmV2aWV3XCI6IGNvbW1vblJlZihcInZlby0zLjAtZmFzdC1nZW5lcmF0ZS1wcmV2aWV3XCIpXG59O1xuZnVuY3Rpb24gaXNWZW9Nb2RlbE5hbWUodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWU/LnN0YXJ0c1dpdGgoXCJ2ZW8tXCIpO1xufVxuZnVuY3Rpb24gbW9kZWwodmVyc2lvbiwgY29uZmlnID0ge30pIHtcbiAgY29uc3QgbmFtZSA9ICgwLCBpbXBvcnRfdXRpbHMuY2hlY2tNb2RlbE5hbWUpKHZlcnNpb24pO1xuICByZXR1cm4gKDAsIGltcG9ydF9nZW5raXQubW9kZWxSZWYpKHtcbiAgICBuYW1lOiBgdmVydGV4YWkvJHtuYW1lfWAsXG4gICAgY29uZmlnLFxuICAgIGNvbmZpZ1NjaGVtYTogVmVvQ29uZmlnU2NoZW1hLFxuICAgIGluZm86IHsgLi4uR0VORVJJQ19NT0RFTC5pbmZvIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBsaXN0QWN0aW9ucyhtb2RlbHMpIHtcbiAgcmV0dXJuIG1vZGVscy5maWx0ZXIoKG0pID0+IGlzVmVvTW9kZWxOYW1lKG0ubmFtZSkpLm1hcCgobSkgPT4ge1xuICAgIGNvbnN0IHJlZiA9IG1vZGVsKG0ubmFtZSk7XG4gICAgcmV0dXJuICgwLCBpbXBvcnRfZ2Vua2l0Lm1vZGVsQWN0aW9uTWV0YWRhdGEpKHtcbiAgICAgIG5hbWU6IHJlZi5uYW1lLFxuICAgICAgaW5mbzogcmVmLmluZm8sXG4gICAgICBjb25maWdTY2hlbWE6IHJlZi5jb25maWdTY2hlbWFcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBkZWZpbmVLbm93bk1vZGVscyhhaSwgY2xpZW50T3B0aW9ucywgcGx1Z2luT3B0aW9ucykge1xuICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoS05PV05fTU9ERUxTKSkge1xuICAgIGRlZmluZU1vZGVsKGFpLCBuYW1lLCBjbGllbnRPcHRpb25zLCBwbHVnaW5PcHRpb25zKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVmaW5lTW9kZWwoYWksIG5hbWUsIGNsaWVudE9wdGlvbnMsIHBsdWdpbk9wdGlvbnMpIHtcbiAgY29uc3QgcmVmID0gbW9kZWwobmFtZSk7XG4gIHJldHVybiBhaS5kZWZpbmVCYWNrZ3JvdW5kTW9kZWwoe1xuICAgIG5hbWU6IHJlZi5uYW1lLFxuICAgIC4uLnJlZi5pbmZvLFxuICAgIGNvbmZpZ1NjaGVtYTogcmVmLmNvbmZpZ1NjaGVtYSxcbiAgICBhc3luYyBzdGFydChyZXF1ZXN0KSB7XG4gICAgICBjb25zdCB2ZW9QcmVkaWN0UmVxdWVzdCA9ICgwLCBpbXBvcnRfY29udmVydGVycy50b1Zlb1ByZWRpY3RSZXF1ZXN0KShyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgKDAsIGltcG9ydF9jbGllbnQudmVvUHJlZGljdCkoXG4gICAgICAgICgwLCBpbXBvcnRfdXRpbHMuZXh0cmFjdFZlcnNpb24pKHJlZiksXG4gICAgICAgIHZlb1ByZWRpY3RSZXF1ZXN0LFxuICAgICAgICBjbGllbnRPcHRpb25zXG4gICAgICApO1xuICAgICAgcmV0dXJuICgwLCBpbXBvcnRfY29udmVydGVycy5mcm9tVmVvT3BlcmF0aW9uKShyZXNwb25zZSk7XG4gICAgfSxcbiAgICBhc3luYyBjaGVjayhvcGVyYXRpb24pIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgKDAsIGltcG9ydF9jbGllbnQudmVvQ2hlY2tPcGVyYXRpb24pKFxuICAgICAgICAoMCwgaW1wb3J0X2NvbnZlcnRlcnMudG9WZW9Nb2RlbCkob3BlcmF0aW9uKSxcbiAgICAgICAgKDAsIGltcG9ydF9jb252ZXJ0ZXJzLnRvVmVvT3BlcmF0aW9uUmVxdWVzdCkob3BlcmF0aW9uKSxcbiAgICAgICAgY2xpZW50T3B0aW9uc1xuICAgICAgKTtcbiAgICAgIHJldHVybiAoMCwgaW1wb3J0X2NvbnZlcnRlcnMuZnJvbVZlb09wZXJhdGlvbikocmVzcG9uc2UpO1xuICAgIH1cbiAgfSk7XG59XG5jb25zdCBURVNUX09OTFkgPSB7XG4gIEdFTkVSSUNfTU9ERUwsXG4gIEtOT1dOX01PREVMU1xufTtcbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBURVNUX09OTFksXG4gIFZlb0NvbmZpZ1NjaGVtYSxcbiAgZGVmaW5lS25vd25Nb2RlbHMsXG4gIGRlZmluZU1vZGVsLFxuICBpc1Zlb01vZGVsTmFtZSxcbiAgbGlzdEFjdGlvbnMsXG4gIG1vZGVsXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlby5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/veo.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/google-genai/lib/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@genkit-ai/google-genai/lib/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   googleAI: () => (/* reexport safe */ _googleai_index_js__WEBPACK_IMPORTED_MODULE_0__.googleAI),\n/* harmony export */   vertexAI: () => (/* reexport safe */ _vertexai_index_js__WEBPACK_IMPORTED_MODULE_1__.vertexAI)\n/* harmony export */ });\n/* harmony import */ var _googleai_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./googleai/index.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/googleai/index.js\");\n/* harmony import */ var _vertexai_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vertexai/index.js */ \"(action-browser)/./node_modules/@genkit-ai/google-genai/lib/vertexai/index.js\");\n\n\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2dvb2dsZS1nZW5haS9saWIvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFFNkI7QUFDa0I7QUFJN0M7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxLUmFtYWNoYVxcRG9jdW1lbnRzXFxTdXN0QUluZXggR0l0IENvZGVcXG5vZGVfbW9kdWxlc1xcQGdlbmtpdC1haVxcZ29vZ2xlLWdlbmFpXFxsaWJcXGluZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBnb29nbGVBSVxufSBmcm9tIFwiLi9nb29nbGVhaS9pbmRleC5qc1wiO1xuaW1wb3J0IHsgdmVydGV4QUkgfSBmcm9tIFwiLi92ZXJ0ZXhhaS9pbmRleC5qc1wiO1xuZXhwb3J0IHtcbiAgZ29vZ2xlQUksXG4gIHZlcnRleEFJXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/google-genai/lib/index.mjs\n");

/***/ })

};
;