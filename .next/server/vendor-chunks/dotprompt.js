"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dotprompt";
exports.ids = ["vendor-chunks/dotprompt"];
exports.modules = {

/***/ "(action-browser)/./node_modules/dotprompt/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/dotprompt/dist/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar index_exports = {};\n__export(index_exports, {\n  Dotprompt: () => Dotprompt,\n  PicoschemaParser: () => PicoschemaParser,\n  picoschema: () => picoschema\n});\nmodule.exports = __toCommonJS(index_exports);\n\n// src/dotprompt.ts\nvar import_handlebars2 = __toESM(__webpack_require__(/*! handlebars/dist/cjs/handlebars.js */ \"(action-browser)/./node_modules/handlebars/dist/cjs/handlebars.js\"));\n\n// src/helpers.ts\nvar helpers_exports = {};\n__export(helpers_exports, {\n  history: () => history,\n  ifEquals: () => ifEquals,\n  json: () => json,\n  media: () => media,\n  role: () => role,\n  section: () => section,\n  unlessEquals: () => unlessEquals\n});\nvar import_handlebars = __toESM(__webpack_require__(/*! handlebars/dist/cjs/handlebars.js */ \"(action-browser)/./node_modules/handlebars/dist/cjs/handlebars.js\"));\nvar { SafeString } = import_handlebars.default;\nfunction json(serializable, options) {\n  return new SafeString(\n    JSON.stringify(serializable, null, options.hash.indent || 0)\n  );\n}\nfunction role(role2) {\n  return new SafeString(`<<<dotprompt:role:${role2}>>>`);\n}\nfunction history() {\n  return new SafeString(\"<<<dotprompt:history>>>\");\n}\nfunction section(name) {\n  return new SafeString(`<<<dotprompt:section ${name}>>>`);\n}\nfunction media(options) {\n  return new SafeString(\n    `<<<dotprompt:media:url ${options.hash.url}${options.hash.contentType ? ` ${options.hash.contentType}` : \"\"}>>>`\n  );\n}\nfunction ifEquals(arg1, arg2, options) {\n  return arg1 === arg2 ? options.fn(this) : options.inverse(this);\n}\nfunction unlessEquals(arg1, arg2, options) {\n  return arg1 !== arg2 ? options.fn(this) : options.inverse(this);\n}\n\n// src/parse.ts\nvar import_yaml = __webpack_require__(/*! yaml */ \"(action-browser)/./node_modules/yaml/dist/index.js\");\nvar ROLE_MARKER_PREFIX = \"<<<dotprompt:role:\";\nvar HISTORY_MARKER_PREFIX = \"<<<dotprompt:history\";\nvar MEDIA_MARKER_PREFIX = \"<<<dotprompt:media:\";\nvar SECTION_MARKER_PREFIX = \"<<<dotprompt:section\";\nvar FRONTMATTER_AND_BODY_REGEX = /^---\\s*(?:\\r\\n|\\r|\\n)([\\s\\S]*?)(?:\\r\\n|\\r|\\n)---\\s*(?:\\r\\n|\\r|\\n)([\\s\\S]*)$/;\nvar ROLE_AND_HISTORY_MARKER_REGEX = /(<<<dotprompt:(?:role:[a-z]+|history))>>>/g;\nvar MEDIA_AND_SECTION_MARKER_REGEX = /(<<<dotprompt:(?:media:url|section).*?)>>>/g;\nvar RESERVED_METADATA_KEYWORDS = [\n  // NOTE: KEEP SORTED\n  \"config\",\n  \"description\",\n  \"ext\",\n  \"input\",\n  \"model\",\n  \"name\",\n  \"output\",\n  \"raw\",\n  \"toolDefs\",\n  \"tools\",\n  \"variant\",\n  \"version\"\n];\nvar BASE_METADATA = {\n  ext: {},\n  metadata: {},\n  config: {}\n};\nfunction splitByRegex(source, regex) {\n  return source.split(regex).filter((s) => s.trim() !== \"\");\n}\nfunction splitByRoleAndHistoryMarkers(renderedString) {\n  return splitByRegex(renderedString, ROLE_AND_HISTORY_MARKER_REGEX);\n}\nfunction splitByMediaAndSectionMarkers(source) {\n  return splitByRegex(source, MEDIA_AND_SECTION_MARKER_REGEX);\n}\nfunction convertNamespacedEntryToNestedObject(key, value, obj = {}) {\n  const result = obj || {};\n  const lastDotIndex = key.lastIndexOf(\".\");\n  const ns = key.substring(0, lastDotIndex);\n  const field = key.substring(lastDotIndex + 1);\n  result[ns] = result[ns] || {};\n  result[ns][field] = value;\n  return result;\n}\nfunction extractFrontmatterAndBody(source) {\n  const match = source.match(FRONTMATTER_AND_BODY_REGEX);\n  if (match) {\n    const [, frontmatter, body] = match;\n    return { frontmatter, body };\n  }\n  return { frontmatter: \"\", body: \"\" };\n}\nfunction parseDocument(source) {\n  const { frontmatter, body } = extractFrontmatterAndBody(source);\n  if (frontmatter) {\n    try {\n      const parsedMetadata = (0, import_yaml.parse)(frontmatter);\n      const raw = { ...parsedMetadata };\n      const pruned = { ...BASE_METADATA };\n      const ext = {};\n      for (const k in raw) {\n        const key = k;\n        if (RESERVED_METADATA_KEYWORDS.includes(key)) {\n          pruned[key] = raw[key];\n        } else if (key.includes(\".\")) {\n          convertNamespacedEntryToNestedObject(key, raw[key], ext);\n        }\n      }\n      return { ...pruned, raw, ext, template: body.trim() };\n    } catch (error) {\n      console.error(\"Dotprompt: Error parsing YAML frontmatter:\", error);\n      return { ...BASE_METADATA, template: source.trim() };\n    }\n  }\n  return { ...BASE_METADATA, template: source };\n}\nfunction messageSourcesToMessages(messageSources) {\n  return messageSources.filter((ms) => ms.content || ms.source).map((m) => {\n    const out = {\n      role: m.role,\n      content: m.content || toParts(m.source || \"\")\n    };\n    if (m.metadata) {\n      out.metadata = m.metadata;\n    }\n    return out;\n  });\n}\nfunction transformMessagesToHistory(messages) {\n  return messages.map((m) => ({\n    ...m,\n    metadata: { ...m.metadata, purpose: \"history\" }\n  }));\n}\nfunction toMessages(renderedString, data) {\n  let currentMessage = { role: \"user\", source: \"\" };\n  const messageSources = [currentMessage];\n  for (const piece of splitByRoleAndHistoryMarkers(renderedString)) {\n    if (piece.startsWith(ROLE_MARKER_PREFIX)) {\n      const role2 = piece.substring(ROLE_MARKER_PREFIX.length);\n      if (currentMessage.source?.trim()) {\n        currentMessage = { role: role2, source: \"\" };\n        messageSources.push(currentMessage);\n      } else {\n        currentMessage.role = role2;\n      }\n    } else if (piece.startsWith(HISTORY_MARKER_PREFIX)) {\n      const historyMessages = transformMessagesToHistory(data?.messages ?? []);\n      if (historyMessages) {\n        messageSources.push(...historyMessages);\n      }\n      currentMessage = { role: \"model\", source: \"\" };\n      messageSources.push(currentMessage);\n    } else {\n      currentMessage.source += piece;\n    }\n  }\n  const messages = messageSourcesToMessages(messageSources);\n  return insertHistory(messages, data?.messages);\n}\nfunction messagesHaveHistory(messages) {\n  return messages.some((m) => m.metadata?.purpose === \"history\");\n}\nfunction insertHistory(messages, history2 = []) {\n  if (!history2 || messagesHaveHistory(messages)) {\n    return messages;\n  }\n  if (messages.length === 0) {\n    return history2;\n  }\n  const lastMessage = messages.at(-1);\n  if (lastMessage?.role === \"user\") {\n    const messagesWithoutLast = messages.slice(0, -1);\n    return [...messagesWithoutLast, ...history2, lastMessage];\n  }\n  return [...messages, ...history2];\n}\nfunction toParts(source) {\n  return splitByMediaAndSectionMarkers(source).map(parsePart);\n}\nfunction parsePart(piece) {\n  if (piece.startsWith(MEDIA_MARKER_PREFIX)) {\n    return parseMediaPart(piece);\n  }\n  if (piece.startsWith(SECTION_MARKER_PREFIX)) {\n    return parseSectionPart(piece);\n  }\n  return parseTextPart(piece);\n}\nfunction parseMediaPart(piece) {\n  if (!piece.startsWith(MEDIA_MARKER_PREFIX)) {\n    throw new Error(\"Invalid media piece\");\n  }\n  const [_, url, contentType] = piece.split(\" \");\n  const part = { media: { url } };\n  if (contentType) {\n    part.media.contentType = contentType;\n  }\n  return part;\n}\nfunction parseSectionPart(piece) {\n  if (!piece.startsWith(SECTION_MARKER_PREFIX)) {\n    throw new Error(\"Invalid section piece\");\n  }\n  const [_, sectionType] = piece.split(\" \");\n  return { metadata: { purpose: sectionType, pending: true } };\n}\nfunction parseTextPart(piece) {\n  return { text: piece };\n}\n\n// src/picoschema.ts\nvar JSON_SCHEMA_SCALAR_TYPES = [\n  \"any\",\n  \"boolean\",\n  \"integer\",\n  \"null\",\n  \"number\",\n  \"string\"\n];\nvar WILDCARD_PROPERTY_NAME = \"(*)\";\nasync function picoschema(schema, options) {\n  return new PicoschemaParser(options).parse(schema);\n}\nvar PicoschemaParser = class {\n  schemaResolver;\n  /**\n   * Constructs a new PicoschemaParser.\n   *\n   * @param options The options for the parser.\n   */\n  constructor(options) {\n    this.schemaResolver = options?.schemaResolver;\n  }\n  /**\n   * Resolves a named schema using the configured resolver.\n   *\n   * @param schemaName The name of the schema to resolve.\n   * @return The resolved JSON Schema.\n   */\n  async mustResolveSchema(schemaName) {\n    if (!this.schemaResolver) {\n      throw new Error(`Picoschema: unsupported scalar type '${schemaName}'.`);\n    }\n    const val = await this.schemaResolver(schemaName);\n    if (!val) {\n      throw new Error(\n        `Picoschema: could not find schema with name '${schemaName}'`\n      );\n    }\n    return val;\n  }\n  /**\n   * Parses a schema, detecting if it's Picoschema or JSON Schema.\n   *\n   * @param schema The schema definition to parse.\n   * @return The resulting JSON Schema, or null if the input is null.\n   */\n  async parse(schema) {\n    if (!schema) {\n      return null;\n    }\n    if (typeof schema === \"string\") {\n      const [type, description] = extractDescription(schema);\n      if (JSON_SCHEMA_SCALAR_TYPES.includes(type)) {\n        let out = { type };\n        if (description) {\n          out = { ...out, description };\n        }\n        return out;\n      }\n      const resolvedSchema = await this.mustResolveSchema(type);\n      return description ? { ...resolvedSchema, description } : resolvedSchema;\n    }\n    if ([...JSON_SCHEMA_SCALAR_TYPES, \"object\", \"array\"].includes(\n      schema?.type\n    )) {\n      return schema;\n    }\n    if (typeof schema?.properties === \"object\") {\n      return { ...schema, type: \"object\" };\n    }\n    return this.parsePico(schema);\n  }\n  /**\n   * Parses a Picoschema object or string fragment.\n   *\n   * @param obj The object or string fragment to parse.\n   * @param path The current path within the schema structure.\n   * @return The parsed JSON Schema.\n   */\n  async parsePico(obj, path = []) {\n    if (typeof obj === \"string\") {\n      const [type, description] = extractDescription(obj);\n      if (!JSON_SCHEMA_SCALAR_TYPES.includes(type)) {\n        let resolvedSchema = await this.mustResolveSchema(type);\n        if (description) resolvedSchema = { ...resolvedSchema, description };\n        return resolvedSchema;\n      }\n      if (type === \"any\") {\n        return description ? { description } : {};\n      }\n      return description ? { type, description } : { type };\n    }\n    if (typeof obj !== \"object\") {\n      throw new Error(\n        `Picoschema: only consists of objects and strings. Got: ${JSON.stringify(obj)}`\n      );\n    }\n    const schema = {\n      type: \"object\",\n      properties: {},\n      required: [],\n      additionalProperties: false\n    };\n    for (const key in obj) {\n      if (key === WILDCARD_PROPERTY_NAME) {\n        schema.additionalProperties = await this.parsePico(obj[key], [\n          ...path,\n          key\n        ]);\n        continue;\n      }\n      const [name, typeInfo] = key.split(\"(\");\n      const isOptional = name.endsWith(\"?\");\n      const propertyName = isOptional ? name.slice(0, -1) : name;\n      if (!isOptional) {\n        schema.required.push(propertyName);\n      }\n      if (!typeInfo) {\n        const prop = { ...await this.parsePico(obj[key], [...path, key]) };\n        if (isOptional && typeof prop.type === \"string\") {\n          prop.type = [prop.type, \"null\"];\n        }\n        schema.properties[propertyName] = prop;\n        continue;\n      }\n      const [type, description] = extractDescription(\n        typeInfo.substring(0, typeInfo.length - 1)\n      );\n      if (type === \"array\") {\n        schema.properties[propertyName] = {\n          type: isOptional ? [\"array\", \"null\"] : \"array\",\n          items: await this.parsePico(obj[key], [...path, key])\n        };\n      } else if (type === \"object\") {\n        const prop = await this.parsePico(obj[key], [...path, key]);\n        if (isOptional) prop.type = [prop.type, \"null\"];\n        schema.properties[propertyName] = prop;\n      } else if (type === \"enum\") {\n        const prop = { enum: obj[key] };\n        if (isOptional && !prop.enum.includes(null)) prop.enum.push(null);\n        schema.properties[propertyName] = prop;\n      } else {\n        throw new Error(\n          `Picoschema: parenthetical types must be 'object' or 'array', got: ${type}`\n        );\n      }\n      if (description) {\n        schema.properties[propertyName].description = description;\n      }\n    }\n    if (!schema.required.length) {\n      schema.required = void 0;\n    }\n    return schema;\n  }\n};\nfunction extractDescription(input) {\n  if (!input.includes(\",\")) {\n    return [input, null];\n  }\n  const match = input.match(/(.*?), *(.*)$/);\n  if (!match) {\n    return [input, null];\n  }\n  return [match[1], match[2]];\n}\n\n// src/util.ts\nfunction removeUndefinedFields(obj) {\n  if (obj === null || typeof obj !== \"object\") {\n    return obj;\n  }\n  if (Array.isArray(obj)) {\n    return obj.map((item) => removeUndefinedFields(item));\n  }\n  const result = {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (value !== void 0) {\n      result[key] = removeUndefinedFields(value);\n    }\n  }\n  return result;\n}\n\n// src/dotprompt.ts\nvar Dotprompt = class {\n  handlebars;\n  knownHelpers = {};\n  defaultModel;\n  modelConfigs = {};\n  tools = {};\n  toolResolver;\n  schemas = {};\n  schemaResolver;\n  partialResolver;\n  store;\n  constructor(options) {\n    this.handlebars = import_handlebars2.default.noConflict();\n    this.modelConfigs = options?.modelConfigs || this.modelConfigs;\n    this.defaultModel = options?.defaultModel;\n    this.tools = options?.tools || {};\n    this.toolResolver = options?.toolResolver;\n    this.schemas = options?.schemas || {};\n    this.schemaResolver = options?.schemaResolver;\n    this.partialResolver = options?.partialResolver;\n    this.registerInitialHelpers(helpers_exports, options?.helpers);\n    this.registerInitialPartials(options?.partials);\n  }\n  /**\n   * Registers a helper function for use in templates.\n   *\n   * @param name The name of the helper function to register\n   * @param fn The helper function implementation\n   * @return This instance for method chaining\n   */\n  defineHelper(name, fn) {\n    this.handlebars.registerHelper(name, fn);\n    this.knownHelpers[name] = true;\n    return this;\n  }\n  /**\n   * Registers a partial template for use in other templates.\n   *\n   * @param name The name of the partial to register\n   * @param source The template source for the partial\n   * @return This instance for method chaining\n   */\n  definePartial(name, source) {\n    this.handlebars.registerPartial(name, source);\n    return this;\n  }\n  /**\n   * Registers a tool definition for use in prompts.\n   *\n   * @param def The tool definition to register\n   * @return This instance for method chaining\n   */\n  defineTool(def) {\n    this.tools[def.name] = def;\n    return this;\n  }\n  /**\n   * Parses a prompt template string into a structured ParsedPrompt object.\n   *\n   * @param source The template source string to parse\n   * @return A parsed prompt object with extracted metadata and template\n   */\n  parse(source) {\n    return parseDocument(source);\n  }\n  /**\n   * Renders a prompt template with the provided data.\n   *\n   * @param source The template source string to render\n   * @param data The data to use when rendering the template\n   * @param options Additional metadata and options for rendering\n   * @return A promise resolving to the rendered prompt\n   */\n  async render(source, data = {}, options) {\n    const renderer = await this.compile(source);\n    return renderer(data, options);\n  }\n  /**\n   * Compiles a template into a reusable function for rendering prompts.\n   *\n   * @param source The template source or parsed prompt to compile\n   * @param additionalMetadata Additional metadata to include in the compiled template\n   * @return A promise resolving to a function for rendering the template\n   */\n  async compile(source, additionalMetadata) {\n    let parsedSource;\n    if (typeof source === \"string\") {\n      parsedSource = this.parse(source);\n    } else {\n      parsedSource = source;\n    }\n    if (additionalMetadata) {\n      parsedSource = { ...parsedSource, ...additionalMetadata };\n    }\n    await this.resolvePartials(parsedSource.template);\n    const renderString = this.handlebars.compile(\n      parsedSource.template,\n      {\n        knownHelpers: this.knownHelpers,\n        knownHelpersOnly: true,\n        noEscape: true\n      }\n    );\n    const renderFunc = async (data, options) => {\n      const { input, ...mergedMetadata } = await this.renderMetadata(parsedSource);\n      const renderedString = renderString(\n        { ...options?.input?.default || {}, ...data.input },\n        {\n          data: {\n            metadata: {\n              prompt: mergedMetadata,\n              docs: data.docs,\n              messages: data.messages\n            },\n            ...data.context || {}\n          }\n        }\n      );\n      return {\n        ...mergedMetadata,\n        messages: toMessages(renderedString, data)\n      };\n    };\n    renderFunc.prompt = parsedSource;\n    return renderFunc;\n  }\n  /**\n   * Processes and resolves all metadata for a prompt template.\n   *\n   * @param source The template source or parsed prompt\n   * @param additionalMetadata Additional metadata to include\n   * @return A promise resolving to the fully processed metadata\n   */\n  async renderMetadata(source, additionalMetadata) {\n    let parsedSource;\n    if (typeof source === \"string\") {\n      parsedSource = this.parse(source);\n    } else {\n      parsedSource = source;\n    }\n    const model = additionalMetadata?.model || parsedSource.model || this.defaultModel;\n    let modelConfig;\n    if (model && this.modelConfigs[model]) {\n      modelConfig = this.modelConfigs[model];\n    }\n    return this.resolveMetadata(\n      modelConfig ? { config: modelConfig } : {},\n      parsedSource,\n      additionalMetadata\n    );\n  }\n  /**\n   * Merges multiple metadata objects together, resolving tools and schemas.\n   *\n   * @param base The base metadata object\n   * @param merges Additional metadata objects to merge into the base\n   * @return A promise resolving to the merged and processed metadata\n   */\n  async resolveMetadata(base, ...merges) {\n    let out = { ...base };\n    for (let i = 0; i < merges.length; i++) {\n      if (!merges[i]) {\n        continue;\n      }\n      const originalConfig = out.config || {};\n      out = { ...out, ...merges[i] };\n      out.config = { ...originalConfig, ...merges[i]?.config || {} };\n    }\n    const { template: _, ...outWithoutTemplate } = out;\n    out = outWithoutTemplate;\n    out = removeUndefinedFields(out);\n    out = await this.resolveTools(out);\n    out = await this.renderPicoschema(out);\n    return out;\n  }\n  /**\n   * Processes schema definitions in picoschema format into standard JSON Schema.\n   *\n   * @param meta The prompt metadata containing schema definitions\n   * @return A promise resolving to the processed metadata with expanded schemas\n   */\n  async renderPicoschema(meta) {\n    if (!meta.output?.schema && !meta.input?.schema) {\n      return meta;\n    }\n    const resolveSchema = (schema) => {\n      return picoschema(schema, {\n        schemaResolver: this.wrappedSchemaResolver.bind(this)\n      });\n    };\n    const newMeta = { ...meta };\n    let inputPromise = null;\n    let outputPromise = null;\n    if (meta.input?.schema) {\n      newMeta.input = { ...meta.input };\n      inputPromise = resolveSchema(meta.input.schema);\n    }\n    if (meta.output?.schema) {\n      newMeta.output = { ...meta.output };\n      outputPromise = resolveSchema(meta.output.schema);\n    }\n    const [inputSchema, outputSchema] = await Promise.all([\n      inputPromise ?? Promise.resolve(null),\n      outputPromise ?? Promise.resolve(null)\n    ]);\n    if (inputSchema && newMeta.input) {\n      newMeta.input.schema = inputSchema;\n    }\n    if (outputSchema && newMeta.output) {\n      newMeta.output.schema = outputSchema;\n    }\n    return newMeta;\n  }\n  /**\n   * Resolves a schema name to its definition, using registered schemas or schema resolver.\n   *\n   * @param name The name of the schema to resolve\n   * @return A promise resolving to the schema definition or null if not found\n   */\n  async wrappedSchemaResolver(name) {\n    if (this.schemas[name]) {\n      return this.schemas[name];\n    }\n    if (this.schemaResolver) {\n      return await this.schemaResolver(name);\n    }\n    return null;\n  }\n  /**\n   * Resolves tool names to their definitions using registered tools or tool resolver.\n   *\n   * @param base The metadata containing tool references to resolve\n   * @return A promise resolving to metadata with resolved tool definitions\n   */\n  async resolveTools(base) {\n    const out = { ...base };\n    if (!out.tools) {\n      return out;\n    }\n    const unregisteredNames = [];\n    out.toolDefs = out.toolDefs || [];\n    await Promise.all(\n      out.tools.map(async (name) => {\n        if (this.tools[name]) {\n          if (out.toolDefs) {\n            out.toolDefs.push(this.tools[name]);\n          }\n        } else if (this.toolResolver) {\n          const resolvedTool = await this.toolResolver(name);\n          if (!resolvedTool) {\n            throw new Error(\n              `Dotprompt: Unable to resolve tool '${name}' to a recognized tool definition.`\n            );\n          }\n          if (out.toolDefs) {\n            out.toolDefs.push(resolvedTool);\n          }\n        } else {\n          unregisteredNames.push(name);\n        }\n      })\n    );\n    out.tools = unregisteredNames;\n    return out;\n  }\n  /**\n   * Identifies all partial references in a template.\n   *\n   * @param template The template to scan for partial references\n   * @return A set of partial names referenced in the template\n   */\n  identifyPartials(template) {\n    const ast = this.handlebars.parse(template);\n    const partials = /* @__PURE__ */ new Set();\n    const visitor = new class extends this.handlebars.Visitor {\n      // Visit partial statements and add their names to our set.\n      PartialStatement(partial) {\n        if (partial && typeof partial === \"object\" && \"name\" in partial && partial.name && typeof partial.name === \"object\" && \"original\" in partial.name && typeof partial.name.original === \"string\") {\n          partials.add(partial.name.original);\n        }\n      }\n    }();\n    visitor.accept(ast);\n    return partials;\n  }\n  /**\n   * Resolves and registers all partials referenced in a template.\n   *\n   * @param template The template containing partial references\n   * @return A promise that resolves when all partials are registered\n   */\n  async resolvePartials(template) {\n    if (!this.partialResolver && !this.store) {\n      return;\n    }\n    const names = this.identifyPartials(template);\n    await Promise.all(\n      Array.from(names).map(async (name) => {\n        if (!this.handlebars.partials[name]) {\n          let content = null;\n          if (this.partialResolver) {\n            content = await this.partialResolver(name);\n          }\n          if (!content && this.store) {\n            const partial = await this.store.loadPartial(name);\n            content = partial?.source;\n          }\n          if (content) {\n            this.definePartial(name, content);\n            await this.resolvePartials(content);\n          }\n        }\n      })\n    );\n  }\n  /**\n   * Registers initial helpers from built-in helpers and options.\n   * @private\n   */\n  registerInitialHelpers(builtinHelpers, customHelpers) {\n    if (builtinHelpers) {\n      for (const key in builtinHelpers) {\n        this.defineHelper(\n          key,\n          builtinHelpers[key]\n        );\n      }\n    }\n    if (customHelpers) {\n      for (const key in customHelpers) {\n        this.defineHelper(key, customHelpers[key]);\n      }\n    }\n  }\n  /**\n   * Registers initial partials from the options.\n   *\n   * @param partials The partials to register\n   * @private\n   */\n  registerInitialPartials(partials) {\n    if (partials) {\n      for (const key in partials) {\n        this.definePartial(key, partials[key]);\n      }\n    }\n  }\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kb3Rwcm9tcHQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSw4QkFBOEI7QUFDdkc7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0EsaUNBQWlDLG1CQUFPLENBQUMsNEdBQW1DOztBQUU1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxnQ0FBZ0MsbUJBQU8sQ0FBQyw0R0FBbUM7QUFDM0UsTUFBTSxhQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsS0FBSztBQUNyRDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUJBQWlCLEVBQUUsK0JBQStCLHlCQUF5QixPQUFPO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxnRUFBTTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsVUFBVSxvQkFBb0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixNQUFNO0FBQ047QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEdBQUc7QUFDSDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsV0FBVztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxXQUFXO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUNBQWlDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QztBQUNBLDZCQUE2QixvQkFBb0IsSUFBSTtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxrRUFBa0Usb0JBQW9CO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLCtFQUErRSxLQUFLO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0EsVUFBVSxnQ0FBZ0MsaUJBQWlCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCLElBQUk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QscUJBQXFCO0FBQ3JCO0FBQ0EsWUFBWSxxQ0FBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsS0FBSztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUlMIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEtSYW1hY2hhXFxEb2N1bWVudHNcXFN1c3RBSW5leCBHSXQgQ29kZVxcbm9kZV9tb2R1bGVzXFxkb3Rwcm9tcHRcXGRpc3RcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cbiAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gIC8vIFwiZGVmYXVsdFwiIHRvIHRoZSBDb21tb25KUyBcIm1vZHVsZS5leHBvcnRzXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoaW5kZXhfZXhwb3J0cywge1xuICBEb3Rwcm9tcHQ6ICgpID0+IERvdHByb21wdCxcbiAgUGljb3NjaGVtYVBhcnNlcjogKCkgPT4gUGljb3NjaGVtYVBhcnNlcixcbiAgcGljb3NjaGVtYTogKCkgPT4gcGljb3NjaGVtYVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhpbmRleF9leHBvcnRzKTtcblxuLy8gc3JjL2RvdHByb21wdC50c1xudmFyIGltcG9ydF9oYW5kbGViYXJzMiA9IF9fdG9FU00ocmVxdWlyZShcImhhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy5qc1wiKSk7XG5cbi8vIHNyYy9oZWxwZXJzLnRzXG52YXIgaGVscGVyc19leHBvcnRzID0ge307XG5fX2V4cG9ydChoZWxwZXJzX2V4cG9ydHMsIHtcbiAgaGlzdG9yeTogKCkgPT4gaGlzdG9yeSxcbiAgaWZFcXVhbHM6ICgpID0+IGlmRXF1YWxzLFxuICBqc29uOiAoKSA9PiBqc29uLFxuICBtZWRpYTogKCkgPT4gbWVkaWEsXG4gIHJvbGU6ICgpID0+IHJvbGUsXG4gIHNlY3Rpb246ICgpID0+IHNlY3Rpb24sXG4gIHVubGVzc0VxdWFsczogKCkgPT4gdW5sZXNzRXF1YWxzXG59KTtcbnZhciBpbXBvcnRfaGFuZGxlYmFycyA9IF9fdG9FU00ocmVxdWlyZShcImhhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy5qc1wiKSk7XG52YXIgeyBTYWZlU3RyaW5nIH0gPSBpbXBvcnRfaGFuZGxlYmFycy5kZWZhdWx0O1xuZnVuY3Rpb24ganNvbihzZXJpYWxpemFibGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBTYWZlU3RyaW5nKFxuICAgIEpTT04uc3RyaW5naWZ5KHNlcmlhbGl6YWJsZSwgbnVsbCwgb3B0aW9ucy5oYXNoLmluZGVudCB8fCAwKVxuICApO1xufVxuZnVuY3Rpb24gcm9sZShyb2xlMikge1xuICByZXR1cm4gbmV3IFNhZmVTdHJpbmcoYDw8PGRvdHByb21wdDpyb2xlOiR7cm9sZTJ9Pj4+YCk7XG59XG5mdW5jdGlvbiBoaXN0b3J5KCkge1xuICByZXR1cm4gbmV3IFNhZmVTdHJpbmcoXCI8PDxkb3Rwcm9tcHQ6aGlzdG9yeT4+PlwiKTtcbn1cbmZ1bmN0aW9uIHNlY3Rpb24obmFtZSkge1xuICByZXR1cm4gbmV3IFNhZmVTdHJpbmcoYDw8PGRvdHByb21wdDpzZWN0aW9uICR7bmFtZX0+Pj5gKTtcbn1cbmZ1bmN0aW9uIG1lZGlhKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBTYWZlU3RyaW5nKFxuICAgIGA8PDxkb3Rwcm9tcHQ6bWVkaWE6dXJsICR7b3B0aW9ucy5oYXNoLnVybH0ke29wdGlvbnMuaGFzaC5jb250ZW50VHlwZSA/IGAgJHtvcHRpb25zLmhhc2guY29udGVudFR5cGV9YCA6IFwiXCJ9Pj4+YFxuICApO1xufVxuZnVuY3Rpb24gaWZFcXVhbHMoYXJnMSwgYXJnMiwgb3B0aW9ucykge1xuICByZXR1cm4gYXJnMSA9PT0gYXJnMiA/IG9wdGlvbnMuZm4odGhpcykgOiBvcHRpb25zLmludmVyc2UodGhpcyk7XG59XG5mdW5jdGlvbiB1bmxlc3NFcXVhbHMoYXJnMSwgYXJnMiwgb3B0aW9ucykge1xuICByZXR1cm4gYXJnMSAhPT0gYXJnMiA/IG9wdGlvbnMuZm4odGhpcykgOiBvcHRpb25zLmludmVyc2UodGhpcyk7XG59XG5cbi8vIHNyYy9wYXJzZS50c1xudmFyIGltcG9ydF95YW1sID0gcmVxdWlyZShcInlhbWxcIik7XG52YXIgUk9MRV9NQVJLRVJfUFJFRklYID0gXCI8PDxkb3Rwcm9tcHQ6cm9sZTpcIjtcbnZhciBISVNUT1JZX01BUktFUl9QUkVGSVggPSBcIjw8PGRvdHByb21wdDpoaXN0b3J5XCI7XG52YXIgTUVESUFfTUFSS0VSX1BSRUZJWCA9IFwiPDw8ZG90cHJvbXB0Om1lZGlhOlwiO1xudmFyIFNFQ1RJT05fTUFSS0VSX1BSRUZJWCA9IFwiPDw8ZG90cHJvbXB0OnNlY3Rpb25cIjtcbnZhciBGUk9OVE1BVFRFUl9BTkRfQk9EWV9SRUdFWCA9IC9eLS0tXFxzKig/OlxcclxcbnxcXHJ8XFxuKShbXFxzXFxTXSo/KSg/OlxcclxcbnxcXHJ8XFxuKS0tLVxccyooPzpcXHJcXG58XFxyfFxcbikoW1xcc1xcU10qKSQvO1xudmFyIFJPTEVfQU5EX0hJU1RPUllfTUFSS0VSX1JFR0VYID0gLyg8PDxkb3Rwcm9tcHQ6KD86cm9sZTpbYS16XSt8aGlzdG9yeSkpPj4+L2c7XG52YXIgTUVESUFfQU5EX1NFQ1RJT05fTUFSS0VSX1JFR0VYID0gLyg8PDxkb3Rwcm9tcHQ6KD86bWVkaWE6dXJsfHNlY3Rpb24pLio/KT4+Pi9nO1xudmFyIFJFU0VSVkVEX01FVEFEQVRBX0tFWVdPUkRTID0gW1xuICAvLyBOT1RFOiBLRUVQIFNPUlRFRFxuICBcImNvbmZpZ1wiLFxuICBcImRlc2NyaXB0aW9uXCIsXG4gIFwiZXh0XCIsXG4gIFwiaW5wdXRcIixcbiAgXCJtb2RlbFwiLFxuICBcIm5hbWVcIixcbiAgXCJvdXRwdXRcIixcbiAgXCJyYXdcIixcbiAgXCJ0b29sRGVmc1wiLFxuICBcInRvb2xzXCIsXG4gIFwidmFyaWFudFwiLFxuICBcInZlcnNpb25cIlxuXTtcbnZhciBCQVNFX01FVEFEQVRBID0ge1xuICBleHQ6IHt9LFxuICBtZXRhZGF0YToge30sXG4gIGNvbmZpZzoge31cbn07XG5mdW5jdGlvbiBzcGxpdEJ5UmVnZXgoc291cmNlLCByZWdleCkge1xuICByZXR1cm4gc291cmNlLnNwbGl0KHJlZ2V4KS5maWx0ZXIoKHMpID0+IHMudHJpbSgpICE9PSBcIlwiKTtcbn1cbmZ1bmN0aW9uIHNwbGl0QnlSb2xlQW5kSGlzdG9yeU1hcmtlcnMocmVuZGVyZWRTdHJpbmcpIHtcbiAgcmV0dXJuIHNwbGl0QnlSZWdleChyZW5kZXJlZFN0cmluZywgUk9MRV9BTkRfSElTVE9SWV9NQVJLRVJfUkVHRVgpO1xufVxuZnVuY3Rpb24gc3BsaXRCeU1lZGlhQW5kU2VjdGlvbk1hcmtlcnMoc291cmNlKSB7XG4gIHJldHVybiBzcGxpdEJ5UmVnZXgoc291cmNlLCBNRURJQV9BTkRfU0VDVElPTl9NQVJLRVJfUkVHRVgpO1xufVxuZnVuY3Rpb24gY29udmVydE5hbWVzcGFjZWRFbnRyeVRvTmVzdGVkT2JqZWN0KGtleSwgdmFsdWUsIG9iaiA9IHt9KSB7XG4gIGNvbnN0IHJlc3VsdCA9IG9iaiB8fCB7fTtcbiAgY29uc3QgbGFzdERvdEluZGV4ID0ga2V5Lmxhc3RJbmRleE9mKFwiLlwiKTtcbiAgY29uc3QgbnMgPSBrZXkuc3Vic3RyaW5nKDAsIGxhc3REb3RJbmRleCk7XG4gIGNvbnN0IGZpZWxkID0ga2V5LnN1YnN0cmluZyhsYXN0RG90SW5kZXggKyAxKTtcbiAgcmVzdWx0W25zXSA9IHJlc3VsdFtuc10gfHwge307XG4gIHJlc3VsdFtuc11bZmllbGRdID0gdmFsdWU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBleHRyYWN0RnJvbnRtYXR0ZXJBbmRCb2R5KHNvdXJjZSkge1xuICBjb25zdCBtYXRjaCA9IHNvdXJjZS5tYXRjaChGUk9OVE1BVFRFUl9BTkRfQk9EWV9SRUdFWCk7XG4gIGlmIChtYXRjaCkge1xuICAgIGNvbnN0IFssIGZyb250bWF0dGVyLCBib2R5XSA9IG1hdGNoO1xuICAgIHJldHVybiB7IGZyb250bWF0dGVyLCBib2R5IH07XG4gIH1cbiAgcmV0dXJuIHsgZnJvbnRtYXR0ZXI6IFwiXCIsIGJvZHk6IFwiXCIgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRG9jdW1lbnQoc291cmNlKSB7XG4gIGNvbnN0IHsgZnJvbnRtYXR0ZXIsIGJvZHkgfSA9IGV4dHJhY3RGcm9udG1hdHRlckFuZEJvZHkoc291cmNlKTtcbiAgaWYgKGZyb250bWF0dGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhcnNlZE1ldGFkYXRhID0gKDAsIGltcG9ydF95YW1sLnBhcnNlKShmcm9udG1hdHRlcik7XG4gICAgICBjb25zdCByYXcgPSB7IC4uLnBhcnNlZE1ldGFkYXRhIH07XG4gICAgICBjb25zdCBwcnVuZWQgPSB7IC4uLkJBU0VfTUVUQURBVEEgfTtcbiAgICAgIGNvbnN0IGV4dCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBrIGluIHJhdykge1xuICAgICAgICBjb25zdCBrZXkgPSBrO1xuICAgICAgICBpZiAoUkVTRVJWRURfTUVUQURBVEFfS0VZV09SRFMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgIHBydW5lZFtrZXldID0gcmF3W2tleV07XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5LmluY2x1ZGVzKFwiLlwiKSkge1xuICAgICAgICAgIGNvbnZlcnROYW1lc3BhY2VkRW50cnlUb05lc3RlZE9iamVjdChrZXksIHJhd1trZXldLCBleHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyAuLi5wcnVuZWQsIHJhdywgZXh0LCB0ZW1wbGF0ZTogYm9keS50cmltKCkgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkRvdHByb21wdDogRXJyb3IgcGFyc2luZyBZQU1MIGZyb250bWF0dGVyOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4geyAuLi5CQVNFX01FVEFEQVRBLCB0ZW1wbGF0ZTogc291cmNlLnRyaW0oKSB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4geyAuLi5CQVNFX01FVEFEQVRBLCB0ZW1wbGF0ZTogc291cmNlIH07XG59XG5mdW5jdGlvbiBtZXNzYWdlU291cmNlc1RvTWVzc2FnZXMobWVzc2FnZVNvdXJjZXMpIHtcbiAgcmV0dXJuIG1lc3NhZ2VTb3VyY2VzLmZpbHRlcigobXMpID0+IG1zLmNvbnRlbnQgfHwgbXMuc291cmNlKS5tYXAoKG0pID0+IHtcbiAgICBjb25zdCBvdXQgPSB7XG4gICAgICByb2xlOiBtLnJvbGUsXG4gICAgICBjb250ZW50OiBtLmNvbnRlbnQgfHwgdG9QYXJ0cyhtLnNvdXJjZSB8fCBcIlwiKVxuICAgIH07XG4gICAgaWYgKG0ubWV0YWRhdGEpIHtcbiAgICAgIG91dC5tZXRhZGF0YSA9IG0ubWV0YWRhdGE7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH0pO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtTWVzc2FnZXNUb0hpc3RvcnkobWVzc2FnZXMpIHtcbiAgcmV0dXJuIG1lc3NhZ2VzLm1hcCgobSkgPT4gKHtcbiAgICAuLi5tLFxuICAgIG1ldGFkYXRhOiB7IC4uLm0ubWV0YWRhdGEsIHB1cnBvc2U6IFwiaGlzdG9yeVwiIH1cbiAgfSkpO1xufVxuZnVuY3Rpb24gdG9NZXNzYWdlcyhyZW5kZXJlZFN0cmluZywgZGF0YSkge1xuICBsZXQgY3VycmVudE1lc3NhZ2UgPSB7IHJvbGU6IFwidXNlclwiLCBzb3VyY2U6IFwiXCIgfTtcbiAgY29uc3QgbWVzc2FnZVNvdXJjZXMgPSBbY3VycmVudE1lc3NhZ2VdO1xuICBmb3IgKGNvbnN0IHBpZWNlIG9mIHNwbGl0QnlSb2xlQW5kSGlzdG9yeU1hcmtlcnMocmVuZGVyZWRTdHJpbmcpKSB7XG4gICAgaWYgKHBpZWNlLnN0YXJ0c1dpdGgoUk9MRV9NQVJLRVJfUFJFRklYKSkge1xuICAgICAgY29uc3Qgcm9sZTIgPSBwaWVjZS5zdWJzdHJpbmcoUk9MRV9NQVJLRVJfUFJFRklYLmxlbmd0aCk7XG4gICAgICBpZiAoY3VycmVudE1lc3NhZ2Uuc291cmNlPy50cmltKCkpIHtcbiAgICAgICAgY3VycmVudE1lc3NhZ2UgPSB7IHJvbGU6IHJvbGUyLCBzb3VyY2U6IFwiXCIgfTtcbiAgICAgICAgbWVzc2FnZVNvdXJjZXMucHVzaChjdXJyZW50TWVzc2FnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50TWVzc2FnZS5yb2xlID0gcm9sZTI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwaWVjZS5zdGFydHNXaXRoKEhJU1RPUllfTUFSS0VSX1BSRUZJWCkpIHtcbiAgICAgIGNvbnN0IGhpc3RvcnlNZXNzYWdlcyA9IHRyYW5zZm9ybU1lc3NhZ2VzVG9IaXN0b3J5KGRhdGE/Lm1lc3NhZ2VzID8/IFtdKTtcbiAgICAgIGlmIChoaXN0b3J5TWVzc2FnZXMpIHtcbiAgICAgICAgbWVzc2FnZVNvdXJjZXMucHVzaCguLi5oaXN0b3J5TWVzc2FnZXMpO1xuICAgICAgfVxuICAgICAgY3VycmVudE1lc3NhZ2UgPSB7IHJvbGU6IFwibW9kZWxcIiwgc291cmNlOiBcIlwiIH07XG4gICAgICBtZXNzYWdlU291cmNlcy5wdXNoKGN1cnJlbnRNZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudE1lc3NhZ2Uuc291cmNlICs9IHBpZWNlO1xuICAgIH1cbiAgfVxuICBjb25zdCBtZXNzYWdlcyA9IG1lc3NhZ2VTb3VyY2VzVG9NZXNzYWdlcyhtZXNzYWdlU291cmNlcyk7XG4gIHJldHVybiBpbnNlcnRIaXN0b3J5KG1lc3NhZ2VzLCBkYXRhPy5tZXNzYWdlcyk7XG59XG5mdW5jdGlvbiBtZXNzYWdlc0hhdmVIaXN0b3J5KG1lc3NhZ2VzKSB7XG4gIHJldHVybiBtZXNzYWdlcy5zb21lKChtKSA9PiBtLm1ldGFkYXRhPy5wdXJwb3NlID09PSBcImhpc3RvcnlcIik7XG59XG5mdW5jdGlvbiBpbnNlcnRIaXN0b3J5KG1lc3NhZ2VzLCBoaXN0b3J5MiA9IFtdKSB7XG4gIGlmICghaGlzdG9yeTIgfHwgbWVzc2FnZXNIYXZlSGlzdG9yeShtZXNzYWdlcykpIHtcbiAgICByZXR1cm4gbWVzc2FnZXM7XG4gIH1cbiAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBoaXN0b3J5MjtcbiAgfVxuICBjb25zdCBsYXN0TWVzc2FnZSA9IG1lc3NhZ2VzLmF0KC0xKTtcbiAgaWYgKGxhc3RNZXNzYWdlPy5yb2xlID09PSBcInVzZXJcIikge1xuICAgIGNvbnN0IG1lc3NhZ2VzV2l0aG91dExhc3QgPSBtZXNzYWdlcy5zbGljZSgwLCAtMSk7XG4gICAgcmV0dXJuIFsuLi5tZXNzYWdlc1dpdGhvdXRMYXN0LCAuLi5oaXN0b3J5MiwgbGFzdE1lc3NhZ2VdO1xuICB9XG4gIHJldHVybiBbLi4ubWVzc2FnZXMsIC4uLmhpc3RvcnkyXTtcbn1cbmZ1bmN0aW9uIHRvUGFydHMoc291cmNlKSB7XG4gIHJldHVybiBzcGxpdEJ5TWVkaWFBbmRTZWN0aW9uTWFya2Vycyhzb3VyY2UpLm1hcChwYXJzZVBhcnQpO1xufVxuZnVuY3Rpb24gcGFyc2VQYXJ0KHBpZWNlKSB7XG4gIGlmIChwaWVjZS5zdGFydHNXaXRoKE1FRElBX01BUktFUl9QUkVGSVgpKSB7XG4gICAgcmV0dXJuIHBhcnNlTWVkaWFQYXJ0KHBpZWNlKTtcbiAgfVxuICBpZiAocGllY2Uuc3RhcnRzV2l0aChTRUNUSU9OX01BUktFUl9QUkVGSVgpKSB7XG4gICAgcmV0dXJuIHBhcnNlU2VjdGlvblBhcnQocGllY2UpO1xuICB9XG4gIHJldHVybiBwYXJzZVRleHRQYXJ0KHBpZWNlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlTWVkaWFQYXJ0KHBpZWNlKSB7XG4gIGlmICghcGllY2Uuc3RhcnRzV2l0aChNRURJQV9NQVJLRVJfUFJFRklYKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbWVkaWEgcGllY2VcIik7XG4gIH1cbiAgY29uc3QgW18sIHVybCwgY29udGVudFR5cGVdID0gcGllY2Uuc3BsaXQoXCIgXCIpO1xuICBjb25zdCBwYXJ0ID0geyBtZWRpYTogeyB1cmwgfSB9O1xuICBpZiAoY29udGVudFR5cGUpIHtcbiAgICBwYXJ0Lm1lZGlhLmNvbnRlbnRUeXBlID0gY29udGVudFR5cGU7XG4gIH1cbiAgcmV0dXJuIHBhcnQ7XG59XG5mdW5jdGlvbiBwYXJzZVNlY3Rpb25QYXJ0KHBpZWNlKSB7XG4gIGlmICghcGllY2Uuc3RhcnRzV2l0aChTRUNUSU9OX01BUktFUl9QUkVGSVgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWN0aW9uIHBpZWNlXCIpO1xuICB9XG4gIGNvbnN0IFtfLCBzZWN0aW9uVHlwZV0gPSBwaWVjZS5zcGxpdChcIiBcIik7XG4gIHJldHVybiB7IG1ldGFkYXRhOiB7IHB1cnBvc2U6IHNlY3Rpb25UeXBlLCBwZW5kaW5nOiB0cnVlIH0gfTtcbn1cbmZ1bmN0aW9uIHBhcnNlVGV4dFBhcnQocGllY2UpIHtcbiAgcmV0dXJuIHsgdGV4dDogcGllY2UgfTtcbn1cblxuLy8gc3JjL3BpY29zY2hlbWEudHNcbnZhciBKU09OX1NDSEVNQV9TQ0FMQVJfVFlQRVMgPSBbXG4gIFwiYW55XCIsXG4gIFwiYm9vbGVhblwiLFxuICBcImludGVnZXJcIixcbiAgXCJudWxsXCIsXG4gIFwibnVtYmVyXCIsXG4gIFwic3RyaW5nXCJcbl07XG52YXIgV0lMRENBUkRfUFJPUEVSVFlfTkFNRSA9IFwiKCopXCI7XG5hc3luYyBmdW5jdGlvbiBwaWNvc2NoZW1hKHNjaGVtYSwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFBpY29zY2hlbWFQYXJzZXIob3B0aW9ucykucGFyc2Uoc2NoZW1hKTtcbn1cbnZhciBQaWNvc2NoZW1hUGFyc2VyID0gY2xhc3Mge1xuICBzY2hlbWFSZXNvbHZlcjtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgUGljb3NjaGVtYVBhcnNlci5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHRoZSBwYXJzZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5zY2hlbWFSZXNvbHZlciA9IG9wdGlvbnM/LnNjaGVtYVJlc29sdmVyO1xuICB9XG4gIC8qKlxuICAgKiBSZXNvbHZlcyBhIG5hbWVkIHNjaGVtYSB1c2luZyB0aGUgY29uZmlndXJlZCByZXNvbHZlci5cbiAgICpcbiAgICogQHBhcmFtIHNjaGVtYU5hbWUgVGhlIG5hbWUgb2YgdGhlIHNjaGVtYSB0byByZXNvbHZlLlxuICAgKiBAcmV0dXJuIFRoZSByZXNvbHZlZCBKU09OIFNjaGVtYS5cbiAgICovXG4gIGFzeW5jIG11c3RSZXNvbHZlU2NoZW1hKHNjaGVtYU5hbWUpIHtcbiAgICBpZiAoIXRoaXMuc2NoZW1hUmVzb2x2ZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUGljb3NjaGVtYTogdW5zdXBwb3J0ZWQgc2NhbGFyIHR5cGUgJyR7c2NoZW1hTmFtZX0nLmApO1xuICAgIH1cbiAgICBjb25zdCB2YWwgPSBhd2FpdCB0aGlzLnNjaGVtYVJlc29sdmVyKHNjaGVtYU5hbWUpO1xuICAgIGlmICghdmFsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBQaWNvc2NoZW1hOiBjb3VsZCBub3QgZmluZCBzY2hlbWEgd2l0aCBuYW1lICcke3NjaGVtYU5hbWV9J2BcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIHNjaGVtYSwgZGV0ZWN0aW5nIGlmIGl0J3MgUGljb3NjaGVtYSBvciBKU09OIFNjaGVtYS5cbiAgICpcbiAgICogQHBhcmFtIHNjaGVtYSBUaGUgc2NoZW1hIGRlZmluaXRpb24gdG8gcGFyc2UuXG4gICAqIEByZXR1cm4gVGhlIHJlc3VsdGluZyBKU09OIFNjaGVtYSwgb3IgbnVsbCBpZiB0aGUgaW5wdXQgaXMgbnVsbC5cbiAgICovXG4gIGFzeW5jIHBhcnNlKHNjaGVtYSkge1xuICAgIGlmICghc2NoZW1hKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IFt0eXBlLCBkZXNjcmlwdGlvbl0gPSBleHRyYWN0RGVzY3JpcHRpb24oc2NoZW1hKTtcbiAgICAgIGlmIChKU09OX1NDSEVNQV9TQ0FMQVJfVFlQRVMuaW5jbHVkZXModHlwZSkpIHtcbiAgICAgICAgbGV0IG91dCA9IHsgdHlwZSB9O1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICBvdXQgPSB7IC4uLm91dCwgZGVzY3JpcHRpb24gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzb2x2ZWRTY2hlbWEgPSBhd2FpdCB0aGlzLm11c3RSZXNvbHZlU2NoZW1hKHR5cGUpO1xuICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uID8geyAuLi5yZXNvbHZlZFNjaGVtYSwgZGVzY3JpcHRpb24gfSA6IHJlc29sdmVkU2NoZW1hO1xuICAgIH1cbiAgICBpZiAoWy4uLkpTT05fU0NIRU1BX1NDQUxBUl9UWVBFUywgXCJvYmplY3RcIiwgXCJhcnJheVwiXS5pbmNsdWRlcyhcbiAgICAgIHNjaGVtYT8udHlwZVxuICAgICkpIHtcbiAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2NoZW1hPy5wcm9wZXJ0aWVzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICByZXR1cm4geyAuLi5zY2hlbWEsIHR5cGU6IFwib2JqZWN0XCIgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQaWNvKHNjaGVtYSk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIFBpY29zY2hlbWEgb2JqZWN0IG9yIHN0cmluZyBmcmFnbWVudC5cbiAgICpcbiAgICogQHBhcmFtIG9iaiBUaGUgb2JqZWN0IG9yIHN0cmluZyBmcmFnbWVudCB0byBwYXJzZS5cbiAgICogQHBhcmFtIHBhdGggVGhlIGN1cnJlbnQgcGF0aCB3aXRoaW4gdGhlIHNjaGVtYSBzdHJ1Y3R1cmUuXG4gICAqIEByZXR1cm4gVGhlIHBhcnNlZCBKU09OIFNjaGVtYS5cbiAgICovXG4gIGFzeW5jIHBhcnNlUGljbyhvYmosIHBhdGggPSBbXSkge1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBbdHlwZSwgZGVzY3JpcHRpb25dID0gZXh0cmFjdERlc2NyaXB0aW9uKG9iaik7XG4gICAgICBpZiAoIUpTT05fU0NIRU1BX1NDQUxBUl9UWVBFUy5pbmNsdWRlcyh0eXBlKSkge1xuICAgICAgICBsZXQgcmVzb2x2ZWRTY2hlbWEgPSBhd2FpdCB0aGlzLm11c3RSZXNvbHZlU2NoZW1hKHR5cGUpO1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24pIHJlc29sdmVkU2NoZW1hID0geyAuLi5yZXNvbHZlZFNjaGVtYSwgZGVzY3JpcHRpb24gfTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkU2NoZW1hO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IFwiYW55XCIpIHtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uID8geyBkZXNjcmlwdGlvbiB9IDoge307XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzY3JpcHRpb24gPyB7IHR5cGUsIGRlc2NyaXB0aW9uIH0gOiB7IHR5cGUgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFBpY29zY2hlbWE6IG9ubHkgY29uc2lzdHMgb2Ygb2JqZWN0cyBhbmQgc3RyaW5ncy4gR290OiAke0pTT04uc3RyaW5naWZ5KG9iail9YFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qgc2NoZW1hID0ge1xuICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgcmVxdWlyZWQ6IFtdLFxuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChrZXkgPT09IFdJTERDQVJEX1BST1BFUlRZX05BTUUpIHtcbiAgICAgICAgc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gYXdhaXQgdGhpcy5wYXJzZVBpY28ob2JqW2tleV0sIFtcbiAgICAgICAgICAuLi5wYXRoLFxuICAgICAgICAgIGtleVxuICAgICAgICBdKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBbbmFtZSwgdHlwZUluZm9dID0ga2V5LnNwbGl0KFwiKFwiKTtcbiAgICAgIGNvbnN0IGlzT3B0aW9uYWwgPSBuYW1lLmVuZHNXaXRoKFwiP1wiKTtcbiAgICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IGlzT3B0aW9uYWwgPyBuYW1lLnNsaWNlKDAsIC0xKSA6IG5hbWU7XG4gICAgICBpZiAoIWlzT3B0aW9uYWwpIHtcbiAgICAgICAgc2NoZW1hLnJlcXVpcmVkLnB1c2gocHJvcGVydHlOYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmICghdHlwZUluZm8pIHtcbiAgICAgICAgY29uc3QgcHJvcCA9IHsgLi4uYXdhaXQgdGhpcy5wYXJzZVBpY28ob2JqW2tleV0sIFsuLi5wYXRoLCBrZXldKSB9O1xuICAgICAgICBpZiAoaXNPcHRpb25hbCAmJiB0eXBlb2YgcHJvcC50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcHJvcC50eXBlID0gW3Byb3AudHlwZSwgXCJudWxsXCJdO1xuICAgICAgICB9XG4gICAgICAgIHNjaGVtYS5wcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV0gPSBwcm9wO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFt0eXBlLCBkZXNjcmlwdGlvbl0gPSBleHRyYWN0RGVzY3JpcHRpb24oXG4gICAgICAgIHR5cGVJbmZvLnN1YnN0cmluZygwLCB0eXBlSW5mby5sZW5ndGggLSAxKVxuICAgICAgKTtcbiAgICAgIGlmICh0eXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgc2NoZW1hLnByb3BlcnRpZXNbcHJvcGVydHlOYW1lXSA9IHtcbiAgICAgICAgICB0eXBlOiBpc09wdGlvbmFsID8gW1wiYXJyYXlcIiwgXCJudWxsXCJdIDogXCJhcnJheVwiLFxuICAgICAgICAgIGl0ZW1zOiBhd2FpdCB0aGlzLnBhcnNlUGljbyhvYmpba2V5XSwgWy4uLnBhdGgsIGtleV0pXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3QgcHJvcCA9IGF3YWl0IHRoaXMucGFyc2VQaWNvKG9ialtrZXldLCBbLi4ucGF0aCwga2V5XSk7XG4gICAgICAgIGlmIChpc09wdGlvbmFsKSBwcm9wLnR5cGUgPSBbcHJvcC50eXBlLCBcIm51bGxcIl07XG4gICAgICAgIHNjaGVtYS5wcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV0gPSBwcm9wO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImVudW1cIikge1xuICAgICAgICBjb25zdCBwcm9wID0geyBlbnVtOiBvYmpba2V5XSB9O1xuICAgICAgICBpZiAoaXNPcHRpb25hbCAmJiAhcHJvcC5lbnVtLmluY2x1ZGVzKG51bGwpKSBwcm9wLmVudW0ucHVzaChudWxsKTtcbiAgICAgICAgc2NoZW1hLnByb3BlcnRpZXNbcHJvcGVydHlOYW1lXSA9IHByb3A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFBpY29zY2hlbWE6IHBhcmVudGhldGljYWwgdHlwZXMgbXVzdCBiZSAnb2JqZWN0JyBvciAnYXJyYXknLCBnb3Q6ICR7dHlwZX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgc2NoZW1hLnByb3BlcnRpZXNbcHJvcGVydHlOYW1lXS5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXNjaGVtYS5yZXF1aXJlZC5sZW5ndGgpIHtcbiAgICAgIHNjaGVtYS5yZXF1aXJlZCA9IHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIHNjaGVtYTtcbiAgfVxufTtcbmZ1bmN0aW9uIGV4dHJhY3REZXNjcmlwdGlvbihpbnB1dCkge1xuICBpZiAoIWlucHV0LmluY2x1ZGVzKFwiLFwiKSkge1xuICAgIHJldHVybiBbaW5wdXQsIG51bGxdO1xuICB9XG4gIGNvbnN0IG1hdGNoID0gaW5wdXQubWF0Y2goLyguKj8pLCAqKC4qKSQvKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBbaW5wdXQsIG51bGxdO1xuICB9XG4gIHJldHVybiBbbWF0Y2hbMV0sIG1hdGNoWzJdXTtcbn1cblxuLy8gc3JjL3V0aWwudHNcbmZ1bmN0aW9uIHJlbW92ZVVuZGVmaW5lZEZpZWxkcyhvYmopIHtcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5tYXAoKGl0ZW0pID0+IHJlbW92ZVVuZGVmaW5lZEZpZWxkcyhpdGVtKSk7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9iaikpIHtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgcmVzdWx0W2tleV0gPSByZW1vdmVVbmRlZmluZWRGaWVsZHModmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvZG90cHJvbXB0LnRzXG52YXIgRG90cHJvbXB0ID0gY2xhc3Mge1xuICBoYW5kbGViYXJzO1xuICBrbm93bkhlbHBlcnMgPSB7fTtcbiAgZGVmYXVsdE1vZGVsO1xuICBtb2RlbENvbmZpZ3MgPSB7fTtcbiAgdG9vbHMgPSB7fTtcbiAgdG9vbFJlc29sdmVyO1xuICBzY2hlbWFzID0ge307XG4gIHNjaGVtYVJlc29sdmVyO1xuICBwYXJ0aWFsUmVzb2x2ZXI7XG4gIHN0b3JlO1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5oYW5kbGViYXJzID0gaW1wb3J0X2hhbmRsZWJhcnMyLmRlZmF1bHQubm9Db25mbGljdCgpO1xuICAgIHRoaXMubW9kZWxDb25maWdzID0gb3B0aW9ucz8ubW9kZWxDb25maWdzIHx8IHRoaXMubW9kZWxDb25maWdzO1xuICAgIHRoaXMuZGVmYXVsdE1vZGVsID0gb3B0aW9ucz8uZGVmYXVsdE1vZGVsO1xuICAgIHRoaXMudG9vbHMgPSBvcHRpb25zPy50b29scyB8fCB7fTtcbiAgICB0aGlzLnRvb2xSZXNvbHZlciA9IG9wdGlvbnM/LnRvb2xSZXNvbHZlcjtcbiAgICB0aGlzLnNjaGVtYXMgPSBvcHRpb25zPy5zY2hlbWFzIHx8IHt9O1xuICAgIHRoaXMuc2NoZW1hUmVzb2x2ZXIgPSBvcHRpb25zPy5zY2hlbWFSZXNvbHZlcjtcbiAgICB0aGlzLnBhcnRpYWxSZXNvbHZlciA9IG9wdGlvbnM/LnBhcnRpYWxSZXNvbHZlcjtcbiAgICB0aGlzLnJlZ2lzdGVySW5pdGlhbEhlbHBlcnMoaGVscGVyc19leHBvcnRzLCBvcHRpb25zPy5oZWxwZXJzKTtcbiAgICB0aGlzLnJlZ2lzdGVySW5pdGlhbFBhcnRpYWxzKG9wdGlvbnM/LnBhcnRpYWxzKTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgaGVscGVyIGZ1bmN0aW9uIGZvciB1c2UgaW4gdGVtcGxhdGVzLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaGVscGVyIGZ1bmN0aW9uIHRvIHJlZ2lzdGVyXG4gICAqIEBwYXJhbSBmbiBUaGUgaGVscGVyIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uXG4gICAqIEByZXR1cm4gVGhpcyBpbnN0YW5jZSBmb3IgbWV0aG9kIGNoYWluaW5nXG4gICAqL1xuICBkZWZpbmVIZWxwZXIobmFtZSwgZm4pIHtcbiAgICB0aGlzLmhhbmRsZWJhcnMucmVnaXN0ZXJIZWxwZXIobmFtZSwgZm4pO1xuICAgIHRoaXMua25vd25IZWxwZXJzW25hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgcGFydGlhbCB0ZW1wbGF0ZSBmb3IgdXNlIGluIG90aGVyIHRlbXBsYXRlcy5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHBhcnRpYWwgdG8gcmVnaXN0ZXJcbiAgICogQHBhcmFtIHNvdXJjZSBUaGUgdGVtcGxhdGUgc291cmNlIGZvciB0aGUgcGFydGlhbFxuICAgKiBAcmV0dXJuIFRoaXMgaW5zdGFuY2UgZm9yIG1ldGhvZCBjaGFpbmluZ1xuICAgKi9cbiAgZGVmaW5lUGFydGlhbChuYW1lLCBzb3VyY2UpIHtcbiAgICB0aGlzLmhhbmRsZWJhcnMucmVnaXN0ZXJQYXJ0aWFsKG5hbWUsIHNvdXJjZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIHRvb2wgZGVmaW5pdGlvbiBmb3IgdXNlIGluIHByb21wdHMuXG4gICAqXG4gICAqIEBwYXJhbSBkZWYgVGhlIHRvb2wgZGVmaW5pdGlvbiB0byByZWdpc3RlclxuICAgKiBAcmV0dXJuIFRoaXMgaW5zdGFuY2UgZm9yIG1ldGhvZCBjaGFpbmluZ1xuICAgKi9cbiAgZGVmaW5lVG9vbChkZWYpIHtcbiAgICB0aGlzLnRvb2xzW2RlZi5uYW1lXSA9IGRlZjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGEgcHJvbXB0IHRlbXBsYXRlIHN0cmluZyBpbnRvIGEgc3RydWN0dXJlZCBQYXJzZWRQcm9tcHQgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gc291cmNlIFRoZSB0ZW1wbGF0ZSBzb3VyY2Ugc3RyaW5nIHRvIHBhcnNlXG4gICAqIEByZXR1cm4gQSBwYXJzZWQgcHJvbXB0IG9iamVjdCB3aXRoIGV4dHJhY3RlZCBtZXRhZGF0YSBhbmQgdGVtcGxhdGVcbiAgICovXG4gIHBhcnNlKHNvdXJjZSkge1xuICAgIHJldHVybiBwYXJzZURvY3VtZW50KHNvdXJjZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBwcm9tcHQgdGVtcGxhdGUgd2l0aCB0aGUgcHJvdmlkZWQgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHNvdXJjZSBUaGUgdGVtcGxhdGUgc291cmNlIHN0cmluZyB0byByZW5kZXJcbiAgICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gdXNlIHdoZW4gcmVuZGVyaW5nIHRoZSB0ZW1wbGF0ZVxuICAgKiBAcGFyYW0gb3B0aW9ucyBBZGRpdGlvbmFsIG1ldGFkYXRhIGFuZCBvcHRpb25zIGZvciByZW5kZXJpbmdcbiAgICogQHJldHVybiBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSByZW5kZXJlZCBwcm9tcHRcbiAgICovXG4gIGFzeW5jIHJlbmRlcihzb3VyY2UsIGRhdGEgPSB7fSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gYXdhaXQgdGhpcy5jb21waWxlKHNvdXJjZSk7XG4gICAgcmV0dXJuIHJlbmRlcmVyKGRhdGEsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBDb21waWxlcyBhIHRlbXBsYXRlIGludG8gYSByZXVzYWJsZSBmdW5jdGlvbiBmb3IgcmVuZGVyaW5nIHByb21wdHMuXG4gICAqXG4gICAqIEBwYXJhbSBzb3VyY2UgVGhlIHRlbXBsYXRlIHNvdXJjZSBvciBwYXJzZWQgcHJvbXB0IHRvIGNvbXBpbGVcbiAgICogQHBhcmFtIGFkZGl0aW9uYWxNZXRhZGF0YSBBZGRpdGlvbmFsIG1ldGFkYXRhIHRvIGluY2x1ZGUgaW4gdGhlIGNvbXBpbGVkIHRlbXBsYXRlXG4gICAqIEByZXR1cm4gQSBwcm9taXNlIHJlc29sdmluZyB0byBhIGZ1bmN0aW9uIGZvciByZW5kZXJpbmcgdGhlIHRlbXBsYXRlXG4gICAqL1xuICBhc3luYyBjb21waWxlKHNvdXJjZSwgYWRkaXRpb25hbE1ldGFkYXRhKSB7XG4gICAgbGV0IHBhcnNlZFNvdXJjZTtcbiAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcGFyc2VkU291cmNlID0gdGhpcy5wYXJzZShzb3VyY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZWRTb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIGlmIChhZGRpdGlvbmFsTWV0YWRhdGEpIHtcbiAgICAgIHBhcnNlZFNvdXJjZSA9IHsgLi4ucGFyc2VkU291cmNlLCAuLi5hZGRpdGlvbmFsTWV0YWRhdGEgfTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5yZXNvbHZlUGFydGlhbHMocGFyc2VkU291cmNlLnRlbXBsYXRlKTtcbiAgICBjb25zdCByZW5kZXJTdHJpbmcgPSB0aGlzLmhhbmRsZWJhcnMuY29tcGlsZShcbiAgICAgIHBhcnNlZFNvdXJjZS50ZW1wbGF0ZSxcbiAgICAgIHtcbiAgICAgICAga25vd25IZWxwZXJzOiB0aGlzLmtub3duSGVscGVycyxcbiAgICAgICAga25vd25IZWxwZXJzT25seTogdHJ1ZSxcbiAgICAgICAgbm9Fc2NhcGU6IHRydWVcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IHJlbmRlckZ1bmMgPSBhc3luYyAoZGF0YSwgb3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgeyBpbnB1dCwgLi4ubWVyZ2VkTWV0YWRhdGEgfSA9IGF3YWl0IHRoaXMucmVuZGVyTWV0YWRhdGEocGFyc2VkU291cmNlKTtcbiAgICAgIGNvbnN0IHJlbmRlcmVkU3RyaW5nID0gcmVuZGVyU3RyaW5nKFxuICAgICAgICB7IC4uLm9wdGlvbnM/LmlucHV0Py5kZWZhdWx0IHx8IHt9LCAuLi5kYXRhLmlucHV0IH0sXG4gICAgICAgIHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICBwcm9tcHQ6IG1lcmdlZE1ldGFkYXRhLFxuICAgICAgICAgICAgICBkb2NzOiBkYXRhLmRvY3MsXG4gICAgICAgICAgICAgIG1lc3NhZ2VzOiBkYXRhLm1lc3NhZ2VzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4uZGF0YS5jb250ZXh0IHx8IHt9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWVyZ2VkTWV0YWRhdGEsXG4gICAgICAgIG1lc3NhZ2VzOiB0b01lc3NhZ2VzKHJlbmRlcmVkU3RyaW5nLCBkYXRhKVxuICAgICAgfTtcbiAgICB9O1xuICAgIHJlbmRlckZ1bmMucHJvbXB0ID0gcGFyc2VkU291cmNlO1xuICAgIHJldHVybiByZW5kZXJGdW5jO1xuICB9XG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgYW5kIHJlc29sdmVzIGFsbCBtZXRhZGF0YSBmb3IgYSBwcm9tcHQgdGVtcGxhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBzb3VyY2UgVGhlIHRlbXBsYXRlIHNvdXJjZSBvciBwYXJzZWQgcHJvbXB0XG4gICAqIEBwYXJhbSBhZGRpdGlvbmFsTWV0YWRhdGEgQWRkaXRpb25hbCBtZXRhZGF0YSB0byBpbmNsdWRlXG4gICAqIEByZXR1cm4gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgZnVsbHkgcHJvY2Vzc2VkIG1ldGFkYXRhXG4gICAqL1xuICBhc3luYyByZW5kZXJNZXRhZGF0YShzb3VyY2UsIGFkZGl0aW9uYWxNZXRhZGF0YSkge1xuICAgIGxldCBwYXJzZWRTb3VyY2U7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHBhcnNlZFNvdXJjZSA9IHRoaXMucGFyc2Uoc291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkU291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBjb25zdCBtb2RlbCA9IGFkZGl0aW9uYWxNZXRhZGF0YT8ubW9kZWwgfHwgcGFyc2VkU291cmNlLm1vZGVsIHx8IHRoaXMuZGVmYXVsdE1vZGVsO1xuICAgIGxldCBtb2RlbENvbmZpZztcbiAgICBpZiAobW9kZWwgJiYgdGhpcy5tb2RlbENvbmZpZ3NbbW9kZWxdKSB7XG4gICAgICBtb2RlbENvbmZpZyA9IHRoaXMubW9kZWxDb25maWdzW21vZGVsXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZU1ldGFkYXRhKFxuICAgICAgbW9kZWxDb25maWcgPyB7IGNvbmZpZzogbW9kZWxDb25maWcgfSA6IHt9LFxuICAgICAgcGFyc2VkU291cmNlLFxuICAgICAgYWRkaXRpb25hbE1ldGFkYXRhXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogTWVyZ2VzIG11bHRpcGxlIG1ldGFkYXRhIG9iamVjdHMgdG9nZXRoZXIsIHJlc29sdmluZyB0b29scyBhbmQgc2NoZW1hcy5cbiAgICpcbiAgICogQHBhcmFtIGJhc2UgVGhlIGJhc2UgbWV0YWRhdGEgb2JqZWN0XG4gICAqIEBwYXJhbSBtZXJnZXMgQWRkaXRpb25hbCBtZXRhZGF0YSBvYmplY3RzIHRvIG1lcmdlIGludG8gdGhlIGJhc2VcbiAgICogQHJldHVybiBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBtZXJnZWQgYW5kIHByb2Nlc3NlZCBtZXRhZGF0YVxuICAgKi9cbiAgYXN5bmMgcmVzb2x2ZU1ldGFkYXRhKGJhc2UsIC4uLm1lcmdlcykge1xuICAgIGxldCBvdXQgPSB7IC4uLmJhc2UgfTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lcmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFtZXJnZXNbaV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvcmlnaW5hbENvbmZpZyA9IG91dC5jb25maWcgfHwge307XG4gICAgICBvdXQgPSB7IC4uLm91dCwgLi4ubWVyZ2VzW2ldIH07XG4gICAgICBvdXQuY29uZmlnID0geyAuLi5vcmlnaW5hbENvbmZpZywgLi4ubWVyZ2VzW2ldPy5jb25maWcgfHwge30gfTtcbiAgICB9XG4gICAgY29uc3QgeyB0ZW1wbGF0ZTogXywgLi4ub3V0V2l0aG91dFRlbXBsYXRlIH0gPSBvdXQ7XG4gICAgb3V0ID0gb3V0V2l0aG91dFRlbXBsYXRlO1xuICAgIG91dCA9IHJlbW92ZVVuZGVmaW5lZEZpZWxkcyhvdXQpO1xuICAgIG91dCA9IGF3YWl0IHRoaXMucmVzb2x2ZVRvb2xzKG91dCk7XG4gICAgb3V0ID0gYXdhaXQgdGhpcy5yZW5kZXJQaWNvc2NoZW1hKG91dCk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICAvKipcbiAgICogUHJvY2Vzc2VzIHNjaGVtYSBkZWZpbml0aW9ucyBpbiBwaWNvc2NoZW1hIGZvcm1hdCBpbnRvIHN0YW5kYXJkIEpTT04gU2NoZW1hLlxuICAgKlxuICAgKiBAcGFyYW0gbWV0YSBUaGUgcHJvbXB0IG1ldGFkYXRhIGNvbnRhaW5pbmcgc2NoZW1hIGRlZmluaXRpb25zXG4gICAqIEByZXR1cm4gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgcHJvY2Vzc2VkIG1ldGFkYXRhIHdpdGggZXhwYW5kZWQgc2NoZW1hc1xuICAgKi9cbiAgYXN5bmMgcmVuZGVyUGljb3NjaGVtYShtZXRhKSB7XG4gICAgaWYgKCFtZXRhLm91dHB1dD8uc2NoZW1hICYmICFtZXRhLmlucHV0Py5zY2hlbWEpIHtcbiAgICAgIHJldHVybiBtZXRhO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlU2NoZW1hID0gKHNjaGVtYSkgPT4ge1xuICAgICAgcmV0dXJuIHBpY29zY2hlbWEoc2NoZW1hLCB7XG4gICAgICAgIHNjaGVtYVJlc29sdmVyOiB0aGlzLndyYXBwZWRTY2hlbWFSZXNvbHZlci5iaW5kKHRoaXMpXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG5ld01ldGEgPSB7IC4uLm1ldGEgfTtcbiAgICBsZXQgaW5wdXRQcm9taXNlID0gbnVsbDtcbiAgICBsZXQgb3V0cHV0UHJvbWlzZSA9IG51bGw7XG4gICAgaWYgKG1ldGEuaW5wdXQ/LnNjaGVtYSkge1xuICAgICAgbmV3TWV0YS5pbnB1dCA9IHsgLi4ubWV0YS5pbnB1dCB9O1xuICAgICAgaW5wdXRQcm9taXNlID0gcmVzb2x2ZVNjaGVtYShtZXRhLmlucHV0LnNjaGVtYSk7XG4gICAgfVxuICAgIGlmIChtZXRhLm91dHB1dD8uc2NoZW1hKSB7XG4gICAgICBuZXdNZXRhLm91dHB1dCA9IHsgLi4ubWV0YS5vdXRwdXQgfTtcbiAgICAgIG91dHB1dFByb21pc2UgPSByZXNvbHZlU2NoZW1hKG1ldGEub3V0cHV0LnNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IFtpbnB1dFNjaGVtYSwgb3V0cHV0U2NoZW1hXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIGlucHV0UHJvbWlzZSA/PyBQcm9taXNlLnJlc29sdmUobnVsbCksXG4gICAgICBvdXRwdXRQcm9taXNlID8/IFByb21pc2UucmVzb2x2ZShudWxsKVxuICAgIF0pO1xuICAgIGlmIChpbnB1dFNjaGVtYSAmJiBuZXdNZXRhLmlucHV0KSB7XG4gICAgICBuZXdNZXRhLmlucHV0LnNjaGVtYSA9IGlucHV0U2NoZW1hO1xuICAgIH1cbiAgICBpZiAob3V0cHV0U2NoZW1hICYmIG5ld01ldGEub3V0cHV0KSB7XG4gICAgICBuZXdNZXRhLm91dHB1dC5zY2hlbWEgPSBvdXRwdXRTY2hlbWE7XG4gICAgfVxuICAgIHJldHVybiBuZXdNZXRhO1xuICB9XG4gIC8qKlxuICAgKiBSZXNvbHZlcyBhIHNjaGVtYSBuYW1lIHRvIGl0cyBkZWZpbml0aW9uLCB1c2luZyByZWdpc3RlcmVkIHNjaGVtYXMgb3Igc2NoZW1hIHJlc29sdmVyLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc2NoZW1hIHRvIHJlc29sdmVcbiAgICogQHJldHVybiBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBzY2hlbWEgZGVmaW5pdGlvbiBvciBudWxsIGlmIG5vdCBmb3VuZFxuICAgKi9cbiAgYXN5bmMgd3JhcHBlZFNjaGVtYVJlc29sdmVyKG5hbWUpIHtcbiAgICBpZiAodGhpcy5zY2hlbWFzW25hbWVdKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY2hlbWFzW25hbWVdO1xuICAgIH1cbiAgICBpZiAodGhpcy5zY2hlbWFSZXNvbHZlcikge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2NoZW1hUmVzb2x2ZXIobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBSZXNvbHZlcyB0b29sIG5hbWVzIHRvIHRoZWlyIGRlZmluaXRpb25zIHVzaW5nIHJlZ2lzdGVyZWQgdG9vbHMgb3IgdG9vbCByZXNvbHZlci5cbiAgICpcbiAgICogQHBhcmFtIGJhc2UgVGhlIG1ldGFkYXRhIGNvbnRhaW5pbmcgdG9vbCByZWZlcmVuY2VzIHRvIHJlc29sdmVcbiAgICogQHJldHVybiBBIHByb21pc2UgcmVzb2x2aW5nIHRvIG1ldGFkYXRhIHdpdGggcmVzb2x2ZWQgdG9vbCBkZWZpbml0aW9uc1xuICAgKi9cbiAgYXN5bmMgcmVzb2x2ZVRvb2xzKGJhc2UpIHtcbiAgICBjb25zdCBvdXQgPSB7IC4uLmJhc2UgfTtcbiAgICBpZiAoIW91dC50b29scykge1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgY29uc3QgdW5yZWdpc3RlcmVkTmFtZXMgPSBbXTtcbiAgICBvdXQudG9vbERlZnMgPSBvdXQudG9vbERlZnMgfHwgW107XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBvdXQudG9vbHMubWFwKGFzeW5jIChuYW1lKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnRvb2xzW25hbWVdKSB7XG4gICAgICAgICAgaWYgKG91dC50b29sRGVmcykge1xuICAgICAgICAgICAgb3V0LnRvb2xEZWZzLnB1c2godGhpcy50b29sc1tuYW1lXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudG9vbFJlc29sdmVyKSB7XG4gICAgICAgICAgY29uc3QgcmVzb2x2ZWRUb29sID0gYXdhaXQgdGhpcy50b29sUmVzb2x2ZXIobmFtZSk7XG4gICAgICAgICAgaWYgKCFyZXNvbHZlZFRvb2wpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYERvdHByb21wdDogVW5hYmxlIHRvIHJlc29sdmUgdG9vbCAnJHtuYW1lfScgdG8gYSByZWNvZ25pemVkIHRvb2wgZGVmaW5pdGlvbi5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3V0LnRvb2xEZWZzKSB7XG4gICAgICAgICAgICBvdXQudG9vbERlZnMucHVzaChyZXNvbHZlZFRvb2wpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1bnJlZ2lzdGVyZWROYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gICAgb3V0LnRvb2xzID0gdW5yZWdpc3RlcmVkTmFtZXM7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICAvKipcbiAgICogSWRlbnRpZmllcyBhbGwgcGFydGlhbCByZWZlcmVuY2VzIGluIGEgdGVtcGxhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB0ZW1wbGF0ZSBUaGUgdGVtcGxhdGUgdG8gc2NhbiBmb3IgcGFydGlhbCByZWZlcmVuY2VzXG4gICAqIEByZXR1cm4gQSBzZXQgb2YgcGFydGlhbCBuYW1lcyByZWZlcmVuY2VkIGluIHRoZSB0ZW1wbGF0ZVxuICAgKi9cbiAgaWRlbnRpZnlQYXJ0aWFscyh0ZW1wbGF0ZSkge1xuICAgIGNvbnN0IGFzdCA9IHRoaXMuaGFuZGxlYmFycy5wYXJzZSh0ZW1wbGF0ZSk7XG4gICAgY29uc3QgcGFydGlhbHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IHZpc2l0b3IgPSBuZXcgY2xhc3MgZXh0ZW5kcyB0aGlzLmhhbmRsZWJhcnMuVmlzaXRvciB7XG4gICAgICAvLyBWaXNpdCBwYXJ0aWFsIHN0YXRlbWVudHMgYW5kIGFkZCB0aGVpciBuYW1lcyB0byBvdXIgc2V0LlxuICAgICAgUGFydGlhbFN0YXRlbWVudChwYXJ0aWFsKSB7XG4gICAgICAgIGlmIChwYXJ0aWFsICYmIHR5cGVvZiBwYXJ0aWFsID09PSBcIm9iamVjdFwiICYmIFwibmFtZVwiIGluIHBhcnRpYWwgJiYgcGFydGlhbC5uYW1lICYmIHR5cGVvZiBwYXJ0aWFsLm5hbWUgPT09IFwib2JqZWN0XCIgJiYgXCJvcmlnaW5hbFwiIGluIHBhcnRpYWwubmFtZSAmJiB0eXBlb2YgcGFydGlhbC5uYW1lLm9yaWdpbmFsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcGFydGlhbHMuYWRkKHBhcnRpYWwubmFtZS5vcmlnaW5hbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KCk7XG4gICAgdmlzaXRvci5hY2NlcHQoYXN0KTtcbiAgICByZXR1cm4gcGFydGlhbHM7XG4gIH1cbiAgLyoqXG4gICAqIFJlc29sdmVzIGFuZCByZWdpc3RlcnMgYWxsIHBhcnRpYWxzIHJlZmVyZW5jZWQgaW4gYSB0ZW1wbGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHRlbXBsYXRlIFRoZSB0ZW1wbGF0ZSBjb250YWluaW5nIHBhcnRpYWwgcmVmZXJlbmNlc1xuICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYWxsIHBhcnRpYWxzIGFyZSByZWdpc3RlcmVkXG4gICAqL1xuICBhc3luYyByZXNvbHZlUGFydGlhbHModGVtcGxhdGUpIHtcbiAgICBpZiAoIXRoaXMucGFydGlhbFJlc29sdmVyICYmICF0aGlzLnN0b3JlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5hbWVzID0gdGhpcy5pZGVudGlmeVBhcnRpYWxzKHRlbXBsYXRlKTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIEFycmF5LmZyb20obmFtZXMpLm1hcChhc3luYyAobmFtZSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuaGFuZGxlYmFycy5wYXJ0aWFsc1tuYW1lXSkge1xuICAgICAgICAgIGxldCBjb250ZW50ID0gbnVsbDtcbiAgICAgICAgICBpZiAodGhpcy5wYXJ0aWFsUmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBhd2FpdCB0aGlzLnBhcnRpYWxSZXNvbHZlcihuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjb250ZW50ICYmIHRoaXMuc3RvcmUpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRpYWwgPSBhd2FpdCB0aGlzLnN0b3JlLmxvYWRQYXJ0aWFsKG5hbWUpO1xuICAgICAgICAgICAgY29udGVudCA9IHBhcnRpYWw/LnNvdXJjZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmaW5lUGFydGlhbChuYW1lLCBjb250ZW50KTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVzb2x2ZVBhcnRpYWxzKGNvbnRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgaW5pdGlhbCBoZWxwZXJzIGZyb20gYnVpbHQtaW4gaGVscGVycyBhbmQgb3B0aW9ucy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlZ2lzdGVySW5pdGlhbEhlbHBlcnMoYnVpbHRpbkhlbHBlcnMsIGN1c3RvbUhlbHBlcnMpIHtcbiAgICBpZiAoYnVpbHRpbkhlbHBlcnMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGJ1aWx0aW5IZWxwZXJzKSB7XG4gICAgICAgIHRoaXMuZGVmaW5lSGVscGVyKFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBidWlsdGluSGVscGVyc1trZXldXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjdXN0b21IZWxwZXJzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdXN0b21IZWxwZXJzKSB7XG4gICAgICAgIHRoaXMuZGVmaW5lSGVscGVyKGtleSwgY3VzdG9tSGVscGVyc1trZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBpbml0aWFsIHBhcnRpYWxzIGZyb20gdGhlIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJ0aWFscyBUaGUgcGFydGlhbHMgdG8gcmVnaXN0ZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlZ2lzdGVySW5pdGlhbFBhcnRpYWxzKHBhcnRpYWxzKSB7XG4gICAgaWYgKHBhcnRpYWxzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJ0aWFscykge1xuICAgICAgICB0aGlzLmRlZmluZVBhcnRpYWwoa2V5LCBwYXJ0aWFsc1trZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgRG90cHJvbXB0LFxuICBQaWNvc2NoZW1hUGFyc2VyLFxuICBwaWNvc2NoZW1hXG59KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/dotprompt/dist/index.js\n");

/***/ })

};
;